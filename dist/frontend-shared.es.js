import { jsx as O, jsxs as pe, Fragment as Nc } from "react/jsx-runtime";
import P, { useState as ee, useRef as q, useSyncExternalStore as X$, useLayoutEffect as Yp, useEffect as oe, isValidElement as Qn, cloneElement as sa, useCallback as be, createContext as ce, useContext as le, forwardRef as xe, createElement as vl, useMemo as G } from "react";
import Lc, { flushSync as ex, createPortal as tx } from "react-dom";
function rx(e, t) {
  for (var r = 0; r < t.length; r++) {
    const n = t[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const i in n)
        if (i !== "default" && !(i in e)) {
          const a = Object.getOwnPropertyDescriptor(n, i);
          a && Object.defineProperty(e, i, a.get ? a : {
            enumerable: !0,
            get: () => n[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
function Jp(e) {
  var t, r, n = "";
  if (typeof e == "string" || typeof e == "number") n += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (r = Jp(e[t])) && (n && (n += " "), n += r);
  } else for (r in e) e[r] && (n && (n += " "), n += r);
  return n;
}
function fr() {
  for (var e, t, r = 0, n = "", i = arguments.length; r < i; r++) (e = arguments[r]) && (t = Jp(e)) && (n && (n += " "), n += t);
  return n;
}
const ua = (e) => typeof e == "number" && !isNaN(e), dn = (e) => typeof e == "string", St = (e) => typeof e == "function", Eo = (e) => dn(e) || St(e) ? e : null, yl = (e) => Qn(e) || dn(e) || St(e) || ua(e);
function nx(e, t, r) {
  r === void 0 && (r = 300);
  const { scrollHeight: n, style: i } = e;
  requestAnimationFrame(() => {
    i.minHeight = "initial", i.height = n + "px", i.transition = `all ${r}ms`, requestAnimationFrame(() => {
      i.height = "0", i.padding = "0", i.margin = "0", setTimeout(t, r);
    });
  });
}
function As(e) {
  let { enter: t, exit: r, appendPosition: n = !1, collapse: i = !0, collapseDuration: a = 300 } = e;
  return function(o) {
    let { children: s, position: u, preventExitTransition: l, done: c, nodeRef: d, isIn: f, playToast: h } = o;
    const p = n ? `${t}--${u}` : t, v = n ? `${r}--${u}` : r, g = q(0);
    return Yp(() => {
      const $ = d.current, m = p.split(" "), b = (D) => {
        D.target === d.current && (h(), $.removeEventListener("animationend", b), $.removeEventListener("animationcancel", b), g.current === 0 && D.type !== "animationcancel" && $.classList.remove(...m));
      };
      $.classList.add(...m), $.addEventListener("animationend", b), $.addEventListener("animationcancel", b);
    }, []), oe(() => {
      const $ = d.current, m = () => {
        $.removeEventListener("animationend", m), i ? nx($, c, a) : c();
      };
      f || (l ? m() : (g.current = 1, $.className += ` ${v}`, $.addEventListener("animationend", m)));
    }, [f]), P.createElement(P.Fragment, null, s);
  };
}
function bf(e, t) {
  return e != null ? { content: e.content, containerId: e.props.containerId, id: e.props.toastId, theme: e.props.theme, type: e.props.type, data: e.props.data || {}, isLoading: e.props.isLoading, icon: e.props.icon, status: t } : {};
}
const ft = /* @__PURE__ */ new Map();
let la = [];
const gl = /* @__PURE__ */ new Set(), ix = (e) => gl.forEach((t) => t(e)), Xp = () => ft.size > 0;
function em(e, t) {
  var r;
  if (t) return !((r = ft.get(t)) == null || !r.isToastActive(e));
  let n = !1;
  return ft.forEach((i) => {
    i.isToastActive(e) && (n = !0);
  }), n;
}
function tm(e, t) {
  yl(e) && (Xp() || la.push({ content: e, options: t }), ft.forEach((r) => {
    r.buildToast(e, t);
  }));
}
function $f(e, t) {
  ft.forEach((r) => {
    t != null && t != null && t.containerId ? (t == null ? void 0 : t.containerId) === r.id && r.toggle(e, t == null ? void 0 : t.id) : r.toggle(e, t == null ? void 0 : t.id);
  });
}
function ax(e) {
  const { subscribe: t, getSnapshot: r, setProps: n } = q(function(a) {
    const o = a.containerId || 1;
    return { subscribe(s) {
      const u = /* @__PURE__ */ function(c, d, f) {
        let h = 1, p = 0, v = [], g = [], $ = [], m = d;
        const b = /* @__PURE__ */ new Map(), D = /* @__PURE__ */ new Set(), S = () => {
          $ = Array.from(b.values()), D.forEach((y) => y());
        }, T = (y) => {
          g = y == null ? [] : g.filter((_) => _ !== y), S();
        }, B = (y) => {
          const { toastId: _, onOpen: w, updateId: E, children: k } = y.props, C = E == null;
          y.staleId && b.delete(y.staleId), b.set(_, y), g = [...g, y.props.toastId].filter((A) => A !== y.staleId), S(), f(bf(y, C ? "added" : "updated")), C && St(w) && w(Qn(k) && k.props);
        };
        return { id: c, props: m, observe: (y) => (D.add(y), () => D.delete(y)), toggle: (y, _) => {
          b.forEach((w) => {
            _ != null && _ !== w.props.toastId || St(w.toggle) && w.toggle(y);
          });
        }, removeToast: T, toasts: b, clearQueue: () => {
          p -= v.length, v = [];
        }, buildToast: (y, _) => {
          if (((ne) => {
            let { containerId: ye, toastId: De, updateId: Fe } = ne;
            const Oe = ye ? ye !== c : c !== 1, V = b.has(De) && Fe == null;
            return Oe || V;
          })(_)) return;
          const { toastId: w, updateId: E, data: k, staleId: C, delay: A } = _, L = () => {
            T(w);
          }, I = E == null;
          I && p++;
          const x = { ...m, style: m.toastStyle, key: h++, ...Object.fromEntries(Object.entries(_).filter((ne) => {
            let [ye, De] = ne;
            return De != null;
          })), toastId: w, updateId: E, data: k, closeToast: L, isIn: !1, className: Eo(_.className || m.toastClassName), bodyClassName: Eo(_.bodyClassName || m.bodyClassName), progressClassName: Eo(_.progressClassName || m.progressClassName), autoClose: !_.isLoading && (U = _.autoClose, K = m.autoClose, U === !1 || ua(U) && U > 0 ? U : K), deleteToast() {
            const ne = b.get(w), { onClose: ye, children: De } = ne.props;
            St(ye) && ye(Qn(De) && De.props), f(bf(ne, "removed")), b.delete(w), p--, p < 0 && (p = 0), v.length > 0 ? B(v.shift()) : S();
          } };
          var U, K;
          x.closeButton = m.closeButton, _.closeButton === !1 || yl(_.closeButton) ? x.closeButton = _.closeButton : _.closeButton === !0 && (x.closeButton = !yl(m.closeButton) || m.closeButton);
          let z = y;
          Qn(y) && !dn(y.type) ? z = sa(y, { closeToast: L, toastProps: x, data: k }) : St(y) && (z = y({ closeToast: L, toastProps: x, data: k }));
          const ae = { content: z, props: x, staleId: C };
          m.limit && m.limit > 0 && p > m.limit && I ? v.push(ae) : ua(A) ? setTimeout(() => {
            B(ae);
          }, A) : B(ae);
        }, setProps(y) {
          m = y;
        }, setToggle: (y, _) => {
          b.get(y).toggle = _;
        }, isToastActive: (y) => g.some((_) => _ === y), getSnapshot: () => m.newestOnTop ? $.reverse() : $ };
      }(o, a, ix);
      ft.set(o, u);
      const l = u.observe(s);
      return la.forEach((c) => tm(c.content, c.options)), la = [], () => {
        l(), ft.delete(o);
      };
    }, setProps(s) {
      var u;
      (u = ft.get(o)) == null || u.setProps(s);
    }, getSnapshot() {
      var s;
      return (s = ft.get(o)) == null ? void 0 : s.getSnapshot();
    } };
  }(e)).current;
  n(e);
  const i = X$(t, r, r);
  return { getToastToRender: function(a) {
    if (!i) return [];
    const o = /* @__PURE__ */ new Map();
    return i.forEach((s) => {
      const { position: u } = s.props;
      o.has(u) || o.set(u, []), o.get(u).push(s);
    }), Array.from(o, (s) => a(s[0], s[1]));
  }, isToastActive: em, count: i == null ? void 0 : i.length };
}
function ox(e) {
  const [t, r] = ee(!1), [n, i] = ee(!1), a = q(null), o = q({ start: 0, delta: 0, removalDistance: 0, canCloseOnClick: !0, canDrag: !1, didMove: !1 }).current, { autoClose: s, pauseOnHover: u, closeToast: l, onClick: c, closeOnClick: d } = e;
  var f, h;
  function p() {
    r(!0);
  }
  function v() {
    r(!1);
  }
  function g(b) {
    const D = a.current;
    o.canDrag && D && (o.didMove = !0, t && v(), o.delta = e.draggableDirection === "x" ? b.clientX - o.start : b.clientY - o.start, o.start !== b.clientX && (o.canCloseOnClick = !1), D.style.transform = `translate3d(${e.draggableDirection === "x" ? `${o.delta}px, var(--y)` : `0, calc(${o.delta}px + var(--y))`},0)`, D.style.opacity = "" + (1 - Math.abs(o.delta / o.removalDistance)));
  }
  function $() {
    document.removeEventListener("pointermove", g), document.removeEventListener("pointerup", $);
    const b = a.current;
    if (o.canDrag && o.didMove && b) {
      if (o.canDrag = !1, Math.abs(o.delta) > o.removalDistance) return i(!0), e.closeToast(), void e.collapseAll();
      b.style.transition = "transform 0.2s, opacity 0.2s", b.style.removeProperty("transform"), b.style.removeProperty("opacity");
    }
  }
  (h = ft.get((f = { id: e.toastId, containerId: e.containerId, fn: r }).containerId || 1)) == null || h.setToggle(f.id, f.fn), oe(() => {
    if (e.pauseOnFocusLoss) return document.hasFocus() || v(), window.addEventListener("focus", p), window.addEventListener("blur", v), () => {
      window.removeEventListener("focus", p), window.removeEventListener("blur", v);
    };
  }, [e.pauseOnFocusLoss]);
  const m = { onPointerDown: function(b) {
    if (e.draggable === !0 || e.draggable === b.pointerType) {
      o.didMove = !1, document.addEventListener("pointermove", g), document.addEventListener("pointerup", $);
      const D = a.current;
      o.canCloseOnClick = !0, o.canDrag = !0, D.style.transition = "none", e.draggableDirection === "x" ? (o.start = b.clientX, o.removalDistance = D.offsetWidth * (e.draggablePercent / 100)) : (o.start = b.clientY, o.removalDistance = D.offsetHeight * (e.draggablePercent === 80 ? 1.5 * e.draggablePercent : e.draggablePercent) / 100);
    }
  }, onPointerUp: function(b) {
    const { top: D, bottom: S, left: T, right: B } = a.current.getBoundingClientRect();
    b.nativeEvent.type !== "touchend" && e.pauseOnHover && b.clientX >= T && b.clientX <= B && b.clientY >= D && b.clientY <= S ? v() : p();
  } };
  return s && u && (m.onMouseEnter = v, e.stacked || (m.onMouseLeave = p)), d && (m.onClick = (b) => {
    c && c(b), o.canCloseOnClick && l();
  }), { playToast: p, pauseToast: v, isRunning: t, preventExitTransition: n, toastRef: a, eventHandlers: m };
}
function sx(e) {
  let { delay: t, isRunning: r, closeToast: n, type: i = "default", hide: a, className: o, style: s, controlledProgress: u, progress: l, rtl: c, isIn: d, theme: f } = e;
  const h = a || u && l === 0, p = { ...s, animationDuration: `${t}ms`, animationPlayState: r ? "running" : "paused" };
  u && (p.transform = `scaleX(${l})`);
  const v = fr("Toastify__progress-bar", u ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${f}`, `Toastify__progress-bar--${i}`, { "Toastify__progress-bar--rtl": c }), g = St(o) ? o({ rtl: c, type: i, defaultClassName: v }) : fr(v, o), $ = { [u && l >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: u && l < 1 ? null : () => {
    d && n();
  } };
  return P.createElement("div", { className: "Toastify__progress-bar--wrp", "data-hidden": h }, P.createElement("div", { className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${f} Toastify__progress-bar--${i}` }), P.createElement("div", { role: "progressbar", "aria-hidden": h ? "true" : "false", "aria-label": "notification timer", className: g, style: p, ...$ }));
}
let ux = 1;
const rm = () => "" + ux++;
function lx(e) {
  return e && (dn(e.toastId) || ua(e.toastId)) ? e.toastId : rm();
}
function Zi(e, t) {
  return tm(e, t), t.toastId;
}
function Vo(e, t) {
  return { ...t, type: t && t.type || e, toastId: lx(t) };
}
function Xa(e) {
  return (t, r) => Zi(t, Vo(e, r));
}
function Ie(e, t) {
  return Zi(e, Vo("default", t));
}
Ie.loading = (e, t) => Zi(e, Vo("default", { isLoading: !0, autoClose: !1, closeOnClick: !1, closeButton: !1, draggable: !1, ...t })), Ie.promise = function(e, t, r) {
  let n, { pending: i, error: a, success: o } = t;
  i && (n = dn(i) ? Ie.loading(i, r) : Ie.loading(i.render, { ...r, ...i }));
  const s = { isLoading: null, autoClose: null, closeOnClick: null, closeButton: null, draggable: null }, u = (c, d, f) => {
    if (d == null) return void Ie.dismiss(n);
    const h = { type: c, ...s, ...r, data: f }, p = dn(d) ? { render: d } : d;
    return n ? Ie.update(n, { ...h, ...p }) : Ie(p.render, { ...h, ...p }), f;
  }, l = St(e) ? e() : e;
  return l.then((c) => u("success", o, c)).catch((c) => u("error", a, c)), l;
}, Ie.success = Xa("success"), Ie.info = Xa("info"), Ie.error = Xa("error"), Ie.warning = Xa("warning"), Ie.warn = Ie.warning, Ie.dark = (e, t) => Zi(e, Vo("default", { theme: "dark", ...t })), Ie.dismiss = function(e) {
  (function(t) {
    var r;
    if (Xp()) {
      if (t == null || dn(r = t) || ua(r)) ft.forEach((n) => {
        n.removeToast(t);
      });
      else if (t && ("containerId" in t || "id" in t)) {
        const n = ft.get(t.containerId);
        n ? n.removeToast(t.id) : ft.forEach((i) => {
          i.removeToast(t.id);
        });
      }
    } else la = la.filter((n) => t != null && n.options.toastId !== t);
  })(e);
}, Ie.clearWaitingQueue = function(e) {
  e === void 0 && (e = {}), ft.forEach((t) => {
    !t.props.limit || e.containerId && t.id !== e.containerId || t.clearQueue();
  });
}, Ie.isActive = em, Ie.update = function(e, t) {
  t === void 0 && (t = {});
  const r = ((n, i) => {
    var a;
    let { containerId: o } = i;
    return (a = ft.get(o || 1)) == null ? void 0 : a.toasts.get(n);
  })(e, t);
  if (r) {
    const { props: n, content: i } = r, a = { delay: 100, ...n, ...t, toastId: t.toastId || e, updateId: rm() };
    a.toastId !== e && (a.staleId = e);
    const o = a.render || i;
    delete a.render, Zi(o, a);
  }
}, Ie.done = (e) => {
  Ie.update(e, { progress: 1 });
}, Ie.onChange = function(e) {
  return gl.add(e), () => {
    gl.delete(e);
  };
}, Ie.play = (e) => $f(!0, e), Ie.pause = (e) => $f(!1, e);
const cx = typeof window < "u" ? Yp : oe, eo = (e) => {
  let { theme: t, type: r, isLoading: n, ...i } = e;
  return P.createElement("svg", { viewBox: "0 0 24 24", width: "100%", height: "100%", fill: t === "colored" ? "currentColor" : `var(--toastify-icon-color-${r})`, ...i });
}, gu = { info: function(e) {
  return P.createElement(eo, { ...e }, P.createElement("path", { d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z" }));
}, warning: function(e) {
  return P.createElement(eo, { ...e }, P.createElement("path", { d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z" }));
}, success: function(e) {
  return P.createElement(eo, { ...e }, P.createElement("path", { d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z" }));
}, error: function(e) {
  return P.createElement(eo, { ...e }, P.createElement("path", { d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z" }));
}, spinner: function() {
  return P.createElement("div", { className: "Toastify__spinner" });
} }, dx = (e) => {
  const { isRunning: t, preventExitTransition: r, toastRef: n, eventHandlers: i, playToast: a } = ox(e), { closeButton: o, children: s, autoClose: u, onClick: l, type: c, hideProgressBar: d, closeToast: f, transition: h, position: p, className: v, style: g, bodyClassName: $, bodyStyle: m, progressClassName: b, progressStyle: D, updateId: S, role: T, progress: B, rtl: y, toastId: _, deleteToast: w, isIn: E, isLoading: k, closeOnClick: C, theme: A } = e, L = fr("Toastify__toast", `Toastify__toast-theme--${A}`, `Toastify__toast--${c}`, { "Toastify__toast--rtl": y }, { "Toastify__toast--close-on-click": C }), I = St(v) ? v({ rtl: y, position: p, type: c, defaultClassName: L }) : fr(L, v), x = function(ae) {
    let { theme: ne, type: ye, isLoading: De, icon: Fe } = ae, Oe = null;
    const V = { theme: ne, type: ye };
    return Fe === !1 || (St(Fe) ? Oe = Fe({ ...V, isLoading: De }) : Qn(Fe) ? Oe = sa(Fe, V) : De ? Oe = gu.spinner() : ((ie) => ie in gu)(ye) && (Oe = gu[ye](V))), Oe;
  }(e), U = !!B || !u, K = { closeToast: f, type: c, theme: A };
  let z = null;
  return o === !1 || (z = St(o) ? o(K) : Qn(o) ? sa(o, K) : function(ae) {
    let { closeToast: ne, theme: ye, ariaLabel: De = "close" } = ae;
    return P.createElement("button", { className: `Toastify__close-button Toastify__close-button--${ye}`, type: "button", onClick: (Fe) => {
      Fe.stopPropagation(), ne(Fe);
    }, "aria-label": De }, P.createElement("svg", { "aria-hidden": "true", viewBox: "0 0 14 16" }, P.createElement("path", { fillRule: "evenodd", d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z" })));
  }(K)), P.createElement(h, { isIn: E, done: w, position: p, preventExitTransition: r, nodeRef: n, playToast: a }, P.createElement("div", { id: _, onClick: l, "data-in": E, className: I, ...i, style: g, ref: n }, P.createElement("div", { ...E && { role: T }, className: St($) ? $({ type: c }) : fr("Toastify__toast-body", $), style: m }, x != null && P.createElement("div", { className: fr("Toastify__toast-icon", { "Toastify--animate-icon Toastify__zoom-enter": !k }) }, x), P.createElement("div", null, s)), z, P.createElement(sx, { ...S && !U ? { key: `pb-${S}` } : {}, rtl: y, theme: A, delay: u, isRunning: t, isIn: E, closeToast: f, hide: d, type: c, style: D, className: b, controlledProgress: U, progress: B || 0 })));
}, _s = function(e, t) {
  return t === void 0 && (t = !1), { enter: `Toastify--animate Toastify__${e}-enter`, exit: `Toastify--animate Toastify__${e}-exit`, appendPosition: t };
}, fx = As(_s("bounce", !0));
As(_s("slide", !0));
As(_s("zoom"));
As(_s("flip"));
const hx = { position: "top-right", transition: fx, autoClose: 5e3, closeButton: !0, pauseOnHover: !0, pauseOnFocusLoss: !0, draggable: "touch", draggablePercent: 80, draggableDirection: "x", role: "alert", theme: "light" };
function px(e) {
  let t = { ...hx, ...e };
  const r = e.stacked, [n, i] = ee(!0), a = q(null), { getToastToRender: o, isToastActive: s, count: u } = ax(t), { className: l, style: c, rtl: d, containerId: f } = t;
  function h(v) {
    const g = fr("Toastify__toast-container", `Toastify__toast-container--${v}`, { "Toastify__toast-container--rtl": d });
    return St(l) ? l({ position: v, rtl: d, defaultClassName: g }) : fr(g, Eo(l));
  }
  function p() {
    r && (i(!0), Ie.play());
  }
  return cx(() => {
    if (r) {
      var v;
      const g = a.current.querySelectorAll('[data-in="true"]'), $ = 12, m = (v = t.position) == null ? void 0 : v.includes("top");
      let b = 0, D = 0;
      Array.from(g).reverse().forEach((S, T) => {
        const B = S;
        B.classList.add("Toastify__toast--stacked"), T > 0 && (B.dataset.collapsed = `${n}`), B.dataset.pos || (B.dataset.pos = m ? "top" : "bot");
        const y = b * (n ? 0.2 : 1) + (n ? 0 : $ * T);
        B.style.setProperty("--y", `${m ? y : -1 * y}px`), B.style.setProperty("--g", `${$}`), B.style.setProperty("--s", "" + (1 - (n ? D : 0))), b += B.offsetHeight, D += 0.025;
      });
    }
  }, [n, u, r]), P.createElement("div", { ref: a, className: "Toastify", id: f, onMouseEnter: () => {
    r && (i(!1), Ie.pause());
  }, onMouseLeave: p }, o((v, g) => {
    const $ = g.length ? { ...c } : { ...c, pointerEvents: "none" };
    return P.createElement("div", { className: h(v), style: $, key: `container-${v}` }, g.map((m) => {
      let { content: b, props: D } = m;
      return P.createElement(dx, { ...D, stacked: r, collapseAll: p, isIn: s(D.toastId, D.containerId), style: D.style, key: `toast-${D.key}` }, b);
    }));
  }));
}
function nm(e) {
  const t = Object.prototype.toString.call(e);
  return e instanceof Date || typeof e == "object" && t === "[object Date]" ? new e.constructor(+e) : typeof e == "number" || t === "[object Number]" || typeof e == "string" || t === "[object String]" ? new Date(e) : /* @__PURE__ */ new Date(NaN);
}
function mx(e, t) {
  return e instanceof Date ? new e.constructor(t) : new Date(t);
}
function vx(e, t) {
  const r = +nm(e);
  return mx(e, r + t);
}
const im = 6e4, am = 36e5;
function yx(e, t) {
  return vx(e, t * 1e3);
}
function Pr(e, t) {
  const r = e < 0 ? "-" : "", n = Math.abs(e).toString().padStart(t, "0");
  return r + n;
}
function gx(e, t) {
  const r = nm(e);
  if (isNaN(r.getTime()))
    throw new RangeError("Invalid time value");
  let n = "", i = "";
  const a = "-", o = ":";
  {
    const s = Pr(r.getDate(), 2), u = Pr(r.getMonth() + 1, 2);
    n = `${Pr(r.getFullYear(), 4)}${a}${u}${a}${s}`;
  }
  {
    const s = r.getTimezoneOffset();
    if (s !== 0) {
      const h = Math.abs(s), p = Pr(Math.trunc(h / 60), 2), v = Pr(h % 60, 2);
      i = `${s < 0 ? "+" : "-"}${p}:${v}`;
    } else
      i = "Z";
    const u = Pr(r.getHours(), 2), l = Pr(r.getMinutes(), 2), c = Pr(r.getSeconds(), 2), d = n === "" ? "" : "T", f = [u, l, c].join(o);
    n = `${n}${d}${f}${i}`;
  }
  return n;
}
function bx(e, t) {
  const n = Ex(e);
  let i;
  if (n.date) {
    const u = wx(n.date, 2);
    i = Cx(u.restDateString, u.year);
  }
  if (!i || isNaN(i.getTime()))
    return /* @__PURE__ */ new Date(NaN);
  const a = i.getTime();
  let o = 0, s;
  if (n.time && (o = Sx(n.time), isNaN(o)))
    return /* @__PURE__ */ new Date(NaN);
  if (n.timezone) {
    if (s = kx(n.timezone), isNaN(s))
      return /* @__PURE__ */ new Date(NaN);
  } else {
    const u = new Date(a + o), l = /* @__PURE__ */ new Date(0);
    return l.setFullYear(
      u.getUTCFullYear(),
      u.getUTCMonth(),
      u.getUTCDate()
    ), l.setHours(
      u.getUTCHours(),
      u.getUTCMinutes(),
      u.getUTCSeconds(),
      u.getUTCMilliseconds()
    ), l;
  }
  return new Date(a + o + s);
}
const to = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
}, $x = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, xx = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, Dx = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function Ex(e) {
  const t = {}, r = e.split(to.dateTimeDelimiter);
  let n;
  if (r.length > 2)
    return t;
  if (/:/.test(r[0]) ? n = r[0] : (t.date = r[0], n = r[1], to.timeZoneDelimiter.test(t.date) && (t.date = e.split(to.timeZoneDelimiter)[0], n = e.substr(
    t.date.length,
    e.length
  ))), n) {
    const i = to.timezone.exec(n);
    i ? (t.time = n.replace(i[1], ""), t.timezone = i[1]) : t.time = n;
  }
  return t;
}
function wx(e, t) {
  const r = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + t) + "})|(\\d{2}|[+-]\\d{" + (2 + t) + "})$)"
  ), n = e.match(r);
  if (!n) return { year: NaN, restDateString: "" };
  const i = n[1] ? parseInt(n[1]) : null, a = n[2] ? parseInt(n[2]) : null;
  return {
    year: a === null ? i : a * 100,
    restDateString: e.slice((n[1] || n[2]).length)
  };
}
function Cx(e, t) {
  if (t === null) return /* @__PURE__ */ new Date(NaN);
  const r = e.match($x);
  if (!r) return /* @__PURE__ */ new Date(NaN);
  const n = !!r[4], i = Ti(r[1]), a = Ti(r[2]) - 1, o = Ti(r[3]), s = Ti(r[4]), u = Ti(r[5]) - 1;
  if (n)
    return Fx(t, s, u) ? Px(t, s, u) : /* @__PURE__ */ new Date(NaN);
  {
    const l = /* @__PURE__ */ new Date(0);
    return !Ax(t, a, o) || !_x(t, i) ? /* @__PURE__ */ new Date(NaN) : (l.setUTCFullYear(t, a, Math.max(i, o)), l);
  }
}
function Ti(e) {
  return e ? parseInt(e) : 1;
}
function Sx(e) {
  const t = e.match(xx);
  if (!t) return NaN;
  const r = bu(t[1]), n = bu(t[2]), i = bu(t[3]);
  return Ox(r, n, i) ? r * am + n * im + i * 1e3 : NaN;
}
function bu(e) {
  return e && parseFloat(e.replace(",", ".")) || 0;
}
function kx(e) {
  if (e === "Z") return 0;
  const t = e.match(Dx);
  if (!t) return 0;
  const r = t[1] === "+" ? -1 : 1, n = parseInt(t[2]), i = t[3] && parseInt(t[3]) || 0;
  return Ix(n, i) ? r * (n * am + i * im) : NaN;
}
function Px(e, t, r) {
  const n = /* @__PURE__ */ new Date(0);
  n.setUTCFullYear(e, 0, 4);
  const i = n.getUTCDay() || 7, a = (t - 1) * 7 + r + 1 - i;
  return n.setUTCDate(n.getUTCDate() + a), n;
}
const Tx = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function om(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function Ax(e, t, r) {
  return t >= 0 && t <= 11 && r >= 1 && r <= (Tx[t] || (om(e) ? 29 : 28));
}
function _x(e, t) {
  return t >= 1 && t <= (om(e) ? 366 : 365);
}
function Fx(e, t, r) {
  return t >= 1 && t <= 53 && r >= 0 && r <= 6;
}
function Ox(e, t, r) {
  return e === 24 ? t === 0 && r === 0 : r >= 0 && r < 60 && t >= 0 && t < 60 && e >= 0 && e < 25;
}
function Ix(e, t) {
  return t >= 0 && t <= 59;
}
const oi = {
  isProd: !0,
  isDev: !1,
  ssoUrl: "https://media-library-api.spillover.com/sso",
  ssoDevUrl: "http://localhost:3030/sso",
  engageGraphqlEndpoint: "https://rails-admin.spillover.com/graphql",
  engageGraphqlDevEndpoint: "http://localhost:8080/graphql",
  accountsGraphqlEndpoint: "https://accounts-api.spillover.com/graphql",
  accountsGraphqlDevEndpoint: "http://localhost:3000/graphql"
};
var $u = function(e, t, r) {
  if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)
    (a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]);
  return e.concat(a || Array.prototype.slice.call(t));
}, Rx = function() {
  function e(t) {
    var r = t.debug, n = r === void 0 ? !1 : r;
    this.debug = n, this.lines = [];
  }
  return e.prototype.emit = function(t, r) {
    if (t in console) {
      var n = e.prefix;
      console[t].apply(console, $u([n], r, !1));
    }
  }, e.prototype.tailLogs = function() {
    var t = this;
    this.lines.forEach(function(r) {
      var n = r[0], i = r[1];
      return t.emit(n, i);
    });
  }, e.prototype.getLogs = function() {
    return this.lines;
  }, e.prototype.write = function(t, r) {
    var n = e.buffer;
    this.lines = $u($u([], this.lines.slice(1 - n), !0), [[t, r]], !1), (this.debug || t !== "log") && this.emit(t, r);
  }, e.prototype.info = function() {
    for (var t = [], r = 0; r < arguments.length; r++)
      t[r] = arguments[r];
    this.write("log", t);
  }, e.prototype.warn = function() {
    for (var t = [], r = 0; r < arguments.length; r++)
      t[r] = arguments[r];
    this.write("warn", t);
  }, e.prototype.error = function() {
    for (var t = [], r = 0; r < arguments.length; r++)
      t[r] = arguments[r];
    this.write("error", t);
  }, e.buffer = 30, e.prefix = "[apollo-cache-persist]", e;
}(), Bx = function() {
  function e(t) {
    var r = t.cache, n = t.serialize, i = n === void 0 ? !0 : n;
    this.cache = r, this.serialize = i;
  }
  return e.prototype.extract = function() {
    var t = this.cache.extract();
    return this.serialize && (t = JSON.stringify(t)), t;
  }, e.prototype.restore = function(t) {
    this.serialize && typeof t == "string" && (t = JSON.parse(t)), t != null && this.cache.restore(t);
  }, e;
}(), ro = function(e, t, r, n) {
  function i(a) {
    return a instanceof r ? a : new r(function(o) {
      o(a);
    });
  }
  return new (r || (r = Promise))(function(a, o) {
    function s(c) {
      try {
        l(n.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(n.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? a(c.value) : i(c.value).then(s, u);
    }
    l((n = n.apply(e, t || [])).next());
  });
}, no = function(e, t) {
  var r = { label: 0, sent: function() {
    if (a[0] & 1) throw a[1];
    return a[1];
  }, trys: [], ops: [] }, n, i, a, o;
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(l) {
    return function(c) {
      return u([l, c]);
    };
  }
  function u(l) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, l[0] && (r = 0)), r; ) try {
      if (n = 1, i && (a = l[0] & 2 ? i.return : l[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, l[1])).done) return a;
      switch (i = 0, a && (l = [l[0] & 2, a.value]), l[0]) {
        case 0:
        case 1:
          a = l;
          break;
        case 4:
          return r.label++, { value: l[1], done: !1 };
        case 5:
          r.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            r = 0;
            continue;
          }
          if (l[0] === 3 && (!a || l[1] > a[0] && l[1] < a[3])) {
            r.label = l[1];
            break;
          }
          if (l[0] === 6 && r.label < a[1]) {
            r.label = a[1], a = l;
            break;
          }
          if (a && r.label < a[2]) {
            r.label = a[2], r.ops.push(l);
            break;
          }
          a[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      l = t.call(e, r);
    } catch (c) {
      l = [6, c], i = 0;
    } finally {
      n = a = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}, sm = function() {
  function e(t) {
    var r = t.storage, n = t.key, i = n === void 0 ? "apollo-cache-persist" : n;
    this.storage = r, this.key = i;
  }
  return e.prototype.read = function() {
    return ro(this, void 0, void 0, function() {
      return no(this, function(t) {
        return [2, this.storage.getItem(this.key)];
      });
    });
  }, e.prototype.write = function(t) {
    return ro(this, void 0, void 0, function() {
      return no(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, this.storage.setItem(this.key, t)];
          case 1:
            return r.sent(), [2];
        }
      });
    });
  }, e.prototype.purge = function() {
    return ro(this, void 0, void 0, function() {
      return no(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.storage.removeItem(this.key)];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, e.prototype.getSize = function() {
    return ro(this, void 0, void 0, function() {
      var t;
      return no(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, this.storage.getItem(this.key)];
          case 1:
            return t = r.sent(), t == null ? [2, 0] : [2, typeof t == "string" ? t.length : null];
        }
      });
    });
  }, e;
}(), xu = function(e, t, r, n) {
  function i(a) {
    return a instanceof r ? a : new r(function(o) {
      o(a);
    });
  }
  return new (r || (r = Promise))(function(a, o) {
    function s(c) {
      try {
        l(n.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(n.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? a(c.value) : i(c.value).then(s, u);
    }
    l((n = n.apply(e, t || [])).next());
  });
}, Du = function(e, t) {
  var r = { label: 0, sent: function() {
    if (a[0] & 1) throw a[1];
    return a[1];
  }, trys: [], ops: [] }, n, i, a, o;
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(l) {
    return function(c) {
      return u([l, c]);
    };
  }
  function u(l) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, l[0] && (r = 0)), r; ) try {
      if (n = 1, i && (a = l[0] & 2 ? i.return : l[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, l[1])).done) return a;
      switch (i = 0, a && (l = [l[0] & 2, a.value]), l[0]) {
        case 0:
        case 1:
          a = l;
          break;
        case 4:
          return r.label++, { value: l[1], done: !1 };
        case 5:
          r.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            r = 0;
            continue;
          }
          if (l[0] === 3 && (!a || l[1] > a[0] && l[1] < a[3])) {
            r.label = l[1];
            break;
          }
          if (l[0] === 6 && r.label < a[1]) {
            r.label = a[1], a = l;
            break;
          }
          if (a && r.label < a[2]) {
            r.label = a[2], r.ops.push(l);
            break;
          }
          a[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      l = t.call(e, r);
    } catch (c) {
      l = [6, c], i = 0;
    } finally {
      n = a = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}, um = function() {
  function e(t, r) {
    var n = t.log, i = t.cache, a = t.storage, o = r.maxSize, s = o === void 0 ? 1024 * 1024 : o, u = r.persistenceMapper;
    this.log = n, this.cache = i, this.storage = a, this.paused = !1, u && (this.persistenceMapper = u), s && (this.maxSize = s);
  }
  return e.prototype.persist = function() {
    return xu(this, void 0, void 0, function() {
      var t, r;
      return Du(this, function(n) {
        switch (n.label) {
          case 0:
            return n.trys.push([0, 6, , 7]), t = this.cache.extract(), !this.paused && this.persistenceMapper ? [4, this.persistenceMapper(t)] : [3, 2];
          case 1:
            t = n.sent(), n.label = 2;
          case 2:
            return this.maxSize != null && typeof t == "string" && t.length > this.maxSize && !this.paused ? [4, this.purge()] : [3, 4];
          case 3:
            return n.sent(), this.paused = !0, [2];
          case 4:
            return this.paused ? [2] : [4, this.storage.write(t)];
          case 5:
            return n.sent(), this.log.info(typeof t == "string" ? "Persisted cache of size ".concat(t.length, " characters") : "Persisted cache"), [3, 7];
          case 6:
            throw r = n.sent(), this.log.error("Error persisting cache", r), r;
          case 7:
            return [2];
        }
      });
    });
  }, e.prototype.restore = function() {
    return xu(this, void 0, void 0, function() {
      var t, r;
      return Du(this, function(n) {
        switch (n.label) {
          case 0:
            return n.trys.push([0, 5, , 6]), [4, this.storage.read()];
          case 1:
            return t = n.sent(), t == null ? [3, 3] : [4, this.cache.restore(t)];
          case 2:
            return n.sent(), this.log.info(typeof t == "string" ? "Restored cache of size ".concat(t.length, " characters") : "Restored cache"), [3, 4];
          case 3:
            this.log.info("No stored cache to restore"), n.label = 4;
          case 4:
            return [3, 6];
          case 5:
            throw r = n.sent(), this.log.error("Error restoring cache", r), r;
          case 6:
            return [2];
        }
      });
    });
  }, e.prototype.purge = function() {
    return xu(this, void 0, void 0, function() {
      var t;
      return Du(this, function(r) {
        switch (r.label) {
          case 0:
            return r.trys.push([0, 2, , 3]), [4, this.storage.purge()];
          case 1:
            return r.sent(), this.log.info("Purged cache storage"), [3, 3];
          case 2:
            throw t = r.sent(), this.log.error("Error purging cache storage", t), t;
          case 3:
            return [2];
        }
      });
    });
  }, e;
}();
const lm = function(e) {
  var t = e.cache;
  return function(r) {
    var n = t.write, i = t.evict, a = t.modify, o = t.gc;
    return t.write = function() {
      for (var s = [], u = 0; u < arguments.length; u++)
        s[u] = arguments[u];
      var l = n.apply(t, s);
      return r(), l;
    }, t.evict = function() {
      for (var s = [], u = 0; u < arguments.length; u++)
        s[u] = arguments[u];
      var l = i.apply(t, s);
      return r(), l;
    }, t.modify = function() {
      for (var s = [], u = 0; u < arguments.length; u++)
        s[u] = arguments[u];
      var l = a.apply(t, s);
      return r(), l;
    }, t.gc = function() {
      for (var s = [], u = 0; u < arguments.length; u++)
        s[u] = arguments[u];
      var l = o.apply(t, s);
      return r(), l;
    }, function() {
      t.write = n, t.evict = i, t.modify = a, t.gc = o;
    };
  };
}, Mx = function(e) {
  var t = e.log, r = e.cache;
  return function(n) {
    return t.warn("Trigger option `background` not available on web; using `write` trigger"), lm({ cache: r })(n);
  };
};
var Nx = function() {
  function e(t, r) {
    var n = t.log, i = t.persistor, a = this;
    this.fire = function() {
      if (!a.debounce) {
        a.persist();
        return;
      }
      a.timeout != null && clearTimeout(a.timeout), a.timeout = setTimeout(a.persist, a.debounce);
    }, this.persist = function() {
      a.paused || a.persistor.persist();
    };
    var o = e.defaultDebounce, s = r.cache, u = r.debounce, l = r.trigger, c = l === void 0 ? "write" : l;
    if (c)
      switch (this.debounce = u ?? o, this.persistor = i, this.paused = !1, c) {
        case "write":
          this.uninstall = lm({ cache: s })(this.fire);
          break;
        case "background":
          u && n.warn("Debounce is not recommended with `background` trigger"), this.debounce = u, this.uninstall = Mx({ cache: s, log: n })(this.fire);
          break;
        default:
          if (typeof c == "function")
            this.uninstall = c(this.fire);
          else
            throw Error("Unrecognized trigger option: ".concat(c));
      }
  }
  return e.prototype.pause = function() {
    this.paused = !0;
  }, e.prototype.resume = function() {
    this.paused = !1;
  }, e.prototype.remove = function() {
    this.uninstall && (this.uninstall(), this.uninstall = null, this.paused = !0);
  }, e.defaultDebounce = 1e3, e;
}(), Lx = function() {
  function e(t) {
    if (!t.cache)
      throw new Error("In order to persist your Apollo Cache, you need to pass in a cache. Please see https://www.apollographql.com/docs/react/basics/caching.html for our default InMemoryCache.");
    if (!t.storage)
      throw new Error("In order to persist your Apollo Cache, you need to pass in an underlying storage provider. Please see https://github.com/apollographql/apollo-cache-persist#storage-providers");
    var r = new Rx(t), n = new Bx(t), i = new sm(t), a = new um({ log: r, cache: n, storage: i }, t), o = new Nx({ log: r, persistor: a }, t);
    this.log = r, this.cache = n, this.storage = i, this.persistor = a, this.trigger = o;
  }
  return e.prototype.persist = function() {
    return this.persistor.persist();
  }, e.prototype.restore = function() {
    return this.persistor.restore();
  }, e.prototype.purge = function() {
    return this.persistor.purge();
  }, e.prototype.pause = function() {
    this.trigger.pause();
  }, e.prototype.resume = function() {
    this.trigger.resume();
  }, e.prototype.remove = function() {
    this.trigger.remove();
  }, e.prototype.getLogs = function(t) {
    if (t === void 0 && (t = !1), t)
      this.log.tailLogs();
    else
      return this.log.getLogs();
  }, e.prototype.getSize = function() {
    return this.storage.getSize();
  }, e;
}(), Vc = /* @__PURE__ */ function() {
  var e = function(t, r) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]);
    }, e(t, r);
  };
  return function(t, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    e(t, r);
    function n() {
      this.constructor = t;
    }
    t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
(function(e) {
  Vc(t, e);
  function t(r) {
    var n = e.call(this, r) || this;
    return n.storage = new zx(r), n.persistor = new Vx({ log: n.log, cache: n.cache, storage: n.storage }, r), n;
  }
  return t.prototype.restoreSync = function() {
    this.persistor.restoreSync();
  }, t;
})(Lx);
var Vx = function(e) {
  Vc(t, e);
  function t(r, n) {
    var i = r.log, a = r.cache, o = r.storage;
    return e.call(this, { log: i, cache: a, storage: o }, n) || this;
  }
  return t.prototype.restoreSync = function() {
    this.cache.restore(this.storage.readSync());
  }, t;
}(um), zx = function(e) {
  Vc(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.readSync = function() {
    return this.storage.getItem(this.key);
  }, t;
}(sm), jx = function() {
  function e(t) {
    this.storage = t;
  }
  return e.prototype.getItem = function(t) {
    return this.storage.getItem(t);
  }, e.prototype.removeItem = function(t) {
    return this.storage.removeItem(t);
  }, e.prototype.setItem = function(t, r) {
    return r !== null ? this.storage.setItem(t, r) : this.removeItem(t);
  }, e;
}();
function Kx(e, t, r = window) {
  const n = q();
  oe(() => {
    n.current = t;
  }, [t]), oe(
    () => {
      if (!(r == null ? void 0 : r.addEventListener)) return;
      const a = (o) => n.current(o);
      return r.addEventListener(e, a), () => {
        r.removeEventListener(e, a);
      };
    },
    [e, r]
    // Re-run if eventName or element changes.
  );
}
const cm = new jx(window.localStorage);
function zc(e) {
  try {
    const t = cm.getItem(e);
    return t ? JSON.parse(t) : null;
  } catch (t) {
    return console.error(t), null;
  }
}
function dm(e, t) {
  try {
    const r = t instanceof Function ? t(zc(e)) : t;
    cm.setItem(
      e,
      r !== null ? JSON.stringify(r) : null
    );
  } catch (r) {
    console.error(r);
  }
  return t;
}
function Ux(e, t, r = { sync: !1 }) {
  const [n, i] = ee(
    () => zc(e) || t
  ), a = be(
    (s) => {
      !s.isTrusted || !r.sync || s.key === e && i(JSON.parse(s.newValue));
    },
    [e, r.sync]
  );
  return Kx("storage", a), [n, (s) => i(dm(e, s))];
}
class si {
  constructor(t) {
    this.accessToken = t.accessToken, this.expiresAt = t.expiresAt, this.ownerId = t.ownerId;
  }
  static fromOAuthResponse(t, r) {
    return new si({
      accessToken: t.access_token,
      expiresAt: yx(/* @__PURE__ */ new Date(), t.expires_in),
      ownerId: r
    });
  }
  static fromStored(t) {
    return new si({
      ...t,
      expiresAt: bx(t.expiresAt)
    });
  }
  get dataForStorage() {
    return {
      accessToken: this.accessToken,
      expiresAt: gx(this.expiresAt),
      ownerId: this.ownerId
    };
  }
  get expiresIn() {
    return this.expiresAt - /* @__PURE__ */ new Date();
  }
  get isExpired() {
    return this.expiresIn <= 0;
  }
  get isValid() {
    return !this.isExpired;
  }
}
const jc = "sfsAuthTokenData";
function fm(e) {
  if (e.error)
    throw new Error(`SSO callback error: ${e.error}`);
  return e;
}
function qx(e) {
  return new Promise((t, r) => {
    const n = document.createElement("iframe");
    n.src = e, n.classList.add("border-0", "w-0", "h-0", "absolute", "invisible"), n.width = 0, n.height = 0;
    const i = (a) => {
      if (a.source !== n.contentWindow) return;
      n.remove();
      const {
        data: { type: o, payload: s }
      } = a;
      switch (o) {
        case "UNAUTHENTICATED":
          window.removeEventListener("message", i), r(new Error("SSO_UNAUTHENTICATED"));
          break;
        case "SSO_CALLBACK":
          window.removeEventListener("message", i), t(fm(s));
          break;
        default:
          console.error("Unknown message type", o, s);
      }
    };
    window.addEventListener("message", i), document.body.appendChild(n);
  });
}
function Hx(e) {
  return new Promise((t, r) => {
    const n = window.open(e, "ssoLogin", "width=600,height=480");
    if (!n) return r(new Error("Failed to open login popup."));
    const i = setInterval(() => {
      n.closed && (clearInterval(i), r(new Error("Login popup closed.")));
    }, 1e3), a = (o) => {
      if (o.source !== n) return;
      const {
        data: { type: s, payload: u }
      } = o;
      s === "SSO_CALLBACK" && (clearInterval(i), n.close(), window.removeEventListener("message", a), t(fm(u)));
    };
    window.addEventListener("message", a);
  });
}
async function Kc({ mode: e, ownerId: t }) {
  const r = e === "development" ? oi.ssoDevUrl : oi.ssoUrl;
  let n;
  try {
    n = await qx(r);
  } catch (a) {
    if (a.message === "SSO_UNAUTHENTICATED") {
      const o = Hx(r);
      n = await Ie.promise(
        o,
        {
          pending: "Please login to use this feature",
          success: "Successfully logged in!",
          error: "Failed to login. You need to login to use this feature."
        },
        { position: "bottom-right" }
      );
    } else
      throw a;
  }
  const i = si.fromOAuthResponse(n, t);
  return dm(jc, i.dataForStorage), i.accessToken;
}
function hm({ ownerId: e }) {
  const t = zc(jc);
  if (t && t.ownerId === e) {
    const { accessToken: r } = si.fromStored(t);
    return r;
  }
  return null;
}
const Wx = ce({
  isAuthenticated: !1,
  tokenData: null,
  reauth: () => {
  }
});
function Qx({ children: e, mode: t, ownerId: r }) {
  const n = Gx({ mode: t, ownerId: r });
  return /* @__PURE__ */ O(Wx.Provider, { value: n, children: e });
}
function Gx({ mode: e, ownerId: t }) {
  let r;
  const [n, i] = Ux(
    jc,
    null,
    { sync: !0 }
  ), a = () => {
    i(null), Kc({ mode: e, ownerId: t });
  };
  n && (t !== n.ownerId ? a() : r = si.fromStored(n));
  const o = !!(r != null && r.accessToken);
  return {
    accessToken: r == null ? void 0 : r.accessToken,
    isAuthenticated: o,
    reauth: a
  };
}
var bl = function(e, t) {
  return bl = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (r[i] = n[i]);
  }, bl(e, t);
};
function Ut(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  bl(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var M = function() {
  return M = Object.assign || function(t) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (t[a] = r[a]);
    }
    return t;
  }, M.apply(this, arguments);
};
function Kt(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
      t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
}
function Or(e, t, r, n) {
  function i(a) {
    return a instanceof r ? a : new r(function(o) {
      o(a);
    });
  }
  return new (r || (r = Promise))(function(a, o) {
    function s(c) {
      try {
        l(n.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(n.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? a(c.value) : i(c.value).then(s, u);
    }
    l((n = n.apply(e, t || [])).next());
  });
}
function Ir(e, t) {
  var r = { label: 0, sent: function() {
    if (a[0] & 1) throw a[1];
    return a[1];
  }, trys: [], ops: [] }, n, i, a, o;
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(l) {
    return function(c) {
      return u([l, c]);
    };
  }
  function u(l) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, l[0] && (r = 0)), r; ) try {
      if (n = 1, i && (a = l[0] & 2 ? i.return : l[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, l[1])).done) return a;
      switch (i = 0, a && (l = [l[0] & 2, a.value]), l[0]) {
        case 0:
        case 1:
          a = l;
          break;
        case 4:
          return r.label++, { value: l[1], done: !1 };
        case 5:
          r.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            r = 0;
            continue;
          }
          if (l[0] === 3 && (!a || l[1] > a[0] && l[1] < a[3])) {
            r.label = l[1];
            break;
          }
          if (l[0] === 6 && r.label < a[1]) {
            r.label = a[1], a = l;
            break;
          }
          if (a && r.label < a[2]) {
            r.label = a[2], r.ops.push(l);
            break;
          }
          a[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      l = t.call(e, r);
    } catch (c) {
      l = [6, c], i = 0;
    } finally {
      n = a = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function jt(e, t, r) {
  if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)
    (a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]);
  return e.concat(a || Array.prototype.slice.call(t));
}
var Eu = "Invariant Violation", xf = Object.setPrototypeOf, Zx = xf === void 0 ? function(e, t) {
  return e.__proto__ = t, e;
} : xf, pm = (
  /** @class */
  function(e) {
    Ut(t, e);
    function t(r) {
      r === void 0 && (r = Eu);
      var n = e.call(this, typeof r == "number" ? Eu + ": " + r + " (see https://github.com/apollographql/invariant-packages)" : r) || this;
      return n.framesToPop = 1, n.name = Eu, Zx(n, t.prototype), n;
    }
    return t;
  }(Error)
);
function en(e, t) {
  if (!e)
    throw new pm(t);
}
var mm = ["debug", "log", "warn", "error", "silent"], Yx = mm.indexOf("log");
function io(e) {
  return function() {
    if (mm.indexOf(e) >= Yx) {
      var t = console[e] || console.log;
      return t.apply(console, arguments);
    }
  };
}
(function(e) {
  e.debug = io("debug"), e.log = io("log"), e.warn = io("warn"), e.error = io("error");
})(en || (en = {}));
var Uc = "3.10.6";
function Vt(e) {
  try {
    return e();
  } catch {
  }
}
const $l = Vt(function() {
  return globalThis;
}) || Vt(function() {
  return window;
}) || Vt(function() {
  return self;
}) || Vt(function() {
  return global;
}) || // We don't expect the Function constructor ever to be invoked at runtime, as
// long as at least one of globalThis, window, self, or global is defined, so
// we are under no obligation to make it easy for static analysis tools to
// detect syntactic usage of the Function constructor. If you think you can
// improve your static analysis to detect this obfuscation, think again. This
// is an arms race you cannot win, at least not in JavaScript.
Vt(function() {
  return Vt.constructor("return this")();
});
var Df = /* @__PURE__ */ new Map();
function xl(e) {
  var t = Df.get(e) || 1;
  return Df.set(e, t + 1), "".concat(e, ":").concat(t, ":").concat(Math.random().toString(36).slice(2));
}
function vm(e, t) {
  t === void 0 && (t = 0);
  var r = xl("stringifyForDisplay");
  return JSON.stringify(e, function(n, i) {
    return i === void 0 ? r : i;
  }, t).split(JSON.stringify(r)).join("<undefined>");
}
function ao(e) {
  return function(t) {
    for (var r = [], n = 1; n < arguments.length; n++)
      r[n - 1] = arguments[n];
    if (typeof t == "number") {
      var i = t;
      t = qc(i), t || (t = Hc(i, r), r = []);
    }
    e.apply(void 0, [t].concat(r));
  };
}
var ue = Object.assign(function(t, r) {
  for (var n = [], i = 2; i < arguments.length; i++)
    n[i - 2] = arguments[i];
  t || en(t, qc(r, n) || Hc(r, n));
}, {
  debug: ao(en.debug),
  log: ao(en.log),
  warn: ao(en.warn),
  error: ao(en.error)
});
function ht(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  return new pm(qc(e, t) || Hc(e, t));
}
var Ef = Symbol.for("ApolloErrorMessageHandler_" + Uc);
function ym(e) {
  return typeof e == "string" ? e : vm(e, 2).slice(0, 1e3);
}
function qc(e, t) {
  if (t === void 0 && (t = []), !!e)
    return $l[Ef] && $l[Ef](e, t.map(ym));
}
function Hc(e, t) {
  if (t === void 0 && (t = []), !!e)
    return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
      version: Uc,
      message: e,
      args: t.map(ym)
    })));
}
function wo(e, t) {
  if (!!!e)
    throw new Error(t);
}
function Jx(e) {
  return typeof e == "object" && e !== null;
}
function Xx(e, t) {
  if (!!!e)
    throw new Error(
      "Unexpected invariant triggered."
    );
}
const eD = /\r\n|[\n\r]/g;
function Dl(e, t) {
  let r = 0, n = 1;
  for (const i of e.body.matchAll(eD)) {
    if (typeof i.index == "number" || Xx(!1), i.index >= t)
      break;
    r = i.index + i[0].length, n += 1;
  }
  return {
    line: n,
    column: t + 1 - r
  };
}
function tD(e) {
  return gm(
    e.source,
    Dl(e.source, e.start)
  );
}
function gm(e, t) {
  const r = e.locationOffset.column - 1, n = "".padStart(r) + e.body, i = t.line - 1, a = e.locationOffset.line - 1, o = t.line + a, s = t.line === 1 ? r : 0, u = t.column + s, l = `${e.name}:${o}:${u}
`, c = n.split(/\r\n|[\n\r]/g), d = c[i];
  if (d.length > 120) {
    const f = Math.floor(u / 80), h = u % 80, p = [];
    for (let v = 0; v < d.length; v += 80)
      p.push(d.slice(v, v + 80));
    return l + wf([
      [`${o} |`, p[0]],
      ...p.slice(1, f + 1).map((v) => ["|", v]),
      ["|", "^".padStart(h)],
      ["|", p[f + 1]]
    ]);
  }
  return l + wf([
    // Lines specified like this: ["prefix", "string"],
    [`${o - 1} |`, c[i - 1]],
    [`${o} |`, d],
    ["|", "^".padStart(u)],
    [`${o + 1} |`, c[i + 1]]
  ]);
}
function wf(e) {
  const t = e.filter(([n, i]) => i !== void 0), r = Math.max(...t.map(([n]) => n.length));
  return t.map(([n, i]) => n.padStart(r) + (i ? " " + i : "")).join(`
`);
}
function rD(e) {
  const t = e[0];
  return t == null || "kind" in t || "length" in t ? {
    nodes: t,
    source: e[1],
    positions: e[2],
    path: e[3],
    originalError: e[4],
    extensions: e[5]
  } : t;
}
class Wc extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(t, ...r) {
    var n, i, a;
    const { nodes: o, source: s, positions: u, path: l, originalError: c, extensions: d } = rD(r);
    super(t), this.name = "GraphQLError", this.path = l ?? void 0, this.originalError = c ?? void 0, this.nodes = Cf(
      Array.isArray(o) ? o : o ? [o] : void 0
    );
    const f = Cf(
      (n = this.nodes) === null || n === void 0 ? void 0 : n.map((p) => p.loc).filter((p) => p != null)
    );
    this.source = s ?? (f == null || (i = f[0]) === null || i === void 0 ? void 0 : i.source), this.positions = u ?? (f == null ? void 0 : f.map((p) => p.start)), this.locations = u && s ? u.map((p) => Dl(s, p)) : f == null ? void 0 : f.map((p) => Dl(p.source, p.start));
    const h = Jx(
      c == null ? void 0 : c.extensions
    ) ? c == null ? void 0 : c.extensions : void 0;
    this.extensions = (a = d ?? h) !== null && a !== void 0 ? a : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), c != null && c.stack ? Object.defineProperty(this, "stack", {
      value: c.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, Wc) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let t = this.message;
    if (this.nodes)
      for (const r of this.nodes)
        r.loc && (t += `

` + tD(r.loc));
    else if (this.source && this.locations)
      for (const r of this.locations)
        t += `

` + gm(this.source, r);
    return t;
  }
  toJSON() {
    const t = {
      message: this.message
    };
    return this.locations != null && (t.locations = this.locations), this.path != null && (t.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (t.extensions = this.extensions), t;
  }
}
function Cf(e) {
  return e === void 0 || e.length === 0 ? void 0 : e;
}
function ot(e, t, r) {
  return new Wc(`Syntax Error: ${r}`, {
    source: e,
    positions: [t]
  });
}
class nD {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(t, r, n) {
    this.start = t.start, this.end = r.end, this.startToken = t, this.endToken = r, this.source = n;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class bm {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(t, r, n, i, a, o) {
    this.kind = t, this.start = r, this.end = n, this.line = i, this.column = a, this.value = o, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const $m = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, iD = new Set(Object.keys($m));
function Sf(e) {
  const t = e == null ? void 0 : e.kind;
  return typeof t == "string" && iD.has(t);
}
var Vn;
(function(e) {
  e.QUERY = "query", e.MUTATION = "mutation", e.SUBSCRIPTION = "subscription";
})(Vn || (Vn = {}));
var El;
(function(e) {
  e.QUERY = "QUERY", e.MUTATION = "MUTATION", e.SUBSCRIPTION = "SUBSCRIPTION", e.FIELD = "FIELD", e.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", e.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", e.INLINE_FRAGMENT = "INLINE_FRAGMENT", e.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", e.SCHEMA = "SCHEMA", e.SCALAR = "SCALAR", e.OBJECT = "OBJECT", e.FIELD_DEFINITION = "FIELD_DEFINITION", e.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", e.INTERFACE = "INTERFACE", e.UNION = "UNION", e.ENUM = "ENUM", e.ENUM_VALUE = "ENUM_VALUE", e.INPUT_OBJECT = "INPUT_OBJECT", e.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(El || (El = {}));
var te;
(function(e) {
  e.NAME = "Name", e.DOCUMENT = "Document", e.OPERATION_DEFINITION = "OperationDefinition", e.VARIABLE_DEFINITION = "VariableDefinition", e.SELECTION_SET = "SelectionSet", e.FIELD = "Field", e.ARGUMENT = "Argument", e.FRAGMENT_SPREAD = "FragmentSpread", e.INLINE_FRAGMENT = "InlineFragment", e.FRAGMENT_DEFINITION = "FragmentDefinition", e.VARIABLE = "Variable", e.INT = "IntValue", e.FLOAT = "FloatValue", e.STRING = "StringValue", e.BOOLEAN = "BooleanValue", e.NULL = "NullValue", e.ENUM = "EnumValue", e.LIST = "ListValue", e.OBJECT = "ObjectValue", e.OBJECT_FIELD = "ObjectField", e.DIRECTIVE = "Directive", e.NAMED_TYPE = "NamedType", e.LIST_TYPE = "ListType", e.NON_NULL_TYPE = "NonNullType", e.SCHEMA_DEFINITION = "SchemaDefinition", e.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", e.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", e.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", e.FIELD_DEFINITION = "FieldDefinition", e.INPUT_VALUE_DEFINITION = "InputValueDefinition", e.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", e.UNION_TYPE_DEFINITION = "UnionTypeDefinition", e.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", e.ENUM_VALUE_DEFINITION = "EnumValueDefinition", e.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", e.DIRECTIVE_DEFINITION = "DirectiveDefinition", e.SCHEMA_EXTENSION = "SchemaExtension", e.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", e.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", e.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", e.UNION_TYPE_EXTENSION = "UnionTypeExtension", e.ENUM_TYPE_EXTENSION = "EnumTypeExtension", e.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(te || (te = {}));
function wl(e) {
  return e === 9 || e === 32;
}
function ca(e) {
  return e >= 48 && e <= 57;
}
function xm(e) {
  return e >= 97 && e <= 122 || // A-Z
  e >= 65 && e <= 90;
}
function Dm(e) {
  return xm(e) || e === 95;
}
function aD(e) {
  return xm(e) || ca(e) || e === 95;
}
function oD(e) {
  var t;
  let r = Number.MAX_SAFE_INTEGER, n = null, i = -1;
  for (let o = 0; o < e.length; ++o) {
    var a;
    const s = e[o], u = sD(s);
    u !== s.length && (n = (a = n) !== null && a !== void 0 ? a : o, i = o, o !== 0 && u < r && (r = u));
  }
  return e.map((o, s) => s === 0 ? o : o.slice(r)).slice(
    (t = n) !== null && t !== void 0 ? t : 0,
    i + 1
  );
}
function sD(e) {
  let t = 0;
  for (; t < e.length && wl(e.charCodeAt(t)); )
    ++t;
  return t;
}
function uD(e, t) {
  const r = e.replace(/"""/g, '\\"""'), n = r.split(/\r\n|[\n\r]/g), i = n.length === 1, a = n.length > 1 && n.slice(1).every((h) => h.length === 0 || wl(h.charCodeAt(0))), o = r.endsWith('\\"""'), s = e.endsWith('"') && !o, u = e.endsWith("\\"), l = s || u, c = (
    // add leading and trailing new lines only if it improves readability
    !i || e.length > 70 || l || a || o
  );
  let d = "";
  const f = i && wl(e.charCodeAt(0));
  return (c && !f || a) && (d += `
`), d += r, (c || l) && (d += `
`), '"""' + d + '"""';
}
var j;
(function(e) {
  e.SOF = "<SOF>", e.EOF = "<EOF>", e.BANG = "!", e.DOLLAR = "$", e.AMP = "&", e.PAREN_L = "(", e.PAREN_R = ")", e.SPREAD = "...", e.COLON = ":", e.EQUALS = "=", e.AT = "@", e.BRACKET_L = "[", e.BRACKET_R = "]", e.BRACE_L = "{", e.PIPE = "|", e.BRACE_R = "}", e.NAME = "Name", e.INT = "Int", e.FLOAT = "Float", e.STRING = "String", e.BLOCK_STRING = "BlockString", e.COMMENT = "Comment";
})(j || (j = {}));
class lD {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(t) {
    const r = new bm(j.SOF, 0, 0, 0, 0);
    this.source = t, this.lastToken = r, this.token = r, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let t = this.token;
    if (t.kind !== j.EOF)
      do
        if (t.next)
          t = t.next;
        else {
          const r = dD(this, t.end);
          t.next = r, r.prev = t, t = r;
        }
      while (t.kind === j.COMMENT);
    return t;
  }
}
function cD(e) {
  return e === j.BANG || e === j.DOLLAR || e === j.AMP || e === j.PAREN_L || e === j.PAREN_R || e === j.SPREAD || e === j.COLON || e === j.EQUALS || e === j.AT || e === j.BRACKET_L || e === j.BRACKET_R || e === j.BRACE_L || e === j.PIPE || e === j.BRACE_R;
}
function gi(e) {
  return e >= 0 && e <= 55295 || e >= 57344 && e <= 1114111;
}
function Fs(e, t) {
  return Em(e.charCodeAt(t)) && wm(e.charCodeAt(t + 1));
}
function Em(e) {
  return e >= 55296 && e <= 56319;
}
function wm(e) {
  return e >= 56320 && e <= 57343;
}
function fn(e, t) {
  const r = e.source.body.codePointAt(t);
  if (r === void 0)
    return j.EOF;
  if (r >= 32 && r <= 126) {
    const n = String.fromCodePoint(r);
    return n === '"' ? `'"'` : `"${n}"`;
  }
  return "U+" + r.toString(16).toUpperCase().padStart(4, "0");
}
function Xe(e, t, r, n, i) {
  const a = e.line, o = 1 + r - e.lineStart;
  return new bm(t, r, n, a, o, i);
}
function dD(e, t) {
  const r = e.source.body, n = r.length;
  let i = t;
  for (; i < n; ) {
    const a = r.charCodeAt(i);
    switch (a) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++i;
        continue;
      case 10:
        ++i, ++e.line, e.lineStart = i;
        continue;
      case 13:
        r.charCodeAt(i + 1) === 10 ? i += 2 : ++i, ++e.line, e.lineStart = i;
        continue;
      case 35:
        return fD(e, i);
      case 33:
        return Xe(e, j.BANG, i, i + 1);
      case 36:
        return Xe(e, j.DOLLAR, i, i + 1);
      case 38:
        return Xe(e, j.AMP, i, i + 1);
      case 40:
        return Xe(e, j.PAREN_L, i, i + 1);
      case 41:
        return Xe(e, j.PAREN_R, i, i + 1);
      case 46:
        if (r.charCodeAt(i + 1) === 46 && r.charCodeAt(i + 2) === 46)
          return Xe(e, j.SPREAD, i, i + 3);
        break;
      case 58:
        return Xe(e, j.COLON, i, i + 1);
      case 61:
        return Xe(e, j.EQUALS, i, i + 1);
      case 64:
        return Xe(e, j.AT, i, i + 1);
      case 91:
        return Xe(e, j.BRACKET_L, i, i + 1);
      case 93:
        return Xe(e, j.BRACKET_R, i, i + 1);
      case 123:
        return Xe(e, j.BRACE_L, i, i + 1);
      case 124:
        return Xe(e, j.PIPE, i, i + 1);
      case 125:
        return Xe(e, j.BRACE_R, i, i + 1);
      case 34:
        return r.charCodeAt(i + 1) === 34 && r.charCodeAt(i + 2) === 34 ? gD(e, i) : pD(e, i);
    }
    if (ca(a) || a === 45)
      return hD(e, i, a);
    if (Dm(a))
      return bD(e, i);
    throw ot(
      e.source,
      i,
      a === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : gi(a) || Fs(r, i) ? `Unexpected character: ${fn(e, i)}.` : `Invalid character: ${fn(e, i)}.`
    );
  }
  return Xe(e, j.EOF, n, n);
}
function fD(e, t) {
  const r = e.source.body, n = r.length;
  let i = t + 1;
  for (; i < n; ) {
    const a = r.charCodeAt(i);
    if (a === 10 || a === 13)
      break;
    if (gi(a))
      ++i;
    else if (Fs(r, i))
      i += 2;
    else
      break;
  }
  return Xe(
    e,
    j.COMMENT,
    t,
    i,
    r.slice(t + 1, i)
  );
}
function hD(e, t, r) {
  const n = e.source.body;
  let i = t, a = r, o = !1;
  if (a === 45 && (a = n.charCodeAt(++i)), a === 48) {
    if (a = n.charCodeAt(++i), ca(a))
      throw ot(
        e.source,
        i,
        `Invalid number, unexpected digit after 0: ${fn(
          e,
          i
        )}.`
      );
  } else
    i = wu(e, i, a), a = n.charCodeAt(i);
  if (a === 46 && (o = !0, a = n.charCodeAt(++i), i = wu(e, i, a), a = n.charCodeAt(i)), (a === 69 || a === 101) && (o = !0, a = n.charCodeAt(++i), (a === 43 || a === 45) && (a = n.charCodeAt(++i)), i = wu(e, i, a), a = n.charCodeAt(i)), a === 46 || Dm(a))
    throw ot(
      e.source,
      i,
      `Invalid number, expected digit but got: ${fn(
        e,
        i
      )}.`
    );
  return Xe(
    e,
    o ? j.FLOAT : j.INT,
    t,
    i,
    n.slice(t, i)
  );
}
function wu(e, t, r) {
  if (!ca(r))
    throw ot(
      e.source,
      t,
      `Invalid number, expected digit but got: ${fn(
        e,
        t
      )}.`
    );
  const n = e.source.body;
  let i = t + 1;
  for (; ca(n.charCodeAt(i)); )
    ++i;
  return i;
}
function pD(e, t) {
  const r = e.source.body, n = r.length;
  let i = t + 1, a = i, o = "";
  for (; i < n; ) {
    const s = r.charCodeAt(i);
    if (s === 34)
      return o += r.slice(a, i), Xe(e, j.STRING, t, i + 1, o);
    if (s === 92) {
      o += r.slice(a, i);
      const u = r.charCodeAt(i + 1) === 117 ? r.charCodeAt(i + 2) === 123 ? mD(e, i) : vD(e, i) : yD(e, i);
      o += u.value, i += u.size, a = i;
      continue;
    }
    if (s === 10 || s === 13)
      break;
    if (gi(s))
      ++i;
    else if (Fs(r, i))
      i += 2;
    else
      throw ot(
        e.source,
        i,
        `Invalid character within String: ${fn(
          e,
          i
        )}.`
      );
  }
  throw ot(e.source, i, "Unterminated string.");
}
function mD(e, t) {
  const r = e.source.body;
  let n = 0, i = 3;
  for (; i < 12; ) {
    const a = r.charCodeAt(t + i++);
    if (a === 125) {
      if (i < 5 || !gi(n))
        break;
      return {
        value: String.fromCodePoint(n),
        size: i
      };
    }
    if (n = n << 4 | Ki(a), n < 0)
      break;
  }
  throw ot(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${r.slice(
      t,
      t + i
    )}".`
  );
}
function vD(e, t) {
  const r = e.source.body, n = kf(r, t + 2);
  if (gi(n))
    return {
      value: String.fromCodePoint(n),
      size: 6
    };
  if (Em(n) && r.charCodeAt(t + 6) === 92 && r.charCodeAt(t + 7) === 117) {
    const i = kf(r, t + 8);
    if (wm(i))
      return {
        value: String.fromCodePoint(n, i),
        size: 12
      };
  }
  throw ot(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${r.slice(t, t + 6)}".`
  );
}
function kf(e, t) {
  return Ki(e.charCodeAt(t)) << 12 | Ki(e.charCodeAt(t + 1)) << 8 | Ki(e.charCodeAt(t + 2)) << 4 | Ki(e.charCodeAt(t + 3));
}
function Ki(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function yD(e, t) {
  const r = e.source.body;
  switch (r.charCodeAt(t + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw ot(
    e.source,
    t,
    `Invalid character escape sequence: "${r.slice(
      t,
      t + 2
    )}".`
  );
}
function gD(e, t) {
  const r = e.source.body, n = r.length;
  let i = e.lineStart, a = t + 3, o = a, s = "";
  const u = [];
  for (; a < n; ) {
    const l = r.charCodeAt(a);
    if (l === 34 && r.charCodeAt(a + 1) === 34 && r.charCodeAt(a + 2) === 34) {
      s += r.slice(o, a), u.push(s);
      const c = Xe(
        e,
        j.BLOCK_STRING,
        t,
        a + 3,
        // Return a string of the lines joined with U+000A.
        oD(u).join(`
`)
      );
      return e.line += u.length - 1, e.lineStart = i, c;
    }
    if (l === 92 && r.charCodeAt(a + 1) === 34 && r.charCodeAt(a + 2) === 34 && r.charCodeAt(a + 3) === 34) {
      s += r.slice(o, a), o = a + 1, a += 4;
      continue;
    }
    if (l === 10 || l === 13) {
      s += r.slice(o, a), u.push(s), l === 13 && r.charCodeAt(a + 1) === 10 ? a += 2 : ++a, s = "", o = a, i = a;
      continue;
    }
    if (gi(l))
      ++a;
    else if (Fs(r, a))
      a += 2;
    else
      throw ot(
        e.source,
        a,
        `Invalid character within String: ${fn(
          e,
          a
        )}.`
      );
  }
  throw ot(e.source, a, "Unterminated string.");
}
function bD(e, t) {
  const r = e.source.body, n = r.length;
  let i = t + 1;
  for (; i < n; ) {
    const a = r.charCodeAt(i);
    if (aD(a))
      ++i;
    else
      break;
  }
  return Xe(
    e,
    j.NAME,
    t,
    i,
    r.slice(t, i)
  );
}
const $D = 10, Cm = 2;
function Qc(e) {
  return Os(e, []);
}
function Os(e, t) {
  switch (typeof e) {
    case "string":
      return JSON.stringify(e);
    case "function":
      return e.name ? `[function ${e.name}]` : "[function]";
    case "object":
      return xD(e, t);
    default:
      return String(e);
  }
}
function xD(e, t) {
  if (e === null)
    return "null";
  if (t.includes(e))
    return "[Circular]";
  const r = [...t, e];
  if (DD(e)) {
    const n = e.toJSON();
    if (n !== e)
      return typeof n == "string" ? n : Os(n, r);
  } else if (Array.isArray(e))
    return wD(e, r);
  return ED(e, r);
}
function DD(e) {
  return typeof e.toJSON == "function";
}
function ED(e, t) {
  const r = Object.entries(e);
  return r.length === 0 ? "{}" : t.length > Cm ? "[" + CD(e) + "]" : "{ " + r.map(
    ([i, a]) => i + ": " + Os(a, t)
  ).join(", ") + " }";
}
function wD(e, t) {
  if (e.length === 0)
    return "[]";
  if (t.length > Cm)
    return "[Array]";
  const r = Math.min($D, e.length), n = e.length - r, i = [];
  for (let a = 0; a < r; ++a)
    i.push(Os(e[a], t));
  return n === 1 ? i.push("... 1 more item") : n > 1 && i.push(`... ${n} more items`), "[" + i.join(", ") + "]";
}
function CD(e) {
  const t = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, "");
  if (t === "Object" && typeof e.constructor == "function") {
    const r = e.constructor.name;
    if (typeof r == "string" && r !== "")
      return r;
  }
  return t;
}
const SD = globalThis.process && // eslint-disable-next-line no-undef
process.env.NODE_ENV === "production", kD = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  SD ? function(t, r) {
    return t instanceof r;
  } : function(t, r) {
    if (t instanceof r)
      return !0;
    if (typeof t == "object" && t !== null) {
      var n;
      const i = r.prototype[Symbol.toStringTag], a = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in t ? t[Symbol.toStringTag] : (n = t.constructor) === null || n === void 0 ? void 0 : n.name
      );
      if (i === a) {
        const o = Qc(t);
        throw new Error(`Cannot use ${i} "${o}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
class Sm {
  constructor(t, r = "GraphQL request", n = {
    line: 1,
    column: 1
  }) {
    typeof t == "string" || wo(!1, `Body must be a string. Received: ${Qc(t)}.`), this.body = t, this.name = r, this.locationOffset = n, this.locationOffset.line > 0 || wo(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || wo(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function PD(e) {
  return kD(e, Sm);
}
function TD(e, t) {
  return new AD(e, t).parseDocument();
}
class AD {
  constructor(t, r = {}) {
    const n = PD(t) ? t : new Sm(t);
    this._lexer = new lD(n), this._options = r, this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const t = this.expectToken(j.NAME);
    return this.node(t, {
      kind: te.NAME,
      value: t.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: te.DOCUMENT,
      definitions: this.many(
        j.SOF,
        this.parseDefinition,
        j.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(j.BRACE_L))
      return this.parseOperationDefinition();
    const t = this.peekDescription(), r = t ? this._lexer.lookahead() : this._lexer.token;
    if (r.kind === j.NAME) {
      switch (r.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (t)
        throw ot(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (r.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(r);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const t = this._lexer.token;
    if (this.peek(j.BRACE_L))
      return this.node(t, {
        kind: te.OPERATION_DEFINITION,
        operation: Vn.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const r = this.parseOperationType();
    let n;
    return this.peek(j.NAME) && (n = this.parseName()), this.node(t, {
      kind: te.OPERATION_DEFINITION,
      operation: r,
      name: n,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const t = this.expectToken(j.NAME);
    switch (t.value) {
      case "query":
        return Vn.QUERY;
      case "mutation":
        return Vn.MUTATION;
      case "subscription":
        return Vn.SUBSCRIPTION;
    }
    throw this.unexpected(t);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      j.PAREN_L,
      this.parseVariableDefinition,
      j.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: te.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(j.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(j.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const t = this._lexer.token;
    return this.expectToken(j.DOLLAR), this.node(t, {
      kind: te.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: te.SELECTION_SET,
      selections: this.many(
        j.BRACE_L,
        this.parseSelection,
        j.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(j.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const t = this._lexer.token, r = this.parseName();
    let n, i;
    return this.expectOptionalToken(j.COLON) ? (n = r, i = this.parseName()) : i = r, this.node(t, {
      kind: te.FIELD,
      alias: n,
      name: i,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(j.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(t) {
    const r = t ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(j.PAREN_L, r, j.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(t = !1) {
    const r = this._lexer.token, n = this.parseName();
    return this.expectToken(j.COLON), this.node(r, {
      kind: te.ARGUMENT,
      name: n,
      value: this.parseValueLiteral(t)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const t = this._lexer.token;
    this.expectToken(j.SPREAD);
    const r = this.expectOptionalKeyword("on");
    return !r && this.peek(j.NAME) ? this.node(t, {
      kind: te.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(t, {
      kind: te.INLINE_FRAGMENT,
      typeCondition: r ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const t = this._lexer.token;
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(t, {
      kind: te.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(t, {
      kind: te.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(t) {
    const r = this._lexer.token;
    switch (r.kind) {
      case j.BRACKET_L:
        return this.parseList(t);
      case j.BRACE_L:
        return this.parseObject(t);
      case j.INT:
        return this.advanceLexer(), this.node(r, {
          kind: te.INT,
          value: r.value
        });
      case j.FLOAT:
        return this.advanceLexer(), this.node(r, {
          kind: te.FLOAT,
          value: r.value
        });
      case j.STRING:
      case j.BLOCK_STRING:
        return this.parseStringLiteral();
      case j.NAME:
        switch (this.advanceLexer(), r.value) {
          case "true":
            return this.node(r, {
              kind: te.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(r, {
              kind: te.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(r, {
              kind: te.NULL
            });
          default:
            return this.node(r, {
              kind: te.ENUM,
              value: r.value
            });
        }
      case j.DOLLAR:
        if (t)
          if (this.expectToken(j.DOLLAR), this._lexer.token.kind === j.NAME) {
            const n = this._lexer.token.value;
            throw ot(
              this._lexer.source,
              r.start,
              `Unexpected variable "$${n}" in constant value.`
            );
          } else
            throw this.unexpected(r);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const t = this._lexer.token;
    return this.advanceLexer(), this.node(t, {
      kind: te.STRING,
      value: t.value,
      block: t.kind === j.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(t) {
    const r = () => this.parseValueLiteral(t);
    return this.node(this._lexer.token, {
      kind: te.LIST,
      values: this.any(j.BRACKET_L, r, j.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(t) {
    const r = () => this.parseObjectField(t);
    return this.node(this._lexer.token, {
      kind: te.OBJECT,
      fields: this.any(j.BRACE_L, r, j.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(t) {
    const r = this._lexer.token, n = this.parseName();
    return this.expectToken(j.COLON), this.node(r, {
      kind: te.OBJECT_FIELD,
      name: n,
      value: this.parseValueLiteral(t)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(t) {
    const r = [];
    for (; this.peek(j.AT); )
      r.push(this.parseDirective(t));
    return r;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(t) {
    const r = this._lexer.token;
    return this.expectToken(j.AT), this.node(r, {
      kind: te.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(t)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const t = this._lexer.token;
    let r;
    if (this.expectOptionalToken(j.BRACKET_L)) {
      const n = this.parseTypeReference();
      this.expectToken(j.BRACKET_R), r = this.node(t, {
        kind: te.LIST_TYPE,
        type: n
      });
    } else
      r = this.parseNamedType();
    return this.expectOptionalToken(j.BANG) ? this.node(t, {
      kind: te.NON_NULL_TYPE,
      type: r
    }) : r;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: te.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(j.STRING) || this.peek(j.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("schema");
    const n = this.parseConstDirectives(), i = this.many(
      j.BRACE_L,
      this.parseOperationTypeDefinition,
      j.BRACE_R
    );
    return this.node(t, {
      kind: te.SCHEMA_DEFINITION,
      description: r,
      directives: n,
      operationTypes: i
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const t = this._lexer.token, r = this.parseOperationType();
    this.expectToken(j.COLON);
    const n = this.parseNamedType();
    return this.node(t, {
      kind: te.OPERATION_TYPE_DEFINITION,
      operation: r,
      type: n
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("scalar");
    const n = this.parseName(), i = this.parseConstDirectives();
    return this.node(t, {
      kind: te.SCALAR_TYPE_DEFINITION,
      description: r,
      name: n,
      directives: i
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("type");
    const n = this.parseName(), i = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(t, {
      kind: te.OBJECT_TYPE_DEFINITION,
      description: r,
      name: n,
      interfaces: i,
      directives: a,
      fields: o
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(j.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      j.BRACE_L,
      this.parseFieldDefinition,
      j.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const t = this._lexer.token, r = this.parseDescription(), n = this.parseName(), i = this.parseArgumentDefs();
    this.expectToken(j.COLON);
    const a = this.parseTypeReference(), o = this.parseConstDirectives();
    return this.node(t, {
      kind: te.FIELD_DEFINITION,
      description: r,
      name: n,
      arguments: i,
      type: a,
      directives: o
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      j.PAREN_L,
      this.parseInputValueDef,
      j.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const t = this._lexer.token, r = this.parseDescription(), n = this.parseName();
    this.expectToken(j.COLON);
    const i = this.parseTypeReference();
    let a;
    this.expectOptionalToken(j.EQUALS) && (a = this.parseConstValueLiteral());
    const o = this.parseConstDirectives();
    return this.node(t, {
      kind: te.INPUT_VALUE_DEFINITION,
      description: r,
      name: n,
      type: i,
      defaultValue: a,
      directives: o
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("interface");
    const n = this.parseName(), i = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(t, {
      kind: te.INTERFACE_TYPE_DEFINITION,
      description: r,
      name: n,
      interfaces: i,
      directives: a,
      fields: o
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("union");
    const n = this.parseName(), i = this.parseConstDirectives(), a = this.parseUnionMemberTypes();
    return this.node(t, {
      kind: te.UNION_TYPE_DEFINITION,
      description: r,
      name: n,
      directives: i,
      types: a
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(j.EQUALS) ? this.delimitedMany(j.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("enum");
    const n = this.parseName(), i = this.parseConstDirectives(), a = this.parseEnumValuesDefinition();
    return this.node(t, {
      kind: te.ENUM_TYPE_DEFINITION,
      description: r,
      name: n,
      directives: i,
      values: a
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      j.BRACE_L,
      this.parseEnumValueDefinition,
      j.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const t = this._lexer.token, r = this.parseDescription(), n = this.parseEnumValueName(), i = this.parseConstDirectives();
    return this.node(t, {
      kind: te.ENUM_VALUE_DEFINITION,
      description: r,
      name: n,
      directives: i
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw ot(
        this._lexer.source,
        this._lexer.token.start,
        `${oo(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("input");
    const n = this.parseName(), i = this.parseConstDirectives(), a = this.parseInputFieldsDefinition();
    return this.node(t, {
      kind: te.INPUT_OBJECT_TYPE_DEFINITION,
      description: r,
      name: n,
      directives: i,
      fields: a
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      j.BRACE_L,
      this.parseInputValueDef,
      j.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const t = this._lexer.lookahead();
    if (t.kind === j.NAME)
      switch (t.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(t);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const r = this.parseConstDirectives(), n = this.optionalMany(
      j.BRACE_L,
      this.parseOperationTypeDefinition,
      j.BRACE_R
    );
    if (r.length === 0 && n.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: te.SCHEMA_EXTENSION,
      directives: r,
      operationTypes: n
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const r = this.parseName(), n = this.parseConstDirectives();
    if (n.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: te.SCALAR_TYPE_EXTENSION,
      name: r,
      directives: n
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const r = this.parseName(), n = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    if (n.length === 0 && i.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: te.OBJECT_TYPE_EXTENSION,
      name: r,
      interfaces: n,
      directives: i,
      fields: a
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const r = this.parseName(), n = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    if (n.length === 0 && i.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: te.INTERFACE_TYPE_EXTENSION,
      name: r,
      interfaces: n,
      directives: i,
      fields: a
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const r = this.parseName(), n = this.parseConstDirectives(), i = this.parseUnionMemberTypes();
    if (n.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: te.UNION_TYPE_EXTENSION,
      name: r,
      directives: n,
      types: i
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const r = this.parseName(), n = this.parseConstDirectives(), i = this.parseEnumValuesDefinition();
    if (n.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: te.ENUM_TYPE_EXTENSION,
      name: r,
      directives: n,
      values: i
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const r = this.parseName(), n = this.parseConstDirectives(), i = this.parseInputFieldsDefinition();
    if (n.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: te.INPUT_OBJECT_TYPE_EXTENSION,
      name: r,
      directives: n,
      fields: i
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(j.AT);
    const n = this.parseName(), i = this.parseArgumentDefs(), a = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const o = this.parseDirectiveLocations();
    return this.node(t, {
      kind: te.DIRECTIVE_DEFINITION,
      description: r,
      name: n,
      arguments: i,
      repeatable: a,
      locations: o
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(j.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const t = this._lexer.token, r = this.parseName();
    if (Object.prototype.hasOwnProperty.call(El, r.value))
      return r;
    throw this.unexpected(t);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(t, r) {
    return this._options.noLocation !== !0 && (r.loc = new nD(
      t,
      this._lexer.lastToken,
      this._lexer.source
    )), r;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(t) {
    return this._lexer.token.kind === t;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(t) {
    const r = this._lexer.token;
    if (r.kind === t)
      return this.advanceLexer(), r;
    throw ot(
      this._lexer.source,
      r.start,
      `Expected ${km(t)}, found ${oo(r)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(t) {
    return this._lexer.token.kind === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(t) {
    const r = this._lexer.token;
    if (r.kind === j.NAME && r.value === t)
      this.advanceLexer();
    else
      throw ot(
        this._lexer.source,
        r.start,
        `Expected "${t}", found ${oo(r)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(t) {
    const r = this._lexer.token;
    return r.kind === j.NAME && r.value === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(t) {
    const r = t ?? this._lexer.token;
    return ot(
      this._lexer.source,
      r.start,
      `Unexpected ${oo(r)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(t, r, n) {
    this.expectToken(t);
    const i = [];
    for (; !this.expectOptionalToken(n); )
      i.push(r.call(this));
    return i;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(t, r, n) {
    if (this.expectOptionalToken(t)) {
      const i = [];
      do
        i.push(r.call(this));
      while (!this.expectOptionalToken(n));
      return i;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(t, r, n) {
    this.expectToken(t);
    const i = [];
    do
      i.push(r.call(this));
    while (!this.expectOptionalToken(n));
    return i;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(t, r) {
    this.expectOptionalToken(t);
    const n = [];
    do
      n.push(r.call(this));
    while (this.expectOptionalToken(t));
    return n;
  }
  advanceLexer() {
    const { maxTokens: t } = this._options, r = this._lexer.advance();
    if (t !== void 0 && r.kind !== j.EOF && (++this._tokenCounter, this._tokenCounter > t))
      throw ot(
        this._lexer.source,
        r.start,
        `Document contains more that ${t} tokens. Parsing aborted.`
      );
  }
}
function oo(e) {
  const t = e.value;
  return km(e.kind) + (t != null ? ` "${t}"` : "");
}
function km(e) {
  return cD(e) ? `"${e}"` : e;
}
function _D(e) {
  return `"${e.replace(FD, OD)}"`;
}
const FD = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function OD(e) {
  return ID[e.charCodeAt(0)];
}
const ID = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], Gc = Object.freeze({});
function yr(e, t, r = $m) {
  const n = /* @__PURE__ */ new Map();
  for (const $ of Object.values(te))
    n.set($, RD(t, $));
  let i, a = Array.isArray(e), o = [e], s = -1, u = [], l = e, c, d;
  const f = [], h = [];
  do {
    s++;
    const $ = s === o.length, m = $ && u.length !== 0;
    if ($) {
      if (c = h.length === 0 ? void 0 : f[f.length - 1], l = d, d = h.pop(), m)
        if (a) {
          l = l.slice();
          let D = 0;
          for (const [S, T] of u) {
            const B = S - D;
            T === null ? (l.splice(B, 1), D++) : l[B] = T;
          }
        } else {
          l = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(l)
          );
          for (const [D, S] of u)
            l[D] = S;
        }
      s = i.index, o = i.keys, u = i.edits, a = i.inArray, i = i.prev;
    } else if (d) {
      if (c = a ? s : o[s], l = d[c], l == null)
        continue;
      f.push(c);
    }
    let b;
    if (!Array.isArray(l)) {
      var p, v;
      Sf(l) || wo(!1, `Invalid AST Node: ${Qc(l)}.`);
      const D = $ ? (p = n.get(l.kind)) === null || p === void 0 ? void 0 : p.leave : (v = n.get(l.kind)) === null || v === void 0 ? void 0 : v.enter;
      if (b = D == null ? void 0 : D.call(t, l, c, d, f, h), b === Gc)
        break;
      if (b === !1) {
        if (!$) {
          f.pop();
          continue;
        }
      } else if (b !== void 0 && (u.push([c, b]), !$))
        if (Sf(b))
          l = b;
        else {
          f.pop();
          continue;
        }
    }
    if (b === void 0 && m && u.push([c, l]), $)
      f.pop();
    else {
      var g;
      i = {
        inArray: a,
        index: s,
        keys: o,
        edits: u,
        prev: i
      }, a = Array.isArray(l), o = a ? l : (g = r[l.kind]) !== null && g !== void 0 ? g : [], s = -1, u = [], d && h.push(d), d = l;
    }
  } while (i !== void 0);
  return u.length !== 0 ? u[u.length - 1][1] : e;
}
function RD(e, t) {
  const r = e[t];
  return typeof r == "object" ? r : typeof r == "function" ? {
    enter: r,
    leave: void 0
  } : {
    enter: e.enter,
    leave: e.leave
  };
}
function BD(e) {
  return yr(e, ND);
}
const MD = 80, ND = {
  Name: {
    leave: (e) => e.value
  },
  Variable: {
    leave: (e) => "$" + e.name
  },
  // Document
  Document: {
    leave: (e) => re(e.definitions, `

`)
  },
  OperationDefinition: {
    leave(e) {
      const t = Ee("(", re(e.variableDefinitions, ", "), ")"), r = re(
        [
          e.operation,
          re([e.name, t]),
          re(e.directives, " ")
        ],
        " "
      );
      return (r === "query" ? "" : r + " ") + e.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: e, type: t, defaultValue: r, directives: n }) => e + ": " + t + Ee(" = ", r) + Ee(" ", re(n, " "))
  },
  SelectionSet: {
    leave: ({ selections: e }) => Nt(e)
  },
  Field: {
    leave({ alias: e, name: t, arguments: r, directives: n, selectionSet: i }) {
      const a = Ee("", e, ": ") + t;
      let o = a + Ee("(", re(r, ", "), ")");
      return o.length > MD && (o = a + Ee(`(
`, Co(re(r, `
`)), `
)`)), re([o, re(n, " "), i], " ");
    }
  },
  Argument: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: e, directives: t }) => "..." + e + Ee(" ", re(t, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: e, directives: t, selectionSet: r }) => re(
      [
        "...",
        Ee("on ", e),
        re(t, " "),
        r
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: e, typeCondition: t, variableDefinitions: r, directives: n, selectionSet: i }) => (
      // or removed in the future.
      `fragment ${e}${Ee("(", re(r, ", "), ")")} on ${t} ${Ee("", re(n, " "), " ")}` + i
    )
  },
  // Value
  IntValue: {
    leave: ({ value: e }) => e
  },
  FloatValue: {
    leave: ({ value: e }) => e
  },
  StringValue: {
    leave: ({ value: e, block: t }) => t ? uD(e) : _D(e)
  },
  BooleanValue: {
    leave: ({ value: e }) => e ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: e }) => e
  },
  ListValue: {
    leave: ({ values: e }) => "[" + re(e, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: e }) => "{" + re(e, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Directive
  Directive: {
    leave: ({ name: e, arguments: t }) => "@" + e + Ee("(", re(t, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: e }) => e
  },
  ListType: {
    leave: ({ type: e }) => "[" + e + "]"
  },
  NonNullType: {
    leave: ({ type: e }) => e + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: e, directives: t, operationTypes: r }) => Ee("", e, `
`) + re(["schema", re(t, " "), Nt(r)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: e, type: t }) => e + ": " + t
  },
  ScalarTypeDefinition: {
    leave: ({ description: e, name: t, directives: r }) => Ee("", e, `
`) + re(["scalar", t, re(r, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: r, directives: n, fields: i }) => Ee("", e, `
`) + re(
      [
        "type",
        t,
        Ee("implements ", re(r, " & ")),
        re(n, " "),
        Nt(i)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: e, name: t, arguments: r, type: n, directives: i }) => Ee("", e, `
`) + t + (Pf(r) ? Ee(`(
`, Co(re(r, `
`)), `
)`) : Ee("(", re(r, ", "), ")")) + ": " + n + Ee(" ", re(i, " "))
  },
  InputValueDefinition: {
    leave: ({ description: e, name: t, type: r, defaultValue: n, directives: i }) => Ee("", e, `
`) + re(
      [t + ": " + r, Ee("= ", n), re(i, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: r, directives: n, fields: i }) => Ee("", e, `
`) + re(
      [
        "interface",
        t,
        Ee("implements ", re(r, " & ")),
        re(n, " "),
        Nt(i)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: e, name: t, directives: r, types: n }) => Ee("", e, `
`) + re(
      ["union", t, re(r, " "), Ee("= ", re(n, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: e, name: t, directives: r, values: n }) => Ee("", e, `
`) + re(["enum", t, re(r, " "), Nt(n)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: e, name: t, directives: r }) => Ee("", e, `
`) + re([t, re(r, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: e, name: t, directives: r, fields: n }) => Ee("", e, `
`) + re(["input", t, re(r, " "), Nt(n)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: e, name: t, arguments: r, repeatable: n, locations: i }) => Ee("", e, `
`) + "directive @" + t + (Pf(r) ? Ee(`(
`, Co(re(r, `
`)), `
)`) : Ee("(", re(r, ", "), ")")) + (n ? " repeatable" : "") + " on " + re(i, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: e, operationTypes: t }) => re(
      ["extend schema", re(e, " "), Nt(t)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: e, directives: t }) => re(["extend scalar", e, re(t, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: r, fields: n }) => re(
      [
        "extend type",
        e,
        Ee("implements ", re(t, " & ")),
        re(r, " "),
        Nt(n)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: r, fields: n }) => re(
      [
        "extend interface",
        e,
        Ee("implements ", re(t, " & ")),
        re(r, " "),
        Nt(n)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: e, directives: t, types: r }) => re(
      [
        "extend union",
        e,
        re(t, " "),
        Ee("= ", re(r, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: e, directives: t, values: r }) => re(["extend enum", e, re(t, " "), Nt(r)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: e, directives: t, fields: r }) => re(["extend input", e, re(t, " "), Nt(r)], " ")
  }
};
function re(e, t = "") {
  var r;
  return (r = e == null ? void 0 : e.filter((n) => n).join(t)) !== null && r !== void 0 ? r : "";
}
function Nt(e) {
  return Ee(`{
`, Co(re(e, `
`)), `
}`);
}
function Ee(e, t, r = "") {
  return t != null && t !== "" ? e + t + r : "";
}
function Co(e) {
  return Ee("  ", e.replace(/\n/g, `
  `));
}
function Pf(e) {
  var t;
  return (t = e == null ? void 0 : e.some((r) => r.includes(`
`))) !== null && t !== void 0 ? t : !1;
}
function Tf(e) {
  return e.kind === te.FIELD || e.kind === te.FRAGMENT_SPREAD || e.kind === te.INLINE_FRAGMENT;
}
function Ia(e, t) {
  var r = e.directives;
  return !r || !r.length ? !0 : zD(r).every(function(n) {
    var i = n.directive, a = n.ifArgument, o = !1;
    return a.value.kind === "Variable" ? (o = t && t[a.value.name.value], ue(o !== void 0, 68, i.name.value)) : o = a.value.value, i.name.value === "skip" ? !o : o;
  });
}
function da(e, t, r) {
  var n = new Set(e), i = n.size;
  return yr(t, {
    Directive: function(a) {
      if (n.delete(a.name.value) && (!r || !n.size))
        return Gc;
    }
  }), r ? !n.size : n.size < i;
}
function LD(e) {
  return e && da(["client", "export"], e, !0);
}
function VD(e) {
  var t = e.name.value;
  return t === "skip" || t === "include";
}
function zD(e) {
  var t = [];
  return e && e.length && e.forEach(function(r) {
    if (VD(r)) {
      var n = r.arguments, i = r.name.value;
      ue(n && n.length === 1, 69, i);
      var a = n[0];
      ue(a.name && a.name.value === "if", 70, i);
      var o = a.value;
      ue(o && (o.kind === "Variable" || o.kind === "BooleanValue"), 71, i), t.push({ directive: r, ifArgument: a });
    }
  }), t;
}
const jD = () => /* @__PURE__ */ Object.create(null), { forEach: KD, slice: Af } = Array.prototype, { hasOwnProperty: UD } = Object.prototype;
let bi = class Pm {
  constructor(t = !0, r = jD) {
    this.weakness = t, this.makeData = r;
  }
  lookup() {
    return this.lookupArray(arguments);
  }
  lookupArray(t) {
    let r = this;
    return KD.call(t, (n) => r = r.getChildTrie(n)), UD.call(r, "data") ? r.data : r.data = this.makeData(Af.call(t));
  }
  peek() {
    return this.peekArray(arguments);
  }
  peekArray(t) {
    let r = this;
    for (let n = 0, i = t.length; r && n < i; ++n) {
      const a = r.mapFor(t[n], !1);
      r = a && a.get(t[n]);
    }
    return r && r.data;
  }
  remove() {
    return this.removeArray(arguments);
  }
  removeArray(t) {
    let r;
    if (t.length) {
      const n = t[0], i = this.mapFor(n, !1), a = i && i.get(n);
      a && (r = a.removeArray(Af.call(t, 1)), !a.data && !a.weak && !(a.strong && a.strong.size) && i.delete(n));
    } else
      r = this.data, delete this.data;
    return r;
  }
  getChildTrie(t) {
    const r = this.mapFor(t, !0);
    let n = r.get(t);
    return n || r.set(t, n = new Pm(this.weakness, this.makeData)), n;
  }
  mapFor(t, r) {
    return this.weakness && qD(t) ? this.weak || (r ? this.weak = /* @__PURE__ */ new WeakMap() : void 0) : this.strong || (r ? this.strong = /* @__PURE__ */ new Map() : void 0);
  }
};
function qD(e) {
  switch (typeof e) {
    case "object":
      if (e === null)
        break;
    case "function":
      return !0;
  }
  return !1;
}
var wn = typeof WeakMap == "function" && !Vt(function() {
  return navigator.product == "ReactNative" && !global.HermesInternal;
}), Tm = typeof WeakSet == "function", Zc = typeof Symbol == "function" && typeof Symbol.for == "function", Is = Zc && Symbol.asyncIterator, Am = typeof Vt(function() {
  return window.document.createElement;
}) == "function", HD = (
  // Following advice found in this comment from @domenic (maintainer of jsdom):
  // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327
  //
  // Since we control the version of Jest and jsdom used when running Apollo
  // Client tests, and that version is recent enought to include " jsdom/x.y.z"
  // at the end of the user agent string, I believe this case is all we need to
  // check. Testing for "Node.js" was recommended for backwards compatibility
  // with older version of jsdom, but we don't have that problem.
  Vt(function() {
    return navigator.userAgent.indexOf("jsdom") >= 0;
  }) || !1
), WD = Am && !HD;
function qe(e) {
  return e !== null && typeof e == "object";
}
function QD(e, t) {
  var r = t, n = [];
  e.definitions.forEach(function(a) {
    if (a.kind === "OperationDefinition")
      throw ht(
        72,
        a.operation,
        a.name ? " named '".concat(a.name.value, "'") : ""
      );
    a.kind === "FragmentDefinition" && n.push(a);
  }), typeof r > "u" && (ue(n.length === 1, 73, n.length), r = n[0].name.value);
  var i = M(M({}, e), { definitions: jt([
    {
      kind: "OperationDefinition",
      // OperationTypeNode is an enum
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: r
            }
          }
        ]
      }
    }
  ], e.definitions, !0) });
  return i;
}
function Rs(e) {
  e === void 0 && (e = []);
  var t = {};
  return e.forEach(function(r) {
    t[r.name.value] = r;
  }), t;
}
function Bs(e, t) {
  switch (e.kind) {
    case "InlineFragment":
      return e;
    case "FragmentSpread": {
      var r = e.name.value;
      if (typeof t == "function")
        return t(r);
      var n = t && t[r];
      return ue(n, 74, r), n || null;
    }
    default:
      return null;
  }
}
function GD() {
}
class Cl {
  constructor(t = 1 / 0, r = GD) {
    this.max = t, this.dispose = r, this.map = /* @__PURE__ */ new Map(), this.newest = null, this.oldest = null;
  }
  has(t) {
    return this.map.has(t);
  }
  get(t) {
    const r = this.getNode(t);
    return r && r.value;
  }
  get size() {
    return this.map.size;
  }
  getNode(t) {
    const r = this.map.get(t);
    if (r && r !== this.newest) {
      const { older: n, newer: i } = r;
      i && (i.older = n), n && (n.newer = i), r.older = this.newest, r.older.newer = r, r.newer = null, this.newest = r, r === this.oldest && (this.oldest = i);
    }
    return r;
  }
  set(t, r) {
    let n = this.getNode(t);
    return n ? n.value = r : (n = {
      key: t,
      value: r,
      newer: null,
      older: this.newest
    }, this.newest && (this.newest.newer = n), this.newest = n, this.oldest = this.oldest || n, this.map.set(t, n), n.value);
  }
  clean() {
    for (; this.oldest && this.map.size > this.max; )
      this.delete(this.oldest.key);
  }
  delete(t) {
    const r = this.map.get(t);
    return r ? (r === this.newest && (this.newest = r.older), r === this.oldest && (this.oldest = r.newer), r.newer && (r.newer.older = r.older), r.older && (r.older.newer = r.newer), this.map.delete(t), this.dispose(r.value, t), !0) : !1;
  }
}
function Sl() {
}
const ZD = Sl, YD = typeof WeakRef < "u" ? WeakRef : function(e) {
  return { deref: () => e };
}, JD = typeof WeakMap < "u" ? WeakMap : Map, XD = typeof FinalizationRegistry < "u" ? FinalizationRegistry : function() {
  return {
    register: Sl,
    unregister: Sl
  };
}, e5 = 10024;
class zo {
  constructor(t = 1 / 0, r = ZD) {
    this.max = t, this.dispose = r, this.map = new JD(), this.newest = null, this.oldest = null, this.unfinalizedNodes = /* @__PURE__ */ new Set(), this.finalizationScheduled = !1, this.size = 0, this.finalize = () => {
      const n = this.unfinalizedNodes.values();
      for (let i = 0; i < e5; i++) {
        const a = n.next().value;
        if (!a)
          break;
        this.unfinalizedNodes.delete(a);
        const o = a.key;
        delete a.key, a.keyRef = new YD(o), this.registry.register(o, a, a);
      }
      this.unfinalizedNodes.size > 0 ? queueMicrotask(this.finalize) : this.finalizationScheduled = !1;
    }, this.registry = new XD(this.deleteNode.bind(this));
  }
  has(t) {
    return this.map.has(t);
  }
  get(t) {
    const r = this.getNode(t);
    return r && r.value;
  }
  getNode(t) {
    const r = this.map.get(t);
    if (r && r !== this.newest) {
      const { older: n, newer: i } = r;
      i && (i.older = n), n && (n.newer = i), r.older = this.newest, r.older.newer = r, r.newer = null, this.newest = r, r === this.oldest && (this.oldest = i);
    }
    return r;
  }
  set(t, r) {
    let n = this.getNode(t);
    return n ? n.value = r : (n = {
      key: t,
      value: r,
      newer: null,
      older: this.newest
    }, this.newest && (this.newest.newer = n), this.newest = n, this.oldest = this.oldest || n, this.scheduleFinalization(n), this.map.set(t, n), this.size++, n.value);
  }
  clean() {
    for (; this.oldest && this.size > this.max; )
      this.deleteNode(this.oldest);
  }
  deleteNode(t) {
    t === this.newest && (this.newest = t.older), t === this.oldest && (this.oldest = t.newer), t.newer && (t.newer.older = t.older), t.older && (t.older.newer = t.newer), this.size--;
    const r = t.key || t.keyRef && t.keyRef.deref();
    this.dispose(t.value, r), t.keyRef ? this.registry.unregister(t) : this.unfinalizedNodes.delete(t), r && this.map.delete(r);
  }
  delete(t) {
    const r = this.map.get(t);
    return r ? (this.deleteNode(r), !0) : !1;
  }
  scheduleFinalization(t) {
    this.unfinalizedNodes.add(t), this.finalizationScheduled || (this.finalizationScheduled = !0, queueMicrotask(this.finalize));
  }
}
var Cu = /* @__PURE__ */ new WeakSet();
function _m(e) {
  e.size <= (e.max || -1) || Cu.has(e) || (Cu.add(e), setTimeout(function() {
    e.clean(), Cu.delete(e);
  }, 100));
}
var Yc = function(e, t) {
  var r = new zo(e, t);
  return r.set = function(n, i) {
    var a = zo.prototype.set.call(this, n, i);
    return _m(this), a;
  }, r;
}, t5 = function(e, t) {
  var r = new Cl(e, t);
  return r.set = function(n, i) {
    var a = Cl.prototype.set.call(this, n, i);
    return _m(this), a;
  }, r;
}, r5 = Symbol.for("apollo.cacheSize"), Xt = M({}, $l[r5]), Xr = {};
function Jc(e, t) {
  Xr[e] = t;
}
var n5 = globalThis.__DEV__ !== !1 ? s5 : void 0, i5 = globalThis.__DEV__ !== !1 ? u5 : void 0, a5 = globalThis.__DEV__ !== !1 ? Fm : void 0;
function o5() {
  var e = {
    parser: 1e3,
    canonicalStringify: 1e3,
    print: 2e3,
    "documentTransform.cache": 2e3,
    "queryManager.getDocumentInfo": 2e3,
    "PersistedQueryLink.persistedQueryHashes": 2e3,
    "fragmentRegistry.transform": 2e3,
    "fragmentRegistry.lookup": 1e3,
    "fragmentRegistry.findFragmentSpreads": 4e3,
    "cache.fragmentQueryDocuments": 1e3,
    "removeTypenameFromVariables.getVariableDefinitions": 2e3,
    "inMemoryCache.maybeBroadcastWatch": 5e3,
    "inMemoryCache.executeSelectionSet": 5e4,
    "inMemoryCache.executeSubSelectedArray": 1e4
  };
  return Object.fromEntries(Object.entries(e).map(function(t) {
    var r = t[0], n = t[1];
    return [
      r,
      Xt[r] || n
    ];
  }));
}
function s5() {
  var e, t, r, n, i;
  if (globalThis.__DEV__ === !1)
    throw new Error("only supported in development mode");
  return {
    limits: o5(),
    sizes: M({ print: (e = Xr.print) === null || e === void 0 ? void 0 : e.call(Xr), parser: (t = Xr.parser) === null || t === void 0 ? void 0 : t.call(Xr), canonicalStringify: (r = Xr.canonicalStringify) === null || r === void 0 ? void 0 : r.call(Xr), links: Pl(this.link), queryManager: {
      getDocumentInfo: this.queryManager.transformCache.size,
      documentTransforms: Im(this.queryManager.documentTransform)
    } }, (i = (n = this.cache).getMemoryInternals) === null || i === void 0 ? void 0 : i.call(n))
  };
}
function Fm() {
  return {
    cache: {
      fragmentQueryDocuments: Rr(this.getFragmentDoc)
    }
  };
}
function u5() {
  var e = this.config.fragments;
  return M(M({}, Fm.apply(this)), { addTypenameDocumentTransform: Im(this.addTypenameTransform), inMemoryCache: {
    executeSelectionSet: Rr(this.storeReader.executeSelectionSet),
    executeSubSelectedArray: Rr(this.storeReader.executeSubSelectedArray),
    maybeBroadcastWatch: Rr(this.maybeBroadcastWatch)
  }, fragmentRegistry: {
    findFragmentSpreads: Rr(e == null ? void 0 : e.findFragmentSpreads),
    lookup: Rr(e == null ? void 0 : e.lookup),
    transform: Rr(e == null ? void 0 : e.transform)
  } });
}
function l5(e) {
  return !!e && "dirtyKey" in e;
}
function Rr(e) {
  return l5(e) ? e.size : void 0;
}
function Om(e) {
  return e != null;
}
function Im(e) {
  return kl(e).map(function(t) {
    return { cache: t };
  });
}
function kl(e) {
  return e ? jt(jt([
    Rr(e == null ? void 0 : e.performWork)
  ], kl(e == null ? void 0 : e.left), !0), kl(e == null ? void 0 : e.right), !0).filter(Om) : [];
}
function Pl(e) {
  var t;
  return e ? jt(jt([
    (t = e == null ? void 0 : e.getMemoryInternals) === null || t === void 0 ? void 0 : t.call(e)
  ], Pl(e == null ? void 0 : e.left), !0), Pl(e == null ? void 0 : e.right), !0).filter(Om) : [];
}
var Vr = Object.assign(function(t) {
  return JSON.stringify(t, c5);
}, {
  reset: function() {
    zn = new t5(
      Xt.canonicalStringify || 1e3
      /* defaultCacheSizes.canonicalStringify */
    );
  }
});
globalThis.__DEV__ !== !1 && Jc("canonicalStringify", function() {
  return zn.size;
});
var zn;
Vr.reset();
function c5(e, t) {
  if (t && typeof t == "object") {
    var r = Object.getPrototypeOf(t);
    if (r === Object.prototype || r === null) {
      var n = Object.keys(t);
      if (n.every(d5))
        return t;
      var i = JSON.stringify(n), a = zn.get(i);
      if (!a) {
        n.sort();
        var o = JSON.stringify(n);
        a = zn.get(o) || n, zn.set(i, a), zn.set(o, a);
      }
      var s = Object.create(r);
      return a.forEach(function(u) {
        s[u] = t[u];
      }), s;
    }
  }
  return t;
}
function d5(e, t, r) {
  return t === 0 || r[t - 1] <= e;
}
function Gn(e) {
  return { __ref: String(e) };
}
function Ae(e) {
  return !!(e && typeof e == "object" && typeof e.__ref == "string");
}
function f5(e) {
  return qe(e) && e.kind === "Document" && Array.isArray(e.definitions);
}
function h5(e) {
  return e.kind === "StringValue";
}
function p5(e) {
  return e.kind === "BooleanValue";
}
function m5(e) {
  return e.kind === "IntValue";
}
function v5(e) {
  return e.kind === "FloatValue";
}
function y5(e) {
  return e.kind === "Variable";
}
function g5(e) {
  return e.kind === "ObjectValue";
}
function b5(e) {
  return e.kind === "ListValue";
}
function $5(e) {
  return e.kind === "EnumValue";
}
function x5(e) {
  return e.kind === "NullValue";
}
function ui(e, t, r, n) {
  if (m5(r) || v5(r))
    e[t.value] = Number(r.value);
  else if (p5(r) || h5(r))
    e[t.value] = r.value;
  else if (g5(r)) {
    var i = {};
    r.fields.map(function(o) {
      return ui(i, o.name, o.value, n);
    }), e[t.value] = i;
  } else if (y5(r)) {
    var a = (n || {})[r.name.value];
    e[t.value] = a;
  } else if (b5(r))
    e[t.value] = r.values.map(function(o) {
      var s = {};
      return ui(s, t, o, n), s[t.value];
    });
  else if ($5(r))
    e[t.value] = r.value;
  else if (x5(r))
    e[t.value] = null;
  else
    throw ht(83, t.value, r.kind);
}
function D5(e, t) {
  var r = null;
  e.directives && (r = {}, e.directives.forEach(function(i) {
    r[i.name.value] = {}, i.arguments && i.arguments.forEach(function(a) {
      var o = a.name, s = a.value;
      return ui(r[i.name.value], o, s, t);
    });
  }));
  var n = null;
  return e.arguments && e.arguments.length && (n = {}, e.arguments.forEach(function(i) {
    var a = i.name, o = i.value;
    return ui(n, a, o, t);
  })), Rm(e.name.value, n, r);
}
var E5 = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export",
  "nonreactive"
], Ai = Vr, Rm = Object.assign(function(e, t, r) {
  if (t && r && r.connection && r.connection.key)
    if (r.connection.filter && r.connection.filter.length > 0) {
      var n = r.connection.filter ? r.connection.filter : [];
      n.sort();
      var i = {};
      return n.forEach(function(s) {
        i[s] = t[s];
      }), "".concat(r.connection.key, "(").concat(Ai(i), ")");
    } else
      return r.connection.key;
  var a = e;
  if (t) {
    var o = Ai(t);
    a += "(".concat(o, ")");
  }
  return r && Object.keys(r).forEach(function(s) {
    E5.indexOf(s) === -1 && (r[s] && Object.keys(r[s]).length ? a += "@".concat(s, "(").concat(Ai(r[s]), ")") : a += "@".concat(s));
  }), a;
}, {
  setStringify: function(e) {
    var t = Ai;
    return Ai = e, t;
  }
});
function Ms(e, t) {
  if (e.arguments && e.arguments.length) {
    var r = {};
    return e.arguments.forEach(function(n) {
      var i = n.name, a = n.value;
      return ui(r, i, a, t);
    }), r;
  }
  return null;
}
function zr(e) {
  return e.alias ? e.alias.value : e.name.value;
}
function Tl(e, t, r) {
  for (var n, i = 0, a = t.selections; i < a.length; i++) {
    var o = a[i];
    if (jr(o)) {
      if (o.name.value === "__typename")
        return e[zr(o)];
    } else n ? n.push(o) : n = [o];
  }
  if (typeof e.__typename == "string")
    return e.__typename;
  if (n)
    for (var s = 0, u = n; s < u.length; s++) {
      var o = u[s], l = Tl(e, Bs(o, r).selectionSet, r);
      if (typeof l == "string")
        return l;
    }
}
function jr(e) {
  return e.kind === "Field";
}
function w5(e) {
  return e.kind === "InlineFragment";
}
function Ra(e) {
  ue(e && e.kind === "Document", 75);
  var t = e.definitions.filter(function(r) {
    return r.kind !== "FragmentDefinition";
  }).map(function(r) {
    if (r.kind !== "OperationDefinition")
      throw ht(76, r.kind);
    return r;
  });
  return ue(t.length <= 1, 77, t.length), e;
}
function Ba(e) {
  return Ra(e), e.definitions.filter(function(t) {
    return t.kind === "OperationDefinition";
  })[0];
}
function Al(e) {
  return e.definitions.filter(function(t) {
    return t.kind === "OperationDefinition" && !!t.name;
  }).map(function(t) {
    return t.name.value;
  })[0] || null;
}
function Ns(e) {
  return e.definitions.filter(function(t) {
    return t.kind === "FragmentDefinition";
  });
}
function Bm(e) {
  var t = Ba(e);
  return ue(t && t.operation === "query", 78), t;
}
function C5(e) {
  ue(e.kind === "Document", 79), ue(e.definitions.length <= 1, 80);
  var t = e.definitions[0];
  return ue(t.kind === "FragmentDefinition", 81), t;
}
function Ma(e) {
  Ra(e);
  for (var t, r = 0, n = e.definitions; r < n.length; r++) {
    var i = n[r];
    if (i.kind === "OperationDefinition") {
      var a = i.operation;
      if (a === "query" || a === "mutation" || a === "subscription")
        return i;
    }
    i.kind === "FragmentDefinition" && !t && (t = i);
  }
  if (t)
    return t;
  throw ht(82);
}
function Xc(e) {
  var t = /* @__PURE__ */ Object.create(null), r = e && e.variableDefinitions;
  return r && r.length && r.forEach(function(n) {
    n.defaultValue && ui(t, n.variable.name, n.defaultValue);
  }), t;
}
const S5 = () => /* @__PURE__ */ Object.create(null), { forEach: k5, slice: P5 } = Array.prototype, { hasOwnProperty: T5 } = Object.prototype;
class ed {
  constructor(t = !0, r = S5) {
    this.weakness = t, this.makeData = r;
  }
  lookup(...t) {
    return this.lookupArray(t);
  }
  lookupArray(t) {
    let r = this;
    return k5.call(t, (n) => r = r.getChildTrie(n)), T5.call(r, "data") ? r.data : r.data = this.makeData(P5.call(t));
  }
  peek(...t) {
    return this.peekArray(t);
  }
  peekArray(t) {
    let r = this;
    for (let n = 0, i = t.length; r && n < i; ++n) {
      const a = this.weakness && _f(t[n]) ? r.weak : r.strong;
      r = a && a.get(t[n]);
    }
    return r && r.data;
  }
  getChildTrie(t) {
    const r = this.weakness && _f(t) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
    let n = r.get(t);
    return n || r.set(t, n = new ed(this.weakness, this.makeData)), n;
  }
}
function _f(e) {
  switch (typeof e) {
    case "object":
      if (e === null)
        break;
    case "function":
      return !0;
  }
  return !1;
}
let ut = null;
const Ff = {};
let A5 = 1;
const _5 = () => class {
  constructor() {
    this.id = [
      "slot",
      A5++,
      Date.now(),
      Math.random().toString(36).slice(2)
    ].join(":");
  }
  hasValue() {
    for (let t = ut; t; t = t.parent)
      if (this.id in t.slots) {
        const r = t.slots[this.id];
        if (r === Ff)
          break;
        return t !== ut && (ut.slots[this.id] = r), !0;
      }
    return ut && (ut.slots[this.id] = Ff), !1;
  }
  getValue() {
    if (this.hasValue())
      return ut.slots[this.id];
  }
  withValue(t, r, n, i) {
    const a = {
      __proto__: null,
      [this.id]: t
    }, o = ut;
    ut = { parent: o, slots: a };
    try {
      return r.apply(i, n);
    } finally {
      ut = o;
    }
  }
  // Capture the current context and wrap a callback function so that it
  // reestablishes the captured context when called.
  static bind(t) {
    const r = ut;
    return function() {
      const n = ut;
      try {
        return ut = r, t.apply(this, arguments);
      } finally {
        ut = n;
      }
    };
  }
  // Immediately run a callback function without any captured context.
  static noContext(t, r, n) {
    if (ut) {
      const i = ut;
      try {
        return ut = null, t.apply(n, r);
      } finally {
        ut = i;
      }
    } else
      return t.apply(n, r);
  }
};
function Of(e) {
  try {
    return e();
  } catch {
  }
}
const Su = "@wry/context:Slot", F5 = (
  // Prefer globalThis when available.
  // https://github.com/benjamn/wryware/issues/347
  Of(() => globalThis) || // Fall back to global, which works in Node.js and may be converted by some
  // bundlers to the appropriate identifier (window, self, ...) depending on the
  // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
  Of(() => global) || // Otherwise, use a dummy host that's local to this module. We used to fall
  // back to using the Array constructor as a namespace, but that was flagged in
  // https://github.com/benjamn/wryware/issues/347, and can be avoided.
  /* @__PURE__ */ Object.create(null)
), If = F5, Mm = If[Su] || // Earlier versions of this package stored the globalKey property on the Array
// constructor, so we check there as well, to prevent Slot class duplication.
Array[Su] || function(e) {
  try {
    Object.defineProperty(If, Su, {
      value: e,
      enumerable: !1,
      writable: !1,
      // When it was possible for globalHost to be the Array constructor (a
      // legacy Slot dedup strategy), it was important for the property to be
      // configurable:true so it could be deleted. That does not seem to be as
      // important when globalHost is the global object, but I don't want to
      // cause similar problems again, and configurable:true seems safest.
      // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
      configurable: !0
    });
  } finally {
    return e;
  }
}(_5()), Ls = new Mm(), { hasOwnProperty: O5 } = Object.prototype, td = Array.from || function(e) {
  const t = [];
  return e.forEach((r) => t.push(r)), t;
};
function rd(e) {
  const { unsubscribe: t } = e;
  typeof t == "function" && (e.unsubscribe = void 0, t());
}
const fa = [], I5 = 100;
function li(e, t) {
  if (!e)
    throw new Error(t || "assertion failure");
}
function Nm(e, t) {
  const r = e.length;
  return (
    // Unknown values are not equal to each other.
    r > 0 && // Both values must be ordinary (or both exceptional) to be equal.
    r === t.length && // The underlying value or exception must be the same.
    e[r - 1] === t[r - 1]
  );
}
function Lm(e) {
  switch (e.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return e[0];
    case 2:
      throw e[1];
  }
}
function Vm(e) {
  return e.slice(0);
}
class Vs {
  constructor(t) {
    this.fn = t, this.parents = /* @__PURE__ */ new Set(), this.childValues = /* @__PURE__ */ new Map(), this.dirtyChildren = null, this.dirty = !0, this.recomputing = !1, this.value = [], this.deps = null, ++Vs.count;
  }
  peek() {
    if (this.value.length === 1 && !Kr(this))
      return Rf(this), this.value[0];
  }
  // This is the most important method of the Entry API, because it
  // determines whether the cached this.value can be returned immediately,
  // or must be recomputed. The overall performance of the caching system
  // depends on the truth of the following observations: (1) this.dirty is
  // usually false, (2) this.dirtyChildren is usually null/empty, and thus
  // (3) valueGet(this.value) is usually returned without recomputation.
  recompute(t) {
    return li(!this.recomputing, "already recomputing"), Rf(this), Kr(this) ? R5(this, t) : Lm(this.value);
  }
  setDirty() {
    this.dirty || (this.dirty = !0, zm(this), rd(this));
  }
  dispose() {
    this.setDirty(), Hm(this), nd(this, (t, r) => {
      t.setDirty(), Wm(t, this);
    });
  }
  forget() {
    this.dispose();
  }
  dependOn(t) {
    t.add(this), this.deps || (this.deps = fa.pop() || /* @__PURE__ */ new Set()), this.deps.add(t);
  }
  forgetDeps() {
    this.deps && (td(this.deps).forEach((t) => t.delete(this)), this.deps.clear(), fa.push(this.deps), this.deps = null);
  }
}
Vs.count = 0;
function Rf(e) {
  const t = Ls.getValue();
  if (t)
    return e.parents.add(t), t.childValues.has(e) || t.childValues.set(e, []), Kr(e) ? Km(t, e) : Um(t, e), t;
}
function R5(e, t) {
  return Hm(e), Ls.withValue(e, B5, [e, t]), N5(e, t) && M5(e), Lm(e.value);
}
function B5(e, t) {
  e.recomputing = !0;
  const { normalizeResult: r } = e;
  let n;
  r && e.value.length === 1 && (n = Vm(e.value)), e.value.length = 0;
  try {
    if (e.value[0] = e.fn.apply(null, t), r && n && !Nm(n, e.value))
      try {
        e.value[0] = r(e.value[0], n[0]);
      } catch {
      }
  } catch (i) {
    e.value[1] = i;
  }
  e.recomputing = !1;
}
function Kr(e) {
  return e.dirty || !!(e.dirtyChildren && e.dirtyChildren.size);
}
function M5(e) {
  e.dirty = !1, !Kr(e) && jm(e);
}
function zm(e) {
  nd(e, Km);
}
function jm(e) {
  nd(e, Um);
}
function nd(e, t) {
  const r = e.parents.size;
  if (r) {
    const n = td(e.parents);
    for (let i = 0; i < r; ++i)
      t(n[i], e);
  }
}
function Km(e, t) {
  li(e.childValues.has(t)), li(Kr(t));
  const r = !Kr(e);
  if (!e.dirtyChildren)
    e.dirtyChildren = fa.pop() || /* @__PURE__ */ new Set();
  else if (e.dirtyChildren.has(t))
    return;
  e.dirtyChildren.add(t), r && zm(e);
}
function Um(e, t) {
  li(e.childValues.has(t)), li(!Kr(t));
  const r = e.childValues.get(t);
  r.length === 0 ? e.childValues.set(t, Vm(t.value)) : Nm(r, t.value) || e.setDirty(), qm(e, t), !Kr(e) && jm(e);
}
function qm(e, t) {
  const r = e.dirtyChildren;
  r && (r.delete(t), r.size === 0 && (fa.length < I5 && fa.push(r), e.dirtyChildren = null));
}
function Hm(e) {
  e.childValues.size > 0 && e.childValues.forEach((t, r) => {
    Wm(e, r);
  }), e.forgetDeps(), li(e.dirtyChildren === null);
}
function Wm(e, t) {
  t.parents.delete(e), e.childValues.delete(t), qm(e, t);
}
function N5(e, t) {
  if (typeof e.subscribe == "function")
    try {
      rd(e), e.unsubscribe = e.subscribe.apply(null, t);
    } catch {
      return e.setDirty(), !1;
    }
  return !0;
}
const L5 = {
  setDirty: !0,
  dispose: !0,
  forget: !0
  // Fully remove parent Entry from LRU cache and computation graph
};
function Qm(e) {
  const t = /* @__PURE__ */ new Map();
  function r(n) {
    const i = Ls.getValue();
    if (i) {
      let a = t.get(n);
      a || t.set(n, a = /* @__PURE__ */ new Set()), i.dependOn(a);
    }
  }
  return r.dirty = function(i, a) {
    const o = t.get(i);
    if (o) {
      const s = a && O5.call(L5, a) ? a : "setDirty";
      td(o).forEach((u) => u[s]()), t.delete(i), rd(o);
    }
  }, r;
}
let Bf;
function V5(...e) {
  return (Bf || (Bf = new ed(typeof WeakMap == "function"))).lookupArray(e);
}
const ku = /* @__PURE__ */ new Set();
function ha(e, { max: t = Math.pow(2, 16), keyArgs: r, makeCacheKey: n = V5, normalizeResult: i, subscribe: a, cache: o = Cl } = /* @__PURE__ */ Object.create(null)) {
  const s = typeof o == "function" ? new o(t, (f) => f.dispose()) : o, u = function() {
    const f = n.apply(null, r ? r.apply(null, arguments) : arguments);
    if (f === void 0)
      return e.apply(null, arguments);
    let h = s.get(f);
    h || (s.set(f, h = new Vs(e)), h.normalizeResult = i, h.subscribe = a, h.forget = () => s.delete(f));
    const p = h.recompute(Array.prototype.slice.call(arguments));
    return s.set(f, h), ku.add(s), Ls.hasValue() || (ku.forEach((v) => v.clean()), ku.clear()), p;
  };
  Object.defineProperty(u, "size", {
    get: () => s.size,
    configurable: !1,
    enumerable: !1
  }), Object.freeze(u.options = {
    max: t,
    keyArgs: r,
    makeCacheKey: n,
    normalizeResult: i,
    subscribe: a,
    cache: s
  });
  function l(f) {
    const h = f && s.get(f);
    h && h.setDirty();
  }
  u.dirtyKey = l, u.dirty = function() {
    l(n.apply(null, arguments));
  };
  function c(f) {
    const h = f && s.get(f);
    if (h)
      return h.peek();
  }
  u.peekKey = c, u.peek = function() {
    return c(n.apply(null, arguments));
  };
  function d(f) {
    return f ? s.delete(f) : !1;
  }
  return u.forgetKey = d, u.forget = function() {
    return d(n.apply(null, arguments));
  }, u.makeCacheKey = n, u.getKey = r ? function() {
    return n.apply(null, r.apply(null, arguments));
  } : n, Object.freeze(u);
}
function z5(e) {
  return e;
}
var Gm = (
  /** @class */
  function() {
    function e(t, r) {
      r === void 0 && (r = /* @__PURE__ */ Object.create(null)), this.resultCache = Tm ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set(), this.transform = t, r.getCacheKey && (this.getCacheKey = r.getCacheKey), this.cached = r.cache !== !1, this.resetCache();
    }
    return e.prototype.getCacheKey = function(t) {
      return [t];
    }, e.identity = function() {
      return new e(z5, { cache: !1 });
    }, e.split = function(t, r, n) {
      return n === void 0 && (n = e.identity()), Object.assign(new e(
        function(i) {
          var a = t(i) ? r : n;
          return a.transformDocument(i);
        },
        // Reasonably assume both `left` and `right` transforms handle their own caching
        { cache: !1 }
      ), { left: r, right: n });
    }, e.prototype.resetCache = function() {
      var t = this;
      if (this.cached) {
        var r = new bi(wn);
        this.performWork = ha(e.prototype.performWork.bind(this), {
          makeCacheKey: function(n) {
            var i = t.getCacheKey(n);
            if (i)
              return ue(Array.isArray(i), 67), r.lookupArray(i);
          },
          max: Xt["documentTransform.cache"],
          cache: zo
        });
      }
    }, e.prototype.performWork = function(t) {
      return Ra(t), this.transform(t);
    }, e.prototype.transformDocument = function(t) {
      if (this.resultCache.has(t))
        return t;
      var r = this.performWork(t);
      return this.resultCache.add(r), r;
    }, e.prototype.concat = function(t) {
      var r = this;
      return Object.assign(new e(
        function(n) {
          return t.transformDocument(r.transformDocument(n));
        },
        // Reasonably assume both transforms handle their own caching
        { cache: !1 }
      ), {
        left: this,
        right: t
      });
    }, e;
  }()
), Yi, zs = Object.assign(function(e) {
  var t = Yi.get(e);
  return t || (t = BD(e), Yi.set(e, t)), t;
}, {
  reset: function() {
    Yi = new Yc(
      Xt.print || 2e3
      /* defaultCacheSizes.print */
    );
  }
});
zs.reset();
globalThis.__DEV__ !== !1 && Jc("print", function() {
  return Yi ? Yi.size : 0;
});
var He = Array.isArray;
function Mt(e) {
  return Array.isArray(e) && e.length > 0;
}
var Mf = {
  kind: te.FIELD,
  name: {
    kind: te.NAME,
    value: "__typename"
  }
};
function Zm(e, t) {
  return !e || e.selectionSet.selections.every(function(r) {
    return r.kind === te.FRAGMENT_SPREAD && Zm(t[r.name.value], t);
  });
}
function j5(e) {
  return Zm(Ba(e) || C5(e), Rs(Ns(e))) ? null : e;
}
function K5(e) {
  var t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  return e.forEach(function(n) {
    n && (n.name ? t.set(n.name, n) : n.test && r.set(n.test, n));
  }), function(n) {
    var i = t.get(n.name.value);
    return !i && r.size && r.forEach(function(a, o) {
      o(n) && (i = a);
    }), i;
  };
}
function Nf(e) {
  var t = /* @__PURE__ */ new Map();
  return function(n) {
    n === void 0 && (n = e);
    var i = t.get(n);
    return i || t.set(n, i = {
      // Variable and fragment spread names used directly within this
      // operation or fragment definition, as identified by key. These sets
      // will be populated during the first traversal of the document in
      // removeDirectivesFromDocument below.
      variables: /* @__PURE__ */ new Set(),
      fragmentSpreads: /* @__PURE__ */ new Set()
    }), i;
  };
}
function Ym(e, t) {
  Ra(t);
  for (var r = Nf(""), n = Nf(""), i = function($) {
    for (var m = 0, b = void 0; m < $.length && (b = $[m]); ++m)
      if (!He(b)) {
        if (b.kind === te.OPERATION_DEFINITION)
          return r(b.name && b.name.value);
        if (b.kind === te.FRAGMENT_DEFINITION)
          return n(b.name.value);
      }
    return globalThis.__DEV__ !== !1 && ue.error(84), null;
  }, a = 0, o = t.definitions.length - 1; o >= 0; --o)
    t.definitions[o].kind === te.OPERATION_DEFINITION && ++a;
  var s = K5(e), u = function($) {
    return Mt($) && $.map(s).some(function(m) {
      return m && m.remove;
    });
  }, l = /* @__PURE__ */ new Map(), c = !1, d = {
    enter: function($) {
      if (u($.directives))
        return c = !0, null;
    }
  }, f = yr(t, {
    // These two AST node types share the same implementation, defined above.
    Field: d,
    InlineFragment: d,
    VariableDefinition: {
      enter: function() {
        return !1;
      }
    },
    Variable: {
      enter: function($, m, b, D, S) {
        var T = i(S);
        T && T.variables.add($.name.value);
      }
    },
    FragmentSpread: {
      enter: function($, m, b, D, S) {
        if (u($.directives))
          return c = !0, null;
        var T = i(S);
        T && T.fragmentSpreads.add($.name.value);
      }
    },
    FragmentDefinition: {
      enter: function($, m, b, D) {
        l.set(JSON.stringify(D), $);
      },
      leave: function($, m, b, D) {
        var S = l.get(JSON.stringify(D));
        if ($ === S)
          return $;
        if (
          // This logic applies only if the document contains one or more
          // operations, since removing all fragments from a document containing
          // only fragments makes the document useless.
          a > 0 && $.selectionSet.selections.every(function(T) {
            return T.kind === te.FIELD && T.name.value === "__typename";
          })
        )
          return n($.name.value).removed = !0, c = !0, null;
      }
    },
    Directive: {
      leave: function($) {
        if (s($))
          return c = !0, null;
      }
    }
  });
  if (!c)
    return t;
  var h = function($) {
    return $.transitiveVars || ($.transitiveVars = new Set($.variables), $.removed || $.fragmentSpreads.forEach(function(m) {
      h(n(m)).transitiveVars.forEach(function(b) {
        $.transitiveVars.add(b);
      });
    })), $;
  }, p = /* @__PURE__ */ new Set();
  f.definitions.forEach(function($) {
    $.kind === te.OPERATION_DEFINITION ? h(r($.name && $.name.value)).fragmentSpreads.forEach(function(m) {
      p.add(m);
    }) : $.kind === te.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment
    // definitions count as usages of their own fragment names. This heuristic
    // prevents accidentally removing all fragment definitions from the
    // document just because it contains no operations that use the fragments.
    a === 0 && !n($.name.value).removed && p.add($.name.value);
  }), p.forEach(function($) {
    h(n($)).fragmentSpreads.forEach(function(m) {
      p.add(m);
    });
  });
  var v = function($) {
    return !!// A fragment definition will be removed if there are no spreads that refer
    // to it, or the fragment was explicitly removed because it had no fields
    // other than __typename.
    (!p.has($) || n($).removed);
  }, g = {
    enter: function($) {
      if (v($.name.value))
        return null;
    }
  };
  return j5(yr(f, {
    // If the fragment is going to be removed, then leaving any dangling
    // FragmentSpread nodes with the same name would be a mistake.
    FragmentSpread: g,
    // This is where the fragment definition is actually removed.
    FragmentDefinition: g,
    OperationDefinition: {
      leave: function($) {
        if ($.variableDefinitions) {
          var m = h(
            // If an operation is anonymous, we use the empty string as its key.
            r($.name && $.name.value)
          ).transitiveVars;
          if (m.size < $.variableDefinitions.length)
            return M(M({}, $), { variableDefinitions: $.variableDefinitions.filter(function(b) {
              return m.has(b.variable.name.value);
            }) });
        }
      }
    }
  }));
}
var id = Object.assign(function(e) {
  return yr(e, {
    SelectionSet: {
      enter: function(t, r, n) {
        if (!(n && n.kind === te.OPERATION_DEFINITION)) {
          var i = t.selections;
          if (i) {
            var a = i.some(function(s) {
              return jr(s) && (s.name.value === "__typename" || s.name.value.lastIndexOf("__", 0) === 0);
            });
            if (!a) {
              var o = n;
              if (!(jr(o) && o.directives && o.directives.some(function(s) {
                return s.name.value === "export";
              })))
                return M(M({}, t), { selections: jt(jt([], i, !0), [Mf], !1) });
            }
          }
        }
      }
    }
  });
}, {
  added: function(e) {
    return e === Mf;
  }
});
function U5(e) {
  var t = Ma(e), r = t.operation;
  if (r === "query")
    return e;
  var n = yr(e, {
    OperationDefinition: {
      enter: function(i) {
        return M(M({}, i), { operation: "query" });
      }
    }
  });
  return n;
}
function Jm(e) {
  Ra(e);
  var t = Ym([
    {
      test: function(r) {
        return r.name.value === "client";
      },
      remove: !0
    }
  ], e);
  return t;
}
var q5 = Object.prototype.hasOwnProperty;
function Lf() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  return js(e);
}
function js(e) {
  var t = e[0] || {}, r = e.length;
  if (r > 1)
    for (var n = new Ur(), i = 1; i < r; ++i)
      t = n.merge(t, e[i]);
  return t;
}
var H5 = function(e, t, r) {
  return this.merge(e[r], t[r]);
}, Ur = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = H5), this.reconciler = t, this.isObject = qe, this.pastCopies = /* @__PURE__ */ new Set();
    }
    return e.prototype.merge = function(t, r) {
      for (var n = this, i = [], a = 2; a < arguments.length; a++)
        i[a - 2] = arguments[a];
      return qe(r) && qe(t) ? (Object.keys(r).forEach(function(o) {
        if (q5.call(t, o)) {
          var s = t[o];
          if (r[o] !== s) {
            var u = n.reconciler.apply(n, jt([
              t,
              r,
              o
            ], i, !1));
            u !== s && (t = n.shallowCopyForMerge(t), t[o] = u);
          }
        } else
          t = n.shallowCopyForMerge(t), t[o] = r[o];
      }), t) : r;
    }, e.prototype.shallowCopyForMerge = function(t) {
      return qe(t) && (this.pastCopies.has(t) || (Array.isArray(t) ? t = t.slice(0) : t = M({ __proto__: Object.getPrototypeOf(t) }, t), this.pastCopies.add(t))), t;
    }, e;
  }()
);
function W5(e, t) {
  var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r) return (r = r.call(e)).next.bind(r);
  if (Array.isArray(e) || (r = Q5(e)) || t) {
    r && (e = r);
    var n = 0;
    return function() {
      return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Q5(e, t) {
  if (e) {
    if (typeof e == "string") return Vf(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Vf(e, t);
  }
}
function Vf(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++)
    n[r] = e[r];
  return n;
}
function zf(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function ad(e, t, r) {
  return t && zf(e.prototype, t), r && zf(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
var od = function() {
  return typeof Symbol == "function";
}, sd = function(e) {
  return od() && !!Symbol[e];
}, ud = function(e) {
  return sd(e) ? Symbol[e] : "@@" + e;
};
od() && !sd("observable") && (Symbol.observable = Symbol("observable"));
var G5 = ud("iterator"), _l = ud("observable"), Xm = ud("species");
function jo(e, t) {
  var r = e[t];
  if (r != null) {
    if (typeof r != "function") throw new TypeError(r + " is not a function");
    return r;
  }
}
function _i(e) {
  var t = e.constructor;
  return t !== void 0 && (t = t[Xm], t === null && (t = void 0)), t !== void 0 ? t : ke;
}
function Z5(e) {
  return e instanceof ke;
}
function ci(e) {
  ci.log ? ci.log(e) : setTimeout(function() {
    throw e;
  });
}
function So(e) {
  Promise.resolve().then(function() {
    try {
      e();
    } catch (t) {
      ci(t);
    }
  });
}
function ev(e) {
  var t = e._cleanup;
  if (t !== void 0 && (e._cleanup = void 0, !!t))
    try {
      if (typeof t == "function")
        t();
      else {
        var r = jo(t, "unsubscribe");
        r && r.call(t);
      }
    } catch (n) {
      ci(n);
    }
}
function Fl(e) {
  e._observer = void 0, e._queue = void 0, e._state = "closed";
}
function Y5(e) {
  var t = e._queue;
  if (t) {
    e._queue = void 0, e._state = "ready";
    for (var r = 0; r < t.length && (tv(e, t[r].type, t[r].value), e._state !== "closed"); ++r)
      ;
  }
}
function tv(e, t, r) {
  e._state = "running";
  var n = e._observer;
  try {
    var i = jo(n, t);
    switch (t) {
      case "next":
        i && i.call(n, r);
        break;
      case "error":
        if (Fl(e), i) i.call(n, r);
        else throw r;
        break;
      case "complete":
        Fl(e), i && i.call(n);
        break;
    }
  } catch (a) {
    ci(a);
  }
  e._state === "closed" ? ev(e) : e._state === "running" && (e._state = "ready");
}
function Pu(e, t, r) {
  if (e._state !== "closed") {
    if (e._state === "buffering") {
      e._queue.push({
        type: t,
        value: r
      });
      return;
    }
    if (e._state !== "ready") {
      e._state = "buffering", e._queue = [{
        type: t,
        value: r
      }], So(function() {
        return Y5(e);
      });
      return;
    }
    tv(e, t, r);
  }
}
var J5 = /* @__PURE__ */ function() {
  function e(r, n) {
    this._cleanup = void 0, this._observer = r, this._queue = void 0, this._state = "initializing";
    var i = new X5(this);
    try {
      this._cleanup = n.call(void 0, i);
    } catch (a) {
      i.error(a);
    }
    this._state === "initializing" && (this._state = "ready");
  }
  var t = e.prototype;
  return t.unsubscribe = function() {
    this._state !== "closed" && (Fl(this), ev(this));
  }, ad(e, [{
    key: "closed",
    get: function() {
      return this._state === "closed";
    }
  }]), e;
}(), X5 = /* @__PURE__ */ function() {
  function e(r) {
    this._subscription = r;
  }
  var t = e.prototype;
  return t.next = function(n) {
    Pu(this._subscription, "next", n);
  }, t.error = function(n) {
    Pu(this._subscription, "error", n);
  }, t.complete = function() {
    Pu(this._subscription, "complete");
  }, ad(e, [{
    key: "closed",
    get: function() {
      return this._subscription._state === "closed";
    }
  }]), e;
}(), ke = /* @__PURE__ */ function() {
  function e(r) {
    if (!(this instanceof e)) throw new TypeError("Observable cannot be called as a function");
    if (typeof r != "function") throw new TypeError("Observable initializer must be a function");
    this._subscriber = r;
  }
  var t = e.prototype;
  return t.subscribe = function(n) {
    return (typeof n != "object" || n === null) && (n = {
      next: n,
      error: arguments[1],
      complete: arguments[2]
    }), new J5(n, this._subscriber);
  }, t.forEach = function(n) {
    var i = this;
    return new Promise(function(a, o) {
      if (typeof n != "function") {
        o(new TypeError(n + " is not a function"));
        return;
      }
      function s() {
        u.unsubscribe(), a();
      }
      var u = i.subscribe({
        next: function(l) {
          try {
            n(l, s);
          } catch (c) {
            o(c), u.unsubscribe();
          }
        },
        error: o,
        complete: a
      });
    });
  }, t.map = function(n) {
    var i = this;
    if (typeof n != "function") throw new TypeError(n + " is not a function");
    var a = _i(this);
    return new a(function(o) {
      return i.subscribe({
        next: function(s) {
          try {
            s = n(s);
          } catch (u) {
            return o.error(u);
          }
          o.next(s);
        },
        error: function(s) {
          o.error(s);
        },
        complete: function() {
          o.complete();
        }
      });
    });
  }, t.filter = function(n) {
    var i = this;
    if (typeof n != "function") throw new TypeError(n + " is not a function");
    var a = _i(this);
    return new a(function(o) {
      return i.subscribe({
        next: function(s) {
          try {
            if (!n(s)) return;
          } catch (u) {
            return o.error(u);
          }
          o.next(s);
        },
        error: function(s) {
          o.error(s);
        },
        complete: function() {
          o.complete();
        }
      });
    });
  }, t.reduce = function(n) {
    var i = this;
    if (typeof n != "function") throw new TypeError(n + " is not a function");
    var a = _i(this), o = arguments.length > 1, s = !1, u = arguments[1], l = u;
    return new a(function(c) {
      return i.subscribe({
        next: function(d) {
          var f = !s;
          if (s = !0, !f || o)
            try {
              l = n(l, d);
            } catch (h) {
              return c.error(h);
            }
          else
            l = d;
        },
        error: function(d) {
          c.error(d);
        },
        complete: function() {
          if (!s && !o) return c.error(new TypeError("Cannot reduce an empty sequence"));
          c.next(l), c.complete();
        }
      });
    });
  }, t.concat = function() {
    for (var n = this, i = arguments.length, a = new Array(i), o = 0; o < i; o++)
      a[o] = arguments[o];
    var s = _i(this);
    return new s(function(u) {
      var l, c = 0;
      function d(f) {
        l = f.subscribe({
          next: function(h) {
            u.next(h);
          },
          error: function(h) {
            u.error(h);
          },
          complete: function() {
            c === a.length ? (l = void 0, u.complete()) : d(s.from(a[c++]));
          }
        });
      }
      return d(n), function() {
        l && (l.unsubscribe(), l = void 0);
      };
    });
  }, t.flatMap = function(n) {
    var i = this;
    if (typeof n != "function") throw new TypeError(n + " is not a function");
    var a = _i(this);
    return new a(function(o) {
      var s = [], u = i.subscribe({
        next: function(c) {
          if (n)
            try {
              c = n(c);
            } catch (f) {
              return o.error(f);
            }
          var d = a.from(c).subscribe({
            next: function(f) {
              o.next(f);
            },
            error: function(f) {
              o.error(f);
            },
            complete: function() {
              var f = s.indexOf(d);
              f >= 0 && s.splice(f, 1), l();
            }
          });
          s.push(d);
        },
        error: function(c) {
          o.error(c);
        },
        complete: function() {
          l();
        }
      });
      function l() {
        u.closed && s.length === 0 && o.complete();
      }
      return function() {
        s.forEach(function(c) {
          return c.unsubscribe();
        }), u.unsubscribe();
      };
    });
  }, t[_l] = function() {
    return this;
  }, e.from = function(n) {
    var i = typeof this == "function" ? this : e;
    if (n == null) throw new TypeError(n + " is not an object");
    var a = jo(n, _l);
    if (a) {
      var o = a.call(n);
      if (Object(o) !== o) throw new TypeError(o + " is not an object");
      return Z5(o) && o.constructor === i ? o : new i(function(s) {
        return o.subscribe(s);
      });
    }
    if (sd("iterator") && (a = jo(n, G5), a))
      return new i(function(s) {
        So(function() {
          if (!s.closed) {
            for (var u = W5(a.call(n)), l; !(l = u()).done; ) {
              var c = l.value;
              if (s.next(c), s.closed) return;
            }
            s.complete();
          }
        });
      });
    if (Array.isArray(n))
      return new i(function(s) {
        So(function() {
          if (!s.closed) {
            for (var u = 0; u < n.length; ++u)
              if (s.next(n[u]), s.closed) return;
            s.complete();
          }
        });
      });
    throw new TypeError(n + " is not observable");
  }, e.of = function() {
    for (var n = arguments.length, i = new Array(n), a = 0; a < n; a++)
      i[a] = arguments[a];
    var o = typeof this == "function" ? this : e;
    return new o(function(s) {
      So(function() {
        if (!s.closed) {
          for (var u = 0; u < i.length; ++u)
            if (s.next(i[u]), s.closed) return;
          s.complete();
        }
      });
    });
  }, ad(e, null, [{
    key: Xm,
    get: function() {
      return this;
    }
  }]), e;
}();
od() && Object.defineProperty(ke, Symbol("extensions"), {
  value: {
    symbol: _l,
    hostReportError: ci
  },
  configurable: !0
});
function e2(e) {
  var t, r = e.Symbol;
  if (typeof r == "function")
    if (r.observable)
      t = r.observable;
    else {
      typeof r.for == "function" ? t = r.for("https://github.com/benlesh/symbol-observable") : t = r("https://github.com/benlesh/symbol-observable");
      try {
        r.observable = t;
      } catch {
      }
    }
  else
    t = "@@observable";
  return t;
}
var Rn;
typeof self < "u" ? Rn = self : typeof window < "u" ? Rn = window : typeof global < "u" ? Rn = global : typeof module < "u" ? Rn = module : Rn = Function("return this")();
e2(Rn);
var jf = ke.prototype, Kf = "@@observable";
jf[Kf] || (jf[Kf] = function() {
  return this;
});
var t2 = Object.prototype.toString;
function rv(e) {
  return Ol(e);
}
function Ol(e, t) {
  switch (t2.call(e)) {
    case "[object Array]": {
      if (t = t || /* @__PURE__ */ new Map(), t.has(e))
        return t.get(e);
      var r = e.slice(0);
      return t.set(e, r), r.forEach(function(i, a) {
        r[a] = Ol(i, t);
      }), r;
    }
    case "[object Object]": {
      if (t = t || /* @__PURE__ */ new Map(), t.has(e))
        return t.get(e);
      var n = Object.create(Object.getPrototypeOf(e));
      return t.set(e, n), Object.keys(e).forEach(function(i) {
        n[i] = Ol(e[i], t);
      }), n;
    }
    default:
      return e;
  }
}
function r2(e) {
  var t = /* @__PURE__ */ new Set([e]);
  return t.forEach(function(r) {
    qe(r) && n2(r) === r && Object.getOwnPropertyNames(r).forEach(function(n) {
      qe(r[n]) && t.add(r[n]);
    });
  }), e;
}
function n2(e) {
  if (globalThis.__DEV__ !== !1 && !Object.isFrozen(e))
    try {
      Object.freeze(e);
    } catch (t) {
      if (t instanceof TypeError)
        return null;
      throw t;
    }
  return e;
}
function pa(e) {
  return globalThis.__DEV__ !== !1 && r2(e), e;
}
function Ji(e, t, r) {
  var n = [];
  e.forEach(function(i) {
    return i[t] && n.push(i);
  }), n.forEach(function(i) {
    return i[t](r);
  });
}
function Tu(e, t, r) {
  return new ke(function(n) {
    var i = {
      // Normally we would initialize promiseQueue to Promise.resolve(), but
      // in this case, for backwards compatibility, we need to be careful to
      // invoke the first callback synchronously.
      then: function(u) {
        return new Promise(function(l) {
          return l(u());
        });
      }
    };
    function a(u, l) {
      return function(c) {
        if (u) {
          var d = function() {
            return n.closed ? (
              /* will be swallowed */
              0
            ) : u(c);
          };
          i = i.then(d, d).then(function(f) {
            return n.next(f);
          }, function(f) {
            return n.error(f);
          });
        } else
          n[l](c);
      };
    }
    var o = {
      next: a(t, "next"),
      error: a(r, "error"),
      complete: function() {
        i.then(function() {
          return n.complete();
        });
      }
    }, s = e.subscribe(o);
    return function() {
      return s.unsubscribe();
    };
  });
}
function nv(e) {
  function t(r) {
    Object.defineProperty(e, r, { value: ke });
  }
  return Zc && Symbol.species && t(Symbol.species), t("@@species"), e;
}
function Uf(e) {
  return e && typeof e.then == "function";
}
var Bn = (
  /** @class */
  function(e) {
    Ut(t, e);
    function t(r) {
      var n = e.call(this, function(i) {
        return n.addObserver(i), function() {
          return n.removeObserver(i);
        };
      }) || this;
      return n.observers = /* @__PURE__ */ new Set(), n.promise = new Promise(function(i, a) {
        n.resolve = i, n.reject = a;
      }), n.handlers = {
        next: function(i) {
          n.sub !== null && (n.latest = ["next", i], n.notify("next", i), Ji(n.observers, "next", i));
        },
        error: function(i) {
          var a = n.sub;
          a !== null && (a && setTimeout(function() {
            return a.unsubscribe();
          }), n.sub = null, n.latest = ["error", i], n.reject(i), n.notify("error", i), Ji(n.observers, "error", i));
        },
        complete: function() {
          var i = n, a = i.sub, o = i.sources, s = o === void 0 ? [] : o;
          if (a !== null) {
            var u = s.shift();
            u ? Uf(u) ? u.then(function(l) {
              return n.sub = l.subscribe(n.handlers);
            }, n.handlers.error) : n.sub = u.subscribe(n.handlers) : (a && setTimeout(function() {
              return a.unsubscribe();
            }), n.sub = null, n.latest && n.latest[0] === "next" ? n.resolve(n.latest[1]) : n.resolve(), n.notify("complete"), Ji(n.observers, "complete"));
          }
        }
      }, n.nextResultListeners = /* @__PURE__ */ new Set(), n.cancel = function(i) {
        n.reject(i), n.sources = [], n.handlers.complete();
      }, n.promise.catch(function(i) {
      }), typeof r == "function" && (r = [new ke(r)]), Uf(r) ? r.then(function(i) {
        return n.start(i);
      }, n.handlers.error) : n.start(r), n;
    }
    return t.prototype.start = function(r) {
      this.sub === void 0 && (this.sources = Array.from(r), this.handlers.complete());
    }, t.prototype.deliverLastMessage = function(r) {
      if (this.latest) {
        var n = this.latest[0], i = r[n];
        i && i.call(r, this.latest[1]), this.sub === null && n === "next" && r.complete && r.complete();
      }
    }, t.prototype.addObserver = function(r) {
      this.observers.has(r) || (this.deliverLastMessage(r), this.observers.add(r));
    }, t.prototype.removeObserver = function(r) {
      this.observers.delete(r) && this.observers.size < 1 && this.handlers.complete();
    }, t.prototype.notify = function(r, n) {
      var i = this.nextResultListeners;
      i.size && (this.nextResultListeners = /* @__PURE__ */ new Set(), i.forEach(function(a) {
        return a(r, n);
      }));
    }, t.prototype.beforeNext = function(r) {
      var n = !1;
      this.nextResultListeners.add(function(i, a) {
        n || (n = !0, r(i, a));
      });
    }, t;
  }(ke)
);
nv(Bn);
function Zn(e) {
  return "incremental" in e;
}
function i2(e) {
  return "hasNext" in e && "data" in e;
}
function a2(e) {
  return Zn(e) || i2(e);
}
function o2(e) {
  return qe(e) && "payload" in e;
}
function iv(e, t) {
  var r = e, n = new Ur();
  return Zn(t) && Mt(t.incremental) && t.incremental.forEach(function(i) {
    for (var a = i.data, o = i.path, s = o.length - 1; s >= 0; --s) {
      var u = o[s], l = !isNaN(+u), c = l ? [] : {};
      c[u] = a, a = c;
    }
    r = n.merge(r, a);
  }), r;
}
function ko(e) {
  var t = Il(e);
  return Mt(t);
}
function Il(e) {
  var t = Mt(e.errors) ? e.errors.slice(0) : [];
  return Zn(e) && Mt(e.incremental) && e.incremental.forEach(function(r) {
    r.errors && t.push.apply(t, r.errors);
  }), t;
}
function hn() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var r = /* @__PURE__ */ Object.create(null);
  return e.forEach(function(n) {
    n && Object.keys(n).forEach(function(i) {
      var a = n[i];
      a !== void 0 && (r[i] = a);
    });
  }), r;
}
function Xi(e, t) {
  return hn(e, t, t.variables && {
    variables: hn(M(M({}, e && e.variables), t.variables))
  });
}
function Au(e) {
  return new ke(function(t) {
    t.error(e);
  });
}
var av = function(e, t, r) {
  var n = new Error(r);
  throw n.name = "ServerError", n.response = e, n.statusCode = e.status, n.result = t, n;
};
function s2(e) {
  for (var t = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ], r = 0, n = Object.keys(e); r < n.length; r++) {
    var i = n[r];
    if (t.indexOf(i) < 0)
      throw ht(43, i);
  }
  return e;
}
function u2(e, t) {
  var r = M({}, e), n = function(a) {
    typeof a == "function" ? r = M(M({}, r), a(r)) : r = M(M({}, r), a);
  }, i = function() {
    return M({}, r);
  };
  return Object.defineProperty(t, "setContext", {
    enumerable: !1,
    value: n
  }), Object.defineProperty(t, "getContext", {
    enumerable: !1,
    value: i
  }), t;
}
function l2(e) {
  var t = {
    variables: e.variables || {},
    extensions: e.extensions || {},
    operationName: e.operationName,
    query: e.query
  };
  return t.operationName || (t.operationName = typeof t.query != "string" ? Al(t.query) || void 0 : ""), t;
}
function c2(e, t) {
  var r = M({}, e), n = new Set(Object.keys(e));
  return yr(t, {
    Variable: function(i, a, o) {
      o && o.kind !== "VariableDefinition" && n.delete(i.name.value);
    }
  }), n.forEach(function(i) {
    delete r[i];
  }), r;
}
function qf(e, t) {
  return t ? t(e) : ke.of();
}
function Fi(e) {
  return typeof e == "function" ? new qt(e) : e;
}
function so(e) {
  return e.request.length <= 1;
}
var qt = (
  /** @class */
  function() {
    function e(t) {
      t && (this.request = t);
    }
    return e.empty = function() {
      return new e(function() {
        return ke.of();
      });
    }, e.from = function(t) {
      return t.length === 0 ? e.empty() : t.map(Fi).reduce(function(r, n) {
        return r.concat(n);
      });
    }, e.split = function(t, r, n) {
      var i = Fi(r), a = Fi(n || new e(qf)), o;
      return so(i) && so(a) ? o = new e(function(s) {
        return t(s) ? i.request(s) || ke.of() : a.request(s) || ke.of();
      }) : o = new e(function(s, u) {
        return t(s) ? i.request(s, u) || ke.of() : a.request(s, u) || ke.of();
      }), Object.assign(o, { left: i, right: a });
    }, e.execute = function(t, r) {
      return t.request(u2(r.context, l2(s2(r)))) || ke.of();
    }, e.concat = function(t, r) {
      var n = Fi(t);
      if (so(n))
        return globalThis.__DEV__ !== !1 && ue.warn(35, n), n;
      var i = Fi(r), a;
      return so(i) ? a = new e(function(o) {
        return n.request(o, function(s) {
          return i.request(s) || ke.of();
        }) || ke.of();
      }) : a = new e(function(o, s) {
        return n.request(o, function(u) {
          return i.request(u, s) || ke.of();
        }) || ke.of();
      }), Object.assign(a, { left: n, right: i });
    }, e.prototype.split = function(t, r, n) {
      return this.concat(e.split(t, r, n || new e(qf)));
    }, e.prototype.concat = function(t) {
      return e.concat(this, t);
    }, e.prototype.request = function(t, r) {
      throw ht(36);
    }, e.prototype.onError = function(t, r) {
      if (r && r.error)
        return r.error(t), !1;
      throw t;
    }, e.prototype.setOnError = function(t) {
      return this.onError = t, this;
    }, e;
  }()
), d2 = function() {
  if (typeof AbortController > "u")
    return { controller: !1, signal: !1 };
  var e = new AbortController(), t = e.signal;
  return { controller: e, signal: t };
};
function f2(e) {
  var t, r = e[Symbol.asyncIterator]();
  return t = {
    next: function() {
      return r.next();
    }
  }, t[Symbol.asyncIterator] = function() {
    return this;
  }, t;
}
function h2(e) {
  var t = null, r = null, n = !1, i = [], a = [];
  function o(d) {
    if (!r) {
      if (a.length) {
        var f = a.shift();
        if (Array.isArray(f) && f[0])
          return f[0]({ value: d, done: !1 });
      }
      i.push(d);
    }
  }
  function s(d) {
    r = d;
    var f = a.slice();
    f.forEach(function(h) {
      h[1](d);
    }), !t || t();
  }
  function u() {
    n = !0;
    var d = a.slice();
    d.forEach(function(f) {
      f[0]({ value: void 0, done: !0 });
    }), !t || t();
  }
  t = function() {
    t = null, e.removeListener("data", o), e.removeListener("error", s), e.removeListener("end", u), e.removeListener("finish", u), e.removeListener("close", u);
  }, e.on("data", o), e.on("error", s), e.on("end", u), e.on("finish", u), e.on("close", u);
  function l() {
    return new Promise(function(d, f) {
      if (r)
        return f(r);
      if (i.length)
        return d({ value: i.shift(), done: !1 });
      if (n)
        return d({ value: void 0, done: !0 });
      a.push([d, f]);
    });
  }
  var c = {
    next: function() {
      return l();
    }
  };
  return Is && (c[Symbol.asyncIterator] = function() {
    return this;
  }), c;
}
function p2(e) {
  var t = !1, r = {
    next: function() {
      return t ? Promise.resolve({
        value: void 0,
        done: !0
      }) : (t = !0, new Promise(function(n, i) {
        e.then(function(a) {
          n({ value: a, done: !1 });
        }).catch(i);
      }));
    }
  };
  return Is && (r[Symbol.asyncIterator] = function() {
    return this;
  }), r;
}
function Hf(e) {
  var t = {
    next: function() {
      return e.read();
    }
  };
  return Is && (t[Symbol.asyncIterator] = function() {
    return this;
  }), t;
}
function m2(e) {
  return !!e.body;
}
function v2(e) {
  return !!e.getReader;
}
function y2(e) {
  return !!(Is && e[Symbol.asyncIterator]);
}
function g2(e) {
  return !!e.stream;
}
function b2(e) {
  return !!e.arrayBuffer;
}
function $2(e) {
  return !!e.pipe;
}
function x2(e) {
  var t = e;
  if (m2(e) && (t = e.body), y2(t))
    return f2(t);
  if (v2(t))
    return Hf(t.getReader());
  if (g2(t))
    return Hf(t.stream().getReader());
  if (b2(t))
    return p2(t.arrayBuffer());
  if ($2(t))
    return h2(t);
  throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
}
var ld = Symbol();
function D2(e) {
  return e.extensions ? Array.isArray(e.extensions[ld]) : !1;
}
function E2(e) {
  return e.hasOwnProperty("graphQLErrors");
}
var w2 = function(e) {
  var t = jt(jt(jt([], e.graphQLErrors, !0), e.clientErrors, !0), e.protocolErrors, !0);
  return e.networkError && t.push(e.networkError), t.map(function(r) {
    return qe(r) && r.message || "Error message not found.";
  }).join(`
`);
}, cr = (
  /** @class */
  function(e) {
    Ut(t, e);
    function t(r) {
      var n = r.graphQLErrors, i = r.protocolErrors, a = r.clientErrors, o = r.networkError, s = r.errorMessage, u = r.extraInfo, l = e.call(this, s) || this;
      return l.name = "ApolloError", l.graphQLErrors = n || [], l.protocolErrors = i || [], l.clientErrors = a || [], l.networkError = o || null, l.message = s || w2(l), l.extraInfo = u, l.__proto__ = t.prototype, l;
    }
    return t;
  }(Error)
), Wf = Object.prototype.hasOwnProperty;
function C2(e, t) {
  return Or(this, void 0, void 0, function() {
    var r, n, i, a, o, s, u, l, c, d, f, h, p, v, g, $, m, b, D, S, T, B, y, _;
    return Ir(this, function(w) {
      switch (w.label) {
        case 0:
          if (TextDecoder === void 0)
            throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
          r = new TextDecoder("utf-8"), n = (_ = e.headers) === null || _ === void 0 ? void 0 : _.get("content-type"), i = "boundary=", a = n != null && n.includes(i) ? n == null ? void 0 : n.substring((n == null ? void 0 : n.indexOf(i)) + i.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-", o = `\r
--`.concat(a), s = "", u = x2(e), l = !0, w.label = 1;
        case 1:
          return l ? [4, u.next()] : [3, 3];
        case 2:
          for (c = w.sent(), d = c.value, f = c.done, h = typeof d == "string" ? d : r.decode(d), p = s.length - o.length + 1, l = !f, s += h, v = s.indexOf(o, p); v > -1; ) {
            if (g = void 0, B = [
              s.slice(0, v),
              s.slice(v + o.length)
            ], g = B[0], s = B[1], $ = g.indexOf(`\r
\r
`), m = S2(g.slice(0, $)), b = m["content-type"], b && b.toLowerCase().indexOf("application/json") === -1)
              throw new Error("Unsupported patch content type: application/json is required.");
            if (D = g.slice($), D) {
              if (S = ov(e, D), Object.keys(S).length > 1 || "data" in S || "incremental" in S || "errors" in S || "payload" in S)
                if (o2(S)) {
                  if (T = {}, "payload" in S) {
                    if (Object.keys(S).length === 1 && S.payload === null)
                      return [
                        2
                        /*return*/
                      ];
                    T = M({}, S.payload);
                  }
                  "errors" in S && (T = M(M({}, T), { extensions: M(M({}, "extensions" in T ? T.extensions : null), (y = {}, y[ld] = S.errors, y)) })), t(T);
                } else
                  t(S);
              else if (
                // If the chunk contains only a "hasNext: false", we can call
                // observer.complete() immediately.
                Object.keys(S).length === 1 && "hasNext" in S && !S.hasNext
              )
                return [
                  2
                  /*return*/
                ];
            }
            v = s.indexOf(o);
          }
          return [3, 1];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function S2(e) {
  var t = {};
  return e.split(`
`).forEach(function(r) {
    var n = r.indexOf(":");
    if (n > -1) {
      var i = r.slice(0, n).trim().toLowerCase(), a = r.slice(n + 1).trim();
      t[i] = a;
    }
  }), t;
}
function ov(e, t) {
  if (e.status >= 300) {
    var r = function() {
      try {
        return JSON.parse(t);
      } catch {
        return t;
      }
    };
    av(e, r(), "Response not successful: Received status code ".concat(e.status));
  }
  try {
    return JSON.parse(t);
  } catch (i) {
    var n = i;
    throw n.name = "ServerParseError", n.response = e, n.statusCode = e.status, n.bodyText = t, n;
  }
}
function k2(e, t) {
  e.result && e.result.errors && e.result.data && t.next(e.result), t.error(e);
}
function sv(e) {
  return function(t) {
    return t.text().then(function(r) {
      return ov(t, r);
    }).then(function(r) {
      return !Array.isArray(r) && !Wf.call(r, "data") && !Wf.call(r, "errors") && av(t, r, "Server response was missing for query '".concat(Array.isArray(e) ? e.map(function(n) {
        return n.operationName;
      }) : e.operationName, "'.")), r;
    });
  };
}
var ma = function(e, t) {
  var r;
  try {
    r = JSON.stringify(e);
  } catch (i) {
    var n = ht(39, t, i.message);
    throw n.parseError = i, n;
  }
  return r;
};
function uv(e, t) {
  var r = [], n = function(d, f) {
    r.push("".concat(d, "=").concat(encodeURIComponent(f)));
  };
  if ("query" in t && n("query", t.query), t.operationName && n("operationName", t.operationName), t.variables) {
    var i = void 0;
    try {
      i = ma(t.variables, "Variables map");
    } catch (d) {
      return { parseError: d };
    }
    n("variables", i);
  }
  if (t.extensions) {
    var a = void 0;
    try {
      a = ma(t.extensions, "Extensions map");
    } catch (d) {
      return { parseError: d };
    }
    n("extensions", a);
  }
  var o = "", s = e, u = e.indexOf("#");
  u !== -1 && (o = e.substr(u), s = e.substr(0, u));
  var l = s.indexOf("?") === -1 ? "?" : "&", c = s + l + r.join("&") + o;
  return { newURI: c };
}
var P2 = {
  includeQuery: !0,
  includeExtensions: !1,
  preserveHeaderCase: !1
}, T2 = {
  // headers are case insensitive (https://stackoverflow.com/a/5259004)
  accept: "*/*",
  // The content-type header describes the type of the body of the request, and
  // so it typically only is sent with requests that actually have bodies. One
  // could imagine that Apollo Client would remove this header when constructing
  // a GET request (which has no body), but we historically have not done that.
  // This means that browsers will preflight all Apollo Client requests (even
  // GET requests). Apollo Server's CSRF prevention feature (introduced in
  // AS3.7) takes advantage of this fact and does not block requests with this
  // header. If you want to drop this header from GET requests, then you should
  // probably replace it with a `apollo-require-preflight` header, or servers
  // with CSRF prevention enabled might block your GET request. See
  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf
  // for more details.
  "content-type": "application/json"
}, A2 = {
  method: "POST"
}, lv = {
  http: P2,
  headers: T2,
  options: A2
}, cv = function(e, t) {
  return t(e);
};
function dv(e, t) {
  for (var r = [], n = 2; n < arguments.length; n++)
    r[n - 2] = arguments[n];
  var i = {}, a = {};
  r.forEach(function(d) {
    i = M(M(M({}, i), d.options), { headers: M(M({}, i.headers), d.headers) }), d.credentials && (i.credentials = d.credentials), a = M(M({}, a), d.http);
  }), i.headers && (i.headers = _2(i.headers, a.preserveHeaderCase));
  var o = e.operationName, s = e.extensions, u = e.variables, l = e.query, c = { operationName: o, variables: u };
  return a.includeExtensions && (c.extensions = s), a.includeQuery && (c.query = t(l, zs)), {
    options: i,
    body: c
  };
}
function _2(e, t) {
  if (!t) {
    var r = /* @__PURE__ */ Object.create(null);
    return Object.keys(Object(e)).forEach(function(a) {
      r[a.toLowerCase()] = e[a];
    }), r;
  }
  var n = /* @__PURE__ */ Object.create(null);
  Object.keys(Object(e)).forEach(function(a) {
    n[a.toLowerCase()] = {
      originalName: a,
      value: e[a]
    };
  });
  var i = /* @__PURE__ */ Object.create(null);
  return Object.keys(n).forEach(function(a) {
    i[n[a].originalName] = n[a].value;
  }), i;
}
var fv = function(e, t) {
  var r = e.getContext(), n = r.uri;
  return n || (typeof t == "function" ? t(e) : t || "/graphql");
};
function F2(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function O2(e, t, r = "") {
  if (!arguments.length) throw new TypeError("Argument 1 `value` is required.");
  if (typeof t != "function")
    throw new TypeError("Argument 2 `isExtractable` must be a function.");
  if (typeof r != "string")
    throw new TypeError("Argument 3 `path` must be a string.");
  const n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  function a(o, s, u) {
    if (t(o)) {
      const d = i.get(o);
      return d ? d.push(s) : i.set(o, [s]), null;
    }
    const l = Array.isArray(o) || typeof FileList < "u" && o instanceof FileList, c = F2(o);
    if (l || c) {
      let d = n.get(o);
      const f = !d;
      if (f && (d = l ? [] : (
        // Replicate if the plain object is an `Object` instance.
        o instanceof /** @type {any} */
        Object ? {} : /* @__PURE__ */ Object.create(null)
      ), n.set(
        o,
        /** @type {Clone} */
        d
      )), !u.has(o)) {
        const h = s ? `${s}.` : "", p = new Set(u).add(o);
        if (l) {
          let v = 0;
          for (const g of o) {
            const $ = a(
              g,
              h + v++,
              p
            );
            f && d.push($);
          }
        } else
          for (const v in o) {
            const g = a(
              o[v],
              h + v,
              p
            );
            f && (d[v] = g);
          }
      }
      return d;
    }
    return o;
  }
  return {
    clone: a(e, r, /* @__PURE__ */ new Set()),
    files: i
  };
}
function I2(e, t, r) {
  "name" in r ? e.append(t, r, r.name) : e.append(t, r);
}
function R2(e) {
  return typeof File < "u" && e instanceof File || typeof Blob < "u" && e instanceof Blob;
}
function hv({
  uri: e = "/graphql",
  useGETForQueries: t,
  isExtractableFile: r = R2,
  FormData: n,
  formDataAppendFile: i = I2,
  print: a = cv,
  fetch: o,
  fetchOptions: s,
  credentials: u,
  headers: l,
  includeExtensions: c
} = {}) {
  const d = {
    http: { includeExtensions: c },
    options: s,
    credentials: u,
    headers: l
  };
  return new qt((f) => {
    const h = (
      /**
       * @type {import("@apollo/client/core/types.js").DefaultContext & {
       *   clientAwareness?: {
       *     name?: string,
       *     version?: string,
       *   },
       * }}
       */
      f.getContext()
    ), {
      // Apollo Studio client awareness `name` and `version` can be configured
      // via `ApolloClient` constructor options:
      // https://www.apollographql.com/docs/graphos/metrics/client-awareness/#setup
      clientAwareness: { name: p, version: v } = {},
      headers: g
    } = h, $ = {
      http: h.http,
      options: h.fetchOptions,
      credentials: h.credentials,
      headers: {
        // Client awareness headers can be overridden by context `headers`.
        ...p && { "apollographql-client-name": p },
        ...v && { "apollographql-client-version": v },
        ...g
      }
    }, { options: m, body: b } = dv(
      f,
      a,
      lv,
      d,
      $
    ), { clone: D, files: S } = O2(b, r, "");
    let T = fv(f, e);
    if (S.size) {
      m.headers && delete m.headers["content-type"];
      const _ = n || FormData, w = new _();
      w.append("operations", ma(D, "Payload"));
      const E = {};
      let k = 0;
      S.forEach((C) => {
        E[++k] = C;
      }), w.append("map", JSON.stringify(E)), k = 0, S.forEach((C, A) => {
        i(w, String(++k), A);
      }), m.body = w;
    } else if (t && // If the operation contains some mutations GET shouldnt be used.
    !f.query.definitions.some(
      (_) => _.kind === "OperationDefinition" && _.operation === "mutation"
    ) && (m.method = "GET"), m.method === "GET") {
      const { newURI: _, parseError: w } = uv(T, b);
      if (w)
        return new ke((E) => {
          E.error(w);
        });
      T = _;
    } else m.body = ma(D, "Payload");
    const { controller: B } = d2();
    typeof B != "boolean" && (m.signal && (m.signal.aborted ? (
      // Signal already aborted, so immediately abort.
      B.abort()
    ) : (
      // Signal not already aborted, so setup a listener to abort when it
      // does.
      m.signal.addEventListener(
        "abort",
        () => {
          B.abort();
        },
        {
          // Prevent a memory leak if the user configured abort controller
          // is long lasting, or controls multiple things.
          once: !0
        }
      )
    )), m.signal = B.signal);
    const y = o || fetch;
    return new ke((_) => {
      let w;
      return y(T, m).then((E) => (f.setContext({ response: E }), E)).then(sv(f)).then((E) => {
        _.next(E), _.complete();
      }).catch((E) => {
        w || (E.result && E.result.errors && E.result.data && _.next(E.result), _.error(E));
      }), () => {
        w = !0, typeof B != "boolean" && B.abort();
      };
    });
  });
}
var Rl = qt.execute, B2 = function(e) {
  if (!e && typeof fetch > "u")
    throw ht(37);
}, Qf = Vt(function() {
  return fetch;
}), M2 = function(e) {
  e === void 0 && (e = {});
  var t = e.uri, r = t === void 0 ? "/graphql" : t, n = e.fetch, i = e.print, a = i === void 0 ? cv : i, o = e.includeExtensions, s = e.preserveHeaderCase, u = e.useGETForQueries, l = e.includeUnusedVariables, c = l === void 0 ? !1 : l, d = Kt(e, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
  globalThis.__DEV__ !== !1 && B2(n || Qf);
  var f = {
    http: { includeExtensions: o, preserveHeaderCase: s },
    options: d.fetchOptions,
    credentials: d.credentials,
    headers: d.headers
  };
  return new qt(function(h) {
    var p = fv(h, r), v = h.getContext(), g = {};
    if (v.clientAwareness) {
      var $ = v.clientAwareness, m = $.name, b = $.version;
      m && (g["apollographql-client-name"] = m), b && (g["apollographql-client-version"] = b);
    }
    var D = M(M({}, g), v.headers), S = {
      http: v.http,
      options: v.fetchOptions,
      credentials: v.credentials,
      headers: D
    };
    if (da(["client"], h.query)) {
      var T = Jm(h.query);
      if (!T)
        return Au(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
      h.query = T;
    }
    var B = dv(h, a, lv, f, S), y = B.options, _ = B.body;
    _.variables && !c && (_.variables = c2(_.variables, h.query));
    var w;
    !y.signal && typeof AbortController < "u" && (w = new AbortController(), y.signal = w.signal);
    var E = function(K) {
      return K.kind === "OperationDefinition" && K.operation === "mutation";
    }, k = function(K) {
      return K.kind === "OperationDefinition" && K.operation === "subscription";
    }, C = k(Ma(h.query)), A = da(["defer"], h.query);
    if (u && !h.query.definitions.some(E) && (y.method = "GET"), A || C) {
      y.headers = y.headers || {};
      var L = "multipart/mixed;";
      C && A && globalThis.__DEV__ !== !1 && ue.warn(38), C ? L += "boundary=graphql;subscriptionSpec=1.0,application/json" : A && (L += "deferSpec=20220824,application/json"), y.headers.accept = L;
    }
    if (y.method === "GET") {
      var I = uv(p, _), x = I.newURI, U = I.parseError;
      if (U)
        return Au(U);
      p = x;
    } else
      try {
        y.body = ma(_, "Payload");
      } catch (K) {
        return Au(K);
      }
    return new ke(function(K) {
      var z = n || Vt(function() {
        return fetch;
      }) || Qf, ae = K.next.bind(K);
      return z(p, y).then(function(ne) {
        var ye;
        h.setContext({ response: ne });
        var De = (ye = ne.headers) === null || ye === void 0 ? void 0 : ye.get("content-type");
        return De !== null && /^multipart\/mixed/i.test(De) ? C2(ne, ae) : sv(h)(ne).then(ae);
      }).then(function() {
        w = void 0, K.complete();
      }).catch(function(ne) {
        w = void 0, k2(ne, K);
      }), function() {
        w && w.abort();
      };
    });
  });
}, N2 = (
  /** @class */
  function(e) {
    Ut(t, e);
    function t(r) {
      r === void 0 && (r = {});
      var n = e.call(this, M2(r).request) || this;
      return n.options = r, n;
    }
    return t;
  }(qt)
);
const { toString: Gf, hasOwnProperty: L2 } = Object.prototype, Zf = Function.prototype.toString, Bl = /* @__PURE__ */ new Map();
function Te(e, t) {
  try {
    return Ml(e, t);
  } finally {
    Bl.clear();
  }
}
function Ml(e, t) {
  if (e === t)
    return !0;
  const r = Gf.call(e), n = Gf.call(t);
  if (r !== n)
    return !1;
  switch (r) {
    case "[object Array]":
      if (e.length !== t.length)
        return !1;
    case "[object Object]": {
      if (Jf(e, t))
        return !0;
      const i = Yf(e), a = Yf(t), o = i.length;
      if (o !== a.length)
        return !1;
      for (let s = 0; s < o; ++s)
        if (!L2.call(t, i[s]))
          return !1;
      for (let s = 0; s < o; ++s) {
        const u = i[s];
        if (!Ml(e[u], t[u]))
          return !1;
      }
      return !0;
    }
    case "[object Error]":
      return e.name === t.name && e.message === t.message;
    case "[object Number]":
      if (e !== e)
        return t !== t;
    case "[object Boolean]":
    case "[object Date]":
      return +e == +t;
    case "[object RegExp]":
    case "[object String]":
      return e == `${t}`;
    case "[object Map]":
    case "[object Set]": {
      if (e.size !== t.size)
        return !1;
      if (Jf(e, t))
        return !0;
      const i = e.entries(), a = r === "[object Map]";
      for (; ; ) {
        const o = i.next();
        if (o.done)
          break;
        const [s, u] = o.value;
        if (!t.has(s) || a && !Ml(u, t.get(s)))
          return !1;
      }
      return !0;
    }
    case "[object Uint16Array]":
    case "[object Uint8Array]":
    case "[object Uint32Array]":
    case "[object Int32Array]":
    case "[object Int8Array]":
    case "[object Int16Array]":
    case "[object ArrayBuffer]":
      e = new Uint8Array(e), t = new Uint8Array(t);
    case "[object DataView]": {
      let i = e.byteLength;
      if (i === t.byteLength)
        for (; i-- && e[i] === t[i]; )
          ;
      return i === -1;
    }
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
    case "[object Function]": {
      const i = Zf.call(e);
      return i !== Zf.call(t) ? !1 : !j2(i, z2);
    }
  }
  return !1;
}
function Yf(e) {
  return Object.keys(e).filter(V2, e);
}
function V2(e) {
  return this[e] !== void 0;
}
const z2 = "{ [native code] }";
function j2(e, t) {
  const r = e.length - t.length;
  return r >= 0 && e.indexOf(t, r) === r;
}
function Jf(e, t) {
  let r = Bl.get(e);
  if (r) {
    if (r.has(t))
      return !0;
  } else
    Bl.set(e, r = /* @__PURE__ */ new Set());
  return r.add(t), !1;
}
function pv(e, t, r, n) {
  var i = t.data, a = Kt(t, ["data"]), o = r.data, s = Kt(r, ["data"]);
  return Te(a, s) && Po(Ma(e).selectionSet, i, o, {
    fragmentMap: Rs(Ns(e)),
    variables: n
  });
}
function Po(e, t, r, n) {
  if (t === r)
    return !0;
  var i = /* @__PURE__ */ new Set();
  return e.selections.every(function(a) {
    if (i.has(a) || (i.add(a), !Ia(a, n.variables)) || Xf(a))
      return !0;
    if (jr(a)) {
      var o = zr(a), s = t && t[o], u = r && r[o], l = a.selectionSet;
      if (!l)
        return Te(s, u);
      var c = Array.isArray(s), d = Array.isArray(u);
      if (c !== d)
        return !1;
      if (c && d) {
        var f = s.length;
        if (u.length !== f)
          return !1;
        for (var h = 0; h < f; ++h)
          if (!Po(l, s[h], u[h], n))
            return !1;
        return !0;
      }
      return Po(l, s, u, n);
    } else {
      var p = Bs(a, n.fragmentMap);
      if (p)
        return Xf(p) ? !0 : Po(
          p.selectionSet,
          // Notice that we reuse the same aResult and bResult values here,
          // since the fragment ...spread does not specify a field name, but
          // consists of multiple fields (within the fragment's selection set)
          // that should be applied to the current result value(s).
          t,
          r,
          n
        );
    }
  });
}
function Xf(e) {
  return !!e.directives && e.directives.some(K2);
}
function K2(e) {
  return e.name.value === "nonreactive";
}
var mv = (
  /** @class */
  function() {
    function e() {
      this.assumeImmutableResults = !1, this.getFragmentDoc = ha(QD, {
        max: Xt["cache.fragmentQueryDocuments"] || 1e3,
        cache: zo
      });
    }
    return e.prototype.batch = function(t) {
      var r = this, n = typeof t.optimistic == "string" ? t.optimistic : t.optimistic === !1 ? null : void 0, i;
      return this.performTransaction(function() {
        return i = t.update(r);
      }, n), i;
    }, e.prototype.recordOptimisticTransaction = function(t, r) {
      this.performTransaction(t, r);
    }, e.prototype.transformDocument = function(t) {
      return t;
    }, e.prototype.transformForLink = function(t) {
      return t;
    }, e.prototype.identify = function(t) {
    }, e.prototype.gc = function() {
      return [];
    }, e.prototype.modify = function(t) {
      return !1;
    }, e.prototype.readQuery = function(t, r) {
      return r === void 0 && (r = !!t.optimistic), this.read(M(M({}, t), { rootId: t.id || "ROOT_QUERY", optimistic: r }));
    }, e.prototype.watchFragment = function(t) {
      var r = this, n = t.fragment, i = t.fragmentName, a = t.from, o = t.optimistic, s = o === void 0 ? !0 : o, u = this.getFragmentDoc(n, i), l = {
        returnPartialData: !0,
        id: typeof a == "string" ? a : this.identify(a),
        query: u,
        optimistic: s
      }, c;
      return new ke(function(d) {
        return r.watch(M(M({}, l), { immediate: !0, callback: function(f) {
          if (
            // Always ensure we deliver the first result
            !(c && pv(u, { data: c == null ? void 0 : c.result }, { data: f.result }))
          ) {
            var h = {
              data: f.result,
              complete: !!f.complete
            };
            f.missing && (h.missing = js(f.missing.map(function(p) {
              return p.missing;
            }))), c = f, d.next(h);
          }
        } }));
      });
    }, e.prototype.readFragment = function(t, r) {
      return r === void 0 && (r = !!t.optimistic), this.read(M(M({}, t), { query: this.getFragmentDoc(t.fragment, t.fragmentName), rootId: t.id, optimistic: r }));
    }, e.prototype.writeQuery = function(t) {
      var r = t.id, n = t.data, i = Kt(t, ["id", "data"]);
      return this.write(Object.assign(i, {
        dataId: r || "ROOT_QUERY",
        result: n
      }));
    }, e.prototype.writeFragment = function(t) {
      var r = t.id, n = t.data, i = t.fragment, a = t.fragmentName, o = Kt(t, ["id", "data", "fragment", "fragmentName"]);
      return this.write(Object.assign(o, {
        query: this.getFragmentDoc(i, a),
        dataId: r,
        result: n
      }));
    }, e.prototype.updateQuery = function(t, r) {
      return this.batch({
        update: function(n) {
          var i = n.readQuery(t), a = r(i);
          return a == null ? i : (n.writeQuery(M(M({}, t), { data: a })), a);
        }
      });
    }, e.prototype.updateFragment = function(t, r) {
      return this.batch({
        update: function(n) {
          var i = n.readFragment(t), a = r(i);
          return a == null ? i : (n.writeFragment(M(M({}, t), { data: a })), a);
        }
      });
    }, e;
  }()
);
globalThis.__DEV__ !== !1 && (mv.prototype.getMemoryInternals = a5);
var vv = (
  /** @class */
  function(e) {
    Ut(t, e);
    function t(r, n, i, a) {
      var o, s = e.call(this, r) || this;
      if (s.message = r, s.path = n, s.query = i, s.variables = a, Array.isArray(s.path)) {
        s.missing = s.message;
        for (var u = s.path.length - 1; u >= 0; --u)
          s.missing = (o = {}, o[s.path[u]] = s.missing, o);
      } else
        s.missing = s.path;
      return s.__proto__ = t.prototype, s;
    }
    return t;
  }(Error)
), at = Object.prototype.hasOwnProperty;
function Oi(e) {
  return e == null;
}
function yv(e, t) {
  var r = e.__typename, n = e.id, i = e._id;
  if (typeof r == "string" && (t && (t.keyObject = Oi(n) ? Oi(i) ? void 0 : { _id: i } : { id: n }), Oi(n) && !Oi(i) && (n = i), !Oi(n)))
    return "".concat(r, ":").concat(typeof n == "number" || typeof n == "string" ? n : JSON.stringify(n));
}
var gv = {
  dataIdFromObject: yv,
  addTypename: !0,
  resultCaching: !0,
  // Thanks to the shouldCanonizeResults helper, this should be the only line
  // you have to change to reenable canonization by default in the future.
  canonizeResults: !1
};
function U2(e) {
  return hn(gv, e);
}
function bv(e) {
  var t = e.canonizeResults;
  return t === void 0 ? gv.canonizeResults : t;
}
function q2(e, t) {
  return Ae(t) ? e.get(t.__ref, "__typename") : t && t.__typename;
}
var $v = /^[_a-z][_0-9a-z]*/i;
function qr(e) {
  var t = e.match($v);
  return t ? t[0] : e;
}
function Nl(e, t, r) {
  return qe(t) ? He(t) ? t.every(function(n) {
    return Nl(e, n, r);
  }) : e.selections.every(function(n) {
    if (jr(n) && Ia(n, r)) {
      var i = zr(n);
      return at.call(t, i) && (!n.selectionSet || Nl(n.selectionSet, t[i], r));
    }
    return !0;
  }) : !1;
}
function jn(e) {
  return qe(e) && !Ae(e) && !He(e);
}
function H2() {
  return new Ur();
}
function xv(e, t) {
  var r = Rs(Ns(e));
  return {
    fragmentMap: r,
    lookupFragment: function(n) {
      var i = r[n];
      return !i && t && (i = t.lookup(n)), i || null;
    }
  };
}
var To = /* @__PURE__ */ Object.create(null), _u = function() {
  return To;
}, eh = /* @__PURE__ */ Object.create(null), va = (
  /** @class */
  function() {
    function e(t, r) {
      var n = this;
      this.policies = t, this.group = r, this.data = /* @__PURE__ */ Object.create(null), this.rootIds = /* @__PURE__ */ Object.create(null), this.refs = /* @__PURE__ */ Object.create(null), this.getFieldValue = function(i, a) {
        return pa(Ae(i) ? n.get(i.__ref, a) : i && i[a]);
      }, this.canRead = function(i) {
        return Ae(i) ? n.has(i.__ref) : typeof i == "object";
      }, this.toReference = function(i, a) {
        if (typeof i == "string")
          return Gn(i);
        if (Ae(i))
          return i;
        var o = n.policies.identify(i)[0];
        if (o) {
          var s = Gn(o);
          return a && n.merge(o, i), s;
        }
      };
    }
    return e.prototype.toObject = function() {
      return M({}, this.data);
    }, e.prototype.has = function(t) {
      return this.lookup(t, !0) !== void 0;
    }, e.prototype.get = function(t, r) {
      if (this.group.depend(t, r), at.call(this.data, t)) {
        var n = this.data[t];
        if (n && at.call(n, r))
          return n[r];
      }
      if (r === "__typename" && at.call(this.policies.rootTypenamesById, t))
        return this.policies.rootTypenamesById[t];
      if (this instanceof _r)
        return this.parent.get(t, r);
    }, e.prototype.lookup = function(t, r) {
      if (r && this.group.depend(t, "__exists"), at.call(this.data, t))
        return this.data[t];
      if (this instanceof _r)
        return this.parent.lookup(t, r);
      if (this.policies.rootTypenamesById[t])
        return /* @__PURE__ */ Object.create(null);
    }, e.prototype.merge = function(t, r) {
      var n = this, i;
      Ae(t) && (t = t.__ref), Ae(r) && (r = r.__ref);
      var a = typeof t == "string" ? this.lookup(i = t) : t, o = typeof r == "string" ? this.lookup(i = r) : r;
      if (o) {
        ue(typeof i == "string", 1);
        var s = new Ur(Q2).merge(a, o);
        if (this.data[i] = s, s !== a && (delete this.refs[i], this.group.caching)) {
          var u = /* @__PURE__ */ Object.create(null);
          a || (u.__exists = 1), Object.keys(o).forEach(function(l) {
            if (!a || a[l] !== s[l]) {
              u[l] = 1;
              var c = qr(l);
              c !== l && !n.policies.hasKeyArgs(s.__typename, c) && (u[c] = 1), s[l] === void 0 && !(n instanceof _r) && delete s[l];
            }
          }), u.__typename && !(a && a.__typename) && // Since we return default root __typename strings
          // automatically from store.get, we don't need to dirty the
          // ROOT_QUERY.__typename field if merged.__typename is equal
          // to the default string (usually "Query").
          this.policies.rootTypenamesById[i] === s.__typename && delete u.__typename, Object.keys(u).forEach(function(l) {
            return n.group.dirty(i, l);
          });
        }
      }
    }, e.prototype.modify = function(t, r) {
      var n = this, i = this.lookup(t);
      if (i) {
        var a = /* @__PURE__ */ Object.create(null), o = !1, s = !0, u = {
          DELETE: To,
          INVALIDATE: eh,
          isReference: Ae,
          toReference: this.toReference,
          canRead: this.canRead,
          readField: function(l, c) {
            return n.policies.readField(typeof l == "string" ? {
              fieldName: l,
              from: c || Gn(t)
            } : l, { store: n });
          }
        };
        if (Object.keys(i).forEach(function(l) {
          var c = qr(l), d = i[l];
          if (d !== void 0) {
            var f = typeof r == "function" ? r : r[l] || r[c];
            if (f) {
              var h = f === _u ? To : f(pa(d), M(M({}, u), { fieldName: c, storeFieldName: l, storage: n.getStorage(t, l) }));
              if (h === eh)
                n.group.dirty(t, l);
              else if (h === To && (h = void 0), h !== d && (a[l] = h, o = !0, d = h, globalThis.__DEV__ !== !1)) {
                var p = function(S) {
                  if (n.lookup(S.__ref) === void 0)
                    return globalThis.__DEV__ !== !1 && ue.warn(2, S), !0;
                };
                if (Ae(h))
                  p(h);
                else if (Array.isArray(h))
                  for (var v = !1, g = void 0, $ = 0, m = h; $ < m.length; $++) {
                    var b = m[$];
                    if (Ae(b)) {
                      if (v = !0, p(b))
                        break;
                    } else if (typeof b == "object" && b) {
                      var D = n.policies.identify(b)[0];
                      D && (g = b);
                    }
                    if (v && g !== void 0) {
                      globalThis.__DEV__ !== !1 && ue.warn(3, g);
                      break;
                    }
                  }
              }
            }
            d !== void 0 && (s = !1);
          }
        }), o)
          return this.merge(t, a), s && (this instanceof _r ? this.data[t] = void 0 : delete this.data[t], this.group.dirty(t, "__exists")), !0;
      }
      return !1;
    }, e.prototype.delete = function(t, r, n) {
      var i, a = this.lookup(t);
      if (a) {
        var o = this.getFieldValue(a, "__typename"), s = r && n ? this.policies.getStoreFieldName({ typename: o, fieldName: r, args: n }) : r;
        return this.modify(t, s ? (i = {}, i[s] = _u, i) : _u);
      }
      return !1;
    }, e.prototype.evict = function(t, r) {
      var n = !1;
      return t.id && (at.call(this.data, t.id) && (n = this.delete(t.id, t.fieldName, t.args)), this instanceof _r && this !== r && (n = this.parent.evict(t, r) || n), (t.fieldName || n) && this.group.dirty(t.id, t.fieldName || "__exists")), n;
    }, e.prototype.clear = function() {
      this.replace(null);
    }, e.prototype.extract = function() {
      var t = this, r = this.toObject(), n = [];
      return this.getRootIdSet().forEach(function(i) {
        at.call(t.policies.rootTypenamesById, i) || n.push(i);
      }), n.length && (r.__META = { extraRootIds: n.sort() }), r;
    }, e.prototype.replace = function(t) {
      var r = this;
      if (Object.keys(this.data).forEach(function(a) {
        t && at.call(t, a) || r.delete(a);
      }), t) {
        var n = t.__META, i = Kt(t, ["__META"]);
        Object.keys(i).forEach(function(a) {
          r.merge(a, i[a]);
        }), n && n.extraRootIds.forEach(this.retain, this);
      }
    }, e.prototype.retain = function(t) {
      return this.rootIds[t] = (this.rootIds[t] || 0) + 1;
    }, e.prototype.release = function(t) {
      if (this.rootIds[t] > 0) {
        var r = --this.rootIds[t];
        return r || delete this.rootIds[t], r;
      }
      return 0;
    }, e.prototype.getRootIdSet = function(t) {
      return t === void 0 && (t = /* @__PURE__ */ new Set()), Object.keys(this.rootIds).forEach(t.add, t), this instanceof _r ? this.parent.getRootIdSet(t) : Object.keys(this.policies.rootTypenamesById).forEach(t.add, t), t;
    }, e.prototype.gc = function() {
      var t = this, r = this.getRootIdSet(), n = this.toObject();
      r.forEach(function(o) {
        at.call(n, o) && (Object.keys(t.findChildRefIds(o)).forEach(r.add, r), delete n[o]);
      });
      var i = Object.keys(n);
      if (i.length) {
        for (var a = this; a instanceof _r; )
          a = a.parent;
        i.forEach(function(o) {
          return a.delete(o);
        });
      }
      return i;
    }, e.prototype.findChildRefIds = function(t) {
      if (!at.call(this.refs, t)) {
        var r = this.refs[t] = /* @__PURE__ */ Object.create(null), n = this.data[t];
        if (!n)
          return r;
        var i = /* @__PURE__ */ new Set([n]);
        i.forEach(function(a) {
          Ae(a) && (r[a.__ref] = !0), qe(a) && Object.keys(a).forEach(function(o) {
            var s = a[o];
            qe(s) && i.add(s);
          });
        });
      }
      return this.refs[t];
    }, e.prototype.makeCacheKey = function() {
      return this.group.keyMaker.lookupArray(arguments);
    }, e;
  }()
), Dv = (
  /** @class */
  function() {
    function e(t, r) {
      r === void 0 && (r = null), this.caching = t, this.parent = r, this.d = null, this.resetCaching();
    }
    return e.prototype.resetCaching = function() {
      this.d = this.caching ? Qm() : null, this.keyMaker = new bi(wn);
    }, e.prototype.depend = function(t, r) {
      if (this.d) {
        this.d(Fu(t, r));
        var n = qr(r);
        n !== r && this.d(Fu(t, n)), this.parent && this.parent.depend(t, r);
      }
    }, e.prototype.dirty = function(t, r) {
      this.d && this.d.dirty(
        Fu(t, r),
        // When storeFieldName === "__exists", that means the entity identified
        // by dataId has either disappeared from the cache or was newly added,
        // so the result caching system would do well to "forget everything it
        // knows" about that object. To achieve that kind of invalidation, we
        // not only dirty the associated result cache entry, but also remove it
        // completely from the dependency graph. For the optimism implementation
        // details, see https://github.com/benjamn/optimism/pull/195.
        r === "__exists" ? "forget" : "setDirty"
      );
    }, e;
  }()
);
function Fu(e, t) {
  return t + "#" + e;
}
function th(e, t) {
  ea(e) && e.group.depend(t, "__exists");
}
(function(e) {
  var t = (
    /** @class */
    function(r) {
      Ut(n, r);
      function n(i) {
        var a = i.policies, o = i.resultCaching, s = o === void 0 ? !0 : o, u = i.seed, l = r.call(this, a, new Dv(s)) || this;
        return l.stump = new W2(l), l.storageTrie = new bi(wn), u && l.replace(u), l;
      }
      return n.prototype.addLayer = function(i, a) {
        return this.stump.addLayer(i, a);
      }, n.prototype.removeLayer = function() {
        return this;
      }, n.prototype.getStorage = function() {
        return this.storageTrie.lookupArray(arguments);
      }, n;
    }(e)
  );
  e.Root = t;
})(va || (va = {}));
var _r = (
  /** @class */
  function(e) {
    Ut(t, e);
    function t(r, n, i, a) {
      var o = e.call(this, n.policies, a) || this;
      return o.id = r, o.parent = n, o.replay = i, o.group = a, i(o), o;
    }
    return t.prototype.addLayer = function(r, n) {
      return new t(r, this, n, this.group);
    }, t.prototype.removeLayer = function(r) {
      var n = this, i = this.parent.removeLayer(r);
      return r === this.id ? (this.group.caching && Object.keys(this.data).forEach(function(a) {
        var o = n.data[a], s = i.lookup(a);
        s ? o ? o !== s && Object.keys(o).forEach(function(u) {
          Te(o[u], s[u]) || n.group.dirty(a, u);
        }) : (n.group.dirty(a, "__exists"), Object.keys(s).forEach(function(u) {
          n.group.dirty(a, u);
        })) : n.delete(a);
      }), i) : i === this.parent ? this : i.addLayer(this.id, this.replay);
    }, t.prototype.toObject = function() {
      return M(M({}, this.parent.toObject()), this.data);
    }, t.prototype.findChildRefIds = function(r) {
      var n = this.parent.findChildRefIds(r);
      return at.call(this.data, r) ? M(M({}, n), e.prototype.findChildRefIds.call(this, r)) : n;
    }, t.prototype.getStorage = function() {
      for (var r = this.parent; r.parent; )
        r = r.parent;
      return r.getStorage.apply(
        r,
        // @ts-expect-error
        arguments
      );
    }, t;
  }(va)
), W2 = (
  /** @class */
  function(e) {
    Ut(t, e);
    function t(r) {
      return e.call(this, "EntityStore.Stump", r, function() {
      }, new Dv(r.group.caching, r.group)) || this;
    }
    return t.prototype.removeLayer = function() {
      return this;
    }, t.prototype.merge = function(r, n) {
      return this.parent.merge(r, n);
    }, t;
  }(_r)
);
function Q2(e, t, r) {
  var n = e[r], i = t[r];
  return Te(n, i) ? n : i;
}
function ea(e) {
  return !!(e instanceof va && e.group.caching);
}
function G2(e) {
  return qe(e) ? He(e) ? e.slice(0) : M({ __proto__: Object.getPrototypeOf(e) }, e) : e;
}
var rh = (
  /** @class */
  function() {
    function e() {
      this.known = new (Tm ? WeakSet : Set)(), this.pool = new bi(wn), this.passes = /* @__PURE__ */ new WeakMap(), this.keysByJSON = /* @__PURE__ */ new Map(), this.empty = this.admit({});
    }
    return e.prototype.isKnown = function(t) {
      return qe(t) && this.known.has(t);
    }, e.prototype.pass = function(t) {
      if (qe(t)) {
        var r = G2(t);
        return this.passes.set(r, t), r;
      }
      return t;
    }, e.prototype.admit = function(t) {
      var r = this;
      if (qe(t)) {
        var n = this.passes.get(t);
        if (n)
          return n;
        var i = Object.getPrototypeOf(t);
        switch (i) {
          case Array.prototype: {
            if (this.known.has(t))
              return t;
            var a = t.map(this.admit, this), o = this.pool.lookupArray(a);
            return o.array || (this.known.add(o.array = a), globalThis.__DEV__ !== !1 && Object.freeze(a)), o.array;
          }
          case null:
          case Object.prototype: {
            if (this.known.has(t))
              return t;
            var s = Object.getPrototypeOf(t), u = [s], l = this.sortedKeys(t);
            u.push(l.json);
            var c = u.length;
            l.sorted.forEach(function(h) {
              u.push(r.admit(t[h]));
            });
            var o = this.pool.lookupArray(u);
            if (!o.object) {
              var d = o.object = Object.create(s);
              this.known.add(d), l.sorted.forEach(function(h, p) {
                d[h] = u[c + p];
              }), globalThis.__DEV__ !== !1 && Object.freeze(d);
            }
            return o.object;
          }
        }
      }
      return t;
    }, e.prototype.sortedKeys = function(t) {
      var r = Object.keys(t), n = this.pool.lookupArray(r);
      if (!n.keys) {
        r.sort();
        var i = JSON.stringify(r);
        (n.keys = this.keysByJSON.get(i)) || this.keysByJSON.set(i, n.keys = { sorted: r, json: i });
      }
      return n.keys;
    }, e;
  }()
);
function nh(e) {
  return [
    e.selectionSet,
    e.objectOrReference,
    e.context,
    // We split out this property so we can pass different values
    // independently without modifying options.context itself.
    e.context.canonizeResults
  ];
}
var Z2 = (
  /** @class */
  function() {
    function e(t) {
      var r = this;
      this.knownResults = new (wn ? WeakMap : Map)(), this.config = hn(t, {
        addTypename: t.addTypename !== !1,
        canonizeResults: bv(t)
      }), this.canon = t.canon || new rh(), this.executeSelectionSet = ha(function(n) {
        var i, a = n.context.canonizeResults, o = nh(n);
        o[3] = !a;
        var s = (i = r.executeSelectionSet).peek.apply(i, o);
        return s ? a ? M(M({}, s), {
          // If we previously read this result without canonizing it, we can
          // reuse that result simply by canonizing it now.
          result: r.canon.admit(s.result)
        }) : s : (th(n.context.store, n.enclosingRef.__ref), r.execSelectionSetImpl(n));
      }, {
        max: this.config.resultCacheMaxSize || Xt["inMemoryCache.executeSelectionSet"] || 5e4,
        keyArgs: nh,
        // Note that the parameters of makeCacheKey are determined by the
        // array returned by keyArgs.
        makeCacheKey: function(n, i, a, o) {
          if (ea(a.store))
            return a.store.makeCacheKey(n, Ae(i) ? i.__ref : i, a.varString, o);
        }
      }), this.executeSubSelectedArray = ha(function(n) {
        return th(n.context.store, n.enclosingRef.__ref), r.execSubSelectedArrayImpl(n);
      }, {
        max: this.config.resultCacheMaxSize || Xt["inMemoryCache.executeSubSelectedArray"] || 1e4,
        makeCacheKey: function(n) {
          var i = n.field, a = n.array, o = n.context;
          if (ea(o.store))
            return o.store.makeCacheKey(i, a, o.varString);
        }
      });
    }
    return e.prototype.resetCanon = function() {
      this.canon = new rh();
    }, e.prototype.diffQueryAgainstStore = function(t) {
      var r = t.store, n = t.query, i = t.rootId, a = i === void 0 ? "ROOT_QUERY" : i, o = t.variables, s = t.returnPartialData, u = s === void 0 ? !0 : s, l = t.canonizeResults, c = l === void 0 ? this.config.canonizeResults : l, d = this.config.cache.policies;
      o = M(M({}, Xc(Bm(n))), o);
      var f = Gn(a), h = this.executeSelectionSet({
        selectionSet: Ma(n).selectionSet,
        objectOrReference: f,
        enclosingRef: f,
        context: M({ store: r, query: n, policies: d, variables: o, varString: Vr(o), canonizeResults: c }, xv(n, this.config.fragments))
      }), p;
      if (h.missing && (p = [
        new vv(Y2(h.missing), h.missing, n, o)
      ], !u))
        throw p[0];
      return {
        result: h.result,
        complete: !p,
        missing: p
      };
    }, e.prototype.isFresh = function(t, r, n, i) {
      if (ea(i.store) && this.knownResults.get(t) === n) {
        var a = this.executeSelectionSet.peek(
          n,
          r,
          i,
          // If result is canonical, then it could only have been previously
          // cached by the canonizing version of executeSelectionSet, so we can
          // avoid checking both possibilities here.
          this.canon.isKnown(t)
        );
        if (a && t === a.result)
          return !0;
      }
      return !1;
    }, e.prototype.execSelectionSetImpl = function(t) {
      var r = this, n = t.selectionSet, i = t.objectOrReference, a = t.enclosingRef, o = t.context;
      if (Ae(i) && !o.policies.rootTypenamesById[i.__ref] && !o.store.has(i.__ref))
        return {
          result: this.canon.empty,
          missing: "Dangling reference to missing ".concat(i.__ref, " object")
        };
      var s = o.variables, u = o.policies, l = o.store, c = l.getFieldValue(i, "__typename"), d = [], f, h = new Ur();
      this.config.addTypename && typeof c == "string" && !u.rootIdsByTypename[c] && d.push({ __typename: c });
      function p(b, D) {
        var S;
        return b.missing && (f = h.merge(f, (S = {}, S[D] = b.missing, S))), b.result;
      }
      var v = new Set(n.selections);
      v.forEach(function(b) {
        var D, S;
        if (Ia(b, s))
          if (jr(b)) {
            var T = u.readField({
              fieldName: b.name.value,
              field: b,
              variables: o.variables,
              from: i
            }, o), B = zr(b);
            T === void 0 ? id.added(b) || (f = h.merge(f, (D = {}, D[B] = "Can't find field '".concat(b.name.value, "' on ").concat(Ae(i) ? i.__ref + " object" : "object " + JSON.stringify(i, null, 2)), D))) : He(T) ? T.length > 0 && (T = p(r.executeSubSelectedArray({
              field: b,
              array: T,
              enclosingRef: a,
              context: o
            }), B)) : b.selectionSet ? T != null && (T = p(r.executeSelectionSet({
              selectionSet: b.selectionSet,
              objectOrReference: T,
              enclosingRef: Ae(T) ? T : a,
              context: o
            }), B)) : o.canonizeResults && (T = r.canon.pass(T)), T !== void 0 && d.push((S = {}, S[B] = T, S));
          } else {
            var y = Bs(b, o.lookupFragment);
            if (!y && b.kind === te.FRAGMENT_SPREAD)
              throw ht(9, b.name.value);
            y && u.fragmentMatches(y, c) && y.selectionSet.selections.forEach(v.add, v);
          }
      });
      var g = js(d), $ = { result: g, missing: f }, m = o.canonizeResults ? this.canon.admit($) : pa($);
      return m.result && this.knownResults.set(m.result, n), m;
    }, e.prototype.execSubSelectedArrayImpl = function(t) {
      var r = this, n = t.field, i = t.array, a = t.enclosingRef, o = t.context, s, u = new Ur();
      function l(c, d) {
        var f;
        return c.missing && (s = u.merge(s, (f = {}, f[d] = c.missing, f))), c.result;
      }
      return n.selectionSet && (i = i.filter(o.store.canRead)), i = i.map(function(c, d) {
        return c === null ? null : He(c) ? l(r.executeSubSelectedArray({
          field: n,
          array: c,
          enclosingRef: a,
          context: o
        }), d) : n.selectionSet ? l(r.executeSelectionSet({
          selectionSet: n.selectionSet,
          objectOrReference: c,
          enclosingRef: Ae(c) ? c : a,
          context: o
        }), d) : (globalThis.__DEV__ !== !1 && J2(o.store, n, c), c);
      }), {
        result: o.canonizeResults ? this.canon.admit(i) : i,
        missing: s
      };
    }, e;
  }()
);
function Y2(e) {
  try {
    JSON.stringify(e, function(t, r) {
      if (typeof r == "string")
        throw r;
      return r;
    });
  } catch (t) {
    return t;
  }
}
function J2(e, t, r) {
  if (!t.selectionSet) {
    var n = /* @__PURE__ */ new Set([r]);
    n.forEach(function(i) {
      qe(i) && (ue(
        !Ae(i),
        10,
        q2(e, i),
        t.name.value
      ), Object.values(i).forEach(n.add, n));
    });
  }
}
var cd = new Mm(), ih = /* @__PURE__ */ new WeakMap();
function ta(e) {
  var t = ih.get(e);
  return t || ih.set(e, t = {
    vars: /* @__PURE__ */ new Set(),
    dep: Qm()
  }), t;
}
function ah(e) {
  ta(e).vars.forEach(function(t) {
    return t.forgetCache(e);
  });
}
function X2(e) {
  ta(e).vars.forEach(function(t) {
    return t.attachCache(e);
  });
}
function eE(e) {
  var t = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), n = function(a) {
    if (arguments.length > 0) {
      if (e !== a) {
        e = a, t.forEach(function(u) {
          ta(u).dep.dirty(n), tE(u);
        });
        var o = Array.from(r);
        r.clear(), o.forEach(function(u) {
          return u(e);
        });
      }
    } else {
      var s = cd.getValue();
      s && (i(s), ta(s).dep(n));
    }
    return e;
  };
  n.onNextChange = function(a) {
    return r.add(a), function() {
      r.delete(a);
    };
  };
  var i = n.attachCache = function(a) {
    return t.add(a), ta(a).vars.add(n), n;
  };
  return n.forgetCache = function(a) {
    return t.delete(a);
  }, n;
}
function tE(e) {
  e.broadcastWatches && e.broadcastWatches();
}
var oh = /* @__PURE__ */ Object.create(null);
function dd(e) {
  var t = JSON.stringify(e);
  return oh[t] || (oh[t] = /* @__PURE__ */ Object.create(null));
}
function sh(e) {
  var t = dd(e);
  return t.keyFieldsFn || (t.keyFieldsFn = function(r, n) {
    var i = function(o, s) {
      return n.readField(s, o);
    }, a = n.keyObject = fd(e, function(o) {
      var s = Yn(
        n.storeObject,
        o,
        // Using context.readField to extract paths from context.storeObject
        // allows the extraction to see through Reference objects and respect
        // custom read functions.
        i
      );
      return s === void 0 && r !== n.storeObject && at.call(r, o[0]) && (s = Yn(r, o, wv)), ue(s !== void 0, 4, o.join("."), r), s;
    });
    return "".concat(n.typename, ":").concat(JSON.stringify(a));
  });
}
function uh(e) {
  var t = dd(e);
  return t.keyArgsFn || (t.keyArgsFn = function(r, n) {
    var i = n.field, a = n.variables, o = n.fieldName, s = fd(e, function(l) {
      var c = l[0], d = c.charAt(0);
      if (d === "@") {
        if (i && Mt(i.directives)) {
          var f = c.slice(1), h = i.directives.find(function($) {
            return $.name.value === f;
          }), p = h && Ms(h, a);
          return p && Yn(
            p,
            // If keyPath.length === 1, this code calls extractKeyPath with an
            // empty path, which works because it uses directiveArgs as the
            // extracted value.
            l.slice(1)
          );
        }
        return;
      }
      if (d === "$") {
        var v = c.slice(1);
        if (a && at.call(a, v)) {
          var g = l.slice(0);
          return g[0] = v, Yn(a, g);
        }
        return;
      }
      if (r)
        return Yn(r, l);
    }), u = JSON.stringify(s);
    return (r || u !== "{}") && (o += ":" + u), o;
  });
}
function fd(e, t) {
  var r = new Ur();
  return Ev(e).reduce(function(n, i) {
    var a, o = t(i);
    if (o !== void 0) {
      for (var s = i.length - 1; s >= 0; --s)
        o = (a = {}, a[i[s]] = o, a);
      n = r.merge(n, o);
    }
    return n;
  }, /* @__PURE__ */ Object.create(null));
}
function Ev(e) {
  var t = dd(e);
  if (!t.paths) {
    var r = t.paths = [], n = [];
    e.forEach(function(i, a) {
      He(i) ? (Ev(i).forEach(function(o) {
        return r.push(n.concat(o));
      }), n.length = 0) : (n.push(i), He(e[a + 1]) || (r.push(n.slice(0)), n.length = 0));
    });
  }
  return t.paths;
}
function wv(e, t) {
  return e[t];
}
function Yn(e, t, r) {
  return r = r || wv, Cv(t.reduce(function n(i, a) {
    return He(i) ? i.map(function(o) {
      return n(o, a);
    }) : i && r(i, a);
  }, e));
}
function Cv(e) {
  return qe(e) ? He(e) ? e.map(Cv) : fd(Object.keys(e).sort(), function(t) {
    return Yn(e, t);
  }) : e;
}
function Ll(e) {
  return e.args !== void 0 ? e.args : e.field ? Ms(e.field, e.variables) : null;
}
var rE = function() {
}, lh = function(e, t) {
  return t.fieldName;
}, ch = function(e, t, r) {
  var n = r.mergeObjects;
  return n(e, t);
}, dh = function(e, t) {
  return t;
}, nE = (
  /** @class */
  function() {
    function e(t) {
      this.config = t, this.typePolicies = /* @__PURE__ */ Object.create(null), this.toBeAdded = /* @__PURE__ */ Object.create(null), this.supertypeMap = /* @__PURE__ */ new Map(), this.fuzzySubtypes = /* @__PURE__ */ new Map(), this.rootIdsByTypename = /* @__PURE__ */ Object.create(null), this.rootTypenamesById = /* @__PURE__ */ Object.create(null), this.usingPossibleTypes = !1, this.config = M({ dataIdFromObject: yv }, t), this.cache = this.config.cache, this.setRootTypename("Query"), this.setRootTypename("Mutation"), this.setRootTypename("Subscription"), t.possibleTypes && this.addPossibleTypes(t.possibleTypes), t.typePolicies && this.addTypePolicies(t.typePolicies);
    }
    return e.prototype.identify = function(t, r) {
      var n, i = this, a = r && (r.typename || ((n = r.storeObject) === null || n === void 0 ? void 0 : n.__typename)) || t.__typename;
      if (a === this.rootTypenamesById.ROOT_QUERY)
        return ["ROOT_QUERY"];
      for (var o = r && r.storeObject || t, s = M(M({}, r), { typename: a, storeObject: o, readField: r && r.readField || function() {
        var f = hd(arguments, o);
        return i.readField(f, {
          store: i.cache.data,
          variables: f.variables
        });
      } }), u, l = a && this.getTypePolicy(a), c = l && l.keyFn || this.config.dataIdFromObject; c; ) {
        var d = c(M(M({}, t), o), s);
        if (He(d))
          c = sh(d);
        else {
          u = d;
          break;
        }
      }
      return u = u ? String(u) : void 0, s.keyObject ? [u, s.keyObject] : [u];
    }, e.prototype.addTypePolicies = function(t) {
      var r = this;
      Object.keys(t).forEach(function(n) {
        var i = t[n], a = i.queryType, o = i.mutationType, s = i.subscriptionType, u = Kt(i, ["queryType", "mutationType", "subscriptionType"]);
        a && r.setRootTypename("Query", n), o && r.setRootTypename("Mutation", n), s && r.setRootTypename("Subscription", n), at.call(r.toBeAdded, n) ? r.toBeAdded[n].push(u) : r.toBeAdded[n] = [u];
      });
    }, e.prototype.updateTypePolicy = function(t, r) {
      var n = this, i = this.getTypePolicy(t), a = r.keyFields, o = r.fields;
      function s(u, l) {
        u.merge = typeof l == "function" ? l : l === !0 ? ch : l === !1 ? dh : u.merge;
      }
      s(i, r.merge), i.keyFn = // Pass false to disable normalization for this typename.
      a === !1 ? rE : He(a) ? sh(a) : typeof a == "function" ? a : i.keyFn, o && Object.keys(o).forEach(function(u) {
        var l = n.getFieldPolicy(t, u, !0), c = o[u];
        if (typeof c == "function")
          l.read = c;
        else {
          var d = c.keyArgs, f = c.read, h = c.merge;
          l.keyFn = // Pass false to disable argument-based differentiation of
          // field identities.
          d === !1 ? lh : He(d) ? uh(d) : typeof d == "function" ? d : l.keyFn, typeof f == "function" && (l.read = f), s(l, h);
        }
        l.read && l.merge && (l.keyFn = l.keyFn || lh);
      });
    }, e.prototype.setRootTypename = function(t, r) {
      r === void 0 && (r = t);
      var n = "ROOT_" + t.toUpperCase(), i = this.rootTypenamesById[n];
      r !== i && (ue(!i || i === t, 5, t), i && delete this.rootIdsByTypename[i], this.rootIdsByTypename[r] = n, this.rootTypenamesById[n] = r);
    }, e.prototype.addPossibleTypes = function(t) {
      var r = this;
      this.usingPossibleTypes = !0, Object.keys(t).forEach(function(n) {
        r.getSupertypeSet(n, !0), t[n].forEach(function(i) {
          r.getSupertypeSet(i, !0).add(n);
          var a = i.match($v);
          (!a || a[0] !== i) && r.fuzzySubtypes.set(i, new RegExp(i));
        });
      });
    }, e.prototype.getTypePolicy = function(t) {
      var r = this;
      if (!at.call(this.typePolicies, t)) {
        var n = this.typePolicies[t] = /* @__PURE__ */ Object.create(null);
        n.fields = /* @__PURE__ */ Object.create(null);
        var i = this.supertypeMap.get(t);
        !i && this.fuzzySubtypes.size && (i = this.getSupertypeSet(t, !0), this.fuzzySubtypes.forEach(function(o, s) {
          if (o.test(t)) {
            var u = r.supertypeMap.get(s);
            u && u.forEach(function(l) {
              return i.add(l);
            });
          }
        })), i && i.size && i.forEach(function(o) {
          var s = r.getTypePolicy(o), u = s.fields, l = Kt(s, ["fields"]);
          Object.assign(n, l), Object.assign(n.fields, u);
        });
      }
      var a = this.toBeAdded[t];
      return a && a.length && a.splice(0).forEach(function(o) {
        r.updateTypePolicy(t, o);
      }), this.typePolicies[t];
    }, e.prototype.getFieldPolicy = function(t, r, n) {
      if (t) {
        var i = this.getTypePolicy(t).fields;
        return i[r] || n && (i[r] = /* @__PURE__ */ Object.create(null));
      }
    }, e.prototype.getSupertypeSet = function(t, r) {
      var n = this.supertypeMap.get(t);
      return !n && r && this.supertypeMap.set(t, n = /* @__PURE__ */ new Set()), n;
    }, e.prototype.fragmentMatches = function(t, r, n, i) {
      var a = this;
      if (!t.typeCondition)
        return !0;
      if (!r)
        return !1;
      var o = t.typeCondition.name.value;
      if (r === o)
        return !0;
      if (this.usingPossibleTypes && this.supertypeMap.has(o))
        for (var s = this.getSupertypeSet(r, !0), u = [s], l = function(p) {
          var v = a.getSupertypeSet(p, !1);
          v && v.size && u.indexOf(v) < 0 && u.push(v);
        }, c = !!(n && this.fuzzySubtypes.size), d = !1, f = 0; f < u.length; ++f) {
          var h = u[f];
          if (h.has(o))
            return s.has(o) || (d && globalThis.__DEV__ !== !1 && ue.warn(6, r, o), s.add(o)), !0;
          h.forEach(l), c && // Start checking fuzzy subtypes only after exhausting all
          // non-fuzzy subtypes (after the final iteration of the loop).
          f === u.length - 1 && // We could wait to compare fragment.selectionSet to result
          // after we verify the supertype, but this check is often less
          // expensive than that search, and we will have to do the
          // comparison anyway whenever we find a potential match.
          Nl(t.selectionSet, n, i) && (c = !1, d = !0, this.fuzzySubtypes.forEach(function(p, v) {
            var g = r.match(p);
            g && g[0] === r && l(v);
          }));
        }
      return !1;
    }, e.prototype.hasKeyArgs = function(t, r) {
      var n = this.getFieldPolicy(t, r, !1);
      return !!(n && n.keyFn);
    }, e.prototype.getStoreFieldName = function(t) {
      var r = t.typename, n = t.fieldName, i = this.getFieldPolicy(r, n, !1), a, o = i && i.keyFn;
      if (o && r)
        for (var s = {
          typename: r,
          fieldName: n,
          field: t.field || null,
          variables: t.variables
        }, u = Ll(t); o; ) {
          var l = o(u, s);
          if (He(l))
            o = uh(l);
          else {
            a = l || n;
            break;
          }
        }
      return a === void 0 && (a = t.field ? D5(t.field, t.variables) : Rm(n, Ll(t))), a === !1 ? n : n === qr(a) ? a : n + ":" + a;
    }, e.prototype.readField = function(t, r) {
      var n = t.from;
      if (n) {
        var i = t.field || t.fieldName;
        if (i) {
          if (t.typename === void 0) {
            var a = r.store.getFieldValue(n, "__typename");
            a && (t.typename = a);
          }
          var o = this.getStoreFieldName(t), s = qr(o), u = r.store.getFieldValue(n, o), l = this.getFieldPolicy(t.typename, s, !1), c = l && l.read;
          if (c) {
            var d = fh(this, n, t, r, r.store.getStorage(Ae(n) ? n.__ref : n, o));
            return cd.withValue(this.cache, c, [
              u,
              d
            ]);
          }
          return u;
        }
      }
    }, e.prototype.getReadFunction = function(t, r) {
      var n = this.getFieldPolicy(t, r, !1);
      return n && n.read;
    }, e.prototype.getMergeFunction = function(t, r, n) {
      var i = this.getFieldPolicy(t, r, !1), a = i && i.merge;
      return !a && n && (i = this.getTypePolicy(n), a = i && i.merge), a;
    }, e.prototype.runMergeFunction = function(t, r, n, i, a) {
      var o = n.field, s = n.typename, u = n.merge;
      return u === ch ? Sv(i.store)(t, r) : u === dh ? r : (i.overwrite && (t = void 0), u(t, r, fh(
        this,
        // Unlike options.readField for read functions, we do not fall
        // back to the current object if no foreignObjOrRef is provided,
        // because it's not clear what the current object should be for
        // merge functions: the (possibly undefined) existing object, or
        // the incoming object? If you think your merge function needs
        // to read sibling fields in order to produce a new value for
        // the current field, you might want to rethink your strategy,
        // because that's a recipe for making merge behavior sensitive
        // to the order in which fields are written into the cache.
        // However, readField(name, ref) is useful for merge functions
        // that need to deduplicate child objects and references.
        void 0,
        {
          typename: s,
          fieldName: o.name.value,
          field: o,
          variables: i.variables
        },
        i,
        a || /* @__PURE__ */ Object.create(null)
      )));
    }, e;
  }()
);
function fh(e, t, r, n, i) {
  var a = e.getStoreFieldName(r), o = qr(a), s = r.variables || n.variables, u = n.store, l = u.toReference, c = u.canRead;
  return {
    args: Ll(r),
    field: r.field || null,
    fieldName: o,
    storeFieldName: a,
    variables: s,
    isReference: Ae,
    toReference: l,
    storage: i,
    cache: e.cache,
    canRead: c,
    readField: function() {
      return e.readField(hd(arguments, t, s), n);
    },
    mergeObjects: Sv(n.store)
  };
}
function hd(e, t, r) {
  var n = e[0], i = e[1], a = e.length, o;
  return typeof n == "string" ? o = {
    fieldName: n,
    // Default to objectOrReference only when no second argument was
    // passed for the from parameter, not when undefined is explicitly
    // passed as the second argument.
    from: a > 1 ? i : t
  } : (o = M({}, n), at.call(o, "from") || (o.from = t)), globalThis.__DEV__ !== !1 && o.from === void 0 && globalThis.__DEV__ !== !1 && ue.warn(7, vm(Array.from(e))), o.variables === void 0 && (o.variables = r), o;
}
function Sv(e) {
  return function(r, n) {
    if (He(r) || He(n))
      throw ht(8);
    if (qe(r) && qe(n)) {
      var i = e.getFieldValue(r, "__typename"), a = e.getFieldValue(n, "__typename"), o = i && a && i !== a;
      if (o)
        return n;
      if (Ae(r) && jn(n))
        return e.merge(r.__ref, n), r;
      if (jn(r) && Ae(n))
        return e.merge(r, n.__ref), n;
      if (jn(r) && jn(n))
        return M(M({}, r), n);
    }
    return n;
  };
}
function Ou(e, t, r) {
  var n = "".concat(t).concat(r), i = e.flavors.get(n);
  return i || e.flavors.set(n, i = e.clientOnly === t && e.deferred === r ? e : M(M({}, e), { clientOnly: t, deferred: r })), i;
}
var iE = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.cache = t, this.reader = r, this.fragments = n;
    }
    return e.prototype.writeToStore = function(t, r) {
      var n = this, i = r.query, a = r.result, o = r.dataId, s = r.variables, u = r.overwrite, l = Ba(i), c = H2();
      s = M(M({}, Xc(l)), s);
      var d = M(M({ store: t, written: /* @__PURE__ */ Object.create(null), merge: function(h, p) {
        return c.merge(h, p);
      }, variables: s, varString: Vr(s) }, xv(i, this.fragments)), { overwrite: !!u, incomingById: /* @__PURE__ */ new Map(), clientOnly: !1, deferred: !1, flavors: /* @__PURE__ */ new Map() }), f = this.processSelectionSet({
        result: a || /* @__PURE__ */ Object.create(null),
        dataId: o,
        selectionSet: l.selectionSet,
        mergeTree: { map: /* @__PURE__ */ new Map() },
        context: d
      });
      if (!Ae(f))
        throw ht(11, a);
      return d.incomingById.forEach(function(h, p) {
        var v = h.storeObject, g = h.mergeTree, $ = h.fieldNodeSet, m = Gn(p);
        if (g && g.map.size) {
          var b = n.applyMerges(g, m, v, d);
          if (Ae(b))
            return;
          v = b;
        }
        if (globalThis.__DEV__ !== !1 && !d.overwrite) {
          var D = /* @__PURE__ */ Object.create(null);
          $.forEach(function(B) {
            B.selectionSet && (D[B.name.value] = !0);
          });
          var S = function(B) {
            return D[qr(B)] === !0;
          }, T = function(B) {
            var y = g && g.map.get(B);
            return !!(y && y.info && y.info.merge);
          };
          Object.keys(v).forEach(function(B) {
            S(B) && !T(B) && aE(m, v, B, d.store);
          });
        }
        t.merge(p, v);
      }), t.retain(f.__ref), f;
    }, e.prototype.processSelectionSet = function(t) {
      var r = this, n = t.dataId, i = t.result, a = t.selectionSet, o = t.context, s = t.mergeTree, u = this.cache.policies, l = /* @__PURE__ */ Object.create(null), c = n && u.rootTypenamesById[n] || Tl(i, a, o.fragmentMap) || n && o.store.get(n, "__typename");
      typeof c == "string" && (l.__typename = c);
      var d = function() {
        var b = hd(arguments, l, o.variables);
        if (Ae(b.from)) {
          var D = o.incomingById.get(b.from.__ref);
          if (D) {
            var S = u.readField(M(M({}, b), { from: D.storeObject }), o);
            if (S !== void 0)
              return S;
          }
        }
        return u.readField(b, o);
      }, f = /* @__PURE__ */ new Set();
      this.flattenFields(
        a,
        i,
        // This WriteContext will be the default context value for fields returned
        // by the flattenFields method, but some fields may be assigned a modified
        // context, depending on the presence of @client and other directives.
        o,
        c
      ).forEach(function(b, D) {
        var S, T = zr(D), B = i[T];
        if (f.add(D), B !== void 0) {
          var y = u.getStoreFieldName({
            typename: c,
            fieldName: D.name.value,
            field: D,
            variables: b.variables
          }), _ = hh(s, y), w = r.processFieldValue(
            B,
            D,
            // Reset context.clientOnly and context.deferred to their default
            // values before processing nested selection sets.
            D.selectionSet ? Ou(b, !1, !1) : b,
            _
          ), E = void 0;
          D.selectionSet && (Ae(w) || jn(w)) && (E = d("__typename", w));
          var k = u.getMergeFunction(c, D.name.value, E);
          k ? _.info = {
            // TODO Check compatibility against any existing childTree.field?
            field: D,
            typename: c,
            merge: k
          } : ph(s, y), l = b.merge(l, (S = {}, S[y] = w, S));
        } else globalThis.__DEV__ !== !1 && !b.clientOnly && !b.deferred && !id.added(D) && // If the field has a read function, it may be a synthetic field or
        // provide a default value, so its absence from the written data should
        // not be cause for alarm.
        !u.getReadFunction(c, D.name.value) && globalThis.__DEV__ !== !1 && ue.error(12, zr(D), i);
      });
      try {
        var h = u.identify(i, {
          typename: c,
          selectionSet: a,
          fragmentMap: o.fragmentMap,
          storeObject: l,
          readField: d
        }), p = h[0], v = h[1];
        n = n || p, v && (l = o.merge(l, v));
      } catch (b) {
        if (!n)
          throw b;
      }
      if (typeof n == "string") {
        var g = Gn(n), $ = o.written[n] || (o.written[n] = []);
        if ($.indexOf(a) >= 0 || ($.push(a), this.reader && this.reader.isFresh(i, g, a, o)))
          return g;
        var m = o.incomingById.get(n);
        return m ? (m.storeObject = o.merge(m.storeObject, l), m.mergeTree = Vl(m.mergeTree, s), f.forEach(function(b) {
          return m.fieldNodeSet.add(b);
        })) : o.incomingById.set(n, {
          storeObject: l,
          // Save a reference to mergeTree only if it is not empty, because
          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and
          // reused for entirely different parts of the result tree.
          mergeTree: Ko(s) ? void 0 : s,
          fieldNodeSet: f
        }), g;
      }
      return l;
    }, e.prototype.processFieldValue = function(t, r, n, i) {
      var a = this;
      return !r.selectionSet || t === null ? globalThis.__DEV__ !== !1 ? rv(t) : t : He(t) ? t.map(function(o, s) {
        var u = a.processFieldValue(o, r, n, hh(i, s));
        return ph(i, s), u;
      }) : this.processSelectionSet({
        result: t,
        selectionSet: r.selectionSet,
        context: n,
        mergeTree: i
      });
    }, e.prototype.flattenFields = function(t, r, n, i) {
      i === void 0 && (i = Tl(r, t, n.fragmentMap));
      var a = /* @__PURE__ */ new Map(), o = this.cache.policies, s = new bi(!1);
      return function u(l, c) {
        var d = s.lookup(
          l,
          // Because we take inheritedClientOnly and inheritedDeferred into
          // consideration here (in addition to selectionSet), it's possible for
          // the same selection set to be flattened more than once, if it appears
          // in the query with different @client and/or @directive configurations.
          c.clientOnly,
          c.deferred
        );
        d.visited || (d.visited = !0, l.selections.forEach(function(f) {
          if (Ia(f, n.variables)) {
            var h = c.clientOnly, p = c.deferred;
            if (
              // Since the presence of @client or @defer on this field can only
              // cause clientOnly or deferred to become true, we can skip the
              // forEach loop if both clientOnly and deferred are already true.
              !(h && p) && Mt(f.directives) && f.directives.forEach(function($) {
                var m = $.name.value;
                if (m === "client" && (h = !0), m === "defer") {
                  var b = Ms($, n.variables);
                  (!b || b.if !== !1) && (p = !0);
                }
              }), jr(f)
            ) {
              var v = a.get(f);
              v && (h = h && v.clientOnly, p = p && v.deferred), a.set(f, Ou(n, h, p));
            } else {
              var g = Bs(f, n.lookupFragment);
              if (!g && f.kind === te.FRAGMENT_SPREAD)
                throw ht(13, f.name.value);
              g && o.fragmentMatches(g, i, r, n.variables) && u(g.selectionSet, Ou(n, h, p));
            }
          }
        }));
      }(t, n), a;
    }, e.prototype.applyMerges = function(t, r, n, i, a) {
      var o, s = this;
      if (t.map.size && !Ae(n)) {
        var u = (
          // Items in the same position in different arrays are not
          // necessarily related to each other, so when incoming is an array
          // we process its elements as if there was no existing data.
          !He(n) && // Likewise, existing must be either a Reference or a StoreObject
          // in order for its fields to be safe to merge with the fields of
          // the incoming object.
          (Ae(r) || jn(r)) ? r : void 0
        ), l = n;
        u && !a && (a = [Ae(u) ? u.__ref : u]);
        var c, d = function(f, h) {
          return He(f) ? typeof h == "number" ? f[h] : void 0 : i.store.getFieldValue(f, String(h));
        };
        t.map.forEach(function(f, h) {
          var p = d(u, h), v = d(l, h);
          if (v !== void 0) {
            a && a.push(h);
            var g = s.applyMerges(f, p, v, i, a);
            g !== v && (c = c || /* @__PURE__ */ new Map(), c.set(h, g)), a && ue(a.pop() === h);
          }
        }), c && (n = He(l) ? l.slice(0) : M({}, l), c.forEach(function(f, h) {
          n[h] = f;
        }));
      }
      return t.info ? this.cache.policies.runMergeFunction(r, n, t.info, i, a && (o = i.store).getStorage.apply(o, a)) : n;
    }, e;
  }()
), kv = [];
function hh(e, t) {
  var r = e.map;
  return r.has(t) || r.set(t, kv.pop() || { map: /* @__PURE__ */ new Map() }), r.get(t);
}
function Vl(e, t) {
  if (e === t || !t || Ko(t))
    return e;
  if (!e || Ko(e))
    return t;
  var r = e.info && t.info ? M(M({}, e.info), t.info) : e.info || t.info, n = e.map.size && t.map.size, i = n ? /* @__PURE__ */ new Map() : e.map.size ? e.map : t.map, a = { info: r, map: i };
  if (n) {
    var o = new Set(t.map.keys());
    e.map.forEach(function(s, u) {
      a.map.set(u, Vl(s, t.map.get(u))), o.delete(u);
    }), o.forEach(function(s) {
      a.map.set(s, Vl(t.map.get(s), e.map.get(s)));
    });
  }
  return a;
}
function Ko(e) {
  return !e || !(e.info || e.map.size);
}
function ph(e, t) {
  var r = e.map, n = r.get(t);
  n && Ko(n) && (kv.push(n), r.delete(t));
}
var mh = /* @__PURE__ */ new Set();
function aE(e, t, r, n) {
  var i = function(d) {
    var f = n.getFieldValue(d, r);
    return typeof f == "object" && f;
  }, a = i(e);
  if (a) {
    var o = i(t);
    if (o && !Ae(a) && !Te(a, o) && !Object.keys(a).every(function(d) {
      return n.getFieldValue(o, d) !== void 0;
    })) {
      var s = n.getFieldValue(e, "__typename") || n.getFieldValue(t, "__typename"), u = qr(r), l = "".concat(s, ".").concat(u);
      if (!mh.has(l)) {
        mh.add(l);
        var c = [];
        !He(a) && !He(o) && [a, o].forEach(function(d) {
          var f = n.getFieldValue(d, "__typename");
          typeof f == "string" && !c.includes(f) && c.push(f);
        }), globalThis.__DEV__ !== !1 && ue.warn(14, u, s, c.length ? "either ensure all objects of type " + c.join(" and ") + " have an ID or a custom merge function, or " : "", l, M({}, a), M({}, o));
      }
    }
  }
}
var pd = (
  /** @class */
  function(e) {
    Ut(t, e);
    function t(r) {
      r === void 0 && (r = {});
      var n = e.call(this) || this;
      return n.watches = /* @__PURE__ */ new Set(), n.addTypenameTransform = new Gm(id), n.assumeImmutableResults = !0, n.makeVar = eE, n.txCount = 0, n.config = U2(r), n.addTypename = !!n.config.addTypename, n.policies = new nE({
        cache: n,
        dataIdFromObject: n.config.dataIdFromObject,
        possibleTypes: n.config.possibleTypes,
        typePolicies: n.config.typePolicies
      }), n.init(), n;
    }
    return t.prototype.init = function() {
      var r = this.data = new va.Root({
        policies: this.policies,
        resultCaching: this.config.resultCaching
      });
      this.optimisticData = r.stump, this.resetResultCache();
    }, t.prototype.resetResultCache = function(r) {
      var n = this, i = this.storeReader, a = this.config.fragments;
      this.storeWriter = new iE(this, this.storeReader = new Z2({
        cache: this,
        addTypename: this.addTypename,
        resultCacheMaxSize: this.config.resultCacheMaxSize,
        canonizeResults: bv(this.config),
        canon: r ? void 0 : i && i.canon,
        fragments: a
      }), a), this.maybeBroadcastWatch = ha(function(o, s) {
        return n.broadcastWatch(o, s);
      }, {
        max: this.config.resultCacheMaxSize || Xt["inMemoryCache.maybeBroadcastWatch"] || 5e3,
        makeCacheKey: function(o) {
          var s = o.optimistic ? n.optimisticData : n.data;
          if (ea(s)) {
            var u = o.optimistic, l = o.id, c = o.variables;
            return s.makeCacheKey(
              o.query,
              // Different watches can have the same query, optimistic
              // status, rootId, and variables, but if their callbacks are
              // different, the (identical) result needs to be delivered to
              // each distinct callback. The easiest way to achieve that
              // separation is to include c.callback in the cache key for
              // maybeBroadcastWatch calls. See issue #5733.
              o.callback,
              Vr({ optimistic: u, id: l, variables: c })
            );
          }
        }
      }), (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(o) {
        return o.resetCaching();
      });
    }, t.prototype.restore = function(r) {
      return this.init(), r && this.data.replace(r), this;
    }, t.prototype.extract = function(r) {
      return r === void 0 && (r = !1), (r ? this.optimisticData : this.data).extract();
    }, t.prototype.read = function(r) {
      var n = r.returnPartialData, i = n === void 0 ? !1 : n;
      try {
        return this.storeReader.diffQueryAgainstStore(M(M({}, r), { store: r.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData: i })).result || null;
      } catch (a) {
        if (a instanceof vv)
          return null;
        throw a;
      }
    }, t.prototype.write = function(r) {
      try {
        return ++this.txCount, this.storeWriter.writeToStore(this.data, r);
      } finally {
        !--this.txCount && r.broadcast !== !1 && this.broadcastWatches();
      }
    }, t.prototype.modify = function(r) {
      if (at.call(r, "id") && !r.id)
        return !1;
      var n = r.optimistic ? this.optimisticData : this.data;
      try {
        return ++this.txCount, n.modify(r.id || "ROOT_QUERY", r.fields);
      } finally {
        !--this.txCount && r.broadcast !== !1 && this.broadcastWatches();
      }
    }, t.prototype.diff = function(r) {
      return this.storeReader.diffQueryAgainstStore(M(M({}, r), { store: r.optimistic ? this.optimisticData : this.data, rootId: r.id || "ROOT_QUERY", config: this.config }));
    }, t.prototype.watch = function(r) {
      var n = this;
      return this.watches.size || X2(this), this.watches.add(r), r.immediate && this.maybeBroadcastWatch(r), function() {
        n.watches.delete(r) && !n.watches.size && ah(n), n.maybeBroadcastWatch.forget(r);
      };
    }, t.prototype.gc = function(r) {
      var n;
      Vr.reset(), zs.reset(), this.addTypenameTransform.resetCache(), (n = this.config.fragments) === null || n === void 0 || n.resetCaches();
      var i = this.optimisticData.gc();
      return r && !this.txCount && (r.resetResultCache ? this.resetResultCache(r.resetResultIdentities) : r.resetResultIdentities && this.storeReader.resetCanon()), i;
    }, t.prototype.retain = function(r, n) {
      return (n ? this.optimisticData : this.data).retain(r);
    }, t.prototype.release = function(r, n) {
      return (n ? this.optimisticData : this.data).release(r);
    }, t.prototype.identify = function(r) {
      if (Ae(r))
        return r.__ref;
      try {
        return this.policies.identify(r)[0];
      } catch (n) {
        globalThis.__DEV__ !== !1 && ue.warn(n);
      }
    }, t.prototype.evict = function(r) {
      if (!r.id) {
        if (at.call(r, "id"))
          return !1;
        r = M(M({}, r), { id: "ROOT_QUERY" });
      }
      try {
        return ++this.txCount, this.optimisticData.evict(r, this.data);
      } finally {
        !--this.txCount && r.broadcast !== !1 && this.broadcastWatches();
      }
    }, t.prototype.reset = function(r) {
      var n = this;
      return this.init(), Vr.reset(), r && r.discardWatches ? (this.watches.forEach(function(i) {
        return n.maybeBroadcastWatch.forget(i);
      }), this.watches.clear(), ah(this)) : this.broadcastWatches(), Promise.resolve();
    }, t.prototype.removeOptimistic = function(r) {
      var n = this.optimisticData.removeLayer(r);
      n !== this.optimisticData && (this.optimisticData = n, this.broadcastWatches());
    }, t.prototype.batch = function(r) {
      var n = this, i = r.update, a = r.optimistic, o = a === void 0 ? !0 : a, s = r.removeOptimistic, u = r.onWatchUpdated, l, c = function(f) {
        var h = n, p = h.data, v = h.optimisticData;
        ++n.txCount, f && (n.data = n.optimisticData = f);
        try {
          return l = i(n);
        } finally {
          --n.txCount, n.data = p, n.optimisticData = v;
        }
      }, d = /* @__PURE__ */ new Set();
      return u && !this.txCount && this.broadcastWatches(M(M({}, r), { onWatchUpdated: function(f) {
        return d.add(f), !1;
      } })), typeof o == "string" ? this.optimisticData = this.optimisticData.addLayer(o, c) : o === !1 ? c(this.data) : c(), typeof s == "string" && (this.optimisticData = this.optimisticData.removeLayer(s)), u && d.size ? (this.broadcastWatches(M(M({}, r), { onWatchUpdated: function(f, h) {
        var p = u.call(this, f, h);
        return p !== !1 && d.delete(f), p;
      } })), d.size && d.forEach(function(f) {
        return n.maybeBroadcastWatch.dirty(f);
      })) : this.broadcastWatches(r), l;
    }, t.prototype.performTransaction = function(r, n) {
      return this.batch({
        update: r,
        optimistic: n || n !== null
      });
    }, t.prototype.transformDocument = function(r) {
      return this.addTypenameToDocument(this.addFragmentsToDocument(r));
    }, t.prototype.broadcastWatches = function(r) {
      var n = this;
      this.txCount || this.watches.forEach(function(i) {
        return n.maybeBroadcastWatch(i, r);
      });
    }, t.prototype.addFragmentsToDocument = function(r) {
      var n = this.config.fragments;
      return n ? n.transform(r) : r;
    }, t.prototype.addTypenameToDocument = function(r) {
      return this.addTypename ? this.addTypenameTransform.transformDocument(r) : r;
    }, t.prototype.broadcastWatch = function(r, n) {
      var i = r.lastDiff, a = this.diff(r);
      n && (r.optimistic && typeof n.optimistic == "string" && (a.fromOptimisticTransaction = !0), n.onWatchUpdated && n.onWatchUpdated.call(this, r, a, i) === !1) || (!i || !Te(i.result, a.result)) && r.callback(r.lastDiff = a, i);
    }, t;
  }(mv)
);
globalThis.__DEV__ !== !1 && (pd.prototype.getMemoryInternals = i5);
var Ce;
(function(e) {
  e[e.loading = 1] = "loading", e[e.setVariables = 2] = "setVariables", e[e.fetchMore = 3] = "fetchMore", e[e.refetch = 4] = "refetch", e[e.poll = 6] = "poll", e[e.ready = 7] = "ready", e[e.error = 8] = "error";
})(Ce || (Ce = {}));
function ya(e) {
  return e ? e < 7 : !1;
}
var vh = Object.assign, oE = Object.hasOwnProperty, zl = (
  /** @class */
  function(e) {
    Ut(t, e);
    function t(r) {
      var n = r.queryManager, i = r.queryInfo, a = r.options, o = e.call(this, function(g) {
        try {
          var $ = g._subscription._observer;
          $ && !$.error && ($.error = sE);
        } catch {
        }
        var m = !o.observers.size;
        o.observers.add(g);
        var b = o.last;
        return b && b.error ? g.error && g.error(b.error) : b && b.result && g.next && g.next(b.result), m && o.reobserve().catch(function() {
        }), function() {
          o.observers.delete(g) && !o.observers.size && o.tearDownQuery();
        };
      }) || this;
      o.observers = /* @__PURE__ */ new Set(), o.subscriptions = /* @__PURE__ */ new Set(), o.queryInfo = i, o.queryManager = n, o.waitForOwnResult = Iu(a.fetchPolicy), o.isTornDown = !1;
      var s = n.defaultOptions.watchQuery, u = s === void 0 ? {} : s, l = u.fetchPolicy, c = l === void 0 ? "cache-first" : l, d = a.fetchPolicy, f = d === void 0 ? c : d, h = a.initialFetchPolicy, p = h === void 0 ? f === "standby" ? c : f : h;
      o.options = M(M({}, a), {
        // Remember the initial options.fetchPolicy so we can revert back to this
        // policy when variables change. This information can also be specified
        // (or overridden) by providing options.initialFetchPolicy explicitly.
        initialFetchPolicy: p,
        // This ensures this.options.fetchPolicy always has a string value, in
        // case options.fetchPolicy was not provided.
        fetchPolicy: f
      }), o.queryId = i.queryId || n.generateQueryId();
      var v = Ba(o.query);
      return o.queryName = v && v.name && v.name.value, o;
    }
    return Object.defineProperty(t.prototype, "query", {
      // The `query` computed property will always reflect the document transformed
      // by the last run query. `this.options.query` will always reflect the raw
      // untransformed query to ensure document transforms with runtime conditionals
      // are run on the original document.
      get: function() {
        return this.lastQuery || this.options.query;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "variables", {
      // Computed shorthand for this.options.variables, preserved for
      // backwards compatibility.
      /**
       * An object containing the variables that were provided for the query.
       */
      get: function() {
        return this.options.variables;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.result = function() {
      var r = this;
      return new Promise(function(n, i) {
        var a = {
          next: function(s) {
            n(s), r.observers.delete(a), r.observers.size || r.queryManager.removeQuery(r.queryId), setTimeout(function() {
              o.unsubscribe();
            }, 0);
          },
          error: i
        }, o = r.subscribe(a);
      });
    }, t.prototype.resetDiff = function() {
      this.queryInfo.resetDiff();
    }, t.prototype.getCurrentResult = function(r) {
      r === void 0 && (r = !0);
      var n = this.getLastResult(!0), i = this.queryInfo.networkStatus || n && n.networkStatus || Ce.ready, a = M(M({}, n), { loading: ya(i), networkStatus: i }), o = this.options.fetchPolicy, s = o === void 0 ? "cache-first" : o;
      if (
        // These fetch policies should never deliver data from the cache, unless
        // redelivering a previously delivered result.
        !(Iu(s) || // If this.options.query has @client(always: true) fields, we cannot
        // trust diff.result, since it was read from the cache without running
        // local resolvers (and it's too late to run resolvers now, since we must
        // return a result synchronously).
        this.queryManager.getDocumentInfo(this.query).hasForcedResolvers)
      ) if (this.waitForOwnResult)
        this.queryInfo.updateWatch();
      else {
        var u = this.queryInfo.getDiff();
        (u.complete || this.options.returnPartialData) && (a.data = u.result), Te(a.data, {}) && (a.data = void 0), u.complete ? (delete a.partial, u.complete && a.networkStatus === Ce.loading && (s === "cache-first" || s === "cache-only") && (a.networkStatus = Ce.ready, a.loading = !1)) : a.partial = !0, globalThis.__DEV__ !== !1 && !u.complete && !this.options.partialRefetch && !a.loading && !a.data && !a.error && Tv(u.missing);
      }
      return r && this.updateLastResult(a), a;
    }, t.prototype.isDifferentFromLastResult = function(r, n) {
      if (!this.last)
        return !0;
      var i = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ? !pv(this.query, this.last.result, r, this.variables) : !Te(this.last.result, r);
      return i || n && !Te(this.last.variables, n);
    }, t.prototype.getLast = function(r, n) {
      var i = this.last;
      if (i && i[r] && (!n || Te(i.variables, this.variables)))
        return i[r];
    }, t.prototype.getLastResult = function(r) {
      return this.getLast("result", r);
    }, t.prototype.getLastError = function(r) {
      return this.getLast("error", r);
    }, t.prototype.resetLastResults = function() {
      delete this.last, this.isTornDown = !1;
    }, t.prototype.resetQueryStoreErrors = function() {
      this.queryManager.resetErrors(this.queryId);
    }, t.prototype.refetch = function(r) {
      var n, i = {
        // Always disable polling for refetches.
        pollInterval: 0
      }, a = this.options.fetchPolicy;
      if (a === "cache-and-network" ? i.fetchPolicy = a : a === "no-cache" ? i.fetchPolicy = "no-cache" : i.fetchPolicy = "network-only", globalThis.__DEV__ !== !1 && r && oE.call(r, "variables")) {
        var o = Bm(this.query), s = o.variableDefinitions;
        (!s || !s.some(function(u) {
          return u.variable.name.value === "variables";
        })) && globalThis.__DEV__ !== !1 && ue.warn(
          20,
          r,
          ((n = o.name) === null || n === void 0 ? void 0 : n.value) || o
        );
      }
      return r && !Te(this.options.variables, r) && (i.variables = this.options.variables = M(M({}, this.options.variables), r)), this.queryInfo.resetLastWrite(), this.reobserve(i, Ce.refetch);
    }, t.prototype.fetchMore = function(r) {
      var n = this, i = M(M({}, r.query ? r : M(M(M(M({}, this.options), { query: this.options.query }), r), { variables: M(M({}, this.options.variables), r.variables) })), {
        // The fetchMore request goes immediately to the network and does
        // not automatically write its result to the cache (hence no-cache
        // instead of network-only), because we allow the caller of
        // fetchMore to provide an updateQuery callback that determines how
        // the data gets written to the cache.
        fetchPolicy: "no-cache"
      });
      i.query = this.transformDocument(i.query);
      var a = this.queryManager.generateQueryId();
      this.lastQuery = r.query ? this.transformDocument(this.options.query) : i.query;
      var o = this.queryInfo, s = o.networkStatus;
      o.networkStatus = Ce.fetchMore, i.notifyOnNetworkStatusChange && this.observe();
      var u = /* @__PURE__ */ new Set();
      return this.queryManager.fetchQuery(a, i, Ce.fetchMore).then(function(l) {
        return n.queryManager.removeQuery(a), o.networkStatus === Ce.fetchMore && (o.networkStatus = s), n.queryManager.cache.batch({
          update: function(c) {
            var d = r.updateQuery;
            d ? c.updateQuery({
              query: n.query,
              variables: n.variables,
              returnPartialData: !0,
              optimistic: !1
            }, function(f) {
              return d(f, {
                fetchMoreResult: l.data,
                variables: i.variables
              });
            }) : c.writeQuery({
              query: i.query,
              variables: i.variables,
              data: l.data
            });
          },
          onWatchUpdated: function(c) {
            u.add(c.query);
          }
        }), l;
      }).finally(function() {
        u.has(n.query) || Pv(n);
      });
    }, t.prototype.subscribeToMore = function(r) {
      var n = this, i = this.queryManager.startGraphQLSubscription({
        query: r.document,
        variables: r.variables,
        context: r.context
      }).subscribe({
        next: function(a) {
          var o = r.updateQuery;
          o && n.updateQuery(function(s, u) {
            var l = u.variables;
            return o(s, {
              subscriptionData: a,
              variables: l
            });
          });
        },
        error: function(a) {
          if (r.onError) {
            r.onError(a);
            return;
          }
          globalThis.__DEV__ !== !1 && ue.error(21, a);
        }
      });
      return this.subscriptions.add(i), function() {
        n.subscriptions.delete(i) && i.unsubscribe();
      };
    }, t.prototype.setOptions = function(r) {
      return this.reobserve(r);
    }, t.prototype.silentSetOptions = function(r) {
      var n = hn(this.options, r || {});
      vh(this.options, n);
    }, t.prototype.setVariables = function(r) {
      return Te(this.variables, r) ? this.observers.size ? this.result() : Promise.resolve() : (this.options.variables = r, this.observers.size ? this.reobserve({
        // Reset options.fetchPolicy to its original value.
        fetchPolicy: this.options.initialFetchPolicy,
        variables: r
      }, Ce.setVariables) : Promise.resolve());
    }, t.prototype.updateQuery = function(r) {
      var n = this.queryManager, i = n.cache.diff({
        query: this.options.query,
        variables: this.variables,
        returnPartialData: !0,
        optimistic: !1
      }).result, a = r(i, {
        variables: this.variables
      });
      a && (n.cache.writeQuery({
        query: this.options.query,
        data: a,
        variables: this.variables
      }), n.broadcastQueries());
    }, t.prototype.startPolling = function(r) {
      this.options.pollInterval = r, this.updatePolling();
    }, t.prototype.stopPolling = function() {
      this.options.pollInterval = 0, this.updatePolling();
    }, t.prototype.applyNextFetchPolicy = function(r, n) {
      if (n.nextFetchPolicy) {
        var i = n.fetchPolicy, a = i === void 0 ? "cache-first" : i, o = n.initialFetchPolicy, s = o === void 0 ? a : o;
        a === "standby" || (typeof n.nextFetchPolicy == "function" ? n.fetchPolicy = n.nextFetchPolicy(a, {
          reason: r,
          options: n,
          observable: this,
          initialFetchPolicy: s
        }) : r === "variables-changed" ? n.fetchPolicy = s : n.fetchPolicy = n.nextFetchPolicy);
      }
      return n.fetchPolicy;
    }, t.prototype.fetch = function(r, n, i) {
      return this.queryManager.setObservableQuery(this), this.queryManager.fetchConcastWithInfo(this.queryId, r, n, i);
    }, t.prototype.updatePolling = function() {
      var r = this;
      if (!this.queryManager.ssrMode) {
        var n = this, i = n.pollingInfo, a = n.options.pollInterval;
        if (!a || !this.hasObservers()) {
          i && (clearTimeout(i.timeout), delete this.pollingInfo);
          return;
        }
        if (!(i && i.interval === a)) {
          ue(a, 22);
          var o = i || (this.pollingInfo = {});
          o.interval = a;
          var s = function() {
            var l, c;
            r.pollingInfo && (!ya(r.queryInfo.networkStatus) && !(!((c = (l = r.options).skipPollAttempt) === null || c === void 0) && c.call(l)) ? r.reobserve({
              // Most fetchPolicy options don't make sense to use in a polling context, as
              // users wouldn't want to be polling the cache directly. However, network-only and
              // no-cache are both useful for when the user wants to control whether or not the
              // polled results are written to the cache.
              fetchPolicy: r.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
            }, Ce.poll).then(u, u) : u());
          }, u = function() {
            var l = r.pollingInfo;
            l && (clearTimeout(l.timeout), l.timeout = setTimeout(s, l.interval));
          };
          u();
        }
      }
    }, t.prototype.updateLastResult = function(r, n) {
      n === void 0 && (n = this.variables);
      var i = this.getLastError();
      return i && this.last && !Te(n, this.last.variables) && (i = void 0), this.last = M({ result: this.queryManager.assumeImmutableResults ? r : rv(r), variables: n }, i ? { error: i } : null);
    }, t.prototype.reobserveAsConcast = function(r, n) {
      var i = this;
      this.isTornDown = !1;
      var a = (
        // Refetching uses a disposable Concast to allow refetches using different
        // options/variables, without permanently altering the options of the
        // original ObservableQuery.
        n === Ce.refetch || // The fetchMore method does not actually call the reobserve method, but,
        // if it did, it would definitely use a disposable Concast.
        n === Ce.fetchMore || // Polling uses a disposable Concast so the polling options (which force
        // fetchPolicy to be "network-only" or "no-cache") won't override the original options.
        n === Ce.poll
      ), o = this.options.variables, s = this.options.fetchPolicy, u = hn(this.options, r || {}), l = a ? (
        // Disposable Concast fetches receive a shallow copy of this.options
        // (merged with newOptions), leaving this.options unmodified.
        u
      ) : vh(this.options, u), c = this.transformDocument(l.query);
      this.lastQuery = c, a || (this.updatePolling(), r && r.variables && !Te(r.variables, o) && // Don't mess with the fetchPolicy if it's currently "standby".
      l.fetchPolicy !== "standby" && // If we're changing the fetchPolicy anyway, don't try to change it here
      // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.
      l.fetchPolicy === s && (this.applyNextFetchPolicy("variables-changed", l), n === void 0 && (n = Ce.setVariables))), this.waitForOwnResult && (this.waitForOwnResult = Iu(l.fetchPolicy));
      var d = function() {
        i.concast === p && (i.waitForOwnResult = !1);
      }, f = l.variables && M({}, l.variables), h = this.fetch(l, n, c), p = h.concast, v = h.fromLink, g = {
        next: function($) {
          Te(i.variables, f) && (d(), i.reportResult($, f));
        },
        error: function($) {
          Te(i.variables, f) && (d(), i.reportError($, f));
        }
      };
      return !a && (v || !this.concast) && (this.concast && this.observer && this.concast.removeObserver(this.observer), this.concast = p, this.observer = g), p.addObserver(g), p;
    }, t.prototype.reobserve = function(r, n) {
      return this.reobserveAsConcast(r, n).promise;
    }, t.prototype.resubscribeAfterError = function() {
      for (var r = [], n = 0; n < arguments.length; n++)
        r[n] = arguments[n];
      var i = this.last;
      this.resetLastResults();
      var a = this.subscribe.apply(this, r);
      return this.last = i, a;
    }, t.prototype.observe = function() {
      this.reportResult(
        // Passing false is important so that this.getCurrentResult doesn't
        // save the fetchMore result as this.lastResult, causing it to be
        // ignored due to the this.isDifferentFromLastResult check in
        // this.reportResult.
        this.getCurrentResult(!1),
        this.variables
      );
    }, t.prototype.reportResult = function(r, n) {
      var i = this.getLastError(), a = this.isDifferentFromLastResult(r, n);
      (i || !r.partial || this.options.returnPartialData) && this.updateLastResult(r, n), (i || a) && Ji(this.observers, "next", r);
    }, t.prototype.reportError = function(r, n) {
      var i = M(M({}, this.getLastResult()), { error: r, errors: r.graphQLErrors, networkStatus: Ce.error, loading: !1 });
      this.updateLastResult(i, n), Ji(this.observers, "error", this.last.error = r);
    }, t.prototype.hasObservers = function() {
      return this.observers.size > 0;
    }, t.prototype.tearDownQuery = function() {
      this.isTornDown || (this.concast && this.observer && (this.concast.removeObserver(this.observer), delete this.concast, delete this.observer), this.stopPolling(), this.subscriptions.forEach(function(r) {
        return r.unsubscribe();
      }), this.subscriptions.clear(), this.queryManager.stopQuery(this.queryId), this.observers.clear(), this.isTornDown = !0);
    }, t.prototype.transformDocument = function(r) {
      return this.queryManager.transform(r);
    }, t;
  }(ke)
);
nv(zl);
function Pv(e) {
  var t = e.options, r = t.fetchPolicy, n = t.nextFetchPolicy;
  return r === "cache-and-network" || r === "network-only" ? e.reobserve({
    fetchPolicy: "cache-first",
    // Use a temporary nextFetchPolicy function that replaces itself with the
    // previous nextFetchPolicy value and returns the original fetchPolicy.
    nextFetchPolicy: function(i, a) {
      return this.nextFetchPolicy = n, typeof this.nextFetchPolicy == "function" ? this.nextFetchPolicy(i, a) : r;
    }
  }) : e.reobserve();
}
function sE(e) {
  globalThis.__DEV__ !== !1 && ue.error(23, e.message, e.stack);
}
function Tv(e) {
  globalThis.__DEV__ !== !1 && e && globalThis.__DEV__ !== !1 && ue.debug(24, e);
}
function Iu(e) {
  return e === "network-only" || e === "no-cache" || e === "standby";
}
var Av = (
  /** @class */
  function() {
    function e(t) {
      var r = t.cache, n = t.client, i = t.resolvers, a = t.fragmentMatcher;
      this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap(), this.cache = r, n && (this.client = n), i && this.addResolvers(i), a && this.setFragmentMatcher(a);
    }
    return e.prototype.addResolvers = function(t) {
      var r = this;
      this.resolvers = this.resolvers || {}, Array.isArray(t) ? t.forEach(function(n) {
        r.resolvers = Lf(r.resolvers, n);
      }) : this.resolvers = Lf(this.resolvers, t);
    }, e.prototype.setResolvers = function(t) {
      this.resolvers = {}, this.addResolvers(t);
    }, e.prototype.getResolvers = function() {
      return this.resolvers || {};
    }, e.prototype.runResolvers = function(t) {
      return Or(this, arguments, void 0, function(r) {
        var n = r.document, i = r.remoteResult, a = r.context, o = r.variables, s = r.onlyRunForcedResolvers, u = s === void 0 ? !1 : s;
        return Ir(this, function(l) {
          return n ? [2, this.resolveDocument(n, i.data, a, o, this.fragmentMatcher, u).then(function(c) {
            return M(M({}, i), { data: c.result });
          })] : [2, i];
        });
      });
    }, e.prototype.setFragmentMatcher = function(t) {
      this.fragmentMatcher = t;
    }, e.prototype.getFragmentMatcher = function() {
      return this.fragmentMatcher;
    }, e.prototype.clientQuery = function(t) {
      return da(["client"], t) && this.resolvers ? t : null;
    }, e.prototype.serverQuery = function(t) {
      return Jm(t);
    }, e.prototype.prepareContext = function(t) {
      var r = this.cache;
      return M(M({}, t), {
        cache: r,
        // Getting an entry's cache key is useful for local state resolvers.
        getCacheKey: function(n) {
          return r.identify(n);
        }
      });
    }, e.prototype.addExportedVariables = function(t) {
      return Or(this, arguments, void 0, function(r, n, i) {
        return n === void 0 && (n = {}), i === void 0 && (i = {}), Ir(this, function(a) {
          return r ? [2, this.resolveDocument(r, this.buildRootValueFromCache(r, n) || {}, this.prepareContext(i), n).then(function(o) {
            return M(M({}, n), o.exportedVariables);
          })] : [2, M({}, n)];
        });
      });
    }, e.prototype.shouldForceResolvers = function(t) {
      var r = !1;
      return yr(t, {
        Directive: {
          enter: function(n) {
            if (n.name.value === "client" && n.arguments && (r = n.arguments.some(function(i) {
              return i.name.value === "always" && i.value.kind === "BooleanValue" && i.value.value === !0;
            }), r))
              return Gc;
          }
        }
      }), r;
    }, e.prototype.buildRootValueFromCache = function(t, r) {
      return this.cache.diff({
        query: U5(t),
        variables: r,
        returnPartialData: !0,
        optimistic: !1
      }).result;
    }, e.prototype.resolveDocument = function(t, r) {
      return Or(this, arguments, void 0, function(n, i, a, o, s, u) {
        var l, c, d, f, h, p, v, g, $, m, b;
        return a === void 0 && (a = {}), o === void 0 && (o = {}), s === void 0 && (s = function() {
          return !0;
        }), u === void 0 && (u = !1), Ir(this, function(D) {
          return l = Ma(n), c = Ns(n), d = Rs(c), f = this.collectSelectionsToResolve(l, d), h = l.operation, p = h ? h.charAt(0).toUpperCase() + h.slice(1) : "Query", v = this, g = v.cache, $ = v.client, m = {
            fragmentMap: d,
            context: M(M({}, a), { cache: g, client: $ }),
            variables: o,
            fragmentMatcher: s,
            defaultOperationType: p,
            exportedVariables: {},
            selectionsToResolve: f,
            onlyRunForcedResolvers: u
          }, b = !1, [2, this.resolveSelectionSet(l.selectionSet, b, i, m).then(function(S) {
            return {
              result: S,
              exportedVariables: m.exportedVariables
            };
          })];
        });
      });
    }, e.prototype.resolveSelectionSet = function(t, r, n, i) {
      return Or(this, void 0, void 0, function() {
        var a, o, s, u, l, c = this;
        return Ir(this, function(d) {
          return a = i.fragmentMap, o = i.context, s = i.variables, u = [n], l = function(f) {
            return Or(c, void 0, void 0, function() {
              var h, p;
              return Ir(this, function(v) {
                return !r && !i.selectionsToResolve.has(f) ? [
                  2
                  /*return*/
                ] : Ia(f, s) ? jr(f) ? [2, this.resolveField(f, r, n, i).then(function(g) {
                  var $;
                  typeof g < "u" && u.push(($ = {}, $[zr(f)] = g, $));
                })] : (w5(f) ? h = f : (h = a[f.name.value], ue(h, 18, f.name.value)), h && h.typeCondition && (p = h.typeCondition.name.value, i.fragmentMatcher(n, p, o)) ? [2, this.resolveSelectionSet(h.selectionSet, r, n, i).then(function(g) {
                  u.push(g);
                })] : [
                  2
                  /*return*/
                ]) : [
                  2
                  /*return*/
                ];
              });
            });
          }, [2, Promise.all(t.selections.map(l)).then(function() {
            return js(u);
          })];
        });
      });
    }, e.prototype.resolveField = function(t, r, n, i) {
      return Or(this, void 0, void 0, function() {
        var a, o, s, u, l, c, d, f, h, p = this;
        return Ir(this, function(v) {
          return n ? (a = i.variables, o = t.name.value, s = zr(t), u = o !== s, l = n[s] || n[o], c = Promise.resolve(l), (!i.onlyRunForcedResolvers || this.shouldForceResolvers(t)) && (d = n.__typename || i.defaultOperationType, f = this.resolvers && this.resolvers[d], f && (h = f[u ? o : s], h && (c = Promise.resolve(
            // In case the resolve function accesses reactive variables,
            // set cacheSlot to the current cache instance.
            cd.withValue(this.cache, h, [
              n,
              Ms(t, a),
              i.context,
              { field: t, fragmentMap: i.fragmentMap }
            ])
          )))), [2, c.then(function(g) {
            var $, m;
            if (g === void 0 && (g = l), t.directives && t.directives.forEach(function(D) {
              D.name.value === "export" && D.arguments && D.arguments.forEach(function(S) {
                S.name.value === "as" && S.value.kind === "StringValue" && (i.exportedVariables[S.value.value] = g);
              });
            }), !t.selectionSet || g == null)
              return g;
            var b = (m = ($ = t.directives) === null || $ === void 0 ? void 0 : $.some(function(D) {
              return D.name.value === "client";
            })) !== null && m !== void 0 ? m : !1;
            if (Array.isArray(g))
              return p.resolveSubSelectedArray(t, r || b, g, i);
            if (t.selectionSet)
              return p.resolveSelectionSet(t.selectionSet, r || b, g, i);
          })]) : [2, null];
        });
      });
    }, e.prototype.resolveSubSelectedArray = function(t, r, n, i) {
      var a = this;
      return Promise.all(n.map(function(o) {
        if (o === null)
          return null;
        if (Array.isArray(o))
          return a.resolveSubSelectedArray(t, r, o, i);
        if (t.selectionSet)
          return a.resolveSelectionSet(t.selectionSet, r, o, i);
      }));
    }, e.prototype.collectSelectionsToResolve = function(t, r) {
      var n = function(o) {
        return !Array.isArray(o);
      }, i = this.selectionsToResolveCache;
      function a(o) {
        if (!i.has(o)) {
          var s = /* @__PURE__ */ new Set();
          i.set(o, s), yr(o, {
            Directive: function(u, l, c, d, f) {
              u.name.value === "client" && f.forEach(function(h) {
                n(h) && Tf(h) && s.add(h);
              });
            },
            FragmentSpread: function(u, l, c, d, f) {
              var h = r[u.name.value];
              ue(h, 19, u.name.value);
              var p = a(h);
              p.size > 0 && (f.forEach(function(v) {
                n(v) && Tf(v) && s.add(v);
              }), s.add(u), p.forEach(function(v) {
                s.add(v);
              }));
            }
          });
        }
        return i.get(o);
      }
      return a(t);
    }, e;
  }()
), Kn = new (wn ? WeakMap : Map)();
function Ru(e, t) {
  var r = e[t];
  typeof r == "function" && (e[t] = function() {
    return Kn.set(
      e,
      // The %1e15 allows the count to wrap around to 0 safely every
      // quadrillion evictions, so there's no risk of overflow. To be
      // clear, this is more of a pedantic principle than something
      // that matters in any conceivable practical scenario.
      (Kn.get(e) + 1) % 1e15
    ), r.apply(this, arguments);
  });
}
function yh(e) {
  e.notifyTimeout && (clearTimeout(e.notifyTimeout), e.notifyTimeout = void 0);
}
var Bu = (
  /** @class */
  function() {
    function e(t, r) {
      r === void 0 && (r = t.generateQueryId()), this.queryId = r, this.listeners = /* @__PURE__ */ new Set(), this.document = null, this.lastRequestId = 1, this.stopped = !1, this.dirty = !1, this.observableQuery = null;
      var n = this.cache = t.cache;
      Kn.has(n) || (Kn.set(n, 0), Ru(n, "evict"), Ru(n, "modify"), Ru(n, "reset"));
    }
    return e.prototype.init = function(t) {
      var r = t.networkStatus || Ce.loading;
      return this.variables && this.networkStatus !== Ce.loading && !Te(this.variables, t.variables) && (r = Ce.setVariables), Te(t.variables, this.variables) || (this.lastDiff = void 0), Object.assign(this, {
        document: t.document,
        variables: t.variables,
        networkError: null,
        graphQLErrors: this.graphQLErrors || [],
        networkStatus: r
      }), t.observableQuery && this.setObservableQuery(t.observableQuery), t.lastRequestId && (this.lastRequestId = t.lastRequestId), this;
    }, e.prototype.reset = function() {
      yh(this), this.dirty = !1;
    }, e.prototype.resetDiff = function() {
      this.lastDiff = void 0;
    }, e.prototype.getDiff = function() {
      var t = this.getDiffOptions();
      if (this.lastDiff && Te(t, this.lastDiff.options))
        return this.lastDiff.diff;
      this.updateWatch(this.variables);
      var r = this.observableQuery;
      if (r && r.options.fetchPolicy === "no-cache")
        return { complete: !1 };
      var n = this.cache.diff(t);
      return this.updateLastDiff(n, t), n;
    }, e.prototype.updateLastDiff = function(t, r) {
      this.lastDiff = t ? {
        diff: t,
        options: r || this.getDiffOptions()
      } : void 0;
    }, e.prototype.getDiffOptions = function(t) {
      var r;
      return t === void 0 && (t = this.variables), {
        query: this.document,
        variables: t,
        returnPartialData: !0,
        optimistic: !0,
        canonizeResults: (r = this.observableQuery) === null || r === void 0 ? void 0 : r.options.canonizeResults
      };
    }, e.prototype.setDiff = function(t) {
      var r = this, n, i = this.lastDiff && this.lastDiff.diff;
      t && !t.complete && (!((n = this.observableQuery) === null || n === void 0) && n.getLastError()) || (this.updateLastDiff(t), !this.dirty && !Te(i && i.result, t && t.result) && (this.dirty = !0, this.notifyTimeout || (this.notifyTimeout = setTimeout(function() {
        return r.notify();
      }, 0))));
    }, e.prototype.setObservableQuery = function(t) {
      var r = this;
      t !== this.observableQuery && (this.oqListener && this.listeners.delete(this.oqListener), this.observableQuery = t, t ? (t.queryInfo = this, this.listeners.add(this.oqListener = function() {
        var n = r.getDiff();
        n.fromOptimisticTransaction ? t.observe() : Pv(t);
      })) : delete this.oqListener);
    }, e.prototype.notify = function() {
      var t = this;
      yh(this), this.shouldNotify() && this.listeners.forEach(function(r) {
        return r(t);
      }), this.dirty = !1;
    }, e.prototype.shouldNotify = function() {
      if (!this.dirty || !this.listeners.size)
        return !1;
      if (ya(this.networkStatus) && this.observableQuery) {
        var t = this.observableQuery.options.fetchPolicy;
        if (t !== "cache-only" && t !== "cache-and-network")
          return !1;
      }
      return !0;
    }, e.prototype.stop = function() {
      if (!this.stopped) {
        this.stopped = !0, this.reset(), this.cancel(), this.cancel = e.prototype.cancel;
        var t = this.observableQuery;
        t && t.stopPolling();
      }
    }, e.prototype.cancel = function() {
    }, e.prototype.updateWatch = function(t) {
      var r = this;
      t === void 0 && (t = this.variables);
      var n = this.observableQuery;
      if (!(n && n.options.fetchPolicy === "no-cache")) {
        var i = M(M({}, this.getDiffOptions(t)), { watcher: this, callback: function(a) {
          return r.setDiff(a);
        } });
        (!this.lastWatch || !Te(i, this.lastWatch)) && (this.cancel(), this.cancel = this.cache.watch(this.lastWatch = i));
      }
    }, e.prototype.resetLastWrite = function() {
      this.lastWrite = void 0;
    }, e.prototype.shouldWrite = function(t, r) {
      var n = this.lastWrite;
      return !(n && // If cache.evict has been called since the last time we wrote this
      // data into the cache, there's a chance writing this result into
      // the cache will repair what was evicted.
      n.dmCount === Kn.get(this.cache) && Te(r, n.variables) && Te(t.data, n.result.data));
    }, e.prototype.markResult = function(t, r, n, i) {
      var a = this, o = new Ur(), s = Mt(t.errors) ? t.errors.slice(0) : [];
      if (this.reset(), "incremental" in t && Mt(t.incremental)) {
        var u = iv(this.getDiff().result, t);
        t.data = u;
      } else if ("hasNext" in t && t.hasNext) {
        var l = this.getDiff();
        t.data = o.merge(l.result, t.data);
      }
      this.graphQLErrors = s, n.fetchPolicy === "no-cache" ? this.updateLastDiff({ result: t.data, complete: !0 }, this.getDiffOptions(n.variables)) : i !== 0 && (jl(t, n.errorPolicy) ? this.cache.performTransaction(function(c) {
        if (a.shouldWrite(t, n.variables))
          c.writeQuery({
            query: r,
            data: t.data,
            variables: n.variables,
            overwrite: i === 1
          }), a.lastWrite = {
            result: t,
            variables: n.variables,
            dmCount: Kn.get(a.cache)
          };
        else if (a.lastDiff && a.lastDiff.diff.complete) {
          t.data = a.lastDiff.diff.result;
          return;
        }
        var d = a.getDiffOptions(n.variables), f = c.diff(d);
        !a.stopped && Te(a.variables, n.variables) && a.updateWatch(n.variables), a.updateLastDiff(f, d), f.complete && (t.data = f.result);
      }) : this.lastWrite = void 0);
    }, e.prototype.markReady = function() {
      return this.networkError = null, this.networkStatus = Ce.ready;
    }, e.prototype.markError = function(t) {
      return this.networkStatus = Ce.error, this.lastWrite = void 0, this.reset(), t.graphQLErrors && (this.graphQLErrors = t.graphQLErrors), t.networkError && (this.networkError = t.networkError), t;
    }, e;
  }()
);
function jl(e, t) {
  t === void 0 && (t = "none");
  var r = t === "ignore" || t === "all", n = !ko(e);
  return !n && r && e.data && (n = !0), n;
}
var uE = Object.prototype.hasOwnProperty, gh = /* @__PURE__ */ Object.create(null), lE = (
  /** @class */
  function() {
    function e(t) {
      var r = t.cache, n = t.link, i = t.defaultOptions, a = t.documentTransform, o = t.queryDeduplication, s = o === void 0 ? !1 : o, u = t.onBroadcast, l = t.ssrMode, c = l === void 0 ? !1 : l, d = t.clientAwareness, f = d === void 0 ? {} : d, h = t.localState, p = t.assumeImmutableResults, v = p === void 0 ? !!r.assumeImmutableResults : p, g = t.defaultContext, $ = this;
      this.clientAwareness = {}, this.queries = /* @__PURE__ */ new Map(), this.fetchCancelFns = /* @__PURE__ */ new Map(), this.transformCache = new Yc(
        Xt["queryManager.getDocumentInfo"] || 2e3
        /* defaultCacheSizes["queryManager.getDocumentInfo"] */
      ), this.queryIdCounter = 1, this.requestIdCounter = 1, this.mutationIdCounter = 1, this.inFlightLinkObservables = new bi(!1);
      var m = new Gm(
        function(b) {
          return $.cache.transformDocument(b);
        },
        // Allow the apollo cache to manage its own transform caches
        { cache: !1 }
      );
      this.cache = r, this.link = n, this.defaultOptions = i || /* @__PURE__ */ Object.create(null), this.queryDeduplication = s, this.clientAwareness = f, this.localState = h || new Av({ cache: r }), this.ssrMode = c, this.assumeImmutableResults = v, this.documentTransform = a ? m.concat(a).concat(m) : m, this.defaultContext = g || /* @__PURE__ */ Object.create(null), (this.onBroadcast = u) && (this.mutationStore = /* @__PURE__ */ Object.create(null));
    }
    return e.prototype.stop = function() {
      var t = this;
      this.queries.forEach(function(r, n) {
        t.stopQueryNoBroadcast(n);
      }), this.cancelPendingFetches(ht(25));
    }, e.prototype.cancelPendingFetches = function(t) {
      this.fetchCancelFns.forEach(function(r) {
        return r(t);
      }), this.fetchCancelFns.clear();
    }, e.prototype.mutate = function(t) {
      return Or(this, arguments, void 0, function(r) {
        var n, i, a, o, s, u, l, c = r.mutation, d = r.variables, f = r.optimisticResponse, h = r.updateQueries, p = r.refetchQueries, v = p === void 0 ? [] : p, g = r.awaitRefetchQueries, $ = g === void 0 ? !1 : g, m = r.update, b = r.onQueryUpdated, D = r.fetchPolicy, S = D === void 0 ? ((u = this.defaultOptions.mutate) === null || u === void 0 ? void 0 : u.fetchPolicy) || "network-only" : D, T = r.errorPolicy, B = T === void 0 ? ((l = this.defaultOptions.mutate) === null || l === void 0 ? void 0 : l.errorPolicy) || "none" : T, y = r.keepRootFields, _ = r.context;
        return Ir(this, function(w) {
          switch (w.label) {
            case 0:
              return ue(c, 26), ue(S === "network-only" || S === "no-cache", 27), n = this.generateMutationId(), c = this.cache.transformForLink(this.transform(c)), i = this.getDocumentInfo(c).hasClientExports, d = this.getVariables(c, d), i ? [4, this.localState.addExportedVariables(c, d, _)] : [3, 2];
            case 1:
              d = w.sent(), w.label = 2;
            case 2:
              return a = this.mutationStore && (this.mutationStore[n] = {
                mutation: c,
                variables: d,
                loading: !0,
                error: null
              }), o = f && this.markMutationOptimistic(f, {
                mutationId: n,
                document: c,
                variables: d,
                fetchPolicy: S,
                errorPolicy: B,
                context: _,
                updateQueries: h,
                update: m,
                keepRootFields: y
              }), this.broadcastQueries(), s = this, [2, new Promise(function(E, k) {
                return Tu(s.getObservableFromLink(c, M(M({}, _), { optimisticResponse: o ? f : void 0 }), d, !1), function(C) {
                  if (ko(C) && B === "none")
                    throw new cr({
                      graphQLErrors: Il(C)
                    });
                  a && (a.loading = !1, a.error = null);
                  var A = M({}, C);
                  return typeof v == "function" && (v = v(A)), B === "ignore" && ko(A) && delete A.errors, s.markMutationResult({
                    mutationId: n,
                    result: A,
                    document: c,
                    variables: d,
                    fetchPolicy: S,
                    errorPolicy: B,
                    context: _,
                    update: m,
                    updateQueries: h,
                    awaitRefetchQueries: $,
                    refetchQueries: v,
                    removeOptimistic: o ? n : void 0,
                    onQueryUpdated: b,
                    keepRootFields: y
                  });
                }).subscribe({
                  next: function(C) {
                    s.broadcastQueries(), (!("hasNext" in C) || C.hasNext === !1) && E(C);
                  },
                  error: function(C) {
                    a && (a.loading = !1, a.error = C), o && s.cache.removeOptimistic(n), s.broadcastQueries(), k(C instanceof cr ? C : new cr({
                      networkError: C
                    }));
                  }
                });
              })];
          }
        });
      });
    }, e.prototype.markMutationResult = function(t, r) {
      var n = this;
      r === void 0 && (r = this.cache);
      var i = t.result, a = [], o = t.fetchPolicy === "no-cache";
      if (!o && jl(i, t.errorPolicy)) {
        if (Zn(i) || a.push({
          result: i.data,
          dataId: "ROOT_MUTATION",
          query: t.document,
          variables: t.variables
        }), Zn(i) && Mt(i.incremental)) {
          var s = r.diff({
            id: "ROOT_MUTATION",
            // The cache complains if passed a mutation where it expects a
            // query, so we transform mutations and subscriptions to queries
            // (only once, thanks to this.transformCache).
            query: this.getDocumentInfo(t.document).asQuery,
            variables: t.variables,
            optimistic: !1,
            returnPartialData: !0
          }), u = void 0;
          s.result && (u = iv(s.result, i)), typeof u < "u" && (i.data = u, a.push({
            result: u,
            dataId: "ROOT_MUTATION",
            query: t.document,
            variables: t.variables
          }));
        }
        var l = t.updateQueries;
        l && this.queries.forEach(function(d, f) {
          var h = d.observableQuery, p = h && h.queryName;
          if (!(!p || !uE.call(l, p))) {
            var v = l[p], g = n.queries.get(f), $ = g.document, m = g.variables, b = r.diff({
              query: $,
              variables: m,
              returnPartialData: !0,
              optimistic: !1
            }), D = b.result, S = b.complete;
            if (S && D) {
              var T = v(D, {
                mutationResult: i,
                queryName: $ && Al($) || void 0,
                queryVariables: m
              });
              T && a.push({
                result: T,
                dataId: "ROOT_QUERY",
                query: $,
                variables: m
              });
            }
          }
        });
      }
      if (a.length > 0 || (t.refetchQueries || "").length > 0 || t.update || t.onQueryUpdated || t.removeOptimistic) {
        var c = [];
        if (this.refetchQueries({
          updateCache: function(d) {
            o || a.forEach(function(v) {
              return d.write(v);
            });
            var f = t.update, h = !a2(i) || Zn(i) && !i.hasNext;
            if (f) {
              if (!o) {
                var p = d.diff({
                  id: "ROOT_MUTATION",
                  // The cache complains if passed a mutation where it expects a
                  // query, so we transform mutations and subscriptions to queries
                  // (only once, thanks to this.transformCache).
                  query: n.getDocumentInfo(t.document).asQuery,
                  variables: t.variables,
                  optimistic: !1,
                  returnPartialData: !0
                });
                p.complete && (i = M(M({}, i), { data: p.result }), "incremental" in i && delete i.incremental, "hasNext" in i && delete i.hasNext);
              }
              h && f(d, i, {
                context: t.context,
                variables: t.variables
              });
            }
            !o && !t.keepRootFields && h && d.modify({
              id: "ROOT_MUTATION",
              fields: function(v, g) {
                var $ = g.fieldName, m = g.DELETE;
                return $ === "__typename" ? v : m;
              }
            });
          },
          include: t.refetchQueries,
          // Write the final mutation.result to the root layer of the cache.
          optimistic: !1,
          // Remove the corresponding optimistic layer at the same time as we
          // write the final non-optimistic result.
          removeOptimistic: t.removeOptimistic,
          // Let the caller of client.mutate optionally determine the refetching
          // behavior for watched queries after the mutation.update function runs.
          // If no onQueryUpdated function was provided for this mutation, pass
          // null instead of undefined to disable the default refetching behavior.
          onQueryUpdated: t.onQueryUpdated || null
        }).forEach(function(d) {
          return c.push(d);
        }), t.awaitRefetchQueries || t.onQueryUpdated)
          return Promise.all(c).then(function() {
            return i;
          });
      }
      return Promise.resolve(i);
    }, e.prototype.markMutationOptimistic = function(t, r) {
      var n = this, i = typeof t == "function" ? t(r.variables, { IGNORE: gh }) : t;
      return i === gh ? !1 : (this.cache.recordOptimisticTransaction(function(a) {
        try {
          n.markMutationResult(M(M({}, r), { result: { data: i } }), a);
        } catch (o) {
          globalThis.__DEV__ !== !1 && ue.error(o);
        }
      }, r.mutationId), !0);
    }, e.prototype.fetchQuery = function(t, r, n) {
      return this.fetchConcastWithInfo(t, r, n).concast.promise;
    }, e.prototype.getQueryStore = function() {
      var t = /* @__PURE__ */ Object.create(null);
      return this.queries.forEach(function(r, n) {
        t[n] = {
          variables: r.variables,
          networkStatus: r.networkStatus,
          networkError: r.networkError,
          graphQLErrors: r.graphQLErrors
        };
      }), t;
    }, e.prototype.resetErrors = function(t) {
      var r = this.queries.get(t);
      r && (r.networkError = void 0, r.graphQLErrors = []);
    }, e.prototype.transform = function(t) {
      return this.documentTransform.transformDocument(t);
    }, e.prototype.getDocumentInfo = function(t) {
      var r = this.transformCache;
      if (!r.has(t)) {
        var n = {
          // TODO These three calls (hasClientExports, shouldForceResolvers, and
          // usesNonreactiveDirective) are performing independent full traversals
          // of the transformed document. We should consider merging these
          // traversals into a single pass in the future, though the work is
          // cached after the first time.
          hasClientExports: LD(t),
          hasForcedResolvers: this.localState.shouldForceResolvers(t),
          hasNonreactiveDirective: da(["nonreactive"], t),
          clientQuery: this.localState.clientQuery(t),
          serverQuery: Ym([
            { name: "client", remove: !0 },
            { name: "connection" },
            { name: "nonreactive" }
          ], t),
          defaultVars: Xc(Ba(t)),
          // Transform any mutation or subscription operations to query operations
          // so we can read/write them from/to the cache.
          asQuery: M(M({}, t), { definitions: t.definitions.map(function(i) {
            return i.kind === "OperationDefinition" && i.operation !== "query" ? M(M({}, i), { operation: "query" }) : i;
          }) })
        };
        r.set(t, n);
      }
      return r.get(t);
    }, e.prototype.getVariables = function(t, r) {
      return M(M({}, this.getDocumentInfo(t).defaultVars), r);
    }, e.prototype.watchQuery = function(t) {
      var r = this.transform(t.query);
      t = M(M({}, t), { variables: this.getVariables(r, t.variables) }), typeof t.notifyOnNetworkStatusChange > "u" && (t.notifyOnNetworkStatusChange = !1);
      var n = new Bu(this), i = new zl({
        queryManager: this,
        queryInfo: n,
        options: t
      });
      return i.lastQuery = r, this.queries.set(i.queryId, n), n.init({
        document: r,
        observableQuery: i,
        variables: i.variables
      }), i;
    }, e.prototype.query = function(t, r) {
      var n = this;
      return r === void 0 && (r = this.generateQueryId()), ue(t.query, 28), ue(t.query.kind === "Document", 29), ue(!t.returnPartialData, 30), ue(!t.pollInterval, 31), this.fetchQuery(r, M(M({}, t), { query: this.transform(t.query) })).finally(function() {
        return n.stopQuery(r);
      });
    }, e.prototype.generateQueryId = function() {
      return String(this.queryIdCounter++);
    }, e.prototype.generateRequestId = function() {
      return this.requestIdCounter++;
    }, e.prototype.generateMutationId = function() {
      return String(this.mutationIdCounter++);
    }, e.prototype.stopQueryInStore = function(t) {
      this.stopQueryInStoreNoBroadcast(t), this.broadcastQueries();
    }, e.prototype.stopQueryInStoreNoBroadcast = function(t) {
      var r = this.queries.get(t);
      r && r.stop();
    }, e.prototype.clearStore = function(t) {
      return t === void 0 && (t = {
        discardWatches: !0
      }), this.cancelPendingFetches(ht(32)), this.queries.forEach(function(r) {
        r.observableQuery ? r.networkStatus = Ce.loading : r.stop();
      }), this.mutationStore && (this.mutationStore = /* @__PURE__ */ Object.create(null)), this.cache.reset(t);
    }, e.prototype.getObservableQueries = function(t) {
      var r = this;
      t === void 0 && (t = "active");
      var n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set();
      return Array.isArray(t) && t.forEach(function(o) {
        typeof o == "string" ? i.set(o, !1) : f5(o) ? i.set(r.transform(o), !1) : qe(o) && o.query && a.add(o);
      }), this.queries.forEach(function(o, s) {
        var u = o.observableQuery, l = o.document;
        if (u) {
          if (t === "all") {
            n.set(s, u);
            return;
          }
          var c = u.queryName, d = u.options.fetchPolicy;
          if (d === "standby" || t === "active" && !u.hasObservers())
            return;
          (t === "active" || c && i.has(c) || l && i.has(l)) && (n.set(s, u), c && i.set(c, !0), l && i.set(l, !0));
        }
      }), a.size && a.forEach(function(o) {
        var s = xl("legacyOneTimeQuery"), u = r.getQuery(s).init({
          document: o.query,
          variables: o.variables
        }), l = new zl({
          queryManager: r,
          queryInfo: u,
          options: M(M({}, o), { fetchPolicy: "network-only" })
        });
        ue(l.queryId === s), u.setObservableQuery(l), n.set(s, l);
      }), globalThis.__DEV__ !== !1 && i.size && i.forEach(function(o, s) {
        o || globalThis.__DEV__ !== !1 && ue.warn(typeof s == "string" ? 33 : 34, s);
      }), n;
    }, e.prototype.reFetchObservableQueries = function(t) {
      var r = this;
      t === void 0 && (t = !1);
      var n = [];
      return this.getObservableQueries(t ? "all" : "active").forEach(function(i, a) {
        var o = i.options.fetchPolicy;
        i.resetLastResults(), (t || o !== "standby" && o !== "cache-only") && n.push(i.refetch()), r.getQuery(a).setDiff(null);
      }), this.broadcastQueries(), Promise.all(n);
    }, e.prototype.setObservableQuery = function(t) {
      this.getQuery(t.queryId).setObservableQuery(t);
    }, e.prototype.startGraphQLSubscription = function(t) {
      var r = this, n = t.query, i = t.fetchPolicy, a = t.errorPolicy, o = a === void 0 ? "none" : a, s = t.variables, u = t.context, l = u === void 0 ? {} : u;
      n = this.transform(n), s = this.getVariables(n, s);
      var c = function(f) {
        return r.getObservableFromLink(n, l, f).map(function(h) {
          i !== "no-cache" && (jl(h, o) && r.cache.write({
            query: n,
            result: h.data,
            dataId: "ROOT_SUBSCRIPTION",
            variables: f
          }), r.broadcastQueries());
          var p = ko(h), v = D2(h);
          if (p || v) {
            var g = {};
            if (p && (g.graphQLErrors = h.errors), v && (g.protocolErrors = h.extensions[ld]), o === "none" || v)
              throw new cr(g);
          }
          return o === "ignore" && delete h.errors, h;
        });
      };
      if (this.getDocumentInfo(n).hasClientExports) {
        var d = this.localState.addExportedVariables(n, s, l).then(c);
        return new ke(function(f) {
          var h = null;
          return d.then(function(p) {
            return h = p.subscribe(f);
          }, f.error), function() {
            return h && h.unsubscribe();
          };
        });
      }
      return c(s);
    }, e.prototype.stopQuery = function(t) {
      this.stopQueryNoBroadcast(t), this.broadcastQueries();
    }, e.prototype.stopQueryNoBroadcast = function(t) {
      this.stopQueryInStoreNoBroadcast(t), this.removeQuery(t);
    }, e.prototype.removeQuery = function(t) {
      this.fetchCancelFns.delete(t), this.queries.has(t) && (this.getQuery(t).stop(), this.queries.delete(t));
    }, e.prototype.broadcastQueries = function() {
      this.onBroadcast && this.onBroadcast(), this.queries.forEach(function(t) {
        return t.notify();
      });
    }, e.prototype.getLocalState = function() {
      return this.localState;
    }, e.prototype.getObservableFromLink = function(t, r, n, i) {
      var a = this, o;
      i === void 0 && (i = (o = r == null ? void 0 : r.queryDeduplication) !== null && o !== void 0 ? o : this.queryDeduplication);
      var s, u = this.getDocumentInfo(t), l = u.serverQuery, c = u.clientQuery;
      if (l) {
        var d = this, f = d.inFlightLinkObservables, h = d.link, p = {
          query: l,
          variables: n,
          operationName: Al(l) || void 0,
          context: this.prepareContext(M(M({}, r), { forceFetch: !i }))
        };
        if (r = p.context, i) {
          var v = zs(l), g = Vr(n), $ = f.lookup(v, g);
          if (s = $.observable, !s) {
            var m = new Bn([
              Rl(h, p)
            ]);
            s = $.observable = m, m.beforeNext(function() {
              f.remove(v, g);
            });
          }
        } else
          s = new Bn([
            Rl(h, p)
          ]);
      } else
        s = new Bn([ke.of({ data: {} })]), r = this.prepareContext(r);
      return c && (s = Tu(s, function(b) {
        return a.localState.runResolvers({
          document: c,
          remoteResult: b,
          context: r,
          variables: n
        });
      })), s;
    }, e.prototype.getResultsFromLink = function(t, r, n) {
      var i = t.lastRequestId = this.generateRequestId(), a = this.cache.transformForLink(n.query);
      return Tu(this.getObservableFromLink(a, n.context, n.variables), function(o) {
        var s = Il(o), u = s.length > 0;
        if (i >= t.lastRequestId) {
          if (u && n.errorPolicy === "none")
            throw t.markError(new cr({
              graphQLErrors: s
            }));
          t.markResult(o, a, n, r), t.markReady();
        }
        var l = {
          data: o.data,
          loading: !1,
          networkStatus: Ce.ready
        };
        return u && n.errorPolicy !== "ignore" && (l.errors = s, l.networkStatus = Ce.error), l;
      }, function(o) {
        var s = E2(o) ? o : new cr({ networkError: o });
        throw i >= t.lastRequestId && t.markError(s), s;
      });
    }, e.prototype.fetchConcastWithInfo = function(t, r, n, i) {
      var a = this;
      n === void 0 && (n = Ce.loading), i === void 0 && (i = r.query);
      var o = this.getVariables(i, r.variables), s = this.getQuery(t), u = this.defaultOptions.watchQuery, l = r.fetchPolicy, c = l === void 0 ? u && u.fetchPolicy || "cache-first" : l, d = r.errorPolicy, f = d === void 0 ? u && u.errorPolicy || "none" : d, h = r.returnPartialData, p = h === void 0 ? !1 : h, v = r.notifyOnNetworkStatusChange, g = v === void 0 ? !1 : v, $ = r.context, m = $ === void 0 ? {} : $, b = Object.assign({}, r, {
        query: i,
        variables: o,
        fetchPolicy: c,
        errorPolicy: f,
        returnPartialData: p,
        notifyOnNetworkStatusChange: g,
        context: m
      }), D = function(_) {
        b.variables = _;
        var w = a.fetchQueryByPolicy(s, b, n);
        return (
          // If we're in standby, postpone advancing options.fetchPolicy using
          // applyNextFetchPolicy.
          b.fetchPolicy !== "standby" && // The "standby" policy currently returns [] from fetchQueryByPolicy, so
          // this is another way to detect when nothing was done/fetched.
          w.sources.length > 0 && s.observableQuery && s.observableQuery.applyNextFetchPolicy("after-fetch", r), w
        );
      }, S = function() {
        return a.fetchCancelFns.delete(t);
      };
      this.fetchCancelFns.set(t, function(_) {
        S(), setTimeout(function() {
          return T.cancel(_);
        });
      });
      var T, B;
      if (this.getDocumentInfo(b.query).hasClientExports)
        T = new Bn(this.localState.addExportedVariables(b.query, b.variables, b.context).then(D).then(function(_) {
          return _.sources;
        })), B = !0;
      else {
        var y = D(b.variables);
        B = y.fromLink, T = new Bn(y.sources);
      }
      return T.promise.then(S, S), {
        concast: T,
        fromLink: B
      };
    }, e.prototype.refetchQueries = function(t) {
      var r = this, n = t.updateCache, i = t.include, a = t.optimistic, o = a === void 0 ? !1 : a, s = t.removeOptimistic, u = s === void 0 ? o ? xl("refetchQueries") : void 0 : s, l = t.onQueryUpdated, c = /* @__PURE__ */ new Map();
      i && this.getObservableQueries(i).forEach(function(f, h) {
        c.set(h, {
          oq: f,
          lastDiff: r.getQuery(h).getDiff()
        });
      });
      var d = /* @__PURE__ */ new Map();
      return n && this.cache.batch({
        update: n,
        // Since you can perform any combination of cache reads and/or writes in
        // the cache.batch update function, its optimistic option can be either
        // a boolean or a string, representing three distinct modes of
        // operation:
        //
        // * false: read/write only the root layer
        // * true: read/write the topmost layer
        // * string: read/write a fresh optimistic layer with that ID string
        //
        // When typeof optimistic === "string", a new optimistic layer will be
        // temporarily created within cache.batch with that string as its ID. If
        // we then pass that same string as the removeOptimistic option, we can
        // make cache.batch immediately remove the optimistic layer after
        // running the updateCache function, triggering only one broadcast.
        //
        // However, the refetchQueries method accepts only true or false for its
        // optimistic option (not string). We interpret true to mean a temporary
        // optimistic layer should be created, to allow efficiently rolling back
        // the effect of the updateCache function, which involves passing a
        // string instead of true as the optimistic option to cache.batch, when
        // refetchQueries receives optimistic: true.
        //
        // In other words, we are deliberately not supporting the use case of
        // writing to an *existing* optimistic layer (using the refetchQueries
        // updateCache function), since that would potentially interfere with
        // other optimistic updates in progress. Instead, you can read/write
        // only the root layer by passing optimistic: false to refetchQueries,
        // or you can read/write a brand new optimistic layer that will be
        // automatically removed by passing optimistic: true.
        optimistic: o && u || !1,
        // The removeOptimistic option can also be provided by itself, even if
        // optimistic === false, to remove some previously-added optimistic
        // layer safely and efficiently, like we do in markMutationResult.
        //
        // If an explicit removeOptimistic string is provided with optimistic:
        // true, the removeOptimistic string will determine the ID of the
        // temporary optimistic layer, in case that ever matters.
        removeOptimistic: u,
        onWatchUpdated: function(f, h, p) {
          var v = f.watcher instanceof Bu && f.watcher.observableQuery;
          if (v) {
            if (l) {
              c.delete(v.queryId);
              var g = l(v, h, p);
              return g === !0 && (g = v.refetch()), g !== !1 && d.set(v, g), g;
            }
            l !== null && c.set(v.queryId, { oq: v, lastDiff: p, diff: h });
          }
        }
      }), c.size && c.forEach(function(f, h) {
        var p = f.oq, v = f.lastDiff, g = f.diff, $;
        if (l) {
          if (!g) {
            var m = p.queryInfo;
            m.reset(), g = m.getDiff();
          }
          $ = l(p, g, v);
        }
        (!l || $ === !0) && ($ = p.refetch()), $ !== !1 && d.set(p, $), h.indexOf("legacyOneTimeQuery") >= 0 && r.stopQueryNoBroadcast(h);
      }), u && this.cache.removeOptimistic(u), d;
    }, e.prototype.fetchQueryByPolicy = function(t, r, n) {
      var i = this, a = r.query, o = r.variables, s = r.fetchPolicy, u = r.refetchWritePolicy, l = r.errorPolicy, c = r.returnPartialData, d = r.context, f = r.notifyOnNetworkStatusChange, h = t.networkStatus;
      t.init({
        document: a,
        variables: o,
        networkStatus: n
      });
      var p = function() {
        return t.getDiff();
      }, v = function(D, S) {
        S === void 0 && (S = t.networkStatus || Ce.loading);
        var T = D.result;
        globalThis.__DEV__ !== !1 && !c && !Te(T, {}) && Tv(D.missing);
        var B = function(y) {
          return ke.of(M({ data: y, loading: ya(S), networkStatus: S }, D.complete ? null : { partial: !0 }));
        };
        return T && i.getDocumentInfo(a).hasForcedResolvers ? i.localState.runResolvers({
          document: a,
          remoteResult: { data: T },
          context: d,
          variables: o,
          onlyRunForcedResolvers: !0
        }).then(function(y) {
          return B(y.data || void 0);
        }) : l === "none" && S === Ce.refetch && Array.isArray(D.missing) ? B(void 0) : B(T);
      }, g = s === "no-cache" ? 0 : n === Ce.refetch && u !== "merge" ? 1 : 2, $ = function() {
        return i.getResultsFromLink(t, g, {
          query: a,
          variables: o,
          context: d,
          fetchPolicy: s,
          errorPolicy: l
        });
      }, m = f && typeof h == "number" && h !== n && ya(n);
      switch (s) {
        default:
        case "cache-first": {
          var b = p();
          return b.complete ? {
            fromLink: !1,
            sources: [v(b, t.markReady())]
          } : c || m ? {
            fromLink: !0,
            sources: [v(b), $()]
          } : { fromLink: !0, sources: [$()] };
        }
        case "cache-and-network": {
          var b = p();
          return b.complete || c || m ? {
            fromLink: !0,
            sources: [v(b), $()]
          } : { fromLink: !0, sources: [$()] };
        }
        case "cache-only":
          return {
            fromLink: !1,
            sources: [v(p(), t.markReady())]
          };
        case "network-only":
          return m ? {
            fromLink: !0,
            sources: [v(p()), $()]
          } : { fromLink: !0, sources: [$()] };
        case "no-cache":
          return m ? {
            fromLink: !0,
            // Note that queryInfo.getDiff() for no-cache queries does not call
            // cache.diff, but instead returns a { complete: false } stub result
            // when there is no queryInfo.diff already defined.
            sources: [v(t.getDiff()), $()]
          } : { fromLink: !0, sources: [$()] };
        case "standby":
          return { fromLink: !1, sources: [] };
      }
    }, e.prototype.getQuery = function(t) {
      return t && !this.queries.has(t) && this.queries.set(t, new Bu(this, t)), this.queries.get(t);
    }, e.prototype.prepareContext = function(t) {
      t === void 0 && (t = {});
      var r = this.localState.prepareContext(t);
      return M(M(M({}, this.defaultContext), r), { clientAwareness: this.clientAwareness });
    }, e;
  }()
), bh = !1, md = (
  /** @class */
  function() {
    function e(t) {
      var r = this;
      if (this.resetStoreCallbacks = [], this.clearStoreCallbacks = [], !t.cache)
        throw ht(15);
      var n = t.uri, i = t.credentials, a = t.headers, o = t.cache, s = t.documentTransform, u = t.ssrMode, l = u === void 0 ? !1 : u, c = t.ssrForceFetchDelay, d = c === void 0 ? 0 : c, f = t.connectToDevTools, h = f === void 0 ? typeof window == "object" && !window.__APOLLO_CLIENT__ && globalThis.__DEV__ !== !1 : f, p = t.queryDeduplication, v = p === void 0 ? !0 : p, g = t.defaultOptions, $ = t.defaultContext, m = t.assumeImmutableResults, b = m === void 0 ? o.assumeImmutableResults : m, D = t.resolvers, S = t.typeDefs, T = t.fragmentMatcher, B = t.name, y = t.version, _ = t.link;
      _ || (_ = n ? new N2({ uri: n, credentials: i, headers: a }) : qt.empty()), this.link = _, this.cache = o, this.disableNetworkFetches = l || d > 0, this.queryDeduplication = v, this.defaultOptions = g || /* @__PURE__ */ Object.create(null), this.typeDefs = S, d && setTimeout(function() {
        return r.disableNetworkFetches = !1;
      }, d), this.watchQuery = this.watchQuery.bind(this), this.query = this.query.bind(this), this.mutate = this.mutate.bind(this), this.watchFragment = this.watchFragment.bind(this), this.resetStore = this.resetStore.bind(this), this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this), this.version = Uc, this.localState = new Av({
        cache: o,
        client: this,
        resolvers: D,
        fragmentMatcher: T
      }), this.queryManager = new lE({
        cache: this.cache,
        link: this.link,
        defaultOptions: this.defaultOptions,
        defaultContext: $,
        documentTransform: s,
        queryDeduplication: v,
        ssrMode: l,
        clientAwareness: {
          name: B,
          version: y
        },
        localState: this.localState,
        assumeImmutableResults: b,
        onBroadcast: h ? function() {
          r.devToolsHookCb && r.devToolsHookCb({
            action: {},
            state: {
              queries: r.queryManager.getQueryStore(),
              mutations: r.queryManager.mutationStore || {}
            },
            dataWithOptimisticResults: r.cache.extract(!0)
          });
        } : void 0
      }), h && this.connectToDevTools();
    }
    return e.prototype.connectToDevTools = function() {
      if (typeof window == "object") {
        var t = window, r = Symbol.for("apollo.devtools");
        (t[r] = t[r] || []).push(this), t.__APOLLO_CLIENT__ = this;
      }
      !bh && globalThis.__DEV__ !== !1 && (bh = !0, setTimeout(function() {
        if (typeof window < "u" && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__ && /^(https?|file):$/.test(window.location.protocol)) {
          var n = window.navigator, i = n && n.userAgent, a = void 0;
          typeof i == "string" && (i.indexOf("Chrome/") > -1 ? a = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm" : i.indexOf("Firefox/") > -1 && (a = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/")), a && globalThis.__DEV__ !== !1 && ue.log("Download the Apollo DevTools for a better development experience: %s", a);
        }
      }, 1e4));
    }, Object.defineProperty(e.prototype, "documentTransform", {
      /**
       * The `DocumentTransform` used to modify GraphQL documents before a request
       * is made. If a custom `DocumentTransform` is not provided, this will be the
       * default document transform.
       */
      get: function() {
        return this.queryManager.documentTransform;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.stop = function() {
      this.queryManager.stop();
    }, e.prototype.watchQuery = function(t) {
      return this.defaultOptions.watchQuery && (t = Xi(this.defaultOptions.watchQuery, t)), this.disableNetworkFetches && (t.fetchPolicy === "network-only" || t.fetchPolicy === "cache-and-network") && (t = M(M({}, t), { fetchPolicy: "cache-first" })), this.queryManager.watchQuery(t);
    }, e.prototype.query = function(t) {
      return this.defaultOptions.query && (t = Xi(this.defaultOptions.query, t)), ue(t.fetchPolicy !== "cache-and-network", 16), this.disableNetworkFetches && t.fetchPolicy === "network-only" && (t = M(M({}, t), { fetchPolicy: "cache-first" })), this.queryManager.query(t);
    }, e.prototype.mutate = function(t) {
      return this.defaultOptions.mutate && (t = Xi(this.defaultOptions.mutate, t)), this.queryManager.mutate(t);
    }, e.prototype.subscribe = function(t) {
      return this.queryManager.startGraphQLSubscription(t);
    }, e.prototype.readQuery = function(t, r) {
      return r === void 0 && (r = !1), this.cache.readQuery(t, r);
    }, e.prototype.watchFragment = function(t) {
      return this.cache.watchFragment(t);
    }, e.prototype.readFragment = function(t, r) {
      return r === void 0 && (r = !1), this.cache.readFragment(t, r);
    }, e.prototype.writeQuery = function(t) {
      var r = this.cache.writeQuery(t);
      return t.broadcast !== !1 && this.queryManager.broadcastQueries(), r;
    }, e.prototype.writeFragment = function(t) {
      var r = this.cache.writeFragment(t);
      return t.broadcast !== !1 && this.queryManager.broadcastQueries(), r;
    }, e.prototype.__actionHookForDevTools = function(t) {
      this.devToolsHookCb = t;
    }, e.prototype.__requestRaw = function(t) {
      return Rl(this.link, t);
    }, e.prototype.resetStore = function() {
      var t = this;
      return Promise.resolve().then(function() {
        return t.queryManager.clearStore({
          discardWatches: !1
        });
      }).then(function() {
        return Promise.all(t.resetStoreCallbacks.map(function(r) {
          return r();
        }));
      }).then(function() {
        return t.reFetchObservableQueries();
      });
    }, e.prototype.clearStore = function() {
      var t = this;
      return Promise.resolve().then(function() {
        return t.queryManager.clearStore({
          discardWatches: !0
        });
      }).then(function() {
        return Promise.all(t.clearStoreCallbacks.map(function(r) {
          return r();
        }));
      });
    }, e.prototype.onResetStore = function(t) {
      var r = this;
      return this.resetStoreCallbacks.push(t), function() {
        r.resetStoreCallbacks = r.resetStoreCallbacks.filter(function(n) {
          return n !== t;
        });
      };
    }, e.prototype.onClearStore = function(t) {
      var r = this;
      return this.clearStoreCallbacks.push(t), function() {
        r.clearStoreCallbacks = r.clearStoreCallbacks.filter(function(n) {
          return n !== t;
        });
      };
    }, e.prototype.reFetchObservableQueries = function(t) {
      return this.queryManager.reFetchObservableQueries(t);
    }, e.prototype.refetchQueries = function(t) {
      var r = this.queryManager.refetchQueries(t), n = [], i = [];
      r.forEach(function(o, s) {
        n.push(s), i.push(o);
      });
      var a = Promise.all(i);
      return a.queries = n, a.results = i, a.catch(function(o) {
        globalThis.__DEV__ !== !1 && ue.debug(17, o);
      }), a;
    }, e.prototype.getObservableQueries = function(t) {
      return t === void 0 && (t = "active"), this.queryManager.getObservableQueries(t);
    }, e.prototype.extract = function(t) {
      return this.cache.extract(t);
    }, e.prototype.restore = function(t) {
      return this.cache.restore(t);
    }, e.prototype.addResolvers = function(t) {
      this.localState.addResolvers(t);
    }, e.prototype.setResolvers = function(t) {
      this.localState.setResolvers(t);
    }, e.prototype.getResolvers = function() {
      return this.localState.getResolvers();
    }, e.prototype.setLocalStateFragmentMatcher = function(t) {
      this.localState.setFragmentMatcher(t);
    }, e.prototype.setLink = function(t) {
      this.link = this.queryManager.link = t;
    }, Object.defineProperty(e.prototype, "defaultContext", {
      get: function() {
        return this.queryManager.defaultContext;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }()
);
globalThis.__DEV__ !== !1 && (md.prototype.getMemoryInternals = n5);
var Ao = /* @__PURE__ */ new Map(), Kl = /* @__PURE__ */ new Map(), _v = !0, Uo = !1;
function Fv(e) {
  return e.replace(/[\s,]+/g, " ").trim();
}
function cE(e) {
  return Fv(e.source.body.substring(e.start, e.end));
}
function dE(e) {
  var t = /* @__PURE__ */ new Set(), r = [];
  return e.definitions.forEach(function(n) {
    if (n.kind === "FragmentDefinition") {
      var i = n.name.value, a = cE(n.loc), o = Kl.get(i);
      o && !o.has(a) ? _v && console.warn("Warning: fragment with name " + i + ` already exists.
graphql-tag enforces all fragment names across your application to be unique; read more about
this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names`) : o || Kl.set(i, o = /* @__PURE__ */ new Set()), o.add(a), t.has(a) || (t.add(a), r.push(n));
    } else
      r.push(n);
  }), M(M({}, e), { definitions: r });
}
function fE(e) {
  var t = new Set(e.definitions);
  t.forEach(function(n) {
    n.loc && delete n.loc, Object.keys(n).forEach(function(i) {
      var a = n[i];
      a && typeof a == "object" && t.add(a);
    });
  });
  var r = e.loc;
  return r && (delete r.startToken, delete r.endToken), e;
}
function hE(e) {
  var t = Fv(e);
  if (!Ao.has(t)) {
    var r = TD(e, {
      experimentalFragmentVariables: Uo,
      allowLegacyFragmentVariables: Uo
    });
    if (!r || r.kind !== "Document")
      throw new Error("Not a valid GraphQL document.");
    Ao.set(t, fE(dE(r)));
  }
  return Ao.get(t);
}
function er(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  typeof e == "string" && (e = [e]);
  var n = e[0];
  return t.forEach(function(i, a) {
    i && i.kind === "Document" ? n += i.loc.source.body : n += i, n += e[a + 1];
  }), hE(n);
}
function pE() {
  Ao.clear(), Kl.clear();
}
function mE() {
  _v = !1;
}
function vE() {
  Uo = !0;
}
function yE() {
  Uo = !1;
}
var Ii = {
  gql: er,
  resetCaches: pE,
  disableFragmentWarnings: mE,
  enableExperimentalFragmentVariables: vE,
  disableExperimentalFragmentVariables: yE
};
(function(e) {
  e.gql = Ii.gql, e.resetCaches = Ii.resetCaches, e.disableFragmentWarnings = Ii.disableFragmentWarnings, e.enableExperimentalFragmentVariables = Ii.enableExperimentalFragmentVariables, e.disableExperimentalFragmentVariables = Ii.disableExperimentalFragmentVariables;
})(er || (er = {}));
er.default = er;
function Ov(e) {
  return new qt(function(t, r) {
    var n = Kt(t, []);
    return new ke(function(i) {
      var a, o = !1;
      return Promise.resolve(n).then(function(s) {
        return e(s, t.getContext());
      }).then(t.setContext).then(function() {
        o || (a = r(t).subscribe({
          next: i.next.bind(i),
          error: i.error.bind(i),
          complete: i.complete.bind(i)
        }));
      }).catch(i.error.bind(i)), function() {
        o = !0, a && a.unsubscribe();
      };
    });
  });
}
function vd(e) {
  return new qt(function(t, r) {
    return new ke(function(n) {
      var i, a, o;
      try {
        i = r(t).subscribe({
          next: function(s) {
            if (s.errors && (o = e({
              graphQLErrors: s.errors,
              response: s,
              operation: t,
              forward: r
            }), o)) {
              a = o.subscribe({
                next: n.next.bind(n),
                error: n.error.bind(n),
                complete: n.complete.bind(n)
              });
              return;
            }
            n.next(s);
          },
          error: function(s) {
            if (o = e({
              operation: t,
              networkError: s,
              //Network errors can return GraphQL errors on for example a 403
              graphQLErrors: s && s.result && s.result.errors || void 0,
              forward: r
            }), o) {
              a = o.subscribe({
                next: n.next.bind(n),
                error: n.error.bind(n),
                complete: n.complete.bind(n)
              });
              return;
            }
            n.error(s);
          },
          complete: function() {
            o || n.complete.bind(n)();
          }
        });
      } catch (s) {
        e({ networkError: s, operation: t, forward: r }), n.error(s);
      }
      return function() {
        i && i.unsubscribe(), a && i.unsubscribe();
      };
    });
  });
}
(function(e) {
  Ut(t, e);
  function t(r) {
    var n = e.call(this) || this;
    return n.link = vd(r), n;
  }
  return t.prototype.request = function(r, n) {
    return this.link.request(r, n);
  }, t;
})(qt);
function gE(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Iv = { exports: {} };
(function(e) {
  e.exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = void 0, e.exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0, e.exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0, Object.assign(e.exports, P);
})(Iv);
var Ze = Iv.exports;
const bE = /* @__PURE__ */ gE(Ze), Rv = /* @__PURE__ */ rx({
  __proto__: null,
  default: bE
}, [Ze]);
var $h = Zc ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
function Bv() {
  ue("createContext" in Rv, 45);
  var e = Ze.createContext[$h];
  return e || (Object.defineProperty(Ze.createContext, $h, {
    value: e = Ze.createContext({}),
    enumerable: !1,
    writable: !1,
    configurable: !0
  }), e.displayName = "ApolloContext"), e;
}
function yd(e) {
  var t = Ze.useContext(Bv()), r = e || t.client;
  return ue(!!r, 49), r;
}
var xh = !1, $E = "useSyncExternalStore", xE = Rv[$E], DE = xE || function(e, t, r) {
  var n = t();
  // DEVIATION: Using __DEV__
  globalThis.__DEV__ !== !1 && !xh && // DEVIATION: Not using Object.is because we know our snapshots will never
  // be exotic primitive values like NaN, which is !== itself.
  n !== t() && (xh = !0, globalThis.__DEV__ !== !1 && ue.error(58));
  var i = Ze.useState({
    inst: { value: n, getSnapshot: t }
  }), a = i[0].inst, o = i[1];
  return WD ? Ze.useLayoutEffect(function() {
    Object.assign(a, { value: n, getSnapshot: t }), Mu(a) && o({ inst: a });
  }, [e, n, t]) : Object.assign(a, { value: n, getSnapshot: t }), Ze.useEffect(function() {
    return Mu(a) && o({ inst: a }), e(function() {
      Mu(a) && o({ inst: a });
    });
  }, [e]), n;
};
function Mu(e) {
  var t = e.value, r = e.getSnapshot;
  try {
    return t !== r();
  } catch {
    return !0;
  }
}
var Zt;
(function(e) {
  e[e.Query = 0] = "Query", e[e.Mutation = 1] = "Mutation", e[e.Subscription = 2] = "Subscription";
})(Zt || (Zt = {}));
var an;
function Dh(e) {
  var t;
  switch (e) {
    case Zt.Query:
      t = "Query";
      break;
    case Zt.Mutation:
      t = "Mutation";
      break;
    case Zt.Subscription:
      t = "Subscription";
      break;
  }
  return t;
}
function Mv(e) {
  an || (an = new Yc(
    Xt.parser || 1e3
    /* defaultCacheSizes.parser */
  ));
  var t = an.get(e);
  if (t)
    return t;
  var r, n, i;
  ue(!!e && !!e.kind, 60, e);
  for (var a = [], o = [], s = [], u = [], l = 0, c = e.definitions; l < c.length; l++) {
    var d = c[l];
    if (d.kind === "FragmentDefinition") {
      a.push(d);
      continue;
    }
    if (d.kind === "OperationDefinition")
      switch (d.operation) {
        case "query":
          o.push(d);
          break;
        case "mutation":
          s.push(d);
          break;
        case "subscription":
          u.push(d);
          break;
      }
  }
  ue(!a.length || o.length || s.length || u.length, 61), ue(
    o.length + s.length + u.length <= 1,
    62,
    e,
    o.length,
    u.length,
    s.length
  ), n = o.length ? Zt.Query : Zt.Mutation, !o.length && !s.length && (n = Zt.Subscription);
  var f = o.length ? o : s.length ? s : u;
  ue(f.length === 1, 63, e, f.length);
  var h = f[0];
  r = h.variableDefinitions || [], h.name && h.name.kind === "Name" ? i = h.name.value : i = "data";
  var p = { name: i, type: n, variables: r };
  return an.set(e, p), p;
}
Mv.resetCache = function() {
  an = void 0;
};
globalThis.__DEV__ !== !1 && Jc("parser", function() {
  return an ? an.size : 0;
});
function Nv(e, t) {
  var r = Mv(e), n = Dh(t), i = Dh(r.type);
  ue(
    r.type === t,
    64,
    n,
    n,
    i
  );
}
var EE = Am ? Ze.useLayoutEffect : Ze.useEffect, wE = Symbol.for("apollo.hook.wrappers");
function CE(e, t, r) {
  var n = r.queryManager, i = n && n[wE], a = i && i[e];
  return a ? a(t) : t;
}
var SE = Object.prototype.hasOwnProperty;
function kE(e, t) {
  return t === void 0 && (t = /* @__PURE__ */ Object.create(null)), CE("useQuery", PE, yd(t && t.client))(e, t);
}
function PE(e, t) {
  return TE(yd(t.client), e).useQuery(t);
}
function TE(e, t) {
  var r = Ze.useReducer(function(s) {
    return s + 1;
  }, 0)[1];
  function n(s) {
    return Object.assign(new AE(e, t, s), {
      forceUpdateState: r
    });
  }
  var i = Ze.useState(n), a = i[0], o = i[1];
  return (e !== a.client || t !== a.query) && o(a = n(a)), a;
}
var AE = (
  /** @class */
  function() {
    function e(t, r, n) {
      var i = this;
      this.client = t, this.query = r, this.forceUpdate = function() {
        return i.forceUpdateState();
      }, this.ssrDisabledResult = pa({
        loading: !0,
        data: void 0,
        error: void 0,
        networkStatus: Ce.loading
      }), this.skipStandbyResult = pa({
        loading: !1,
        data: void 0,
        error: void 0,
        networkStatus: Ce.ready
      }), this.toQueryResultCache = new (wn ? WeakMap : Map)(), Nv(r, Zt.Query);
      var a = n && n.result, o = a && a.data;
      o && (this.previousData = o);
    }
    return e.prototype.forceUpdateState = function() {
      globalThis.__DEV__ !== !1 && ue.warn(51);
    }, e.prototype.executeQuery = function(t) {
      var r = this, n;
      t.query && Object.assign(this, { query: t.query }), this.watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = t);
      var i = this.observable.reobserveAsConcast(this.getObsQueryOptions());
      return this.previousData = ((n = this.result) === null || n === void 0 ? void 0 : n.data) || this.previousData, this.result = void 0, this.forceUpdate(), new Promise(function(a) {
        var o;
        i.subscribe({
          next: function(s) {
            o = s;
          },
          error: function() {
            a(r.toQueryResult(r.observable.getCurrentResult()));
          },
          complete: function() {
            a(r.toQueryResult(o));
          }
        });
      });
    }, e.prototype.useQuery = function(t) {
      var r = this;
      this.renderPromises = Ze.useContext(Bv()).renderPromises, this.useOptions(t);
      var n = this.useObservableQuery(), i = DE(
        // eslint-disable-next-line react-hooks/rules-of-hooks
        Ze.useCallback(function(a) {
          if (r.renderPromises)
            return function() {
            };
          r.forceUpdate = a;
          var o = function() {
            var l = r.result, c = n.getCurrentResult();
            l && l.loading === c.loading && l.networkStatus === c.networkStatus && Te(l.data, c.data) || r.setResult(c);
          }, s = function(l) {
            if (u.unsubscribe(), u = n.resubscribeAfterError(o, s), !SE.call(l, "graphQLErrors"))
              throw l;
            var c = r.result;
            (!c || c && c.loading || !Te(l, c.error)) && r.setResult({
              data: c && c.data,
              error: l,
              loading: !1,
              networkStatus: Ce.error
            });
          }, u = n.subscribe(o, s);
          return function() {
            setTimeout(function() {
              return u.unsubscribe();
            }), r.forceUpdate = function() {
              return r.forceUpdateState();
            };
          };
        }, [
          // We memoize the subscribe function using useCallback and the following
          // dependency keys, because the subscribe function reference is all that
          // useSyncExternalStore uses internally as a dependency key for the
          // useEffect ultimately responsible for the subscription, so we are
          // effectively passing this dependency array to that useEffect buried
          // inside useSyncExternalStore, as desired.
          n,
          // eslint-disable-next-line react-hooks/exhaustive-deps
          this.renderPromises,
          // eslint-disable-next-line react-hooks/exhaustive-deps
          this.client.disableNetworkFetches
        ]),
        function() {
          return r.getCurrentResult();
        },
        function() {
          return r.getCurrentResult();
        }
      );
      return this.unsafeHandlePartialRefetch(i), this.toQueryResult(i);
    }, e.prototype.useOptions = function(t) {
      var r, n = this.createWatchQueryOptions(this.queryHookOptions = t), i = this.watchQueryOptions;
      Te(n, i) || (this.watchQueryOptions = n, i && this.observable && (this.observable.reobserve(this.getObsQueryOptions()), this.previousData = ((r = this.result) === null || r === void 0 ? void 0 : r.data) || this.previousData, this.result = void 0)), this.onCompleted = t.onCompleted || e.prototype.onCompleted, this.onError = t.onError || e.prototype.onError, (this.renderPromises || this.client.disableNetworkFetches) && this.queryHookOptions.ssr === !1 && !this.queryHookOptions.skip ? this.result = this.ssrDisabledResult : this.queryHookOptions.skip || this.watchQueryOptions.fetchPolicy === "standby" ? this.result = this.skipStandbyResult : (this.result === this.ssrDisabledResult || this.result === this.skipStandbyResult) && (this.result = void 0);
    }, e.prototype.getObsQueryOptions = function() {
      var t = [], r = this.client.defaultOptions.watchQuery;
      return r && t.push(r), this.queryHookOptions.defaultOptions && t.push(this.queryHookOptions.defaultOptions), t.push(hn(this.observable && this.observable.options, this.watchQueryOptions)), t.reduce(Xi);
    }, e.prototype.createWatchQueryOptions = function(t) {
      var r;
      t === void 0 && (t = {});
      var n = t.skip;
      t.ssr, t.onCompleted, t.onError, t.defaultOptions;
      var i = Kt(t, ["skip", "ssr", "onCompleted", "onError", "defaultOptions"]), a = Object.assign(i, { query: this.query });
      if (this.renderPromises && (a.fetchPolicy === "network-only" || a.fetchPolicy === "cache-and-network") && (a.fetchPolicy = "cache-first"), a.variables || (a.variables = {}), n) {
        var o = a.fetchPolicy, s = o === void 0 ? this.getDefaultFetchPolicy() : o, u = a.initialFetchPolicy, l = u === void 0 ? s : u;
        Object.assign(a, {
          initialFetchPolicy: l,
          fetchPolicy: "standby"
        });
      } else a.fetchPolicy || (a.fetchPolicy = ((r = this.observable) === null || r === void 0 ? void 0 : r.options.initialFetchPolicy) || this.getDefaultFetchPolicy());
      return a;
    }, e.prototype.getDefaultFetchPolicy = function() {
      var t, r;
      return ((t = this.queryHookOptions.defaultOptions) === null || t === void 0 ? void 0 : t.fetchPolicy) || ((r = this.client.defaultOptions.watchQuery) === null || r === void 0 ? void 0 : r.fetchPolicy) || "cache-first";
    }, e.prototype.onCompleted = function(t) {
    }, e.prototype.onError = function(t) {
    }, e.prototype.useObservableQuery = function() {
      var t = this.observable = this.renderPromises && this.renderPromises.getSSRObservable(this.watchQueryOptions) || this.observable || // Reuse this.observable if possible (and not SSR)
      this.client.watchQuery(this.getObsQueryOptions());
      this.obsQueryFields = Ze.useMemo(function() {
        return {
          refetch: t.refetch.bind(t),
          reobserve: t.reobserve.bind(t),
          fetchMore: t.fetchMore.bind(t),
          updateQuery: t.updateQuery.bind(t),
          startPolling: t.startPolling.bind(t),
          stopPolling: t.stopPolling.bind(t),
          subscribeToMore: t.subscribeToMore.bind(t)
        };
      }, [t]);
      var r = !(this.queryHookOptions.ssr === !1 || this.queryHookOptions.skip);
      return this.renderPromises && r && (this.renderPromises.registerSSRObservable(t), t.getCurrentResult().loading && this.renderPromises.addObservableQueryPromise(t)), t;
    }, e.prototype.setResult = function(t) {
      var r = this.result;
      r && r.data && (this.previousData = r.data), this.result = t, this.forceUpdate(), this.handleErrorOrCompleted(t, r);
    }, e.prototype.handleErrorOrCompleted = function(t, r) {
      var n = this;
      if (!t.loading) {
        var i = this.toApolloError(t);
        Promise.resolve().then(function() {
          i ? n.onError(i) : t.data && (r == null ? void 0 : r.networkStatus) !== t.networkStatus && t.networkStatus === Ce.ready && n.onCompleted(t.data);
        }).catch(function(a) {
          globalThis.__DEV__ !== !1 && ue.warn(a);
        });
      }
    }, e.prototype.toApolloError = function(t) {
      return Mt(t.errors) ? new cr({ graphQLErrors: t.errors }) : t.error;
    }, e.prototype.getCurrentResult = function() {
      return this.result || this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult()), this.result;
    }, e.prototype.toQueryResult = function(t) {
      var r = this.toQueryResultCache.get(t);
      if (r)
        return r;
      var n = t.data;
      t.partial;
      var i = Kt(t, ["data", "partial"]);
      return this.toQueryResultCache.set(t, r = M(M(M({ data: n }, i), this.obsQueryFields), { client: this.client, observable: this.observable, variables: this.observable.variables, called: !this.queryHookOptions.skip, previousData: this.previousData })), !r.error && Mt(t.errors) && (r.error = new cr({ graphQLErrors: t.errors })), r;
    }, e.prototype.unsafeHandlePartialRefetch = function(t) {
      t.partial && this.queryHookOptions.partialRefetch && !t.loading && (!t.data || Object.keys(t.data).length === 0) && this.observable.options.fetchPolicy !== "cache-only" && (Object.assign(t, {
        loading: !0,
        networkStatus: Ce.refetch
      }), this.observable.refetch());
    }, e;
  }()
);
function Lv(e, t) {
  var r = yd(t == null ? void 0 : t.client);
  Nv(e, Zt.Mutation);
  var n = Ze.useState({
    called: !1,
    loading: !1,
    client: r
  }), i = n[0], a = n[1], o = Ze.useRef({
    result: i,
    mutationId: 0,
    isMounted: !0,
    client: r,
    mutation: e,
    options: t
  });
  EE(function() {
    Object.assign(o.current, { client: r, options: t, mutation: e });
  });
  var s = Ze.useCallback(function(l) {
    l === void 0 && (l = {});
    var c = o.current, d = c.options, f = c.mutation, h = M(M({}, d), { mutation: f }), p = l.client || o.current.client;
    !o.current.result.loading && !h.ignoreResults && o.current.isMounted && a(o.current.result = {
      loading: !0,
      error: void 0,
      data: void 0,
      called: !0,
      client: p
    });
    var v = ++o.current.mutationId, g = Xi(h, l);
    return p.mutate(g).then(function($) {
      var m, b, D = $.data, S = $.errors, T = S && S.length > 0 ? new cr({ graphQLErrors: S }) : void 0, B = l.onError || ((m = o.current.options) === null || m === void 0 ? void 0 : m.onError);
      if (T && B && B(T, g), v === o.current.mutationId && !g.ignoreResults) {
        var y = {
          called: !0,
          loading: !1,
          data: D,
          error: T,
          client: p
        };
        o.current.isMounted && !Te(o.current.result, y) && a(o.current.result = y);
      }
      var _ = l.onCompleted || ((b = o.current.options) === null || b === void 0 ? void 0 : b.onCompleted);
      return T || _ == null || _($.data, g), $;
    }).catch(function($) {
      var m;
      if (v === o.current.mutationId && o.current.isMounted) {
        var b = {
          loading: !1,
          error: $,
          data: void 0,
          called: !0,
          client: p
        };
        Te(o.current.result, b) || a(o.current.result = b);
      }
      var D = l.onError || ((m = o.current.options) === null || m === void 0 ? void 0 : m.onError);
      if (D)
        return D($, g), { data: void 0, errors: $ };
      throw $;
    });
  }, []), u = Ze.useCallback(function() {
    if (o.current.isMounted) {
      var l = {
        called: !1,
        loading: !1,
        client: o.current.client
      };
      Object.assign(o.current, { mutationId: 0, result: l }), a(l);
    }
  }, []);
  return Ze.useEffect(function() {
    var l = o.current;
    return l.isMounted = !0, function() {
      l.isMounted = !1;
    };
  }, []), [s, M({ reset: u }, i)];
}
const _E = new pd();
async function FE({ mode: e, ownerId: t }) {
  const r = e === "development" ? oi.engageGraphqlDevEndpoint : oi.engageGraphqlEndpoint, n = hv({ uri: r }), i = Ov((s, { headers: u }) => {
    const l = hm({ ownerId: t }), c = l ? `Accounts ${l}` : "";
    return {
      headers: {
        ...u,
        authorization: c
      }
    };
  }), a = vd(({ networkError: s, operation: u, forward: l }) => {
    if (s && s.statusCode === 401)
      return console.log("Re-authenticating..."), new ke((c) => {
        Kc({ mode: e, ownerId: t }).then((d) => {
          u.setContext(({ headers: h }) => ({
            headers: {
              ...h,
              authorization: d ? `Accounts ${d}` : ""
            }
          }));
          const f = {
            next: c.next.bind(c),
            error: c.error.bind(c),
            complete: c.complete.bind(c)
          };
          l(u).subscribe(f);
        }).catch(c.error.bind(c));
      });
  });
  return new md({
    link: qt.from([a, i, n]),
    cache: _E
  });
}
const Vv = ce({
  apolloClient: null
});
function OE({ children: e, mode: t, ownerId: r }) {
  const [n, i] = ee(null);
  return oe(() => {
    async function a() {
      i(await FE({ mode: t, ownerId: r }));
    }
    a().catch(console.error);
  }, [t, r]), n ? /* @__PURE__ */ O(Vv.Provider, { value: { client: n }, children: e }) : /* @__PURE__ */ O("h2", { children: "Initializing..." });
}
function IE() {
  const e = le(Vv);
  if (!e)
    throw new Error("useEngage must be used within an EngageProvider");
  return e;
}
function RE(e, t = {}) {
  const { client: r } = IE();
  return Lv(e, { ...t, client: r });
}
const BE = new pd();
async function ME({ mode: e, ownerId: t }) {
  const r = e === "development" ? oi.accountsGraphqlDevEndpoint : oi.accountsGraphqlEndpoint, n = hv({ uri: r }), i = Ov((s, { headers: u }) => {
    const l = hm({ ownerId: t }), c = l ? `Bearer ${l}` : "";
    return {
      headers: {
        ...u,
        accept: "application/json",
        // Necessary to get a 401 instead of a redirect on auth errors.
        authorization: c
      }
    };
  }), a = vd(({ networkError: s, operation: u, forward: l }) => {
    if (s && s.statusCode === 401)
      return console.log("Re-authenticating..."), new ke((c) => {
        Kc({ mode: e, ownerId: t }).then((d) => {
          u.setContext(({ headers: h }) => ({
            headers: {
              ...h,
              authorization: d ? `Accounts ${d}` : ""
            }
          }));
          const f = {
            next: c.next.bind(c),
            error: c.error.bind(c),
            complete: c.complete.bind(c)
          };
          l(u).subscribe(f);
        }).catch(c.error.bind(c));
      });
  });
  return new md({
    link: qt.from([a, i, n]),
    cache: BE
  });
}
const zv = ce({
  apolloClient: null
});
function NE({ children: e, mode: t, ownerId: r }) {
  const [n, i] = ee(null);
  return oe(() => {
    async function a() {
      i(await ME({ mode: t, ownerId: r }));
    }
    a().catch(console.error);
  }, [t, r]), n ? /* @__PURE__ */ O(zv.Provider, { value: { client: n }, children: e }) : /* @__PURE__ */ O("h2", { children: "Initializing..." });
}
function jv() {
  const e = le(zv);
  if (!e)
    throw new Error("useAccounts must be used within an AccountsProvider");
  return e;
}
function LE(e, t = {}) {
  const { client: r } = jv();
  return Lv(e, { ...t, client: r });
}
function gd(e, t = {}) {
  const { client: r } = jv();
  return kE(e, { ...t, client: r });
}
const Kv = ce({}), VE = () => le(Kv);
function zE({ children: e, options: t = {} }) {
  return t.isProd = t.mode === "production", t.isDev = !t.isProd, /* @__PURE__ */ O(Kv.Provider, { value: t, children: e });
}
function TT({
  ownerId: e,
  senalysisBusinessId: t,
  spilloverBusinessId: r,
  children: n,
  mode: i = "production"
}) {
  return /* @__PURE__ */ O(zE, { options: {
    mode: i,
    ownerId: e,
    senalysisBusinessId: t,
    spilloverBusinessId: r
  }, children: /* @__PURE__ */ O(Qx, { mode: i, ownerId: e, children: /* @__PURE__ */ O(NE, { mode: i, ownerId: e, children: /* @__PURE__ */ O(OE, { mode: i, ownerId: e, children: /* @__PURE__ */ pe(
    "div",
    {
      className: "sfs-isolate",
      style: { height: "100%", width: "100%" },
      children: [
        n,
        /* @__PURE__ */ O(px, {})
      ]
    }
  ) }) }) }) });
}
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const jE = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), Uv = (...e) => e.filter((t, r, n) => !!t && n.indexOf(t) === r).join(" ");
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var KE = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const UE = xe(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: r = 2,
    absoluteStrokeWidth: n,
    className: i = "",
    children: a,
    iconNode: o,
    ...s
  }, u) => vl(
    "svg",
    {
      ref: u,
      ...KE,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: n ? Number(r) * 24 / Number(t) : r,
      className: Uv("lucide", i),
      ...s
    },
    [
      ...o.map(([l, c]) => vl(l, c)),
      ...Array.isArray(a) ? a : [a]
    ]
  )
);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ne = (e, t) => {
  const r = xe(
    ({ className: n, ...i }, a) => vl(UE, {
      ref: a,
      iconNode: t,
      className: Uv(`lucide-${jE(e)}`, n),
      ...i
    })
  );
  return r.displayName = `${e}`, r;
};
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const qE = Ne("BookA", [
  ["path", { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20", key: "t4utmx" }],
  ["path", { d: "m8 13 4-7 4 7", key: "4rari8" }],
  ["path", { d: "M9.1 11h5.7", key: "1gkovt" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const HE = Ne("Calendar", [
  ["path", { d: "M8 2v4", key: "1cmpym" }],
  ["path", { d: "M16 2v4", key: "4m81vk" }],
  ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
  ["path", { d: "M3 10h18", key: "8toen8" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const WE = Ne("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const qv = Ne("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ul = Ne("ChevronLeft", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Eh = Ne("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const QE = Ne("CircleMinus", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M8 12h8", key: "1wcyev" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const GE = Ne("CirclePlus", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M8 12h8", key: "1wcyev" }],
  ["path", { d: "M12 8v8", key: "napkw2" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ZE = Ne("Ellipsis", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const YE = Ne("Feather", [
  [
    "path",
    {
      d: "M12.67 19a2 2 0 0 0 1.416-.588l6.154-6.172a6 6 0 0 0-8.49-8.49L5.586 9.914A2 2 0 0 0 5 11.328V18a1 1 0 0 0 1 1z",
      key: "18jl4k"
    }
  ],
  ["path", { d: "M16 8 2 22", key: "vp34q" }],
  ["path", { d: "M17.5 15H9", key: "1oz8nu" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const JE = Ne("FileDown", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M12 18v-6", key: "17g6i2" }],
  ["path", { d: "m9 15 3 3 3-3", key: "1npd3o" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const wh = Ne("FileText", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const XE = Ne("HeartHandshake", [
  [
    "path",
    {
      d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z",
      key: "c3ymky"
    }
  ],
  [
    "path",
    {
      d: "M12 5 9.04 7.96a2.17 2.17 0 0 0 0 3.08c.82.82 2.13.85 3 .07l2.07-1.9a2.82 2.82 0 0 1 3.79 0l2.96 2.66",
      key: "4oyue0"
    }
  ],
  ["path", { d: "m18 15-2-2", key: "60u0ii" }],
  ["path", { d: "m15 18-2-2", key: "6p76be" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const e6 = Ne("Languages", [
  ["path", { d: "m5 8 6 6", key: "1wu5hv" }],
  ["path", { d: "m4 14 6-6 2-3", key: "1k1g8d" }],
  ["path", { d: "M2 5h12", key: "or177f" }],
  ["path", { d: "M7 2h1", key: "1t2jsx" }],
  ["path", { d: "m22 22-5-10-5 10", key: "don7ne" }],
  ["path", { d: "M14 18h6", key: "1m8k6r" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const t6 = Ne("Laugh", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M18 13a6 6 0 0 1-6 5 6 6 0 0 1-6-5h12Z", key: "b2q4dd" }],
  ["line", { x1: "9", x2: "9.01", y1: "9", y2: "9", key: "yxxnd0" }],
  ["line", { x1: "15", x2: "15.01", y1: "9", y2: "9", key: "1p4y9e" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const r6 = Ne("List", [
  ["line", { x1: "8", x2: "21", y1: "6", y2: "6", key: "7ey8pc" }],
  ["line", { x1: "8", x2: "21", y1: "12", y2: "12", key: "rjfblc" }],
  ["line", { x1: "8", x2: "21", y1: "18", y2: "18", key: "c3b1m8" }],
  ["line", { x1: "3", x2: "3.01", y1: "6", y2: "6", key: "1g7gq3" }],
  ["line", { x1: "3", x2: "3.01", y1: "12", y2: "12", key: "1pjlvk" }],
  ["line", { x1: "3", x2: "3.01", y1: "18", y2: "18", key: "28t2mc" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Hv = Ne("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const n6 = Ne("Loader", [
  ["path", { d: "M12 2v4", key: "3427ic" }],
  ["path", { d: "m16.2 7.8 2.9-2.9", key: "r700ao" }],
  ["path", { d: "M18 12h4", key: "wj9ykh" }],
  ["path", { d: "m16.2 16.2 2.9 2.9", key: "1bxg5t" }],
  ["path", { d: "M12 18v4", key: "jadmvz" }],
  ["path", { d: "m4.9 19.1 2.9-2.9", key: "bwix9q" }],
  ["path", { d: "M2 12h4", key: "j09sii" }],
  ["path", { d: "m4.9 4.9 2.9 2.9", key: "giyufr" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const i6 = Ne("MailCheck", [
  ["path", { d: "M22 13V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h8", key: "12jkf8" }],
  ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }],
  ["path", { d: "m16 19 2 2 4-4", key: "1b14m6" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const a6 = Ne("RefreshCw", [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const o6 = Ne("Reply", [
  ["polyline", { points: "9 17 4 12 9 7", key: "hvgpf2" }],
  ["path", { d: "M20 18v-2a4 4 0 0 0-4-4H4", key: "5vmcpk" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const s6 = Ne("SmilePlus", [
  ["path", { d: "M22 11v1a10 10 0 1 1-9-10", key: "ew0xw9" }],
  ["path", { d: "M8 14s1.5 2 4 2 4-2 4-2", key: "1y1vjs" }],
  ["line", { x1: "9", x2: "9.01", y1: "9", y2: "9", key: "yxxnd0" }],
  ["line", { x1: "15", x2: "15.01", y1: "9", y2: "9", key: "1p4y9e" }],
  ["path", { d: "M16 5h6", key: "1vod17" }],
  ["path", { d: "M19 2v6", key: "4bpg5p" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const u6 = Ne("SpellCheck", [
  ["path", { d: "m6 16 6-12 6 12", key: "1b4byz" }],
  ["path", { d: "M8 12h8", key: "1wcyev" }],
  ["path", { d: "m16 20 2 2 4-4", key: "13tcca" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const l6 = Ne("Star", [
  [
    "polygon",
    {
      points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2",
      key: "8f66p6"
    }
  ]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ks = Ne("WandSparkles", [
  [
    "path",
    {
      d: "m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72",
      key: "ul74o6"
    }
  ],
  ["path", { d: "m14 7 3 3", key: "1r5n42" }],
  ["path", { d: "M5 6v4", key: "ilb8ba" }],
  ["path", { d: "M19 14v4", key: "blhpug" }],
  ["path", { d: "M10 2v2", key: "7u0qdc" }],
  ["path", { d: "M7 8H3", key: "zfb6yr" }],
  ["path", { d: "M21 16h-4", key: "1cnmox" }],
  ["path", { d: "M11 3H9", key: "1obp7u" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Wv = Ne("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), Qv = ce({
  currentScreen: null
});
function bd() {
  const e = le(Qv);
  if (!e)
    throw new Error("useMiniApp must be used within a MiniAppProvider");
  return e;
}
function c6({ onCloseButtonClick: e, children: t }) {
  const [r, n] = ee(null), i = () => n(null);
  return /* @__PURE__ */ O(
    Qv.Provider,
    {
      value: { currentScreen: r, setCurrentScreen: n, goHome: i, onCloseButtonClick: e },
      children: t
    }
  );
}
ce(null);
ce(null);
ce(null);
ce(null);
ce(null);
const Us = ce({}), Re = typeof document < "u" ? P.useLayoutEffect : () => {
};
function lt(e) {
  const t = q(null);
  return Re(() => {
    t.current = e;
  }, [
    e
  ]), be((...r) => {
    const n = t.current;
    return n == null ? void 0 : n(...r);
  }, []);
}
function d6(e) {
  let [t, r] = ee(e), n = q(null), i = lt(() => {
    if (!n.current) return;
    let o = n.current.next();
    if (o.done) {
      n.current = null;
      return;
    }
    t === o.value ? i() : r(o.value);
  });
  Re(() => {
    n.current && i();
  });
  let a = lt((o) => {
    n.current = o(t), i();
  });
  return [
    t,
    a
  ];
}
const qo = {
  prefix: String(Math.round(Math.random() * 1e10)),
  current: 0
}, Gv = /* @__PURE__ */ P.createContext(qo), f6 = /* @__PURE__ */ P.createContext(!1);
let h6 = !!(typeof window < "u" && window.document && window.document.createElement), Nu = /* @__PURE__ */ new WeakMap();
function p6(e = !1) {
  let t = le(Gv), r = q(null);
  if (r.current === null && !e) {
    var n, i;
    let a = (i = P.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || i === void 0 || (n = i.ReactCurrentOwner) === null || n === void 0 ? void 0 : n.current;
    if (a) {
      let o = Nu.get(a);
      o == null ? Nu.set(a, {
        id: t.current,
        state: a.memoizedState
      }) : a.memoizedState !== o.state && (t.current = o.id, Nu.delete(a));
    }
    r.current = ++t.current;
  }
  return r.current;
}
function m6(e) {
  let t = le(Gv);
  t === qo && !h6 && console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
  let r = p6(!!e), n = t === qo && process.env.NODE_ENV === "test" ? "react-aria" : `react-aria${t.prefix}`;
  return e || `${n}-${r}`;
}
function v6(e) {
  let t = P.useId(), [r] = ee(wr()), n = r || process.env.NODE_ENV === "test" ? "react-aria" : `react-aria${qo.prefix}`;
  return e || `${n}-${t}`;
}
const y6 = typeof P.useId == "function" ? v6 : m6;
function g6() {
  return !1;
}
function b6() {
  return !0;
}
function $6(e) {
  return () => {
  };
}
function wr() {
  return typeof P.useSyncExternalStore == "function" ? P.useSyncExternalStore($6, g6, b6) : le(f6);
}
let x6 = !!(typeof window < "u" && window.document && window.document.createElement), Ho = /* @__PURE__ */ new Map();
function kt(e) {
  let [t, r] = ee(e), n = q(null), i = y6(t), a = be((o) => {
    n.current = o;
  }, []);
  return x6 && Ho.set(i, a), Re(() => {
    let o = i;
    return () => {
      Ho.delete(o);
    };
  }, [
    i
  ]), oe(() => {
    let o = n.current;
    o && (n.current = null, r(o));
  }), i;
}
function D6(e, t) {
  if (e === t) return e;
  let r = Ho.get(e);
  if (r)
    return r(t), t;
  let n = Ho.get(t);
  return n ? (n(e), e) : t;
}
function di(e = []) {
  let t = kt(), [r, n] = d6(t), i = be(() => {
    n(function* () {
      yield t, yield document.getElementById(t) ? t : void 0;
    });
  }, [
    t,
    n
  ]);
  return Re(i, [
    t,
    i,
    ...e
  ]), r;
}
function Hr(...e) {
  return (...t) => {
    for (let r of e) typeof r == "function" && r(...t);
  };
}
const Be = (e) => {
  var t;
  return (t = e == null ? void 0 : e.ownerDocument) !== null && t !== void 0 ? t : document;
}, It = (e) => e && "window" in e && e.window === e ? e : Be(e).defaultView || window;
function ve(...e) {
  let t = {
    ...e[0]
  };
  for (let r = 1; r < e.length; r++) {
    let n = e[r];
    for (let i in n) {
      let a = t[i], o = n[i];
      typeof a == "function" && typeof o == "function" && // This is a lot faster than a regex.
      i[0] === "o" && i[1] === "n" && i.charCodeAt(2) >= /* 'A' */
      65 && i.charCodeAt(2) <= /* 'Z' */
      90 ? t[i] = Hr(a, o) : (i === "className" || i === "UNSAFE_className") && typeof a == "string" && typeof o == "string" ? t[i] = fr(a, o) : i === "id" && a && o ? t.id = D6(a, o) : t[i] = o !== void 0 ? o : a;
    }
  }
  return t;
}
function $d(...e) {
  return e.length === 1 ? e[0] : (t) => {
    for (let r of e)
      typeof r == "function" ? r(t) : r != null && (r.current = t);
  };
}
const E6 = /* @__PURE__ */ new Set([
  "id"
]), w6 = /* @__PURE__ */ new Set([
  "aria-label",
  "aria-labelledby",
  "aria-describedby",
  "aria-details"
]), C6 = /* @__PURE__ */ new Set([
  "href",
  "hrefLang",
  "target",
  "rel",
  "download",
  "ping",
  "referrerPolicy"
]), S6 = /^(data-.*)$/;
function _e(e, t = {}) {
  let { labelable: r, isLink: n, propNames: i } = t, a = {};
  for (const o in e) Object.prototype.hasOwnProperty.call(e, o) && (E6.has(o) || r && w6.has(o) || n && C6.has(o) || i != null && i.has(o) || S6.test(o)) && (a[o] = e[o]);
  return a;
}
function Wt(e) {
  if (k6()) e.focus({
    preventScroll: !0
  });
  else {
    let t = P6(e);
    e.focus(), T6(t);
  }
}
let uo = null;
function k6() {
  if (uo == null) {
    uo = !1;
    try {
      document.createElement("div").focus({
        get preventScroll() {
          return uo = !0, !0;
        }
      });
    } catch {
    }
  }
  return uo;
}
function P6(e) {
  let t = e.parentNode, r = [], n = document.scrollingElement || document.documentElement;
  for (; t instanceof HTMLElement && t !== n; )
    (t.offsetHeight < t.scrollHeight || t.offsetWidth < t.scrollWidth) && r.push({
      element: t,
      scrollTop: t.scrollTop,
      scrollLeft: t.scrollLeft
    }), t = t.parentNode;
  return n instanceof HTMLElement && r.push({
    element: n,
    scrollTop: n.scrollTop,
    scrollLeft: n.scrollLeft
  }), r;
}
function T6(e) {
  for (let { element: t, scrollTop: r, scrollLeft: n } of e)
    t.scrollTop = r, t.scrollLeft = n;
}
function qs(e) {
  var t;
  return typeof window > "u" || window.navigator == null ? !1 : ((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.brands.some((r) => e.test(r.brand))) || e.test(window.navigator.userAgent);
}
function xd(e) {
  var t;
  return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
}
function gr() {
  return xd(/^Mac/i);
}
function A6() {
  return xd(/^iPhone/i);
}
function Zv() {
  return xd(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  gr() && navigator.maxTouchPoints > 1;
}
function Na() {
  return A6() || Zv();
}
function _o() {
  return gr() || Na();
}
function Dd() {
  return qs(/AppleWebKit/i) && !_6();
}
function _6() {
  return qs(/Chrome/i);
}
function Yv() {
  return qs(/Android/i);
}
function F6() {
  return qs(/Firefox/i);
}
const O6 = /* @__PURE__ */ ce({
  isNative: !0,
  open: R6,
  useHref: (e) => e
});
function Hs() {
  return le(O6);
}
function pn(e, t, r = !0) {
  var n, i;
  let { metaKey: a, ctrlKey: o, altKey: s, shiftKey: u } = t;
  F6() && (!((i = window.event) === null || i === void 0 || (n = i.type) === null || n === void 0) && n.startsWith("key")) && e.target === "_blank" && (gr() ? a = !0 : o = !0);
  let l = Dd() && gr() && !Zv() ? new KeyboardEvent("keydown", {
    keyIdentifier: "Enter",
    metaKey: a,
    ctrlKey: o,
    altKey: s,
    shiftKey: u
  }) : new MouseEvent("click", {
    metaKey: a,
    ctrlKey: o,
    altKey: s,
    shiftKey: u,
    bubbles: !0,
    cancelable: !0
  });
  pn.isOpening = r, Wt(e), e.dispatchEvent(l), pn.isOpening = !1;
}
pn.isOpening = !1;
function I6(e, t) {
  if (e instanceof HTMLAnchorElement) t(e);
  else if (e.hasAttribute("data-href")) {
    let r = document.createElement("a");
    r.href = e.getAttribute("data-href"), e.hasAttribute("data-target") && (r.target = e.getAttribute("data-target")), e.hasAttribute("data-rel") && (r.rel = e.getAttribute("data-rel")), e.hasAttribute("data-download") && (r.download = e.getAttribute("data-download")), e.hasAttribute("data-ping") && (r.ping = e.getAttribute("data-ping")), e.hasAttribute("data-referrer-policy") && (r.referrerPolicy = e.getAttribute("data-referrer-policy")), e.appendChild(r), t(r), e.removeChild(r);
  }
}
function R6(e, t) {
  I6(e, (r) => pn(r, t));
}
function B6(e) {
  let t = Hs();
  return {
    href: e != null && e.href ? t.useHref(e == null ? void 0 : e.href) : void 0,
    target: e == null ? void 0 : e.target,
    rel: e == null ? void 0 : e.rel,
    download: e == null ? void 0 : e.download,
    ping: e == null ? void 0 : e.ping,
    referrerPolicy: e == null ? void 0 : e.referrerPolicy
  };
}
let Mn = /* @__PURE__ */ new Map(), ql = /* @__PURE__ */ new Set();
function Ch() {
  if (typeof window > "u") return;
  function e(n) {
    return "propertyName" in n;
  }
  let t = (n) => {
    if (!e(n) || !n.target) return;
    let i = Mn.get(n.target);
    i || (i = /* @__PURE__ */ new Set(), Mn.set(n.target, i), n.target.addEventListener("transitioncancel", r, {
      once: !0
    })), i.add(n.propertyName);
  }, r = (n) => {
    if (!e(n) || !n.target) return;
    let i = Mn.get(n.target);
    if (i && (i.delete(n.propertyName), i.size === 0 && (n.target.removeEventListener("transitioncancel", r), Mn.delete(n.target)), Mn.size === 0)) {
      for (let a of ql) a();
      ql.clear();
    }
  };
  document.body.addEventListener("transitionrun", t), document.body.addEventListener("transitionend", r);
}
typeof document < "u" && (document.readyState !== "loading" ? Ch() : document.addEventListener("DOMContentLoaded", Ch));
function Jv(e) {
  requestAnimationFrame(() => {
    Mn.size === 0 ? e() : ql.add(e);
  });
}
function Ed() {
  let e = q(/* @__PURE__ */ new Map()), t = be((i, a, o, s) => {
    let u = s != null && s.once ? (...l) => {
      e.current.delete(o), o(...l);
    } : o;
    e.current.set(o, {
      type: a,
      eventTarget: i,
      fn: u,
      options: s
    }), i.addEventListener(a, o, s);
  }, []), r = be((i, a, o, s) => {
    var u;
    let l = ((u = e.current.get(o)) === null || u === void 0 ? void 0 : u.fn) || o;
    i.removeEventListener(a, l, s), e.current.delete(o);
  }, []), n = be(() => {
    e.current.forEach((i, a) => {
      r(i.eventTarget, i.type, a, i.options);
    });
  }, [
    r
  ]);
  return oe(() => n, [
    n
  ]), {
    addGlobalListener: t,
    removeGlobalListener: r,
    removeAllGlobalListeners: n
  };
}
function mn(e, t) {
  let { id: r, "aria-label": n, "aria-labelledby": i } = e;
  return r = kt(r), i && n ? i = [
    .../* @__PURE__ */ new Set([
      r,
      ...i.trim().split(/\s+/)
    ])
  ].join(" ") : i && (i = i.trim().split(/\s+/).join(" ")), !n && !i && t && (n = t), {
    id: r,
    "aria-label": n,
    "aria-labelledby": i
  };
}
function Cn(e) {
  const t = q(null);
  return G(() => ({
    get current() {
      return t.current;
    },
    set current(r) {
      t.current = r, typeof e == "function" ? e(r) : e && (e.current = r);
    }
  }), [
    e
  ]);
}
function Sh(e, t) {
  const r = q(!0), n = q(null);
  oe(() => (r.current = !0, () => {
    r.current = !1;
  }), []), oe(() => {
    r.current ? r.current = !1 : (!n.current || t.some((i, a) => !Object.is(i, n[a]))) && e(), n.current = t;
  }, t);
}
function M6() {
  return typeof window.ResizeObserver < "u";
}
function Ws(e) {
  const { ref: t, onResize: r } = e;
  oe(() => {
    let n = t == null ? void 0 : t.current;
    if (n)
      if (M6()) {
        const i = new window.ResizeObserver((a) => {
          a.length && r();
        });
        return i.observe(n), () => {
          n && i.unobserve(n);
        };
      } else
        return window.addEventListener("resize", r, !1), () => {
          window.removeEventListener("resize", r, !1);
        };
  }, [
    r,
    t
  ]);
}
function wd(e, t) {
  Re(() => {
    if (e && e.ref && t)
      return e.ref.current = t.current, () => {
        e.ref && (e.ref.current = null);
      };
  });
}
function ga(e, t) {
  let r = window.getComputedStyle(e), n = /(auto|scroll)/.test(r.overflow + r.overflowX + r.overflowY);
  return n && t && (n = e.scrollHeight !== e.clientHeight || e.scrollWidth !== e.clientWidth), n;
}
function Qs(e, t) {
  let r = e;
  for (ga(r, t) && (r = r.parentElement); r && !ga(r, t); ) r = r.parentElement;
  return r || document.scrollingElement || document.documentElement;
}
function N6(e, t) {
  const r = [];
  for (; e && e !== document.documentElement; )
    ga(e, t) && r.push(e), e = e.parentElement;
  return r;
}
let _t = typeof document < "u" && window.visualViewport;
function L6() {
  let e = wr(), [t, r] = ee(() => e ? {
    width: 0,
    height: 0
  } : kh());
  return oe(() => {
    let n = () => {
      r((i) => {
        let a = kh();
        return a.width === i.width && a.height === i.height ? i : a;
      });
    };
    return _t ? _t.addEventListener("resize", n) : window.addEventListener("resize", n), () => {
      _t ? _t.removeEventListener("resize", n) : window.removeEventListener("resize", n);
    };
  }, []), t;
}
function kh() {
  return {
    width: _t && (_t == null ? void 0 : _t.width) || window.innerWidth,
    height: _t && (_t == null ? void 0 : _t.height) || window.innerHeight
  };
}
let V6 = 0;
const Lu = /* @__PURE__ */ new Map();
function Gs(e) {
  let [t, r] = ee();
  return Re(() => {
    if (!e) return;
    let n = Lu.get(e);
    if (n)
      r(n.element.id);
    else {
      let i = `react-aria-description-${V6++}`;
      r(i);
      let a = document.createElement("div");
      a.id = i, a.style.display = "none", a.textContent = e, document.body.appendChild(a), n = {
        refCount: 0,
        element: a
      }, Lu.set(e, n);
    }
    return n.refCount++, () => {
      n && --n.refCount === 0 && (n.element.remove(), Lu.delete(e));
    };
  }, [
    e
  ]), {
    "aria-describedby": e ? t : void 0
  };
}
function Jn(e, t, r, n) {
  let i = lt(r), a = r == null;
  oe(() => {
    if (a || !e.current) return;
    let o = e.current;
    return o.addEventListener(t, i, n), () => {
      o.removeEventListener(t, i, n);
    };
  }, [
    e,
    t,
    n,
    a,
    i
  ]);
}
function Xv(e, t) {
  let r = Ph(e, t, "left"), n = Ph(e, t, "top"), i = t.offsetWidth, a = t.offsetHeight, o = e.scrollLeft, s = e.scrollTop, { borderTopWidth: u, borderLeftWidth: l } = getComputedStyle(e), c = e.scrollLeft + parseInt(l, 10), d = e.scrollTop + parseInt(u, 10), f = c + e.clientWidth, h = d + e.clientHeight;
  r <= o ? o = r - parseInt(l, 10) : r + i > f && (o += r + i - f), n <= d ? s = n - parseInt(u, 10) : n + a > h && (s += n + a - h), e.scrollLeft = o, e.scrollTop = s;
}
function Ph(e, t, r) {
  const n = r === "left" ? "offsetLeft" : "offsetTop";
  let i = 0;
  for (; t.offsetParent && (i += t[n], t.offsetParent !== e); ) {
    if (t.offsetParent.contains(e)) {
      i -= e[n];
      break;
    }
    t = t.offsetParent;
  }
  return i;
}
function Wo(e, t) {
  if (document.contains(e)) {
    let o = document.scrollingElement || document.documentElement;
    if (window.getComputedStyle(o).overflow === "hidden") {
      let u = N6(e);
      for (let l of u) Xv(l, e);
    } else {
      var r;
      let { left: u, top: l } = e.getBoundingClientRect();
      e == null || (r = e.scrollIntoView) === null || r === void 0 || r.call(e, {
        block: "nearest"
      });
      let { left: c, top: d } = e.getBoundingClientRect();
      if (Math.abs(u - c) > 1 || Math.abs(l - d) > 1) {
        var n, i, a;
        t == null || (i = t.containingElement) === null || i === void 0 || (n = i.scrollIntoView) === null || n === void 0 || n.call(i, {
          block: "center",
          inline: "center"
        }), (a = e.scrollIntoView) === null || a === void 0 || a.call(e, {
          block: "nearest"
        });
      }
    }
  }
}
function Hl(e) {
  return e.mozInputSource === 0 && e.isTrusted ? !0 : Yv() && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType;
}
function z6(e) {
  return !Yv() && e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "mouse";
}
function ey(e, t) {
  let r = q(null);
  return e && r.current && t(e, r.current) && (e = r.current), r.current = e, e;
}
function Cd(e, t, r) {
  let n = q(t), i = lt(() => {
    r && r(n.current);
  });
  oe(() => {
    var a;
    let o = e == null || (a = e.current) === null || a === void 0 ? void 0 : a.form;
    return o == null || o.addEventListener("reset", i), () => {
      o == null || o.removeEventListener("reset", i);
    };
  }, [
    e,
    i
  ]);
}
function tr(e, t, r) {
  let [n, i] = ee(e || t), a = q(e !== void 0), o = e !== void 0;
  oe(() => {
    let l = a.current;
    l !== o && console.warn(`WARN: A component changed from ${l ? "controlled" : "uncontrolled"} to ${o ? "controlled" : "uncontrolled"}.`), a.current = o;
  }, [
    o
  ]);
  let s = o ? e : n, u = be((l, ...c) => {
    let d = (f, ...h) => {
      r && (Object.is(s, f) || r(f, ...h)), o || (s = f);
    };
    typeof l == "function" ? (console.warn("We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320"), i((h, ...p) => {
      let v = l(o ? s : h, ...p);
      return d(v, ...c), o ? h : v;
    })) : (o || i(l), d(l, ...c));
  }, [
    o,
    s,
    r
  ]);
  return [
    s,
    u
  ];
}
function Wl(e, t = -1 / 0, r = 1 / 0) {
  return Math.min(Math.max(e, t), r);
}
let Un = "default", Ql = "", Fo = /* @__PURE__ */ new WeakMap();
function Th(e) {
  if (Na()) {
    if (Un === "default") {
      const t = Be(e);
      Ql = t.documentElement.style.webkitUserSelect, t.documentElement.style.webkitUserSelect = "none";
    }
    Un = "disabled";
  } else (e instanceof HTMLElement || e instanceof SVGElement) && (Fo.set(e, e.style.userSelect), e.style.userSelect = "none");
}
function lo(e) {
  if (Na()) {
    if (Un !== "disabled") return;
    Un = "restoring", setTimeout(() => {
      Jv(() => {
        if (Un === "restoring") {
          const t = Be(e);
          t.documentElement.style.webkitUserSelect === "none" && (t.documentElement.style.webkitUserSelect = Ql || ""), Ql = "", Un = "default";
        }
      });
    }, 300);
  } else if ((e instanceof HTMLElement || e instanceof SVGElement) && e && Fo.has(e)) {
    let t = Fo.get(e);
    e.style.userSelect === "none" && (e.style.userSelect = t), e.getAttribute("style") === "" && e.removeAttribute("style"), Fo.delete(e);
  }
}
const ba = P.createContext({
  register: () => {
  }
});
ba.displayName = "PressResponderContext";
function j6(e, t) {
  return t.get ? t.get.call(e) : t.value;
}
function ty(e, t, r) {
  if (!t.has(e)) throw new TypeError("attempted to " + r + " private field on non-instance");
  return t.get(e);
}
function K6(e, t) {
  var r = ty(e, t, "get");
  return j6(e, r);
}
function U6(e, t) {
  if (t.has(e))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function La(e, t, r) {
  U6(e, t), t.set(e, r);
}
function q6(e, t, r) {
  if (t.set) t.set.call(e, r);
  else {
    if (!t.writable)
      throw new TypeError("attempted to set read only private field");
    t.value = r;
  }
}
function Ah(e, t, r) {
  var n = ty(e, t, "set");
  return q6(e, n, r), r;
}
function H6(e) {
  let t = le(ba);
  if (t) {
    let { register: r, ...n } = t;
    e = ve(n, e), r();
  }
  return wd(t, e.ref), e;
}
var co = /* @__PURE__ */ new WeakMap();
class fo {
  continuePropagation() {
    Ah(this, co, !1);
  }
  get shouldStopPropagation() {
    return K6(this, co);
  }
  constructor(t, r, n) {
    La(this, co, {
      writable: !0,
      value: void 0
    }), Ah(this, co, !0), this.type = t, this.pointerType = r, this.target = n.currentTarget, this.shiftKey = n.shiftKey, this.metaKey = n.metaKey, this.ctrlKey = n.ctrlKey, this.altKey = n.altKey;
  }
}
const _h = Symbol("linkClicked");
function Va(e) {
  let {
    onPress: t,
    onPressChange: r,
    onPressStart: n,
    onPressEnd: i,
    onPressUp: a,
    isDisabled: o,
    isPressed: s,
    preventFocusOnPress: u,
    shouldCancelOnPointerExit: l,
    allowTextSelectionOnPress: c,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: d,
    ...f
  } = H6(e), [h, p] = ee(!1), v = q({
    isPressed: !1,
    ignoreEmulatedMouseEvents: !1,
    ignoreClickAfterPress: !1,
    didFirePressStart: !1,
    isTriggeringEvent: !1,
    activePointerId: null,
    target: null,
    isOverTarget: !1,
    pointerType: null
  }), { addGlobalListener: g, removeAllGlobalListeners: $ } = Ed(), m = lt((y, _) => {
    let w = v.current;
    if (o || w.didFirePressStart) return !1;
    let E = !0;
    if (w.isTriggeringEvent = !0, n) {
      let k = new fo("pressstart", _, y);
      n(k), E = k.shouldStopPropagation;
    }
    return r && r(!0), w.isTriggeringEvent = !1, w.didFirePressStart = !0, p(!0), E;
  }), b = lt((y, _, w = !0) => {
    let E = v.current;
    if (!E.didFirePressStart) return !1;
    E.ignoreClickAfterPress = !0, E.didFirePressStart = !1, E.isTriggeringEvent = !0;
    let k = !0;
    if (i) {
      let C = new fo("pressend", _, y);
      i(C), k = C.shouldStopPropagation;
    }
    if (r && r(!1), p(!1), t && w && !o) {
      let C = new fo("press", _, y);
      t(C), k && (k = C.shouldStopPropagation);
    }
    return E.isTriggeringEvent = !1, k;
  }), D = lt((y, _) => {
    let w = v.current;
    if (o) return !1;
    if (a) {
      w.isTriggeringEvent = !0;
      let E = new fo("pressup", _, y);
      return a(E), w.isTriggeringEvent = !1, E.shouldStopPropagation;
    }
    return !0;
  }), S = lt((y) => {
    let _ = v.current;
    _.isPressed && _.target && (_.isOverTarget && _.pointerType != null && b(ir(_.target, y), _.pointerType, !1), _.isPressed = !1, _.isOverTarget = !1, _.activePointerId = null, _.pointerType = null, $(), c || lo(_.target));
  }), T = lt((y) => {
    l && S(y);
  }), B = G(() => {
    let y = v.current, _ = {
      onKeyDown(E) {
        if (Vu(E.nativeEvent, E.currentTarget) && E.currentTarget.contains(E.target)) {
          var k;
          Oh(E.target, E.key) && E.preventDefault();
          let C = !0;
          if (!y.isPressed && !E.repeat) {
            y.target = E.currentTarget, y.isPressed = !0, C = m(E, "keyboard");
            let A = E.currentTarget, L = (I) => {
              Vu(I, A) && !I.repeat && A.contains(I.target) && y.target && D(ir(y.target, I), "keyboard");
            };
            g(Be(E.currentTarget), "keyup", Hr(L, w), !0);
          }
          C && E.stopPropagation(), E.metaKey && gr() && ((k = y.metaKeyEvents) === null || k === void 0 || k.set(E.key, E.nativeEvent));
        } else E.key === "Meta" && (y.metaKeyEvents = /* @__PURE__ */ new Map());
      },
      onClick(E) {
        if (!(E && !E.currentTarget.contains(E.target)) && E && E.button === 0 && !y.isTriggeringEvent && !pn.isOpening) {
          let k = !0;
          if (o && E.preventDefault(), !y.ignoreClickAfterPress && !y.ignoreEmulatedMouseEvents && !y.isPressed && (y.pointerType === "virtual" || Hl(E.nativeEvent))) {
            !o && !u && Wt(E.currentTarget);
            let C = m(E, "virtual"), A = D(E, "virtual"), L = b(E, "virtual");
            k = C && A && L;
          }
          y.ignoreEmulatedMouseEvents = !1, y.ignoreClickAfterPress = !1, k && E.stopPropagation();
        }
      }
    }, w = (E) => {
      var k;
      if (y.isPressed && y.target && Vu(E, y.target)) {
        var C;
        Oh(E.target, E.key) && E.preventDefault();
        let L = E.target;
        b(ir(y.target, E), "keyboard", y.target.contains(L)), $(), E.key !== "Enter" && Sd(y.target) && y.target.contains(L) && !E[_h] && (E[_h] = !0, pn(y.target, E, !1)), y.isPressed = !1, (C = y.metaKeyEvents) === null || C === void 0 || C.delete(E.key);
      } else if (E.key === "Meta" && (!((k = y.metaKeyEvents) === null || k === void 0) && k.size)) {
        var A;
        let L = y.metaKeyEvents;
        y.metaKeyEvents = void 0;
        for (let I of L.values()) (A = y.target) === null || A === void 0 || A.dispatchEvent(new KeyboardEvent("keyup", I));
      }
    };
    if (typeof PointerEvent < "u") {
      _.onPointerDown = (A) => {
        if (A.button !== 0 || !A.currentTarget.contains(A.target)) return;
        if (z6(A.nativeEvent)) {
          y.pointerType = "virtual";
          return;
        }
        zu(A.currentTarget) && A.preventDefault(), y.pointerType = A.pointerType;
        let L = !0;
        y.isPressed || (y.isPressed = !0, y.isOverTarget = !0, y.activePointerId = A.pointerId, y.target = A.currentTarget, !o && !u && Wt(A.currentTarget), c || Th(y.target), L = m(A, y.pointerType), g(Be(A.currentTarget), "pointermove", E, !1), g(Be(A.currentTarget), "pointerup", k, !1), g(Be(A.currentTarget), "pointercancel", C, !1)), L && A.stopPropagation();
      }, _.onMouseDown = (A) => {
        A.currentTarget.contains(A.target) && A.button === 0 && (zu(A.currentTarget) && A.preventDefault(), A.stopPropagation());
      }, _.onPointerUp = (A) => {
        !A.currentTarget.contains(A.target) || y.pointerType === "virtual" || A.button === 0 && _n(A, A.currentTarget) && D(A, y.pointerType || A.pointerType);
      };
      let E = (A) => {
        A.pointerId === y.activePointerId && (y.target && _n(A, y.target) ? !y.isOverTarget && y.pointerType != null && (y.isOverTarget = !0, m(ir(y.target, A), y.pointerType)) : y.target && y.isOverTarget && y.pointerType != null && (y.isOverTarget = !1, b(ir(y.target, A), y.pointerType, !1), T(A)));
      }, k = (A) => {
        A.pointerId === y.activePointerId && y.isPressed && A.button === 0 && y.target && (_n(A, y.target) && y.pointerType != null ? b(ir(y.target, A), y.pointerType) : y.isOverTarget && y.pointerType != null && b(ir(y.target, A), y.pointerType, !1), y.isPressed = !1, y.isOverTarget = !1, y.activePointerId = null, y.pointerType = null, $(), c || lo(y.target));
      }, C = (A) => {
        S(A);
      };
      _.onDragStart = (A) => {
        A.currentTarget.contains(A.target) && S(A);
      };
    } else {
      _.onMouseDown = (C) => {
        if (C.button !== 0 || !C.currentTarget.contains(C.target)) return;
        if (zu(C.currentTarget) && C.preventDefault(), y.ignoreEmulatedMouseEvents) {
          C.stopPropagation();
          return;
        }
        y.isPressed = !0, y.isOverTarget = !0, y.target = C.currentTarget, y.pointerType = Hl(C.nativeEvent) ? "virtual" : "mouse", !o && !u && Wt(C.currentTarget), m(C, y.pointerType) && C.stopPropagation(), g(Be(C.currentTarget), "mouseup", E, !1);
      }, _.onMouseEnter = (C) => {
        if (!C.currentTarget.contains(C.target)) return;
        let A = !0;
        y.isPressed && !y.ignoreEmulatedMouseEvents && y.pointerType != null && (y.isOverTarget = !0, A = m(C, y.pointerType)), A && C.stopPropagation();
      }, _.onMouseLeave = (C) => {
        if (!C.currentTarget.contains(C.target)) return;
        let A = !0;
        y.isPressed && !y.ignoreEmulatedMouseEvents && y.pointerType != null && (y.isOverTarget = !1, A = b(C, y.pointerType, !1), T(C)), A && C.stopPropagation();
      }, _.onMouseUp = (C) => {
        C.currentTarget.contains(C.target) && !y.ignoreEmulatedMouseEvents && C.button === 0 && D(C, y.pointerType || "mouse");
      };
      let E = (C) => {
        if (C.button === 0) {
          if (y.isPressed = !1, $(), y.ignoreEmulatedMouseEvents) {
            y.ignoreEmulatedMouseEvents = !1;
            return;
          }
          y.target && _n(C, y.target) && y.pointerType != null ? b(ir(y.target, C), y.pointerType) : y.target && y.isOverTarget && y.pointerType != null && b(ir(y.target, C), y.pointerType, !1), y.isOverTarget = !1;
        }
      };
      _.onTouchStart = (C) => {
        if (!C.currentTarget.contains(C.target)) return;
        let A = W6(C.nativeEvent);
        if (!A) return;
        y.activePointerId = A.identifier, y.ignoreEmulatedMouseEvents = !0, y.isOverTarget = !0, y.isPressed = !0, y.target = C.currentTarget, y.pointerType = "touch", !o && !u && Wt(C.currentTarget), c || Th(y.target), m(C, y.pointerType) && C.stopPropagation(), g(It(C.currentTarget), "scroll", k, !0);
      }, _.onTouchMove = (C) => {
        if (!C.currentTarget.contains(C.target)) return;
        if (!y.isPressed) {
          C.stopPropagation();
          return;
        }
        let A = Fh(C.nativeEvent, y.activePointerId), L = !0;
        A && _n(A, C.currentTarget) ? !y.isOverTarget && y.pointerType != null && (y.isOverTarget = !0, L = m(C, y.pointerType)) : y.isOverTarget && y.pointerType != null && (y.isOverTarget = !1, L = b(C, y.pointerType, !1), T(C)), L && C.stopPropagation();
      }, _.onTouchEnd = (C) => {
        if (!C.currentTarget.contains(C.target)) return;
        if (!y.isPressed) {
          C.stopPropagation();
          return;
        }
        let A = Fh(C.nativeEvent, y.activePointerId), L = !0;
        A && _n(A, C.currentTarget) && y.pointerType != null ? (D(C, y.pointerType), L = b(C, y.pointerType)) : y.isOverTarget && y.pointerType != null && (L = b(C, y.pointerType, !1)), L && C.stopPropagation(), y.isPressed = !1, y.activePointerId = null, y.isOverTarget = !1, y.ignoreEmulatedMouseEvents = !0, y.target && !c && lo(y.target), $();
      }, _.onTouchCancel = (C) => {
        C.currentTarget.contains(C.target) && (C.stopPropagation(), y.isPressed && S(C));
      };
      let k = (C) => {
        y.isPressed && C.target.contains(y.target) && S({
          currentTarget: y.target,
          shiftKey: !1,
          ctrlKey: !1,
          metaKey: !1,
          altKey: !1
        });
      };
      _.onDragStart = (C) => {
        C.currentTarget.contains(C.target) && S(C);
      };
    }
    return _;
  }, [
    g,
    o,
    u,
    $,
    c,
    S,
    T,
    b,
    m,
    D
  ]);
  return oe(() => () => {
    var y;
    c || lo((y = v.current.target) !== null && y !== void 0 ? y : void 0);
  }, [
    c
  ]), {
    isPressed: s || h,
    pressProps: ve(f, B)
  };
}
function Sd(e) {
  return e.tagName === "A" && e.hasAttribute("href");
}
function Vu(e, t) {
  const { key: r, code: n } = e, i = t, a = i.getAttribute("role");
  return (r === "Enter" || r === " " || r === "Spacebar" || n === "Space") && !(i instanceof It(i).HTMLInputElement && !ry(i, r) || i instanceof It(i).HTMLTextAreaElement || i.isContentEditable) && // Links should only trigger with Enter key
  !((a === "link" || !a && Sd(i)) && r !== "Enter");
}
function W6(e) {
  const { targetTouches: t } = e;
  return t.length > 0 ? t[0] : null;
}
function Fh(e, t) {
  const r = e.changedTouches;
  for (let n = 0; n < r.length; n++) {
    const i = r[n];
    if (i.identifier === t) return i;
  }
  return null;
}
function ir(e, t) {
  return {
    currentTarget: e,
    shiftKey: t.shiftKey,
    ctrlKey: t.ctrlKey,
    metaKey: t.metaKey,
    altKey: t.altKey
  };
}
function Q6(e) {
  let t = 0, r = 0;
  return e.width !== void 0 ? t = e.width / 2 : e.radiusX !== void 0 && (t = e.radiusX), e.height !== void 0 ? r = e.height / 2 : e.radiusY !== void 0 && (r = e.radiusY), {
    top: e.clientY - r,
    right: e.clientX + t,
    bottom: e.clientY + r,
    left: e.clientX - t
  };
}
function G6(e, t) {
  return !(e.left > t.right || t.left > e.right || e.top > t.bottom || t.top > e.bottom);
}
function _n(e, t) {
  let r = t.getBoundingClientRect(), n = Q6(e);
  return G6(r, n);
}
function zu(e) {
  return !(e instanceof HTMLElement) || !e.hasAttribute("draggable");
}
function Oh(e, t) {
  return e instanceof HTMLInputElement ? !ry(e, t) : e instanceof HTMLButtonElement ? e.type !== "submit" && e.type !== "reset" : !Sd(e);
}
const Z6 = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function ry(e, t) {
  return e.type === "checkbox" || e.type === "radio" ? t === " " : Z6.has(e.type);
}
const Y6 = /* @__PURE__ */ P.forwardRef(({ children: e, ...t }, r) => {
  let n = q(!1), i = le(ba);
  r = Cn(r || (i == null ? void 0 : i.ref));
  let a = ve(i || {}, {
    ...t,
    ref: r,
    register() {
      n.current = !0, i && i.register();
    }
  });
  return wd(i, r), oe(() => {
    n.current || (console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component."), n.current = !0);
  }, []), /* @__PURE__ */ P.createElement(ba.Provider, {
    value: a
  }, e);
});
function J6({ children: e }) {
  let t = G(() => ({
    register: () => {
    }
  }), []);
  return /* @__PURE__ */ P.createElement(ba.Provider, {
    value: t
  }, e);
}
class X6 {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = !0, this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation(), this.isPropagationStopped = () => !0;
  }
  isPropagationStopped() {
    return !1;
  }
  persist() {
  }
  constructor(t, r) {
    this.nativeEvent = r, this.target = r.target, this.currentTarget = r.currentTarget, this.relatedTarget = r.relatedTarget, this.bubbles = r.bubbles, this.cancelable = r.cancelable, this.defaultPrevented = r.defaultPrevented, this.eventPhase = r.eventPhase, this.isTrusted = r.isTrusted, this.timeStamp = r.timeStamp, this.type = t;
  }
}
function ny(e) {
  let t = q({
    isFocused: !1,
    observer: null
  });
  Re(() => {
    const n = t.current;
    return () => {
      n.observer && (n.observer.disconnect(), n.observer = null);
    };
  }, []);
  let r = lt((n) => {
    e == null || e(n);
  });
  return be((n) => {
    if (n.target instanceof HTMLButtonElement || n.target instanceof HTMLInputElement || n.target instanceof HTMLTextAreaElement || n.target instanceof HTMLSelectElement) {
      t.current.isFocused = !0;
      let i = n.target, a = (o) => {
        t.current.isFocused = !1, i.disabled && r(new X6("blur", o)), t.current.observer && (t.current.observer.disconnect(), t.current.observer = null);
      };
      i.addEventListener("focusout", a, {
        once: !0
      }), t.current.observer = new MutationObserver(() => {
        if (t.current.isFocused && i.disabled) {
          var o;
          (o = t.current.observer) === null || o === void 0 || o.disconnect();
          let s = i === document.activeElement ? null : document.activeElement;
          i.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: s
          })), i.dispatchEvent(new FocusEvent("focusout", {
            bubbles: !0,
            relatedTarget: s
          }));
        }
      }), t.current.observer.observe(i, {
        attributes: !0,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    r
  ]);
}
function iy(e) {
  let { isDisabled: t, onFocus: r, onBlur: n, onFocusChange: i } = e;
  const a = be((u) => {
    if (u.target === u.currentTarget)
      return n && n(u), i && i(!1), !0;
  }, [
    n,
    i
  ]), o = ny(a), s = be((u) => {
    const l = Be(u.target);
    u.target === u.currentTarget && l.activeElement === u.target && (r && r(u), i && i(!0), o(u));
  }, [
    i,
    r,
    o
  ]);
  return {
    focusProps: {
      onFocus: !t && (r || i || n) ? s : void 0,
      onBlur: !t && (n || i) ? a : void 0
    }
  };
}
let br = null, $a = /* @__PURE__ */ new Set(), ra = /* @__PURE__ */ new Map(), vn = !1, Gl = !1;
const ew = {
  Tab: !0,
  Escape: !0
};
function Zs(e, t) {
  for (let r of $a) r(e, t);
}
function tw(e) {
  return !(e.metaKey || !gr() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function Qo(e) {
  vn = !0, tw(e) && (br = "keyboard", Zs("keyboard", e));
}
function Ot(e) {
  br = "pointer", (e.type === "mousedown" || e.type === "pointerdown") && (vn = !0, Zs("pointer", e));
}
function ay(e) {
  Hl(e) && (vn = !0, br = "virtual");
}
function oy(e) {
  e.target === window || e.target === document || (!vn && !Gl && (br = "virtual", Zs("virtual", e)), vn = !1, Gl = !1);
}
function sy() {
  vn = !1, Gl = !0;
}
function Go(e) {
  if (typeof window > "u" || ra.get(It(e))) return;
  const t = It(e), r = Be(e);
  let n = t.HTMLElement.prototype.focus;
  t.HTMLElement.prototype.focus = function() {
    vn = !0, n.apply(this, arguments);
  }, r.addEventListener("keydown", Qo, !0), r.addEventListener("keyup", Qo, !0), r.addEventListener("click", ay, !0), t.addEventListener("focus", oy, !0), t.addEventListener("blur", sy, !1), typeof PointerEvent < "u" ? (r.addEventListener("pointerdown", Ot, !0), r.addEventListener("pointermove", Ot, !0), r.addEventListener("pointerup", Ot, !0)) : (r.addEventListener("mousedown", Ot, !0), r.addEventListener("mousemove", Ot, !0), r.addEventListener("mouseup", Ot, !0)), t.addEventListener("beforeunload", () => {
    uy(e);
  }, {
    once: !0
  }), ra.set(t, {
    focus: n
  });
}
const uy = (e, t) => {
  const r = It(e), n = Be(e);
  t && n.removeEventListener("DOMContentLoaded", t), ra.has(r) && (r.HTMLElement.prototype.focus = ra.get(r).focus, n.removeEventListener("keydown", Qo, !0), n.removeEventListener("keyup", Qo, !0), n.removeEventListener("click", ay, !0), r.removeEventListener("focus", oy, !0), r.removeEventListener("blur", sy, !1), typeof PointerEvent < "u" ? (n.removeEventListener("pointerdown", Ot, !0), n.removeEventListener("pointermove", Ot, !0), n.removeEventListener("pointerup", Ot, !0)) : (n.removeEventListener("mousedown", Ot, !0), n.removeEventListener("mousemove", Ot, !0), n.removeEventListener("mouseup", Ot, !0)), ra.delete(r));
};
function rw(e) {
  const t = Be(e);
  let r;
  return t.readyState !== "loading" ? Go(e) : (r = () => {
    Go(e);
  }, t.addEventListener("DOMContentLoaded", r)), () => uy(e, r);
}
typeof document < "u" && rw();
function Zo() {
  return br !== "pointer";
}
function Yo() {
  return br;
}
function ly(e) {
  br = e, Zs(e, null);
}
function nw() {
  Go();
  let [e, t] = ee(br);
  return oe(() => {
    let r = () => {
      t(br);
    };
    return $a.add(r), () => {
      $a.delete(r);
    };
  }, []), wr() ? null : e;
}
const iw = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function aw(e, t, r) {
  var n;
  const i = typeof window < "u" ? It(r == null ? void 0 : r.target).HTMLInputElement : HTMLInputElement, a = typeof window < "u" ? It(r == null ? void 0 : r.target).HTMLTextAreaElement : HTMLTextAreaElement, o = typeof window < "u" ? It(r == null ? void 0 : r.target).HTMLElement : HTMLElement, s = typeof window < "u" ? It(r == null ? void 0 : r.target).KeyboardEvent : KeyboardEvent;
  return e = e || (r == null ? void 0 : r.target) instanceof i && !iw.has(r == null || (n = r.target) === null || n === void 0 ? void 0 : n.type) || (r == null ? void 0 : r.target) instanceof a || (r == null ? void 0 : r.target) instanceof o && (r == null ? void 0 : r.target.isContentEditable), !(e && t === "keyboard" && r instanceof s && !ew[r.key]);
}
function ow(e, t, r) {
  Go(), oe(() => {
    let n = (i, a) => {
      aw(!!(r != null && r.isTextInput), i, a) && e(Zo());
    };
    return $a.add(n), () => {
      $a.delete(n);
    };
  }, t);
}
function $i(e) {
  let { isDisabled: t, onBlurWithin: r, onFocusWithin: n, onFocusWithinChange: i } = e, a = q({
    isFocusWithin: !1
  }), o = be((l) => {
    a.current.isFocusWithin && !l.currentTarget.contains(l.relatedTarget) && (a.current.isFocusWithin = !1, r && r(l), i && i(!1));
  }, [
    r,
    i,
    a
  ]), s = ny(o), u = be((l) => {
    !a.current.isFocusWithin && document.activeElement === l.target && (n && n(l), i && i(!0), a.current.isFocusWithin = !0, s(l));
  }, [
    n,
    i,
    s
  ]);
  return t ? {
    focusWithinProps: {
      // These should not have been null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  } : {
    focusWithinProps: {
      onFocus: u,
      onBlur: o
    }
  };
}
let Jo = !1, ju = 0;
function Zl() {
  Jo = !0, setTimeout(() => {
    Jo = !1;
  }, 50);
}
function Ih(e) {
  e.pointerType === "touch" && Zl();
}
function sw() {
  if (!(typeof document > "u"))
    return typeof PointerEvent < "u" ? document.addEventListener("pointerup", Ih) : document.addEventListener("touchend", Zl), ju++, () => {
      ju--, !(ju > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", Ih) : document.removeEventListener("touchend", Zl));
    };
}
function Sn(e) {
  let { onHoverStart: t, onHoverChange: r, onHoverEnd: n, isDisabled: i } = e, [a, o] = ee(!1), s = q({
    isHovered: !1,
    ignoreEmulatedMouseEvents: !1,
    pointerType: "",
    target: null
  }).current;
  oe(sw, []);
  let { hoverProps: u, triggerHoverEnd: l } = G(() => {
    let c = (h, p) => {
      if (s.pointerType = p, i || p === "touch" || s.isHovered || !h.currentTarget.contains(h.target)) return;
      s.isHovered = !0;
      let v = h.currentTarget;
      s.target = v, t && t({
        type: "hoverstart",
        target: v,
        pointerType: p
      }), r && r(!0), o(!0);
    }, d = (h, p) => {
      if (s.pointerType = "", s.target = null, p === "touch" || !s.isHovered) return;
      s.isHovered = !1;
      let v = h.currentTarget;
      n && n({
        type: "hoverend",
        target: v,
        pointerType: p
      }), r && r(!1), o(!1);
    }, f = {};
    return typeof PointerEvent < "u" ? (f.onPointerEnter = (h) => {
      Jo && h.pointerType === "mouse" || c(h, h.pointerType);
    }, f.onPointerLeave = (h) => {
      !i && h.currentTarget.contains(h.target) && d(h, h.pointerType);
    }) : (f.onTouchStart = () => {
      s.ignoreEmulatedMouseEvents = !0;
    }, f.onMouseEnter = (h) => {
      !s.ignoreEmulatedMouseEvents && !Jo && c(h, "mouse"), s.ignoreEmulatedMouseEvents = !1;
    }, f.onMouseLeave = (h) => {
      !i && h.currentTarget.contains(h.target) && d(h, "mouse");
    }), {
      hoverProps: f,
      triggerHoverEnd: d
    };
  }, [
    t,
    r,
    n,
    i,
    s
  ]);
  return oe(() => {
    i && l({
      currentTarget: s.target
    }, s.pointerType);
  }, [
    i
  ]), {
    hoverProps: u,
    isHovered: a
  };
}
function uw(e) {
  let { ref: t, onInteractOutside: r, isDisabled: n, onInteractOutsideStart: i } = e, a = q({
    isPointerDown: !1,
    ignoreEmulatedMouseEvents: !1
  }), o = lt((u) => {
    r && ho(u, t) && (i && i(u), a.current.isPointerDown = !0);
  }), s = lt((u) => {
    r && r(u);
  });
  oe(() => {
    let u = a.current;
    if (n) return;
    const l = t.current, c = Be(l);
    if (typeof PointerEvent < "u") {
      let d = (f) => {
        u.isPointerDown && ho(f, t) && s(f), u.isPointerDown = !1;
      };
      return c.addEventListener("pointerdown", o, !0), c.addEventListener("pointerup", d, !0), () => {
        c.removeEventListener("pointerdown", o, !0), c.removeEventListener("pointerup", d, !0);
      };
    } else {
      let d = (h) => {
        u.ignoreEmulatedMouseEvents ? u.ignoreEmulatedMouseEvents = !1 : u.isPointerDown && ho(h, t) && s(h), u.isPointerDown = !1;
      }, f = (h) => {
        u.ignoreEmulatedMouseEvents = !0, u.isPointerDown && ho(h, t) && s(h), u.isPointerDown = !1;
      };
      return c.addEventListener("mousedown", o, !0), c.addEventListener("mouseup", d, !0), c.addEventListener("touchstart", o, !0), c.addEventListener("touchend", f, !0), () => {
        c.removeEventListener("mousedown", o, !0), c.removeEventListener("mouseup", d, !0), c.removeEventListener("touchstart", o, !0), c.removeEventListener("touchend", f, !0);
      };
    }
  }, [
    t,
    n,
    o,
    s
  ]);
}
function ho(e, t) {
  if (e.button > 0) return !1;
  if (e.target) {
    const r = e.target.ownerDocument;
    if (!r || !r.documentElement.contains(e.target) || e.target.closest("[data-react-aria-top-layer]")) return !1;
  }
  return t.current && !t.current.contains(e.target);
}
function Rh(e) {
  if (!e) return;
  let t = !0;
  return (r) => {
    let n = {
      ...r,
      preventDefault() {
        r.preventDefault();
      },
      isDefaultPrevented() {
        return r.isDefaultPrevented();
      },
      stopPropagation() {
        console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
      },
      continuePropagation() {
        t = !1;
      }
    };
    e(n), t && r.stopPropagation();
  };
}
function lw(e) {
  return {
    keyboardProps: e.isDisabled ? {} : {
      onKeyDown: Rh(e.onKeyDown),
      onKeyUp: Rh(e.onKeyUp)
    }
  };
}
const cw = 500;
function cy(e) {
  let { isDisabled: t, onLongPressStart: r, onLongPressEnd: n, onLongPress: i, threshold: a = cw, accessibilityDescription: o } = e;
  const s = q();
  let { addGlobalListener: u, removeGlobalListener: l } = Ed(), { pressProps: c } = Va({
    isDisabled: t,
    onPressStart(f) {
      if (f.continuePropagation(), (f.pointerType === "mouse" || f.pointerType === "touch") && (r && r({
        ...f,
        type: "longpressstart"
      }), s.current = setTimeout(() => {
        f.target.dispatchEvent(new PointerEvent("pointercancel", {
          bubbles: !0
        })), i && i({
          ...f,
          type: "longpress"
        }), s.current = void 0;
      }, a), f.pointerType === "touch")) {
        let h = (p) => {
          p.preventDefault();
        };
        u(f.target, "contextmenu", h, {
          once: !0
        }), u(window, "pointerup", () => {
          setTimeout(() => {
            l(f.target, "contextmenu", h);
          }, 30);
        }, {
          once: !0
        });
      }
    },
    onPressEnd(f) {
      s.current && clearTimeout(s.current), n && (f.pointerType === "mouse" || f.pointerType === "touch") && n({
        ...f,
        type: "longpressend"
      });
    }
  }), d = Gs(i && !t ? o : void 0);
  return {
    longPressProps: ve(c, d)
  };
}
function yn(e) {
  const t = Be(e);
  if (Yo() === "virtual") {
    let r = t.activeElement;
    Jv(() => {
      t.activeElement === r && e.isConnected && Wt(e);
    });
  } else Wt(e);
}
function dw(e) {
  const t = It(e);
  if (!(e instanceof t.HTMLElement) && !(e instanceof t.SVGElement)) return !1;
  let { display: r, visibility: n } = e.style, i = r !== "none" && n !== "hidden" && n !== "collapse";
  if (i) {
    const { getComputedStyle: a } = e.ownerDocument.defaultView;
    let { display: o, visibility: s } = a(e);
    i = o !== "none" && s !== "hidden" && s !== "collapse";
  }
  return i;
}
function fw(e, t) {
  return !e.hasAttribute("hidden") && // Ignore HiddenSelect when tree walking.
  !e.hasAttribute("data-react-aria-prevent-focus") && (e.nodeName === "DETAILS" && t && t.nodeName !== "SUMMARY" ? e.hasAttribute("open") : !0);
}
function dy(e, t) {
  return e.nodeName !== "#comment" && dw(e) && fw(e, t) && (!e.parentElement || dy(e.parentElement, e));
}
const Bh = /* @__PURE__ */ P.createContext(null);
let Me = null;
function fy(e) {
  let { children: t, contain: r, restoreFocus: n, autoFocus: i } = e, a = q(null), o = q(null), s = q([]), { parentNode: u } = le(Bh) || {}, l = G(() => new Yl({
    scopeRef: s
  }), [
    s
  ]);
  Re(() => {
    let f = u || et.root;
    if (et.getTreeNode(f.scopeRef) && Me && !es(Me, f.scopeRef)) {
      let h = et.getTreeNode(Me);
      h && (f = h);
    }
    f.addChild(l), et.addNode(l);
  }, [
    l,
    u
  ]), Re(() => {
    let f = et.getTreeNode(s);
    f && (f.contain = !!r);
  }, [
    r
  ]), Re(() => {
    var f;
    let h = (f = a.current) === null || f === void 0 ? void 0 : f.nextSibling, p = [];
    for (; h && h !== o.current; )
      p.push(h), h = h.nextSibling;
    s.current = p;
  }, [
    t
  ]), bw(s, n, r), vw(s, r), xw(s, n, r), gw(s, i), oe(() => {
    const f = Be(s.current ? s.current[0] : void 0).activeElement;
    let h = null;
    if (ct(f, s.current)) {
      for (let p of et.traverse()) p.scopeRef && ct(f, p.scopeRef.current) && (h = p);
      h === et.getTreeNode(s) && (Me = h.scopeRef);
    }
  }, [
    s
  ]), Re(() => () => {
    var f, h, p;
    let v = (p = (h = et.getTreeNode(s)) === null || h === void 0 || (f = h.parent) === null || f === void 0 ? void 0 : f.scopeRef) !== null && p !== void 0 ? p : null;
    (s === Me || es(s, Me)) && (!v || et.getTreeNode(v)) && (Me = v), et.removeTreeNode(s);
  }, [
    s
  ]);
  let c = G(() => hw(s), []), d = G(() => ({
    focusManager: c,
    parentNode: l
  }), [
    l,
    c
  ]);
  return /* @__PURE__ */ P.createElement(Bh.Provider, {
    value: d
  }, /* @__PURE__ */ P.createElement("span", {
    "data-focus-scope-start": !0,
    hidden: !0,
    ref: a
  }), t, /* @__PURE__ */ P.createElement("span", {
    "data-focus-scope-end": !0,
    hidden: !0,
    ref: o
  }));
}
function hw(e) {
  return {
    focusNext(t = {}) {
      let r = e.current, { from: n, tabbable: i, wrap: a, accept: o } = t, s = n || Be(r[0]).activeElement, u = r[0].previousElementSibling, l = on(r), c = bt(l, {
        tabbable: i,
        accept: o
      }, r);
      c.currentNode = ct(s, r) ? s : u;
      let d = c.nextNode();
      return !d && a && (c.currentNode = u, d = c.nextNode()), d && gt(d, !0), d;
    },
    focusPrevious(t = {}) {
      let r = e.current, { from: n, tabbable: i, wrap: a, accept: o } = t, s = n || Be(r[0]).activeElement, u = r[r.length - 1].nextElementSibling, l = on(r), c = bt(l, {
        tabbable: i,
        accept: o
      }, r);
      c.currentNode = ct(s, r) ? s : u;
      let d = c.previousNode();
      return !d && a && (c.currentNode = u, d = c.previousNode()), d && gt(d, !0), d;
    },
    focusFirst(t = {}) {
      let r = e.current, { tabbable: n, accept: i } = t, a = on(r), o = bt(a, {
        tabbable: n,
        accept: i
      }, r);
      o.currentNode = r[0].previousElementSibling;
      let s = o.nextNode();
      return s && gt(s, !0), s;
    },
    focusLast(t = {}) {
      let r = e.current, { tabbable: n, accept: i } = t, a = on(r), o = bt(a, {
        tabbable: n,
        accept: i
      }, r);
      o.currentNode = r[r.length - 1].nextElementSibling;
      let s = o.previousNode();
      return s && gt(s, !0), s;
    }
  };
}
const kd = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[contenteditable]"
], pw = kd.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
kd.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const mw = kd.join(':not([hidden]):not([tabindex="-1"]),');
function on(e) {
  return e[0].parentElement;
}
function Ui(e) {
  let t = et.getTreeNode(Me);
  for (; t && t.scopeRef !== e; ) {
    if (t.contain) return !1;
    t = t.parent;
  }
  return !0;
}
function vw(e, t) {
  let r = q(), n = q();
  Re(() => {
    let i = e.current;
    if (!t) {
      n.current && (cancelAnimationFrame(n.current), n.current = void 0);
      return;
    }
    const a = Be(i ? i[0] : void 0);
    let o = (l) => {
      if (l.key !== "Tab" || l.altKey || l.ctrlKey || l.metaKey || !Ui(e) || l.isComposing) return;
      let c = a.activeElement, d = e.current;
      if (!d || !ct(c, d)) return;
      let f = on(d), h = bt(f, {
        tabbable: !0
      }, d);
      if (!c) return;
      h.currentNode = c;
      let p = l.shiftKey ? h.previousNode() : h.nextNode();
      p || (h.currentNode = l.shiftKey ? d[d.length - 1].nextElementSibling : d[0].previousElementSibling, p = l.shiftKey ? h.previousNode() : h.nextNode()), l.preventDefault(), p && gt(p, !0);
    }, s = (l) => {
      (!Me || es(Me, e)) && ct(l.target, e.current) ? (Me = e, r.current = l.target) : Ui(e) && !Xo(l.target, e) ? r.current ? r.current.focus() : Me && Me.current && ts(Me.current) : Ui(e) && (r.current = l.target);
    }, u = (l) => {
      n.current && cancelAnimationFrame(n.current), n.current = requestAnimationFrame(() => {
        if (a.activeElement && Ui(e) && !Xo(a.activeElement, e))
          if (Me = e, a.body.contains(l.target)) {
            var c;
            r.current = l.target, (c = r.current) === null || c === void 0 || c.focus();
          } else Me.current && ts(Me.current);
      });
    };
    return a.addEventListener("keydown", o, !1), a.addEventListener("focusin", s, !1), i == null || i.forEach((l) => l.addEventListener("focusin", s, !1)), i == null || i.forEach((l) => l.addEventListener("focusout", u, !1)), () => {
      a.removeEventListener("keydown", o, !1), a.removeEventListener("focusin", s, !1), i == null || i.forEach((l) => l.removeEventListener("focusin", s, !1)), i == null || i.forEach((l) => l.removeEventListener("focusout", u, !1));
    };
  }, [
    e,
    t
  ]), Re(() => () => {
    n.current && cancelAnimationFrame(n.current);
  }, [
    n
  ]);
}
function hy(e) {
  return Xo(e);
}
function ct(e, t) {
  return !e || !t ? !1 : t.some((r) => r.contains(e));
}
function Xo(e, t = null) {
  if (e instanceof Element && e.closest("[data-react-aria-top-layer]")) return !0;
  for (let { scopeRef: r } of et.traverse(et.getTreeNode(t)))
    if (r && ct(e, r.current)) return !0;
  return !1;
}
function yw(e) {
  return Xo(e, Me);
}
function es(e, t) {
  var r;
  let n = (r = et.getTreeNode(t)) === null || r === void 0 ? void 0 : r.parent;
  for (; n; ) {
    if (n.scopeRef === e) return !0;
    n = n.parent;
  }
  return !1;
}
function gt(e, t = !1) {
  if (e != null && !t) try {
    yn(e);
  } catch {
  }
  else if (e != null) try {
    e.focus();
  } catch {
  }
}
function ts(e, t = !0) {
  let r = e[0].previousElementSibling, n = on(e), i = bt(n, {
    tabbable: t
  }, e);
  i.currentNode = r;
  let a = i.nextNode();
  t && !a && (n = on(e), i = bt(n, {
    tabbable: !1
  }, e), i.currentNode = r, a = i.nextNode()), gt(a);
}
function gw(e, t) {
  const r = P.useRef(t);
  oe(() => {
    if (r.current) {
      Me = e;
      const n = Be(e.current ? e.current[0] : void 0);
      !ct(n.activeElement, Me.current) && e.current && ts(e.current);
    }
    r.current = !1;
  }, [
    e
  ]);
}
function bw(e, t, r) {
  Re(() => {
    if (t || r) return;
    let n = e.current;
    const i = Be(n ? n[0] : void 0);
    let a = (o) => {
      let s = o.target;
      ct(s, e.current) ? Me = e : hy(s) || (Me = null);
    };
    return i.addEventListener("focusin", a, !1), n == null || n.forEach((o) => o.addEventListener("focusin", a, !1)), () => {
      i.removeEventListener("focusin", a, !1), n == null || n.forEach((o) => o.removeEventListener("focusin", a, !1));
    };
  }, [
    e,
    t,
    r
  ]);
}
function $w(e) {
  let t = et.getTreeNode(Me);
  for (; t && t.scopeRef !== e; ) {
    if (t.nodeToRestore) return !1;
    t = t.parent;
  }
  return (t == null ? void 0 : t.scopeRef) === e;
}
function xw(e, t, r) {
  const n = q(typeof document < "u" ? Be(e.current ? e.current[0] : void 0).activeElement : null);
  Re(() => {
    let i = e.current;
    const a = Be(i ? i[0] : void 0);
    if (!t || r) return;
    let o = () => {
      (!Me || es(Me, e)) && ct(a.activeElement, e.current) && (Me = e);
    };
    return a.addEventListener("focusin", o, !1), i == null || i.forEach((s) => s.addEventListener("focusin", o, !1)), () => {
      a.removeEventListener("focusin", o, !1), i == null || i.forEach((s) => s.removeEventListener("focusin", o, !1));
    };
  }, [
    e,
    r
  ]), Re(() => {
    const i = Be(e.current ? e.current[0] : void 0);
    if (!t) return;
    let a = (o) => {
      if (o.key !== "Tab" || o.altKey || o.ctrlKey || o.metaKey || !Ui(e) || o.isComposing) return;
      let s = i.activeElement;
      if (!ct(s, e.current)) return;
      let u = et.getTreeNode(e);
      if (!u) return;
      let l = u.nodeToRestore, c = bt(i.body, {
        tabbable: !0
      });
      c.currentNode = s;
      let d = o.shiftKey ? c.previousNode() : c.nextNode();
      if ((!l || !i.body.contains(l) || l === i.body) && (l = void 0, u.nodeToRestore = void 0), (!d || !ct(d, e.current)) && l) {
        c.currentNode = l;
        do
          d = o.shiftKey ? c.previousNode() : c.nextNode();
        while (ct(d, e.current));
        o.preventDefault(), o.stopPropagation(), d ? gt(d, !0) : hy(l) ? gt(l, !0) : s.blur();
      }
    };
    return r || i.addEventListener("keydown", a, !0), () => {
      r || i.removeEventListener("keydown", a, !0);
    };
  }, [
    e,
    t,
    r
  ]), Re(() => {
    const i = Be(e.current ? e.current[0] : void 0);
    if (!t) return;
    let a = et.getTreeNode(e);
    if (a) {
      var o;
      return a.nodeToRestore = (o = n.current) !== null && o !== void 0 ? o : void 0, () => {
        let s = et.getTreeNode(e);
        if (!s) return;
        let u = s.nodeToRestore;
        if (t && u && // eslint-disable-next-line react-hooks/exhaustive-deps
        (ct(i.activeElement, e.current) || i.activeElement === i.body && $w(e))) {
          let l = et.clone();
          requestAnimationFrame(() => {
            if (i.activeElement === i.body) {
              let c = l.getTreeNode(e);
              for (; c; ) {
                if (c.nodeToRestore && c.nodeToRestore.isConnected) {
                  gt(c.nodeToRestore);
                  return;
                }
                c = c.parent;
              }
              for (c = l.getTreeNode(e); c; ) {
                if (c.scopeRef && c.scopeRef.current && et.getTreeNode(c.scopeRef)) {
                  ts(c.scopeRef.current, !0);
                  return;
                }
                c = c.parent;
              }
            }
          });
        }
      };
    }
  }, [
    e,
    t
  ]);
}
function bt(e, t, r) {
  let n = t != null && t.tabbable ? mw : pw, i = Be(e).createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode(a) {
      var o;
      return !(t == null || (o = t.from) === null || o === void 0) && o.contains(a) ? NodeFilter.FILTER_REJECT : a.matches(n) && dy(a) && (!r || ct(a, r)) && (!(t != null && t.accept) || t.accept(a)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  return t != null && t.from && (i.currentNode = t.from), i;
}
function Pd(e, t = {}) {
  return {
    focusNext(r = {}) {
      let n = e.current;
      if (!n) return null;
      let { from: i, tabbable: a = t.tabbable, wrap: o = t.wrap, accept: s = t.accept } = r, u = i || Be(n).activeElement, l = bt(n, {
        tabbable: a,
        accept: s
      });
      n.contains(u) && (l.currentNode = u);
      let c = l.nextNode();
      return !c && o && (l.currentNode = n, c = l.nextNode()), c && gt(c, !0), c;
    },
    focusPrevious(r = t) {
      let n = e.current;
      if (!n) return null;
      let { from: i, tabbable: a = t.tabbable, wrap: o = t.wrap, accept: s = t.accept } = r, u = i || Be(n).activeElement, l = bt(n, {
        tabbable: a,
        accept: s
      });
      if (n.contains(u)) l.currentNode = u;
      else {
        let d = Ku(l);
        return d && gt(d, !0), d ?? null;
      }
      let c = l.previousNode();
      if (!c && o) {
        l.currentNode = n;
        let d = Ku(l);
        if (!d)
          return null;
        c = d;
      }
      return c && gt(c, !0), c ?? null;
    },
    focusFirst(r = t) {
      let n = e.current;
      if (!n) return null;
      let { tabbable: i = t.tabbable, accept: a = t.accept } = r, s = bt(n, {
        tabbable: i,
        accept: a
      }).nextNode();
      return s && gt(s, !0), s;
    },
    focusLast(r = t) {
      let n = e.current;
      if (!n) return null;
      let { tabbable: i = t.tabbable, accept: a = t.accept } = r, o = bt(n, {
        tabbable: i,
        accept: a
      }), s = Ku(o);
      return s && gt(s, !0), s ?? null;
    }
  };
}
function Ku(e) {
  let t, r;
  do
    r = e.lastChild(), r && (t = r);
  while (r);
  return t;
}
class Td {
  get size() {
    return this.fastMap.size;
  }
  getTreeNode(t) {
    return this.fastMap.get(t);
  }
  addTreeNode(t, r, n) {
    let i = this.fastMap.get(r ?? null);
    if (!i) return;
    let a = new Yl({
      scopeRef: t
    });
    i.addChild(a), a.parent = i, this.fastMap.set(t, a), n && (a.nodeToRestore = n);
  }
  addNode(t) {
    this.fastMap.set(t.scopeRef, t);
  }
  removeTreeNode(t) {
    if (t === null) return;
    let r = this.fastMap.get(t);
    if (!r) return;
    let n = r.parent;
    for (let a of this.traverse()) a !== r && r.nodeToRestore && a.nodeToRestore && r.scopeRef && r.scopeRef.current && ct(a.nodeToRestore, r.scopeRef.current) && (a.nodeToRestore = r.nodeToRestore);
    let i = r.children;
    n && (n.removeChild(r), i.size > 0 && i.forEach((a) => n && n.addChild(a))), this.fastMap.delete(r.scopeRef);
  }
  // Pre Order Depth First
  *traverse(t = this.root) {
    if (t.scopeRef != null && (yield t), t.children.size > 0) for (let r of t.children) yield* this.traverse(r);
  }
  clone() {
    var t;
    let r = new Td();
    var n;
    for (let i of this.traverse()) r.addTreeNode(i.scopeRef, (n = (t = i.parent) === null || t === void 0 ? void 0 : t.scopeRef) !== null && n !== void 0 ? n : null, i.nodeToRestore);
    return r;
  }
  constructor() {
    this.fastMap = /* @__PURE__ */ new Map(), this.root = new Yl({
      scopeRef: null
    }), this.fastMap.set(null, this.root);
  }
}
class Yl {
  addChild(t) {
    this.children.add(t), t.parent = this;
  }
  removeChild(t) {
    this.children.delete(t), t.parent = void 0;
  }
  constructor(t) {
    this.children = /* @__PURE__ */ new Set(), this.contain = !1, this.scopeRef = t.scopeRef;
  }
}
let et = new Td();
function Qr(e = {}) {
  let { autoFocus: t = !1, isTextInput: r, within: n } = e, i = q({
    isFocused: !1,
    isFocusVisible: t || Zo()
  }), [a, o] = ee(!1), [s, u] = ee(() => i.current.isFocused && i.current.isFocusVisible), l = be(() => u(i.current.isFocused && i.current.isFocusVisible), []), c = be((h) => {
    i.current.isFocused = h, o(h), l();
  }, [
    l
  ]);
  ow((h) => {
    i.current.isFocusVisible = h, l();
  }, [], {
    isTextInput: r
  });
  let { focusProps: d } = iy({
    isDisabled: n,
    onFocusChange: c
  }), { focusWithinProps: f } = $i({
    isDisabled: !n,
    onFocusWithinChange: c
  });
  return {
    isFocused: a,
    isFocusVisible: s,
    focusProps: n ? f : d
  };
}
let Dw = /* @__PURE__ */ P.createContext(null);
function Ew(e) {
  let t = le(Dw) || {};
  wd(t, e);
  let { ref: r, ...n } = t;
  return n;
}
function py(e, t) {
  let { focusProps: r } = iy(e), { keyboardProps: n } = lw(e), i = ve(r, n), a = Ew(t), o = e.isDisabled ? {} : a, s = q(e.autoFocus);
  return oe(() => {
    s.current && t.current && yn(t.current), s.current = !1;
  }, [
    t
  ]), {
    focusableProps: ve({
      ...i,
      tabIndex: e.excludeFromTabOrder && !e.isDisabled ? -1 : void 0
    }, o)
  };
}
const ww = /* @__PURE__ */ new Set([
  "Arab",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]), Cw = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function Sw(e) {
  if (Intl.Locale) {
    let r = new Intl.Locale(e).maximize(), n = typeof r.getTextInfo == "function" ? r.getTextInfo() : r.textInfo;
    if (n) return n.direction === "rtl";
    if (r.script) return ww.has(r.script);
  }
  let t = e.split("-")[0];
  return Cw.has(t);
}
const kw = Symbol.for("react-aria.i18n.locale");
function my() {
  let e = typeof window < "u" && window[kw] || typeof navigator < "u" && (navigator.language || navigator.userLanguage) || "en-US";
  try {
    Intl.DateTimeFormat.supportedLocalesOf([
      e
    ]);
  } catch {
    e = "en-US";
  }
  return {
    locale: e,
    direction: Sw(e) ? "rtl" : "ltr"
  };
}
let Jl = my(), qi = /* @__PURE__ */ new Set();
function Mh() {
  Jl = my();
  for (let e of qi) e(Jl);
}
function Pw() {
  let e = wr(), [t, r] = ee(Jl);
  return oe(() => (qi.size === 0 && window.addEventListener("languagechange", Mh), qi.add(r), () => {
    qi.delete(r), qi.size === 0 && window.removeEventListener("languagechange", Mh);
  }), []), e ? {
    locale: "en-US",
    direction: "ltr"
  } : t;
}
const Tw = /* @__PURE__ */ P.createContext(null);
function st() {
  let e = Pw();
  return le(Tw) || e;
}
const Aw = Symbol.for("react-aria.i18n.locale"), _w = Symbol.for("react-aria.i18n.strings");
let Fn;
class Gr {
  /** Returns a localized string for the given key and locale. */
  getStringForLocale(t, r) {
    let i = this.getStringsForLocale(r)[t];
    if (!i) throw new Error(`Could not find intl message ${t} in ${r} locale`);
    return i;
  }
  /** Returns all localized strings for the given locale. */
  getStringsForLocale(t) {
    let r = this.strings[t];
    return r || (r = Fw(t, this.strings, this.defaultLocale), this.strings[t] = r), r;
  }
  static getGlobalDictionaryForPackage(t) {
    if (typeof window > "u") return null;
    let r = window[Aw];
    if (Fn === void 0) {
      let i = window[_w];
      if (!i) return null;
      Fn = {};
      for (let a in i) Fn[a] = new Gr({
        [r]: i[a]
      }, r);
    }
    let n = Fn == null ? void 0 : Fn[t];
    if (!n) throw new Error(`Strings for package "${t}" were not included by LocalizedStringProvider. Please add it to the list passed to createLocalizedStringDictionary.`);
    return n;
  }
  constructor(t, r = "en-US") {
    this.strings = Object.fromEntries(Object.entries(t).filter(([, n]) => n)), this.defaultLocale = r;
  }
}
function Fw(e, t, r = "en-US") {
  if (t[e]) return t[e];
  let n = Ow(e);
  if (t[n]) return t[n];
  for (let i in t)
    if (i.startsWith(n + "-")) return t[i];
  return t[r];
}
function Ow(e) {
  return Intl.Locale ? new Intl.Locale(e).language : e.split("-")[0];
}
const Nh = /* @__PURE__ */ new Map(), Lh = /* @__PURE__ */ new Map();
class vy {
  /** Formats a localized string for the given key with the provided variables. */
  format(t, r) {
    let n = this.strings.getStringForLocale(t, this.locale);
    return typeof n == "function" ? n(r, this) : n;
  }
  plural(t, r, n = "cardinal") {
    let i = r["=" + t];
    if (i) return typeof i == "function" ? i() : i;
    let a = this.locale + ":" + n, o = Nh.get(a);
    o || (o = new Intl.PluralRules(this.locale, {
      type: n
    }), Nh.set(a, o));
    let s = o.select(t);
    return i = r[s] || r.other, typeof i == "function" ? i() : i;
  }
  number(t) {
    let r = Lh.get(this.locale);
    return r || (r = new Intl.NumberFormat(this.locale), Lh.set(this.locale, r)), r.format(t);
  }
  select(t, r) {
    let n = t[r] || t.other;
    return typeof n == "function" ? n() : n;
  }
  constructor(t, r) {
    this.locale = t, this.strings = r;
  }
}
const Vh = /* @__PURE__ */ new WeakMap();
function Iw(e) {
  let t = Vh.get(e);
  return t || (t = new Gr(e), Vh.set(e, t)), t;
}
function yy(e, t) {
  return t && Gr.getGlobalDictionaryForPackage(t) || Iw(e);
}
function Ht(e, t) {
  let { locale: r } = st(), n = yy(e, t);
  return G(() => new vy(r, n), [
    r,
    n
  ]);
}
function Xn(e, t) {
  return e - t * Math.floor(e / t);
}
const gy = 1721426;
function sn(e, t, r, n) {
  t = za(e, t);
  let i = t - 1, a = -2;
  return r <= 2 ? a = 0 : Nr(t) && (a = -1), gy - 1 + 365 * i + Math.floor(i / 4) - Math.floor(i / 100) + Math.floor(i / 400) + Math.floor((367 * r - 362) / 12 + a + n);
}
function Nr(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function za(e, t) {
  return e === "BC" ? 1 - t : t;
}
function Ys(e) {
  let t = "AD";
  return e <= 0 && (t = "BC", e = 1 - e), [
    t,
    e
  ];
}
const Rw = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
class xt {
  fromJulianDay(t) {
    let r = t, n = r - gy, i = Math.floor(n / 146097), a = Xn(n, 146097), o = Math.floor(a / 36524), s = Xn(a, 36524), u = Math.floor(s / 1461), l = Xn(s, 1461), c = Math.floor(l / 365), d = i * 400 + o * 100 + u * 4 + c + (o !== 4 && c !== 4 ? 1 : 0), [f, h] = Ys(d), p = r - sn(f, h, 1, 1), v = 2;
    r < sn(f, h, 3, 1) ? v = 0 : Nr(h) && (v = 1);
    let g = Math.floor(((p + v) * 12 + 373) / 367), $ = r - sn(f, h, g, 1) + 1;
    return new rt(f, h, g, $);
  }
  toJulianDay(t) {
    return sn(t.era, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    return Rw[Nr(t.year) ? "leapyear" : "standard"][t.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(t) {
    return 12;
  }
  getDaysInYear(t) {
    return Nr(t.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(t) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(t) {
    return t.era === "BC";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BC" ? "AD" : "BC", t.year = 1 - t.year);
  }
  constructor() {
    this.identifier = "gregory";
  }
}
const Bw = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};
function tt(e, t) {
  return t = ze(t, e.calendar), e.era === t.era && e.year === t.year && e.month === t.month && e.day === t.day;
}
function Mw(e, t) {
  return t = ze(t, e.calendar), e = $r(e), t = $r(t), e.era === t.era && e.year === t.year && e.month === t.month;
}
function Xl(e, t) {
  return e.calendar.identifier === t.calendar.identifier && e.era === t.era && e.year === t.year && e.month === t.month && e.day === t.day;
}
function Nw(e, t) {
  return tt(e, Js(t));
}
function Ad(e, t) {
  let r = e.calendar.toJulianDay(e), n = Math.ceil(r + 1 - Kw(t)) % 7;
  return n < 0 && (n += 7), n;
}
function by(e) {
  return hr(Date.now(), e);
}
function Js(e) {
  return $t(by(e));
}
function $y(e, t) {
  return e.calendar.toJulianDay(e) - t.calendar.toJulianDay(t);
}
function xy(e, t) {
  return zh(e) - zh(t);
}
function zh(e) {
  return e.hour * 36e5 + e.minute * 6e4 + e.second * 1e3 + e.millisecond;
}
let Uu = null;
function gn() {
  return Uu == null && (Uu = new Intl.DateTimeFormat().resolvedOptions().timeZone), Uu;
}
function $r(e) {
  return e.subtract({
    days: e.day - 1
  });
}
function fi(e) {
  return e.add({
    days: e.calendar.getDaysInMonth(e) - e.day
  });
}
function ec(e) {
  return $r(e.subtract({
    months: e.month - 1
  }));
}
function Lw(e) {
  return fi(e.add({
    months: e.calendar.getMonthsInYear(e) - e.month
  }));
}
function Vw(e) {
  return e.calendar.getMinimumMonthInYear ? e.calendar.getMinimumMonthInYear(e) : 1;
}
function zw(e) {
  return e.calendar.getMinimumDayInMonth ? e.calendar.getMinimumDayInMonth(e) : 1;
}
function bn(e, t) {
  let r = Ad(e, t);
  return e.subtract({
    days: r
  });
}
function Dy(e, t) {
  return bn(e, t).add({
    days: 6
  });
}
const jh = /* @__PURE__ */ new Map();
function jw(e) {
  if (Intl.Locale) {
    let r = jh.get(e);
    return r || (r = new Intl.Locale(e).maximize().region, r && jh.set(e, r)), r;
  }
  let t = e.split("-")[1];
  return t === "u" ? void 0 : t;
}
function Kw(e) {
  let t = jw(e);
  return t && Bw[t] || 0;
}
function Uw(e, t) {
  let r = e.calendar.getDaysInMonth(e);
  return Math.ceil((Ad($r(e), t) + r) / 7);
}
function _d(e, t) {
  return e && t ? e.compare(t) <= 0 ? e : t : e || t;
}
function Fd(e, t) {
  return e && t ? e.compare(t) >= 0 ? e : t : e || t;
}
function hi(e) {
  e = ze(e, new xt());
  let t = za(e.era, e.year);
  return Ey(t, e.month, e.day, e.hour, e.minute, e.second, e.millisecond);
}
function Ey(e, t, r, n, i, a, o) {
  let s = /* @__PURE__ */ new Date();
  return s.setUTCHours(n, i, a, o), s.setUTCFullYear(e, t - 1, r), s.getTime();
}
function tc(e, t) {
  if (t === "UTC") return 0;
  if (e > 0 && t === gn()) return new Date(e).getTimezoneOffset() * -6e4;
  let { year: r, month: n, day: i, hour: a, minute: o, second: s } = wy(e, t);
  return Ey(r, n, i, a, o, s, 0) - Math.floor(e / 1e3) * 1e3;
}
const Kh = /* @__PURE__ */ new Map();
function wy(e, t) {
  let r = Kh.get(t);
  r || (r = new Intl.DateTimeFormat("en-US", {
    timeZone: t,
    hour12: !1,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), Kh.set(t, r));
  let n = r.formatToParts(new Date(e)), i = {};
  for (let a of n) a.type !== "literal" && (i[a.type] = a.value);
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: i.era === "BC" || i.era === "B" ? -i.year + 1 : +i.year,
    month: +i.month,
    day: +i.day,
    hour: i.hour === "24" ? 0 : +i.hour,
    minute: +i.minute,
    second: +i.second
  };
}
const Uh = 864e5;
function qw(e, t, r, n) {
  return (r === n ? [
    r
  ] : [
    r,
    n
  ]).filter((a) => Hw(e, t, a));
}
function Hw(e, t, r) {
  let n = wy(r, t);
  return e.year === n.year && e.month === n.month && e.day === n.day && e.hour === n.hour && e.minute === n.minute && e.second === n.second;
}
function dr(e, t, r = "compatible") {
  let n = xr(e);
  if (t === "UTC") return hi(n);
  if (t === gn() && r === "compatible") {
    n = ze(n, new xt());
    let u = /* @__PURE__ */ new Date(), l = za(n.era, n.year);
    return u.setFullYear(l, n.month - 1, n.day), u.setHours(n.hour, n.minute, n.second, n.millisecond), u.getTime();
  }
  let i = hi(n), a = tc(i - Uh, t), o = tc(i + Uh, t), s = qw(n, t, i - a, i - o);
  if (s.length === 1) return s[0];
  if (s.length > 1) switch (r) {
    case "compatible":
    case "earlier":
      return s[0];
    case "later":
      return s[s.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (r) {
    case "earlier":
      return Math.min(i - a, i - o);
    case "compatible":
    case "later":
      return Math.max(i - a, i - o);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function Cy(e, t, r = "compatible") {
  return new Date(dr(e, t, r));
}
function hr(e, t) {
  let r = tc(e, t), n = new Date(e + r), i = n.getUTCFullYear(), a = n.getUTCMonth() + 1, o = n.getUTCDate(), s = n.getUTCHours(), u = n.getUTCMinutes(), l = n.getUTCSeconds(), c = n.getUTCMilliseconds();
  return new Da(i, a, o, t, r, s, u, l, c);
}
function $t(e) {
  return new rt(e.calendar, e.era, e.year, e.month, e.day);
}
function xr(e, t) {
  let r = 0, n = 0, i = 0, a = 0;
  if ("timeZone" in e) ({ hour: r, minute: n, second: i, millisecond: a } = e);
  else if ("hour" in e && !t) return e;
  return t && ({ hour: r, minute: n, second: i, millisecond: a } = t), new rs(e.calendar, e.era, e.year, e.month, e.day, r, n, i, a);
}
function ze(e, t) {
  if (e.calendar.identifier === t.identifier) return e;
  let r = t.fromJulianDay(e.calendar.toJulianDay(e)), n = e.copy();
  return n.calendar = t, n.era = r.era, n.year = r.year, n.month = r.month, n.day = r.day, $n(n), n;
}
function Ww(e, t, r) {
  if (e instanceof Da)
    return e.timeZone === t ? e : Gw(e, t);
  let n = dr(e, t, r);
  return hr(n, t);
}
function Qw(e) {
  let t = hi(e) - e.offset;
  return new Date(t);
}
function Gw(e, t) {
  let r = hi(e) - e.offset;
  return ze(hr(r, t), e.calendar);
}
const Ri = 36e5;
function Xs(e, t) {
  let r = e.copy(), n = "hour" in r ? Ty(r, t) : 0;
  rc(r, t.years || 0), r.calendar.balanceYearMonth && r.calendar.balanceYearMonth(r, e), r.month += t.months || 0, nc(r), Sy(r), r.day += (t.weeks || 0) * 7, r.day += t.days || 0, r.day += n, Zw(r), r.calendar.balanceDate && r.calendar.balanceDate(r), r.year < 1 && (r.year = 1, r.month = 1, r.day = 1);
  let i = r.calendar.getYearsInEra(r);
  if (r.year > i) {
    var a, o;
    let u = (a = (o = r.calendar).isInverseEra) === null || a === void 0 ? void 0 : a.call(o, r);
    r.year = i, r.month = u ? 1 : r.calendar.getMonthsInYear(r), r.day = u ? 1 : r.calendar.getDaysInMonth(r);
  }
  r.month < 1 && (r.month = 1, r.day = 1);
  let s = r.calendar.getMonthsInYear(r);
  return r.month > s && (r.month = s, r.day = r.calendar.getDaysInMonth(r)), r.day = Math.max(1, Math.min(r.calendar.getDaysInMonth(r), r.day)), r;
}
function rc(e, t) {
  var r, n;
  !((r = (n = e.calendar).isInverseEra) === null || r === void 0) && r.call(n, e) && (t = -t), e.year += t;
}
function nc(e) {
  for (; e.month < 1; )
    rc(e, -1), e.month += e.calendar.getMonthsInYear(e);
  let t = 0;
  for (; e.month > (t = e.calendar.getMonthsInYear(e)); )
    e.month -= t, rc(e, 1);
}
function Zw(e) {
  for (; e.day < 1; )
    e.month--, nc(e), e.day += e.calendar.getDaysInMonth(e);
  for (; e.day > e.calendar.getDaysInMonth(e); )
    e.day -= e.calendar.getDaysInMonth(e), e.month++, nc(e);
}
function Sy(e) {
  e.month = Math.max(1, Math.min(e.calendar.getMonthsInYear(e), e.month)), e.day = Math.max(1, Math.min(e.calendar.getDaysInMonth(e), e.day));
}
function $n(e) {
  e.calendar.constrainDate && e.calendar.constrainDate(e), e.year = Math.max(1, Math.min(e.calendar.getYearsInEra(e), e.year)), Sy(e);
}
function Od(e) {
  let t = {};
  for (let r in e) typeof e[r] == "number" && (t[r] = -e[r]);
  return t;
}
function ky(e, t) {
  return Xs(e, Od(t));
}
function Id(e, t) {
  let r = e.copy();
  return t.era != null && (r.era = t.era), t.year != null && (r.year = t.year), t.month != null && (r.month = t.month), t.day != null && (r.day = t.day), $n(r), r;
}
function xa(e, t) {
  let r = e.copy();
  return t.hour != null && (r.hour = t.hour), t.minute != null && (r.minute = t.minute), t.second != null && (r.second = t.second), t.millisecond != null && (r.millisecond = t.millisecond), Py(r), r;
}
function Yw(e) {
  e.second += Math.floor(e.millisecond / 1e3), e.millisecond = po(e.millisecond, 1e3), e.minute += Math.floor(e.second / 60), e.second = po(e.second, 60), e.hour += Math.floor(e.minute / 60), e.minute = po(e.minute, 60);
  let t = Math.floor(e.hour / 24);
  return e.hour = po(e.hour, 24), t;
}
function Py(e) {
  e.millisecond = Math.max(0, Math.min(e.millisecond, 1e3)), e.second = Math.max(0, Math.min(e.second, 59)), e.minute = Math.max(0, Math.min(e.minute, 59)), e.hour = Math.max(0, Math.min(e.hour, 23));
}
function po(e, t) {
  let r = e % t;
  return r < 0 && (r += t), r;
}
function Ty(e, t) {
  return e.hour += t.hours || 0, e.minute += t.minutes || 0, e.second += t.seconds || 0, e.millisecond += t.milliseconds || 0, Yw(e);
}
function Ay(e, t) {
  let r = e.copy();
  return Ty(r, t), r;
}
function Jw(e, t) {
  return Ay(e, Od(t));
}
function Rd(e, t, r, n) {
  let i = e.copy();
  switch (t) {
    case "era": {
      let s = e.calendar.getEras(), u = s.indexOf(e.era);
      if (u < 0) throw new Error("Invalid era: " + e.era);
      u = pr(u, r, 0, s.length - 1, n == null ? void 0 : n.round), i.era = s[u], $n(i);
      break;
    }
    case "year":
      var a, o;
      !((a = (o = i.calendar).isInverseEra) === null || a === void 0) && a.call(o, i) && (r = -r), i.year = pr(e.year, r, -1 / 0, 9999, n == null ? void 0 : n.round), i.year === -1 / 0 && (i.year = 1), i.calendar.balanceYearMonth && i.calendar.balanceYearMonth(i, e);
      break;
    case "month":
      i.month = pr(e.month, r, 1, e.calendar.getMonthsInYear(e), n == null ? void 0 : n.round);
      break;
    case "day":
      i.day = pr(e.day, r, 1, e.calendar.getDaysInMonth(e), n == null ? void 0 : n.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return e.calendar.balanceDate && e.calendar.balanceDate(i), $n(i), i;
}
function Bd(e, t, r, n) {
  let i = e.copy();
  switch (t) {
    case "hour": {
      let a = e.hour, o = 0, s = 23;
      if ((n == null ? void 0 : n.hourCycle) === 12) {
        let u = a >= 12;
        o = u ? 12 : 0, s = u ? 23 : 11;
      }
      i.hour = pr(a, r, o, s, n == null ? void 0 : n.round);
      break;
    }
    case "minute":
      i.minute = pr(e.minute, r, 0, 59, n == null ? void 0 : n.round);
      break;
    case "second":
      i.second = pr(e.second, r, 0, 59, n == null ? void 0 : n.round);
      break;
    case "millisecond":
      i.millisecond = pr(e.millisecond, r, 0, 999, n == null ? void 0 : n.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return i;
}
function pr(e, t, r, n, i = !1) {
  if (i) {
    e += Math.sign(t), e < r && (e = n);
    let a = Math.abs(t);
    t > 0 ? e = Math.ceil(e / a) * a : e = Math.floor(e / a) * a, e > n && (e = r);
  } else
    e += t, e < r ? e = n - (r - e - 1) : e > n && (e = r + (e - n - 1));
  return e;
}
function _y(e, t) {
  let r;
  if (t.years != null && t.years !== 0 || t.months != null && t.months !== 0 || t.weeks != null && t.weeks !== 0 || t.days != null && t.days !== 0) {
    let i = Xs(xr(e), {
      years: t.years,
      months: t.months,
      weeks: t.weeks,
      days: t.days
    });
    r = dr(i, e.timeZone);
  } else
    r = hi(e) - e.offset;
  r += t.milliseconds || 0, r += (t.seconds || 0) * 1e3, r += (t.minutes || 0) * 6e4, r += (t.hours || 0) * 36e5;
  let n = hr(r, e.timeZone);
  return ze(n, e.calendar);
}
function Xw(e, t) {
  return _y(e, Od(t));
}
function eC(e, t, r, n) {
  switch (t) {
    case "hour": {
      let i = 0, a = 23;
      if ((n == null ? void 0 : n.hourCycle) === 12) {
        let p = e.hour >= 12;
        i = p ? 12 : 0, a = p ? 23 : 11;
      }
      let o = xr(e), s = ze(xa(o, {
        hour: i
      }), new xt()), u = [
        dr(s, e.timeZone, "earlier"),
        dr(s, e.timeZone, "later")
      ].filter((p) => hr(p, e.timeZone).day === s.day)[0], l = ze(xa(o, {
        hour: a
      }), new xt()), c = [
        dr(l, e.timeZone, "earlier"),
        dr(l, e.timeZone, "later")
      ].filter((p) => hr(p, e.timeZone).day === l.day).pop(), d = hi(e) - e.offset, f = Math.floor(d / Ri), h = d % Ri;
      return d = pr(f, r, Math.floor(u / Ri), Math.floor(c / Ri), n == null ? void 0 : n.round) * Ri + h, ze(hr(d, e.timeZone), e.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return Bd(e, t, r, n);
    case "era":
    case "year":
    case "month":
    case "day": {
      let i = Rd(xr(e), t, r, n), a = dr(i, e.timeZone);
      return ze(hr(a, e.timeZone), e.calendar);
    }
    default:
      throw new Error("Unsupported field " + t);
  }
}
function tC(e, t, r) {
  let n = xr(e), i = xa(Id(n, t), t);
  if (i.compare(n) === 0) return e;
  let a = dr(i, e.timeZone, r);
  return ze(hr(a, e.timeZone), e.calendar);
}
function Fy(e) {
  return `${String(e.hour).padStart(2, "0")}:${String(e.minute).padStart(2, "0")}:${String(e.second).padStart(2, "0")}${e.millisecond ? String(e.millisecond / 1e3).slice(1) : ""}`;
}
function Oy(e) {
  let t = ze(e, new xt());
  return `${String(t.year).padStart(4, "0")}-${String(t.month).padStart(2, "0")}-${String(t.day).padStart(2, "0")}`;
}
function Iy(e) {
  return `${Oy(e)}T${Fy(e)}`;
}
function rC(e) {
  let t = Math.sign(e) < 0 ? "-" : "+";
  e = Math.abs(e);
  let r = Math.floor(e / 36e5), n = e % 36e5 / 6e4;
  return `${t}${String(r).padStart(2, "0")}:${String(n).padStart(2, "0")}`;
}
function nC(e) {
  return `${Iy(e)}${rC(e.offset)}[${e.timeZone}]`;
}
function Md(e) {
  let t = typeof e[0] == "object" ? e.shift() : new xt(), r;
  if (typeof e[0] == "string") r = e.shift();
  else {
    let o = t.getEras();
    r = o[o.length - 1];
  }
  let n = e.shift(), i = e.shift(), a = e.shift();
  return [
    t,
    r,
    n,
    i,
    a
  ];
}
var iC = /* @__PURE__ */ new WeakMap();
class rt {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new rt(this.calendar, this.era, this.year, this.month, this.day) : new rt(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(t) {
    return Xs(this, t);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(t) {
    return ky(this, t);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return Id(this, t);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, r, n) {
    return Rd(this, t, r, n);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(t) {
    return Cy(this, t);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return Oy(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return $y(this, t);
  }
  constructor(...t) {
    La(this, iC, {
      writable: !0,
      value: void 0
    });
    let [r, n, i, a, o] = Md(t);
    this.calendar = r, this.era = n, this.year = i, this.month = a, this.day = o, $n(this);
  }
}
var aC = /* @__PURE__ */ new WeakMap();
class Nd {
  /** Returns a copy of this time. */
  copy() {
    return new Nd(this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `Time` with the given duration added to it. */
  add(t) {
    return Ay(this, t);
  }
  /** Returns a new `Time` with the given duration subtracted from it. */
  subtract(t) {
    return Jw(this, t);
  }
  /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return xa(this, t);
  }
  /**
  * Returns a new `Time` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, r, n) {
    return Bd(this, t, r, n);
  }
  /** Converts the time to an ISO 8601 formatted string. */
  toString() {
    return Fy(this);
  }
  /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */
  compare(t) {
    return xy(this, t);
  }
  constructor(t = 0, r = 0, n = 0, i = 0) {
    La(this, aC, {
      writable: !0,
      value: void 0
    }), this.hour = t, this.minute = r, this.second = n, this.millisecond = i, Py(this);
  }
}
var oC = /* @__PURE__ */ new WeakMap();
class rs {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new rs(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond) : new rs(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(t) {
    return Xs(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return ky(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return Id(xa(this, t), t);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, r, n) {
    switch (t) {
      case "era":
      case "year":
      case "month":
      case "day":
        return Rd(this, t, r, n);
      default:
        return Bd(this, t, r, n);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(t, r) {
    return Cy(this, t, r);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return Iy(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    let r = $y(this, t);
    return r === 0 ? xy(this, xr(t)) : r;
  }
  constructor(...t) {
    La(this, oC, {
      writable: !0,
      value: void 0
    });
    let [r, n, i, a, o] = Md(t);
    this.calendar = r, this.era = n, this.year = i, this.month = a, this.day = o, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, $n(this);
  }
}
var sC = /* @__PURE__ */ new WeakMap();
class Da {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Da(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond) : new Da(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(t) {
    return _y(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return Xw(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t, r) {
    return tC(this, t, r);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, r, n) {
    return eC(this, t, r, n);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return Qw(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return nC(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return this.toDate().getTime() - Ww(t, this.timeZone).toDate().getTime();
  }
  constructor(...t) {
    La(this, sC, {
      writable: !0,
      value: void 0
    });
    let [r, n, i, a, o] = Md(t), s = t.shift(), u = t.shift();
    this.calendar = r, this.era = n, this.year = i, this.month = a, this.day = o, this.timeZone = s, this.offset = u, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, $n(this);
  }
}
const ei = [
  [
    1868,
    9,
    8
  ],
  [
    1912,
    7,
    30
  ],
  [
    1926,
    12,
    25
  ],
  [
    1989,
    1,
    8
  ],
  [
    2019,
    5,
    1
  ]
], uC = [
  [
    1912,
    7,
    29
  ],
  [
    1926,
    12,
    24
  ],
  [
    1989,
    1,
    7
  ],
  [
    2019,
    4,
    30
  ]
], Oo = [
  1867,
  1911,
  1925,
  1988,
  2018
], Br = [
  "meiji",
  "taisho",
  "showa",
  "heisei",
  "reiwa"
];
function qh(e) {
  const t = ei.findIndex(([r, n, i]) => e.year < r || e.year === r && e.month < n || e.year === r && e.month === n && e.day < i);
  return t === -1 ? ei.length - 1 : t === 0 ? 0 : t - 1;
}
function qu(e) {
  let t = Oo[Br.indexOf(e.era)];
  if (!t) throw new Error("Unknown era: " + e.era);
  return new rt(e.year + t, e.month, e.day);
}
class lC extends xt {
  fromJulianDay(t) {
    let r = super.fromJulianDay(t), n = qh(r);
    return new rt(this, Br[n], r.year - Oo[n], r.month, r.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(qu(t));
  }
  balanceDate(t) {
    let r = qu(t), n = qh(r);
    Br[n] !== t.era && (t.era = Br[n], t.year = r.year - Oo[n]), this.constrainDate(t);
  }
  constrainDate(t) {
    let r = Br.indexOf(t.era), n = uC[r];
    if (n != null) {
      let [i, a, o] = n, s = i - Oo[r];
      t.year = Math.max(1, Math.min(s, t.year)), t.year === s && (t.month = Math.min(a, t.month), t.month === a && (t.day = Math.min(o, t.day)));
    }
    if (t.year === 1 && r >= 0) {
      let [, i, a] = ei[r];
      t.month = Math.max(i, t.month), t.month === i && (t.day = Math.max(a, t.day));
    }
  }
  getEras() {
    return Br;
  }
  getYearsInEra(t) {
    let r = Br.indexOf(t.era), n = ei[r], i = ei[r + 1];
    if (i == null)
      return 9999 - n[0] + 1;
    let a = i[0] - n[0];
    return (t.month < i[1] || t.month === i[1] && t.day < i[2]) && a++, a;
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(qu(t));
  }
  getMinimumMonthInYear(t) {
    let r = Hh(t);
    return r ? r[1] : 1;
  }
  getMinimumDayInMonth(t) {
    let r = Hh(t);
    return r && t.month === r[1] ? r[2] : 1;
  }
  constructor(...t) {
    super(...t), this.identifier = "japanese";
  }
}
function Hh(e) {
  if (e.year === 1) {
    let t = Br.indexOf(e.era);
    return ei[t];
  }
}
const Ry = -543;
class cC extends xt {
  fromJulianDay(t) {
    let r = super.fromJulianDay(t), n = za(r.era, r.year);
    return new rt(this, n - Ry, r.month, r.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(Wh(t));
  }
  getEras() {
    return [
      "BE"
    ];
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(Wh(t));
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "buddhist";
  }
}
function Wh(e) {
  let [t, r] = Ys(e.year + Ry);
  return new rt(t, r, e.month, e.day);
}
const ns = 1911;
function By(e) {
  return e.era === "minguo" ? e.year + ns : 1 - e.year + ns;
}
function Qh(e) {
  let t = e - ns;
  return t > 0 ? [
    "minguo",
    t
  ] : [
    "before_minguo",
    1 - t
  ];
}
class dC extends xt {
  fromJulianDay(t) {
    let r = super.fromJulianDay(t), n = za(r.era, r.year), [i, a] = Qh(n);
    return new rt(this, i, a, r.month, r.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(Gh(t));
  }
  getEras() {
    return [
      "before_minguo",
      "minguo"
    ];
  }
  balanceDate(t) {
    let [r, n] = Qh(By(t));
    t.era = r, t.year = n;
  }
  isInverseEra(t) {
    return t.era === "before_minguo";
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(Gh(t));
  }
  getYearsInEra(t) {
    return t.era === "before_minguo" ? 9999 : 9999 - ns;
  }
  constructor(...t) {
    super(...t), this.identifier = "roc";
  }
}
function Gh(e) {
  let [t, r] = Ys(By(e));
  return new rt(t, r, e.month, e.day);
}
const Zh = 1948320, Yh = [
  0,
  31,
  62,
  93,
  124,
  155,
  186,
  216,
  246,
  276,
  306,
  336
  // Esfand
];
class fC {
  fromJulianDay(t) {
    let r = t - Zh, n = 1 + Math.floor((33 * r + 3) / 12053), i = 365 * (n - 1) + Math.floor((8 * n + 21) / 33), a = r - i, o = a < 216 ? Math.floor(a / 31) : Math.floor((a - 6) / 30), s = a - Yh[o] + 1;
    return new rt(this, n, o + 1, s);
  }
  toJulianDay(t) {
    let r = Zh - 1 + 365 * (t.year - 1) + Math.floor((8 * t.year + 21) / 33);
    return r += Yh[t.month - 1], r += t.day, r;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInMonth(t) {
    return t.month <= 6 ? 31 : t.month <= 11 || Xn(25 * t.year + 11, 33) < 8 ? 30 : 29;
  }
  getEras() {
    return [
      "AP"
    ];
  }
  getYearsInEra() {
    return 9377;
  }
  constructor() {
    this.identifier = "persian";
  }
}
const Hu = 78, Jh = 80;
class hC extends xt {
  fromJulianDay(t) {
    let r = super.fromJulianDay(t), n = r.year - Hu, i = t - sn(r.era, r.year, 1, 1), a;
    i < Jh ? (n--, a = Nr(r.year - 1) ? 31 : 30, i += a + 155 + 90 + 10) : (a = Nr(r.year) ? 31 : 30, i -= Jh);
    let o, s;
    if (i < a)
      o = 1, s = i + 1;
    else {
      let u = i - a;
      u < 155 ? (o = Math.floor(u / 31) + 2, s = u % 31 + 1) : (u -= 155, o = Math.floor(u / 30) + 7, s = u % 30 + 1);
    }
    return new rt(this, n, o, s);
  }
  toJulianDay(t) {
    let r = t.year + Hu, [n, i] = Ys(r), a, o;
    return Nr(i) ? (a = 31, o = sn(n, i, 3, 21)) : (a = 30, o = sn(n, i, 3, 22)), t.month === 1 ? o + t.day - 1 : (o += a + Math.min(t.month - 2, 5) * 31, t.month >= 8 && (o += (t.month - 7) * 30), o += t.day - 1, o);
  }
  getDaysInMonth(t) {
    return t.month === 1 && Nr(t.year + Hu) || t.month >= 2 && t.month <= 6 ? 31 : 30;
  }
  getYearsInEra() {
    return 9919;
  }
  getEras() {
    return [
      "saka"
    ];
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "indian";
  }
}
const is = 1948440, Xh = 1948439, Ft = 1300, On = 1600, pC = 460322;
function as(e, t, r, n) {
  return n + Math.ceil(29.5 * (r - 1)) + (t - 1) * 354 + Math.floor((3 + 11 * t) / 30) + e - 1;
}
function My(e, t, r) {
  let n = Math.floor((30 * (r - t) + 10646) / 10631), i = Math.min(12, Math.ceil((r - (29 + as(t, n, 1, 1))) / 29.5) + 1), a = r - as(t, n, i, 1) + 1;
  return new rt(e, n, i, a);
}
function ep(e) {
  return (14 + 11 * e) % 30 < 11;
}
class Ld {
  fromJulianDay(t) {
    return My(this, is, t);
  }
  toJulianDay(t) {
    return as(is, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    let r = 29 + t.month % 2;
    return t.month === 12 && ep(t.year) && r++, r;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInYear(t) {
    return ep(t.year) ? 355 : 354;
  }
  getYearsInEra() {
    return 9665;
  }
  getEras() {
    return [
      "AH"
    ];
  }
  constructor() {
    this.identifier = "islamic-civil";
  }
}
class mC extends Ld {
  fromJulianDay(t) {
    return My(this, Xh, t);
  }
  toJulianDay(t) {
    return as(Xh, t.year, t.month, t.day);
  }
  constructor(...t) {
    super(...t), this.identifier = "islamic-tbla";
  }
}
const vC = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
let ic, ti;
function Io(e) {
  return pC + ti[e - Ft];
}
function Hi(e, t) {
  let r = e - Ft, n = 1 << 11 - (t - 1);
  return ic[r] & n ? 30 : 29;
}
function tp(e, t) {
  let r = Io(e);
  for (let n = 1; n < t; n++) r += Hi(e, n);
  return r;
}
function rp(e) {
  return ti[e + 1 - Ft] - ti[e - Ft];
}
class yC extends Ld {
  fromJulianDay(t) {
    let r = t - is, n = Io(Ft), i = Io(On);
    if (r < n || r > i) return super.fromJulianDay(t);
    {
      let a = Ft - 1, o = 1, s = 1;
      for (; s > 0; ) {
        a++, s = r - Io(a) + 1;
        let u = rp(a);
        if (s === u) {
          o = 12;
          break;
        } else if (s < u) {
          let l = Hi(a, o);
          for (o = 1; s > l; )
            s -= l, o++, l = Hi(a, o);
          break;
        }
      }
      return new rt(this, a, o, r - tp(a, o) + 1);
    }
  }
  toJulianDay(t) {
    return t.year < Ft || t.year > On ? super.toJulianDay(t) : is + tp(t.year, t.month) + (t.day - 1);
  }
  getDaysInMonth(t) {
    return t.year < Ft || t.year > On ? super.getDaysInMonth(t) : Hi(t.year, t.month);
  }
  getDaysInYear(t) {
    return t.year < Ft || t.year > On ? super.getDaysInYear(t) : rp(t.year);
  }
  constructor() {
    if (super(), this.identifier = "islamic-umalqura", ic || (ic = new Uint16Array(Uint8Array.from(atob(vC), (t) => t.charCodeAt(0)).buffer)), !ti) {
      ti = new Uint32Array(On - Ft + 1);
      let t = 0;
      for (let r = Ft; r <= On; r++) {
        ti[r - Ft] = t;
        for (let n = 1; n <= 12; n++) t += Hi(r, n);
      }
    }
  }
}
const np = 347997, Ny = 1080, Ly = 24 * Ny, gC = 29, bC = 12 * Ny + 793, $C = gC * Ly + bC;
function tn(e) {
  return Xn(e * 7 + 1, 19) < 7;
}
function Ro(e) {
  let t = Math.floor((235 * e - 234) / 19), r = 12084 + 13753 * t, n = t * 29 + Math.floor(r / 25920);
  return Xn(3 * (n + 1), 7) < 3 && (n += 1), n;
}
function xC(e) {
  let t = Ro(e - 1), r = Ro(e);
  return Ro(e + 1) - r === 356 ? 2 : r - t === 382 ? 1 : 0;
}
function na(e) {
  return Ro(e) + xC(e);
}
function Vy(e) {
  return na(e + 1) - na(e);
}
function DC(e) {
  let t = Vy(e);
  switch (t > 380 && (t -= 30), t) {
    case 353:
      return 0;
    case 354:
      return 1;
    case 355:
      return 2;
  }
}
function mo(e, t) {
  if (t >= 6 && !tn(e) && t++, t === 4 || t === 7 || t === 9 || t === 11 || t === 13) return 29;
  let r = DC(e);
  return t === 2 ? r === 2 ? 30 : 29 : t === 3 ? r === 0 ? 29 : 30 : t === 6 ? tn(e) ? 30 : 0 : 30;
}
class EC {
  fromJulianDay(t) {
    let r = t - np, n = r * Ly / $C, i = Math.floor((19 * n + 234) / 235) + 1, a = na(i), o = Math.floor(r - a);
    for (; o < 1; )
      i--, a = na(i), o = Math.floor(r - a);
    let s = 1, u = 0;
    for (; u < o; )
      u += mo(i, s), s++;
    s--, u -= mo(i, s);
    let l = o - u;
    return new rt(this, i, s, l);
  }
  toJulianDay(t) {
    let r = na(t.year);
    for (let n = 1; n < t.month; n++) r += mo(t.year, n);
    return r + t.day + np;
  }
  getDaysInMonth(t) {
    return mo(t.year, t.month);
  }
  getMonthsInYear(t) {
    return tn(t.year) ? 13 : 12;
  }
  getDaysInYear(t) {
    return Vy(t.year);
  }
  getYearsInEra() {
    return 9999;
  }
  getEras() {
    return [
      "AM"
    ];
  }
  balanceYearMonth(t, r) {
    r.year !== t.year && (tn(r.year) && !tn(t.year) && r.month > 6 ? t.month-- : !tn(r.year) && tn(t.year) && r.month > 6 && t.month++);
  }
  constructor() {
    this.identifier = "hebrew";
  }
}
const ac = 1723856, ip = 1824665, oc = 5500;
function os(e, t, r, n) {
  return e + 365 * t + Math.floor(t / 4) + 30 * (r - 1) + n - 1;
}
function Vd(e, t) {
  let r = Math.floor(4 * (t - e) / 1461), n = 1 + Math.floor((t - os(e, r, 1, 1)) / 30), i = t + 1 - os(e, r, n, 1);
  return [
    r,
    n,
    i
  ];
}
function zy(e) {
  return Math.floor(e % 4 / 3);
}
function jy(e, t) {
  return t % 13 !== 0 ? 30 : zy(e) + 5;
}
class zd {
  fromJulianDay(t) {
    let [r, n, i] = Vd(ac, t), a = "AM";
    return r <= 0 && (a = "AA", r += oc), new rt(this, a, r, n, i);
  }
  toJulianDay(t) {
    let r = t.year;
    return t.era === "AA" && (r -= oc), os(ac, r, t.month, t.day);
  }
  getDaysInMonth(t) {
    return jy(t.year, t.month);
  }
  getMonthsInYear() {
    return 13;
  }
  getDaysInYear(t) {
    return 365 + zy(t.year);
  }
  getYearsInEra(t) {
    return t.era === "AA" ? 9999 : 9991;
  }
  getEras() {
    return [
      "AA",
      "AM"
    ];
  }
  constructor() {
    this.identifier = "ethiopic";
  }
}
class wC extends zd {
  fromJulianDay(t) {
    let [r, n, i] = Vd(ac, t);
    return r += oc, new rt(this, "AA", r, n, i);
  }
  getEras() {
    return [
      "AA"
    ];
  }
  getYearsInEra() {
    return 9999;
  }
  constructor(...t) {
    super(...t), this.identifier = "ethioaa";
  }
}
class CC extends zd {
  fromJulianDay(t) {
    let [r, n, i] = Vd(ip, t), a = "CE";
    return r <= 0 && (a = "BCE", r = 1 - r), new rt(this, a, r, n, i);
  }
  toJulianDay(t) {
    let r = t.year;
    return t.era === "BCE" && (r = 1 - r), os(ip, r, t.month, t.day);
  }
  getDaysInMonth(t) {
    let r = t.year;
    return t.era === "BCE" && (r = 1 - r), jy(r, t.month);
  }
  isInverseEra(t) {
    return t.era === "BCE";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BCE" ? "CE" : "BCE", t.year = 1 - t.year);
  }
  getEras() {
    return [
      "BCE",
      "CE"
    ];
  }
  getYearsInEra(t) {
    return t.era === "BCE" ? 9999 : 9715;
  }
  constructor(...t) {
    super(...t), this.identifier = "coptic";
  }
}
function eu(e) {
  switch (e) {
    case "buddhist":
      return new cC();
    case "ethiopic":
      return new zd();
    case "ethioaa":
      return new wC();
    case "coptic":
      return new CC();
    case "hebrew":
      return new EC();
    case "indian":
      return new hC();
    case "islamic-civil":
      return new Ld();
    case "islamic-tbla":
      return new mC();
    case "islamic-umalqura":
      return new yC();
    case "japanese":
      return new lC();
    case "persian":
      return new fC();
    case "roc":
      return new dC();
    case "gregory":
    default:
      return new xt();
  }
}
let Wu = /* @__PURE__ */ new Map();
class Yt {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(t) {
    return this.formatter.format(t);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(t) {
    return this.formatter.formatToParts(t);
  }
  /** Formats a date range as a string. */
  formatRange(t, r) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(t, r);
    if (r < t) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(t)}  ${this.formatter.format(r)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(t, r) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(t, r);
    if (r < t) throw new RangeError("End date must be >= start date");
    let n = this.formatter.formatToParts(t), i = this.formatter.formatToParts(r);
    return [
      ...n.map((a) => ({
        ...a,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...i.map((a) => ({
        ...a,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.formatter.resolvedOptions();
    return PC() && (this.resolvedHourCycle || (this.resolvedHourCycle = TC(t.locale, this.options)), t.hourCycle = this.resolvedHourCycle, t.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), t.calendar === "ethiopic-amete-alem" && (t.calendar = "ethioaa"), t;
  }
  constructor(t, r = {}) {
    this.formatter = Ky(t, r), this.options = r;
  }
}
const SC = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function Ky(e, t = {}) {
  if (typeof t.hour12 == "boolean" && kC()) {
    t = {
      ...t
    };
    let i = SC[String(t.hour12)][e.split("-")[0]], a = t.hour12 ? "h12" : "h23";
    t.hourCycle = i ?? a, delete t.hour12;
  }
  let r = e + (t ? Object.entries(t).sort((i, a) => i[0] < a[0] ? -1 : 1).join() : "");
  if (Wu.has(r)) return Wu.get(r);
  let n = new Intl.DateTimeFormat(e, t);
  return Wu.set(r, n), n;
}
let Qu = null;
function kC() {
  return Qu == null && (Qu = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), Qu;
}
let Gu = null;
function PC() {
  return Gu == null && (Gu = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), Gu;
}
function TC(e, t) {
  if (!t.timeStyle && !t.hour) return;
  e = e.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), e += (e.includes("-u-") ? "" : "-u") + "-nu-latn";
  let r = Ky(e, {
    ...t,
    timeZone: void 0
    // use local timezone
  }), n = parseInt(r.formatToParts(new Date(2020, 2, 3, 0)).find((a) => a.type === "hour").value, 10), i = parseInt(r.formatToParts(new Date(2020, 2, 3, 23)).find((a) => a.type === "hour").value, 10);
  if (n === 0 && i === 23) return "h23";
  if (n === 24 && i === 23) return "h24";
  if (n === 0 && i === 11) return "h11";
  if (n === 12 && i === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
function Qt(e) {
  e = ey(e ?? {}, AC);
  let { locale: t } = st();
  return G(() => new Yt(t, e), [
    t,
    e
  ]);
}
function AC(e, t) {
  if (e === t) return !0;
  let r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length) return !1;
  for (let i of r)
    if (t[i] !== e[i]) return !1;
  return !0;
}
let Zu = /* @__PURE__ */ new Map(), sc = !1;
try {
  sc = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
let ss = !1;
try {
  ss = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
const Uy = {
  degree: {
    narrow: {
      default: "",
      "ja-JP": " ",
      "zh-TW": "",
      "sl-SI": " "
    }
  }
};
class _C {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(t) {
    let r = "";
    if (!sc && this.options.signDisplay != null ? r = OC(this.numberFormatter, this.options.signDisplay, t) : r = this.numberFormatter.format(t), this.options.style === "unit" && !ss) {
      var n;
      let { unit: i, unitDisplay: a = "short", locale: o } = this.resolvedOptions();
      if (!i) return r;
      let s = (n = Uy[i]) === null || n === void 0 ? void 0 : n[a];
      r += s[o] || s.default;
    }
    return r;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(t) {
    return this.numberFormatter.formatToParts(t);
  }
  /** Formats a number range as a string. */
  formatRange(t, r) {
    if (typeof this.numberFormatter.formatRange == "function")
      return this.numberFormatter.formatRange(t, r);
    if (r < t) throw new RangeError("End date must be >= start date");
    return `${this.format(t)}  ${this.format(r)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(t, r) {
    if (typeof this.numberFormatter.formatRangeToParts == "function")
      return this.numberFormatter.formatRangeToParts(t, r);
    if (r < t) throw new RangeError("End date must be >= start date");
    let n = this.numberFormatter.formatToParts(t), i = this.numberFormatter.formatToParts(r);
    return [
      ...n.map((a) => ({
        ...a,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...i.map((a) => ({
        ...a,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.numberFormatter.resolvedOptions();
    return !sc && this.options.signDisplay != null && (t = {
      ...t,
      signDisplay: this.options.signDisplay
    }), !ss && this.options.style === "unit" && (t = {
      ...t,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    }), t;
  }
  constructor(t, r = {}) {
    this.numberFormatter = FC(t, r), this.options = r;
  }
}
function FC(e, t = {}) {
  let { numberingSystem: r } = t;
  if (r && e.includes("-nu-") && (e.includes("-u-") || (e += "-u-"), e += `-nu-${r}`), t.style === "unit" && !ss) {
    var n;
    let { unit: o, unitDisplay: s = "short" } = t;
    if (!o) throw new Error('unit option must be provided with style: "unit"');
    if (!(!((n = Uy[o]) === null || n === void 0) && n[s])) throw new Error(`Unsupported unit ${o} with unitDisplay = ${s}`);
    t = {
      ...t,
      style: "decimal"
    };
  }
  let i = e + (t ? Object.entries(t).sort((o, s) => o[0] < s[0] ? -1 : 1).join() : "");
  if (Zu.has(i)) return Zu.get(i);
  let a = new Intl.NumberFormat(e, t);
  return Zu.set(i, a), a;
}
function OC(e, t, r) {
  if (t === "auto") return e.format(r);
  if (t === "never") return e.format(Math.abs(r));
  {
    let n = !1;
    if (t === "always" ? n = r > 0 || Object.is(r, 0) : t === "exceptZero" && (Object.is(r, -0) || Object.is(r, 0) ? r = Math.abs(r) : n = r > 0), n) {
      let i = e.format(-r), a = e.format(r), o = i.replace(a, "").replace(/\u200e|\u061C/, "");
      return [
        ...o
      ].length !== 1 && console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case"), i.replace(a, "!!!").replace(o, "+").replace("!!!", a);
    } else return e.format(r);
  }
}
const IC = new RegExp("^.*\\(.*\\).*$"), RC = [
  "latn",
  "arab",
  "hanidec"
];
class qy {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(t) {
    return Yu(this.locale, this.options, t).parse(t);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(t, r, n) {
    return Yu(this.locale, this.options, t).isValidPartialNumber(t, r, n);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(t) {
    return Yu(this.locale, this.options, t).options.numberingSystem;
  }
  constructor(t, r = {}) {
    this.locale = t, this.options = r;
  }
}
const ap = /* @__PURE__ */ new Map();
function Yu(e, t, r) {
  let n = op(e, t);
  if (!e.includes("-nu-") && !n.isValidPartialNumber(r)) {
    for (let i of RC) if (i !== n.options.numberingSystem) {
      let a = op(e + (e.includes("-u-") ? "-nu-" : "-u-nu-") + i, t);
      if (a.isValidPartialNumber(r)) return a;
    }
  }
  return n;
}
function op(e, t) {
  let r = e + (t ? Object.entries(t).sort((i, a) => i[0] < a[0] ? -1 : 1).join() : ""), n = ap.get(r);
  return n || (n = new BC(e, t), ap.set(r, n)), n;
}
class BC {
  parse(t) {
    let r = this.sanitize(t);
    if (this.symbols.group && (r = vo(r, this.symbols.group, "")), this.symbols.decimal && (r = r.replace(this.symbols.decimal, ".")), this.symbols.minusSign && (r = r.replace(this.symbols.minusSign, "-")), r = r.replace(this.symbols.numeral, this.symbols.index), this.options.style === "percent") {
      let o = r.indexOf("-");
      r = r.replace("-", "");
      let s = r.indexOf(".");
      s === -1 && (s = r.length), r = r.replace(".", ""), s - 2 === 0 ? r = `0.${r}` : s - 2 === -1 ? r = `0.0${r}` : s - 2 === -2 ? r = "0.00" : r = `${r.slice(0, s - 2)}.${r.slice(s - 2)}`, o > -1 && (r = `-${r}`);
    }
    let n = r ? +r : NaN;
    if (isNaN(n)) return NaN;
    if (this.options.style === "percent") {
      var i, a;
      let o = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((i = this.options.minimumFractionDigits) !== null && i !== void 0 ? i : 0) + 2, 20),
        maximumFractionDigits: Math.min(((a = this.options.maximumFractionDigits) !== null && a !== void 0 ? a : 0) + 2, 20)
      };
      return new qy(this.locale, o).parse(new _C(this.locale, o).format(n));
    }
    return this.options.currencySign === "accounting" && IC.test(t) && (n = -1 * n), n;
  }
  sanitize(t) {
    return t = t.replace(this.symbols.literals, ""), this.symbols.minusSign && (t = t.replace("-", this.symbols.minusSign)), this.options.numberingSystem === "arab" && (this.symbols.decimal && (t = t.replace(",", this.symbols.decimal), t = t.replace("", this.symbols.decimal)), this.symbols.group && (t = vo(t, ".", this.symbols.group))), this.options.locale === "fr-FR" && (t = vo(t, ".", "")), t;
  }
  isValidPartialNumber(t, r = -1 / 0, n = 1 / 0) {
    return t = this.sanitize(t), this.symbols.minusSign && t.startsWith(this.symbols.minusSign) && r < 0 ? t = t.slice(this.symbols.minusSign.length) : this.symbols.plusSign && t.startsWith(this.symbols.plusSign) && n > 0 && (t = t.slice(this.symbols.plusSign.length)), this.symbols.group && t.startsWith(this.symbols.group) || this.symbols.decimal && t.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0 ? !1 : (this.symbols.group && (t = vo(t, this.symbols.group, "")), t = t.replace(this.symbols.numeral, ""), this.symbols.decimal && (t = t.replace(this.symbols.decimal, "")), t.length === 0);
  }
  constructor(t, r = {}) {
    this.locale = t, this.formatter = new Intl.NumberFormat(t, r), this.options = this.formatter.resolvedOptions(), this.symbols = NC(t, this.formatter, this.options, r);
    var n, i;
    this.options.style === "percent" && (((n = this.options.minimumFractionDigits) !== null && n !== void 0 ? n : 0) > 18 || ((i = this.options.maximumFractionDigits) !== null && i !== void 0 ? i : 0) > 18) && console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
}
const sp = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]), MC = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function NC(e, t, r, n) {
  var i, a, o, s;
  let u = new Intl.NumberFormat(e, {
    ...r,
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21
  }), l = u.formatToParts(-10000.111), c = u.formatToParts(10000.111), d = MC.map((w) => u.formatToParts(w));
  var f;
  let h = (f = (i = l.find((w) => w.type === "minusSign")) === null || i === void 0 ? void 0 : i.value) !== null && f !== void 0 ? f : "-", p = (a = c.find((w) => w.type === "plusSign")) === null || a === void 0 ? void 0 : a.value;
  !p && ((n == null ? void 0 : n.signDisplay) === "exceptZero" || (n == null ? void 0 : n.signDisplay) === "always") && (p = "+");
  let g = (o = new Intl.NumberFormat(e, {
    ...r,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3).find((w) => w.type === "decimal")) === null || o === void 0 ? void 0 : o.value, $ = (s = l.find((w) => w.type === "group")) === null || s === void 0 ? void 0 : s.value, m = l.filter((w) => !sp.has(w.type)).map((w) => up(w.value)), b = d.flatMap((w) => w.filter((E) => !sp.has(E.type)).map((E) => up(E.value))), D = [
    .../* @__PURE__ */ new Set([
      ...m,
      ...b
    ])
  ].sort((w, E) => E.length - w.length), S = D.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${D.join("|")}|[\\p{White_Space}]`, "gu"), T = [
    ...new Intl.NumberFormat(r.locale, {
      useGrouping: !1
    }).format(9876543210)
  ].reverse(), B = new Map(T.map((w, E) => [
    w,
    E
  ])), y = new RegExp(`[${T.join("")}]`, "g");
  return {
    minusSign: h,
    plusSign: p,
    decimal: g,
    group: $,
    literals: S,
    numeral: y,
    index: (w) => String(B.get(w))
  };
}
function vo(e, t, r) {
  return e.replaceAll ? e.replaceAll(t, r) : e.split(t).join(r);
}
function up(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
let Ju = /* @__PURE__ */ new Map();
function tu(e) {
  let { locale: t } = st(), r = t + (e ? Object.entries(e).sort((i, a) => i[0] < a[0] ? -1 : 1).join() : "");
  if (Ju.has(r)) return Ju.get(r);
  let n = new Intl.Collator(t, e);
  return Ju.set(r, n), n;
}
function Hy(e) {
  let t = tu({
    usage: "search",
    ...e
  }), r = be((a, o) => o.length === 0 ? !0 : (a = a.normalize("NFC"), o = o.normalize("NFC"), t.compare(a.slice(0, o.length), o) === 0), [
    t
  ]), n = be((a, o) => o.length === 0 ? !0 : (a = a.normalize("NFC"), o = o.normalize("NFC"), t.compare(a.slice(-o.length), o) === 0), [
    t
  ]), i = be((a, o) => {
    if (o.length === 0) return !0;
    a = a.normalize("NFC"), o = o.normalize("NFC");
    let s = 0, u = o.length;
    for (; s + u <= a.length; s++) {
      let l = a.slice(s, s + u);
      if (t.compare(o, l) === 0) return !0;
    }
    return !1;
  }, [
    t
  ]);
  return G(() => ({
    startsWith: r,
    endsWith: n,
    contains: i
  }), [
    r,
    n,
    i
  ]);
}
function LC(e, t) {
  let {
    elementType: r = "button",
    isDisabled: n,
    onPress: i,
    onPressStart: a,
    onPressEnd: o,
    onPressUp: s,
    onPressChange: u,
    preventFocusOnPress: l,
    allowFocusWhenDisabled: c,
    // @ts-ignore
    onClick: d,
    href: f,
    target: h,
    rel: p,
    type: v = "button"
  } = e, g;
  r === "button" ? g = {
    type: v,
    disabled: n
  } : g = {
    role: "button",
    tabIndex: n ? void 0 : 0,
    href: r === "a" && n ? void 0 : f,
    target: r === "a" ? h : void 0,
    type: r === "input" ? v : void 0,
    disabled: r === "input" ? n : void 0,
    "aria-disabled": !n || r === "input" ? void 0 : n,
    rel: r === "a" ? p : void 0
  };
  let { pressProps: $, isPressed: m } = Va({
    onPressStart: a,
    onPressEnd: o,
    onPressChange: u,
    onPress: i,
    onPressUp: s,
    isDisabled: n,
    preventFocusOnPress: l,
    ref: t
  }), { focusableProps: b } = py(e, t);
  c && (b.tabIndex = n ? -1 : b.tabIndex);
  let D = ve(b, $, _e(e, {
    labelable: !0
  }));
  return {
    isPressed: m,
    buttonProps: ve(g, D, {
      "aria-haspopup": e["aria-haspopup"],
      "aria-expanded": e["aria-expanded"],
      "aria-controls": e["aria-controls"],
      "aria-pressed": e["aria-pressed"],
      onClick: (S) => {
        d && (d(S), console.warn("onClick is deprecated, please use onPress"));
      }
    })
  };
}
var Wy = {};
Wy = {
  dateRange: (e) => `${e.startDate}  ${e.endDate}`,
  dateSelected: (e) => `${e.date} `,
  finishRangeSelectionPrompt: "     ",
  maximumDate: "  ",
  minimumDate: "  ",
  next: "",
  previous: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => `  : ${e.dateRange}`,
  startRangeSelectionPrompt: "     ",
  todayDate: (e) => ` ${e.date}`,
  todayDateSelected: (e) => ` ${e.date} `
};
var Qy = {};
Qy = {
  dateRange: (e) => `${e.startDate}  ${e.endDate}`,
  dateSelected: (e) => `  ${e.date}`,
  finishRangeSelectionPrompt: ",       ",
  maximumDate: "  ",
  minimumDate: "  ",
  next: "",
  previous: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` : ${e.dateRange}`,
  startRangeSelectionPrompt: ",        ",
  todayDate: (e) => `, ${e.date}`,
  todayDateSelected: (e) => `, ${e.date}  `
};
var Gy = {};
Gy = {
  dateRange: (e) => `${e.startDate} a ${e.endDate}`,
  dateSelected: (e) => `Vybrno ${e.date}`,
  finishRangeSelectionPrompt: "Kliknutm dokonte vbr rozsahu dat",
  maximumDate: "Posledn dostupn datum",
  minimumDate: "Prvn dostupn datum",
  next: "Dal",
  previous: "Pedchoz",
  selectedDateDescription: (e) => `Vybran datum: ${e.date}`,
  selectedRangeDescription: (e) => `Vybran obdob: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kliknutm zahjte vbr rozsahu dat",
  todayDate: (e) => `Dnes, ${e.date}`,
  todayDateSelected: (e) => `Dnes, vybrno ${e.date}`
};
var Zy = {};
Zy = {
  dateRange: (e) => `${e.startDate} til ${e.endDate}`,
  dateSelected: (e) => `${e.date} valgt`,
  finishRangeSelectionPrompt: "Klik for at fuldfre valg af datoomrde",
  maximumDate: "Sidste ledige dato",
  minimumDate: "Frste ledige dato",
  next: "Nste",
  previous: "Forrige",
  selectedDateDescription: (e) => `Valgt dato: ${e.date}`,
  selectedRangeDescription: (e) => `Valgt interval: ${e.dateRange}`,
  startRangeSelectionPrompt: "Klik for at starte valg af datoomrde",
  todayDate: (e) => `I dag, ${e.date}`,
  todayDateSelected: (e) => `I dag, ${e.date} valgt`
};
var Yy = {};
Yy = {
  dateRange: (e) => `${e.startDate} bis ${e.endDate}`,
  dateSelected: (e) => `${e.date} ausgewhlt`,
  finishRangeSelectionPrompt: "Klicken, um die Auswahl des Datumsbereichs zu beenden",
  maximumDate: "Letztes verfgbares Datum",
  minimumDate: "Erstes verfgbares Datum",
  next: "Weiter",
  previous: "Zurck",
  selectedDateDescription: (e) => `Ausgewhltes Datum: ${e.date}`,
  selectedRangeDescription: (e) => `Ausgewhlter Bereich: ${e.dateRange}`,
  startRangeSelectionPrompt: "Klicken, um die Auswahl des Datumsbereichs zu beginnen",
  todayDate: (e) => `Heute, ${e.date}`,
  todayDateSelected: (e) => `Heute, ${e.date} ausgewhlt`
};
var Jy = {};
Jy = {
  dateRange: (e) => `${e.startDate}  ${e.endDate}`,
  dateSelected: (e) => ` ${e.date}`,
  finishRangeSelectionPrompt: "        ",
  maximumDate: "  ",
  minimumDate: "  ",
  next: "",
  previous: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` : ${e.dateRange}`,
  startRangeSelectionPrompt: "        ",
  todayDate: (e) => `, ${e.date}`,
  todayDateSelected: (e) => `,  ${e.date}`
};
var Xy = {};
Xy = {
  previous: "Previous",
  next: "Next",
  selectedDateDescription: (e) => `Selected Date: ${e.date}`,
  selectedRangeDescription: (e) => `Selected Range: ${e.dateRange}`,
  todayDate: (e) => `Today, ${e.date}`,
  todayDateSelected: (e) => `Today, ${e.date} selected`,
  dateSelected: (e) => `${e.date} selected`,
  startRangeSelectionPrompt: "Click to start selecting date range",
  finishRangeSelectionPrompt: "Click to finish selecting date range",
  minimumDate: "First available date",
  maximumDate: "Last available date",
  dateRange: (e) => `${e.startDate} to ${e.endDate}`
};
var eg = {};
eg = {
  dateRange: (e) => `${e.startDate} a ${e.endDate}`,
  dateSelected: (e) => `${e.date} seleccionado`,
  finishRangeSelectionPrompt: "Haga clic para terminar de seleccionar rango de fechas",
  maximumDate: "ltima fecha disponible",
  minimumDate: "Primera fecha disponible",
  next: "Siguiente",
  previous: "Anterior",
  selectedDateDescription: (e) => `Fecha seleccionada: ${e.date}`,
  selectedRangeDescription: (e) => `Intervalo seleccionado: ${e.dateRange}`,
  startRangeSelectionPrompt: "Haga clic para comenzar a seleccionar un rango de fechas",
  todayDate: (e) => `Hoy, ${e.date}`,
  todayDateSelected: (e) => `Hoy, ${e.date} seleccionado`
};
var tg = {};
tg = {
  dateRange: (e) => `${e.startDate} kuni ${e.endDate}`,
  dateSelected: (e) => `${e.date} valitud`,
  finishRangeSelectionPrompt: "Klpsake kuupevavahemiku valimise lpetamiseks",
  maximumDate: "Viimane saadaolev kuupev",
  minimumDate: "Esimene saadaolev kuupev",
  next: "Jrgmine",
  previous: "Eelmine",
  selectedDateDescription: (e) => `Valitud kuupev: ${e.date}`,
  selectedRangeDescription: (e) => `Valitud vahemik: ${e.dateRange}`,
  startRangeSelectionPrompt: "Klpsake kuupevavahemiku valimiseks",
  todayDate: (e) => `Tna, ${e.date}`,
  todayDateSelected: (e) => `Tna, ${e.date} valitud`
};
var rg = {};
rg = {
  dateRange: (e) => `${e.startDate}  ${e.endDate}`,
  dateSelected: (e) => `${e.date} valittu`,
  finishRangeSelectionPrompt: "Lopeta pivmralueen valinta napsauttamalla tt.",
  maximumDate: "Viimeinen varattavissa oleva pivmr",
  minimumDate: "Ensimminen varattavissa oleva pivmr",
  next: "Seuraava",
  previous: "Edellinen",
  selectedDateDescription: (e) => `Valittu pivmr: ${e.date}`,
  selectedRangeDescription: (e) => `Valittu aikavli: ${e.dateRange}`,
  startRangeSelectionPrompt: "Aloita pivmralueen valinta napsauttamalla tt.",
  todayDate: (e) => `Tnn, ${e.date}`,
  todayDateSelected: (e) => `Tnn, ${e.date} valittu`
};
var ng = {};
ng = {
  dateRange: (e) => `${e.startDate}  ${e.endDate}`,
  dateSelected: (e) => `${e.date} slectionn`,
  finishRangeSelectionPrompt: "Cliquer pour finir de slectionner la plage de dates",
  maximumDate: "Dernire date disponible",
  minimumDate: "Premire date disponible",
  next: "Suivant",
  previous: "Prcdent",
  selectedDateDescription: (e) => `Date slectionne: ${e.date}`,
  selectedRangeDescription: (e) => `Plage slectionne: ${e.dateRange}`,
  startRangeSelectionPrompt: "Cliquer pour commencer  slectionner la plage de dates",
  todayDate: (e) => `Aujourd'hui, ${e.date}`,
  todayDateSelected: (e) => `Aujourdhui, ${e.date} slectionn`
};
var ig = {};
ig = {
  dateRange: (e) => `${e.startDate}  ${e.endDate}`,
  dateSelected: (e) => `${e.date} `,
  finishRangeSelectionPrompt: "      ",
  maximumDate: "  ",
  minimumDate: "  ",
  next: "",
  previous: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` : ${e.dateRange}`,
  startRangeSelectionPrompt: "     ",
  todayDate: (e) => `, ${e.date}`,
  todayDateSelected: (e) => `, ${e.date} `
};
var ag = {};
ag = {
  dateRange: (e) => `${e.startDate} do ${e.endDate}`,
  dateSelected: (e) => `${e.date} odabran`,
  finishRangeSelectionPrompt: "Kliknite da dovrite raspon odabranih datuma",
  maximumDate: "Posljednji raspoloivi datum",
  minimumDate: "Prvi raspoloivi datum",
  next: "Sljedei",
  previous: "Prethodni",
  selectedDateDescription: (e) => `Odabrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Odabrani raspon: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kliknite da zaponete raspon odabranih datuma",
  todayDate: (e) => `Danas, ${e.date}`,
  todayDateSelected: (e) => `Danas, odabran ${e.date}`
};
var og = {};
og = {
  dateRange: (e) => `${e.startDate}${e.endDate}`,
  dateSelected: (e) => `${e.date} kivlasztva`,
  finishRangeSelectionPrompt: "Kattintson a dtumtartomny kijellsnek befejezshez",
  maximumDate: "Utols elrhet dtum",
  minimumDate: "Az els elrhet dtum",
  next: "Kvetkez",
  previous: "Elz",
  selectedDateDescription: (e) => `Kijellt dtum: ${e.date}`,
  selectedRangeDescription: (e) => `Kijellt tartomny: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kattintson a dtumtartomny kijellsnek indtshoz",
  todayDate: (e) => `Ma, ${e.date}`,
  todayDateSelected: (e) => `Ma, ${e.date} kijellve`
};
var sg = {};
sg = {
  dateRange: (e) => `Da ${e.startDate} a ${e.endDate}`,
  dateSelected: (e) => `${e.date} selezionata`,
  finishRangeSelectionPrompt: "Fai clic per completare la selezione dellintervallo di date",
  maximumDate: "Ultima data disponibile",
  minimumDate: "Prima data disponibile",
  next: "Successivo",
  previous: "Precedente",
  selectedDateDescription: (e) => `Data selezionata: ${e.date}`,
  selectedRangeDescription: (e) => `Intervallo selezionato: ${e.dateRange}`,
  startRangeSelectionPrompt: "Fai clic per selezionare lintervallo di date",
  todayDate: (e) => `Oggi, ${e.date}`,
  todayDateSelected: (e) => `Oggi, ${e.date} selezionata`
};
var ug = {};
ug = {
  dateRange: (e) => `${e.startDate}  ${e.endDate}`,
  dateSelected: (e) => `${e.date} `,
  finishRangeSelectionPrompt: "",
  maximumDate: "",
  minimumDate: "",
  next: "",
  previous: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` : ${e.dateRange}`,
  startRangeSelectionPrompt: "",
  todayDate: (e) => `${e.date}`,
  todayDateSelected: (e) => `${e.date} `
};
var lg = {};
lg = {
  dateRange: (e) => `${e.startDate} ~ ${e.endDate}`,
  dateSelected: (e) => `${e.date} `,
  finishRangeSelectionPrompt: "    .",
  maximumDate: "   ",
  minimumDate: "   ",
  next: "",
  previous: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` : ${e.dateRange}`,
  startRangeSelectionPrompt: "    .",
  todayDate: (e) => `, ${e.date}`,
  todayDateSelected: (e) => `, ${e.date} `
};
var cg = {};
cg = {
  dateRange: (e) => `Nuo ${e.startDate} iki ${e.endDate}`,
  dateSelected: (e) => `Pasirinkta ${e.date}`,
  finishRangeSelectionPrompt: "Spustelkite, kad baigtumte pasirinkti dat interval",
  maximumDate: "Paskutin galima data",
  minimumDate: "Pirmoji galima data",
  next: "Paskesnis",
  previous: "Ankstesnis",
  selectedDateDescription: (e) => `Pasirinkta data: ${e.date}`,
  selectedRangeDescription: (e) => `Pasirinktas intervalas: ${e.dateRange}`,
  startRangeSelectionPrompt: "Spustelkite, kad pradtumte pasirinkti dat interval",
  todayDate: (e) => `iandien, ${e.date}`,
  todayDateSelected: (e) => `iandien, pasirinkta ${e.date}`
};
var dg = {};
dg = {
  dateRange: (e) => `No ${e.startDate} ldz ${e.endDate}`,
  dateSelected: (e) => `Atlasts: ${e.date}`,
  finishRangeSelectionPrompt: "Noklikiniet, lai pabeigtu datumu diapazona atlasi",
  maximumDate: "Pdjais pieejamais datums",
  minimumDate: "Pirmais pieejamais datums",
  next: "Tlk",
  previous: "Atpaka",
  selectedDateDescription: (e) => `Atlastais datums: ${e.date}`,
  selectedRangeDescription: (e) => `Atlastais diapazons: ${e.dateRange}`,
  startRangeSelectionPrompt: "Noklikiniet, lai sktu datumu diapazona atlasi",
  todayDate: (e) => `odien, ${e.date}`,
  todayDateSelected: (e) => `Atlasta odiena, ${e.date}`
};
var fg = {};
fg = {
  dateRange: (e) => `${e.startDate} til ${e.endDate}`,
  dateSelected: (e) => `${e.date} valgt`,
  finishRangeSelectionPrompt: "Klikk for  fullfre valg av datoomrde",
  maximumDate: "Siste tilgjengelige dato",
  minimumDate: "Frste tilgjengelige dato",
  next: "Neste",
  previous: "Forrige",
  selectedDateDescription: (e) => `Valgt dato: ${e.date}`,
  selectedRangeDescription: (e) => `Valgt omrde: ${e.dateRange}`,
  startRangeSelectionPrompt: "Klikk for  starte valg av datoomrde",
  todayDate: (e) => `I dag, ${e.date}`,
  todayDateSelected: (e) => `I dag, ${e.date} valgt`
};
var hg = {};
hg = {
  dateRange: (e) => `${e.startDate} tot ${e.endDate}`,
  dateSelected: (e) => `${e.date} geselecteerd`,
  finishRangeSelectionPrompt: "Klik om de selectie van het datumbereik te voltooien",
  maximumDate: "Laatste beschikbare datum",
  minimumDate: "Eerste beschikbare datum",
  next: "Volgende",
  previous: "Vorige",
  selectedDateDescription: (e) => `Geselecteerde datum: ${e.date}`,
  selectedRangeDescription: (e) => `Geselecteerd bereik: ${e.dateRange}`,
  startRangeSelectionPrompt: "Klik om het datumbereik te selecteren",
  todayDate: (e) => `Vandaag, ${e.date}`,
  todayDateSelected: (e) => `Vandaag, ${e.date} geselecteerd`
};
var pg = {};
pg = {
  dateRange: (e) => `${e.startDate} do ${e.endDate}`,
  dateSelected: (e) => `Wybrano ${e.date}`,
  finishRangeSelectionPrompt: "Kliknij, aby zakoczy wybr zakresu dat",
  maximumDate: "Ostatnia dostpna data",
  minimumDate: "Pierwsza dostpna data",
  next: "Dalej",
  previous: "Wstecz",
  selectedDateDescription: (e) => `Wybrana data: ${e.date}`,
  selectedRangeDescription: (e) => `Wybrany zakres: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kliknij, aby rozpocz wybr zakresu dat",
  todayDate: (e) => `Dzisiaj, ${e.date}`,
  todayDateSelected: (e) => `Dzisiaj wybrano ${e.date}`
};
var mg = {};
mg = {
  dateRange: (e) => `${e.startDate} a ${e.endDate}`,
  dateSelected: (e) => `${e.date} selecionado`,
  finishRangeSelectionPrompt: "Clique para concluir a seleo do intervalo de datas",
  maximumDate: "ltima data disponvel",
  minimumDate: "Primeira data disponvel",
  next: "Prximo",
  previous: "Anterior",
  selectedDateDescription: (e) => `Data selecionada: ${e.date}`,
  selectedRangeDescription: (e) => `Intervalo selecionado: ${e.dateRange}`,
  startRangeSelectionPrompt: "Clique para iniciar a seleo do intervalo de datas",
  todayDate: (e) => `Hoje, ${e.date}`,
  todayDateSelected: (e) => `Hoje, ${e.date} selecionado`
};
var vg = {};
vg = {
  dateRange: (e) => `${e.startDate} a ${e.endDate}`,
  dateSelected: (e) => `${e.date} selecionado`,
  finishRangeSelectionPrompt: "Clique para terminar de selecionar o intervalo de datas",
  maximumDate: "ltima data disponvel",
  minimumDate: "Primeira data disponvel",
  next: "Prximo",
  previous: "Anterior",
  selectedDateDescription: (e) => `Data selecionada: ${e.date}`,
  selectedRangeDescription: (e) => `Intervalo selecionado: ${e.dateRange}`,
  startRangeSelectionPrompt: "Clique para comear a selecionar o intervalo de datas",
  todayDate: (e) => `Hoje, ${e.date}`,
  todayDateSelected: (e) => `Hoje, ${e.date} selecionado`
};
var yg = {};
yg = {
  dateRange: (e) => `De la ${e.startDate} pn la ${e.endDate}`,
  dateSelected: (e) => `${e.date} selectat`,
  finishRangeSelectionPrompt: "Apsai pentru a finaliza selecia razei pentru dat",
  maximumDate: "Ultima dat disponibil",
  minimumDate: "Prima dat disponibil",
  next: "Urmtorul",
  previous: "nainte",
  selectedDateDescription: (e) => `Dat selectat: ${e.date}`,
  selectedRangeDescription: (e) => `Interval selectat: ${e.dateRange}`,
  startRangeSelectionPrompt: "Apsai pentru a ncepe selecia razei pentru dat",
  todayDate: (e) => `Astzi, ${e.date}`,
  todayDateSelected: (e) => `Azi, ${e.date} selectat`
};
var gg = {};
gg = {
  dateRange: (e) => ` ${e.startDate}  ${e.endDate}`,
  dateSelected: (e) => ` ${e.date}`,
  finishRangeSelectionPrompt: ",     ",
  maximumDate: "  ",
  minimumDate: "  ",
  next: "",
  previous: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` : ${e.dateRange}`,
  startRangeSelectionPrompt: ",     ",
  todayDate: (e) => `, ${e.date}`,
  todayDateSelected: (e) => `,  ${e.date}`
};
var bg = {};
bg = {
  dateRange: (e) => `Od ${e.startDate} do ${e.endDate}`,
  dateSelected: (e) => `Vybrat dtum ${e.date}`,
  finishRangeSelectionPrompt: "Kliknutm dokonte vber rozsahu dtumov",
  maximumDate: "Posledn dostupn dtum",
  minimumDate: "Prv dostupn dtum",
  next: "Nasledujce",
  previous: "Predchdzajce",
  selectedDateDescription: (e) => `Vybrat dtum: ${e.date}`,
  selectedRangeDescription: (e) => `Vybrat rozsah: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kliknutm spustte vber rozsahu dtumov",
  todayDate: (e) => `Dnes ${e.date}`,
  todayDateSelected: (e) => `Vybrat dnen dtum ${e.date}`
};
var $g = {};
$g = {
  dateRange: (e) => `${e.startDate} do ${e.endDate}`,
  dateSelected: (e) => `${e.date} izbrano`,
  finishRangeSelectionPrompt: "Kliknite za dokonanje izbire datumskega obsega",
  maximumDate: "Zadnji razpololjivi datum",
  minimumDate: "Prvi razpololjivi datum",
  next: "Naprej",
  previous: "Nazaj",
  selectedDateDescription: (e) => `Izbrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Izbrano obmoje: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kliknite za zaetek izbire datumskega obsega",
  todayDate: (e) => `Danes, ${e.date}`,
  todayDateSelected: (e) => `Danes, ${e.date} izbrano`
};
var xg = {};
xg = {
  dateRange: (e) => `${e.startDate} do ${e.endDate}`,
  dateSelected: (e) => `${e.date} izabran`,
  finishRangeSelectionPrompt: "Kliknite da dovrite opseg izabranih datuma",
  maximumDate: "Zadnji raspoloivi datum",
  minimumDate: "Prvi raspoloivi datum",
  next: "Sledei",
  previous: "Prethodni",
  selectedDateDescription: (e) => `Izabrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Izabrani period: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kliknite da zaponete opseg izabranih datuma",
  todayDate: (e) => `Danas, ${e.date}`,
  todayDateSelected: (e) => `Danas, izabran ${e.date}`
};
var Dg = {};
Dg = {
  dateRange: (e) => `${e.startDate} till ${e.endDate}`,
  dateSelected: (e) => `${e.date} har valts`,
  finishRangeSelectionPrompt: "Klicka fr att avsluta val av datumintervall",
  maximumDate: "Sista tillgngliga datum",
  minimumDate: "Frsta tillgngliga datum",
  next: "Nsta",
  previous: "Fregende",
  selectedDateDescription: (e) => `Valt datum: ${e.date}`,
  selectedRangeDescription: (e) => `Valt intervall: ${e.dateRange}`,
  startRangeSelectionPrompt: "Klicka fr att vlja datumintervall",
  todayDate: (e) => `Idag, ${e.date}`,
  todayDateSelected: (e) => `Idag, ${e.date} har valts`
};
var Eg = {};
Eg = {
  dateRange: (e) => `${e.startDate} - ${e.endDate}`,
  dateSelected: (e) => `${e.date} seildi`,
  finishRangeSelectionPrompt: "Tarih aral seimini tamamlamak iin tklayn",
  maximumDate: "Son msait tarih",
  minimumDate: "lk msait tarih",
  next: "Sonraki",
  previous: "nceki",
  selectedDateDescription: (e) => `Seilen Tarih: ${e.date}`,
  selectedRangeDescription: (e) => `Seilen Aralk: ${e.dateRange}`,
  startRangeSelectionPrompt: "Tarih aral seimini balatmak iin tklayn",
  todayDate: (e) => `Bugn, ${e.date}`,
  todayDateSelected: (e) => `Bugn, ${e.date} seildi`
};
var wg = {};
wg = {
  dateRange: (e) => `${e.startDate}  ${e.endDate}`,
  dateSelected: (e) => ` ${e.date}`,
  finishRangeSelectionPrompt: ",     ",
  maximumDate: "  ",
  minimumDate: "  ",
  next: "",
  previous: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` : ${e.dateRange}`,
  startRangeSelectionPrompt: ",     ",
  todayDate: (e) => `, ${e.date}`,
  todayDateSelected: (e) => `,  ${e.date}`
};
var Cg = {};
Cg = {
  dateRange: (e) => `${e.startDate}  ${e.endDate}`,
  dateSelected: (e) => ` ${e.date}`,
  finishRangeSelectionPrompt: "",
  maximumDate: "",
  minimumDate: "",
  next: "",
  previous: "",
  selectedDateDescription: (e) => `${e.date}`,
  selectedRangeDescription: (e) => `${e.dateRange}`,
  startRangeSelectionPrompt: "",
  todayDate: (e) => ` ${e.date}`,
  todayDateSelected: (e) => ` ${e.date}`
};
var Sg = {};
Sg = {
  dateRange: (e) => `${e.startDate}  ${e.endDate}`,
  dateSelected: (e) => ` ${e.date}`,
  finishRangeSelectionPrompt: "",
  maximumDate: "",
  minimumDate: "",
  next: "",
  previous: "",
  selectedDateDescription: (e) => `${e.date}`,
  selectedRangeDescription: (e) => `${e.dateRange}`,
  startRangeSelectionPrompt: "",
  todayDate: (e) => `${e.date}`,
  todayDateSelected: (e) => `${e.date}`
};
var ja = {};
ja = {
  "ar-AE": Wy,
  "bg-BG": Qy,
  "cs-CZ": Gy,
  "da-DK": Zy,
  "de-DE": Yy,
  "el-GR": Jy,
  "en-US": Xy,
  "es-ES": eg,
  "et-EE": tg,
  "fi-FI": rg,
  "fr-FR": ng,
  "he-IL": ig,
  "hr-HR": ag,
  "hu-HU": og,
  "it-IT": sg,
  "ja-JP": ug,
  "ko-KR": lg,
  "lt-LT": cg,
  "lv-LV": dg,
  "nb-NO": fg,
  "nl-NL": hg,
  "pl-PL": pg,
  "pt-BR": mg,
  "pt-PT": vg,
  "ro-RO": yg,
  "ru-RU": gg,
  "sk-SK": bg,
  "sl-SI": $g,
  "sr-SP": xg,
  "sv-SE": Dg,
  "tr-TR": Eg,
  "uk-UA": wg,
  "zh-CN": Cg,
  "zh-TW": Sg
};
function kg(e) {
  return e && e.__esModule ? e.default : e;
}
const jd = /* @__PURE__ */ new WeakMap();
function Ea(e) {
  return (e == null ? void 0 : e.calendar.identifier) === "gregory" && e.era === "BC" ? "short" : void 0;
}
function VC(e) {
  let t = Ht(kg(ja), "@react-aria/calendar"), r, n;
  "highlightedRange" in e ? { start: r, end: n } = e.highlightedRange || {} : r = n = e.value;
  let i = Qt({
    weekday: "long",
    month: "long",
    year: "numeric",
    day: "numeric",
    era: Ea(r) || Ea(n),
    timeZone: e.timeZone
  }), a = "anchorDate" in e ? e.anchorDate : null;
  return G(() => {
    if (!a && r && n)
      if (tt(r, n)) {
        let o = i.format(r.toDate(e.timeZone));
        return t.format("selectedDateDescription", {
          date: o
        });
      } else {
        let o = lc(i, t, r, n, e.timeZone);
        return t.format("selectedRangeDescription", {
          dateRange: o
        });
      }
    return "";
  }, [
    r,
    n,
    a,
    e.timeZone,
    t,
    i
  ]);
}
function uc(e, t, r, n) {
  let i = Ht(kg(ja), "@react-aria/calendar"), a = Ea(e) || Ea(t), o = Qt({
    month: "long",
    year: "numeric",
    era: a,
    calendar: e.calendar.identifier,
    timeZone: r
  }), s = Qt({
    month: "long",
    year: "numeric",
    day: "numeric",
    era: a,
    calendar: e.calendar.identifier,
    timeZone: r
  });
  return G(() => {
    if (tt(e, $r(e))) {
      if (tt(t, fi(e))) return o.format(e.toDate(r));
      if (tt(t, fi(t))) return n ? lc(o, i, e, t, r) : o.formatRange(e.toDate(r), t.toDate(r));
    }
    return n ? lc(s, i, e, t, r) : s.formatRange(e.toDate(r), t.toDate(r));
  }, [
    e,
    t,
    o,
    s,
    i,
    r,
    n
  ]);
}
function lc(e, t, r, n, i) {
  let a = e.formatRangeToParts(r.toDate(i), n.toDate(i)), o = -1;
  for (let l = 0; l < a.length; l++) {
    let c = a[l];
    if (c.source === "shared" && c.type === "literal") o = l;
    else if (c.source === "endRange") break;
  }
  let s = "", u = "";
  for (let l = 0; l < a.length; l++)
    l < o ? s += a[l].value : l > o && (u += a[l].value);
  return t.format("dateRange", {
    startDate: s,
    endDate: u
  });
}
const Pg = 7e3;
let ia = null;
function ri(e, t = "assertive", r = Pg) {
  ia || (ia = new jC()), ia.announce(e, t, r);
}
function zC(e) {
  ia && ia.clear(e);
}
class jC {
  createLog(t) {
    let r = document.createElement("div");
    return r.setAttribute("role", "log"), r.setAttribute("aria-live", t), r.setAttribute("aria-relevant", "additions"), r;
  }
  destroy() {
    this.node && (document.body.removeChild(this.node), this.node = null);
  }
  announce(t, r = "assertive", n = Pg) {
    if (!this.node) return;
    let i = document.createElement("div");
    i.textContent = t, r === "assertive" ? this.assertiveLog.appendChild(i) : this.politeLog.appendChild(i), t !== "" && setTimeout(() => {
      i.remove();
    }, n);
  }
  clear(t) {
    this.node && ((!t || t === "assertive") && (this.assertiveLog.innerHTML = ""), (!t || t === "polite") && (this.politeLog.innerHTML = ""));
  }
  constructor() {
    this.node = document.createElement("div"), this.node.dataset.liveAnnouncer = "true", Object.assign(this.node.style, {
      border: 0,
      clip: "rect(0 0 0 0)",
      clipPath: "inset(50%)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: 0,
      position: "absolute",
      width: "1px",
      whiteSpace: "nowrap"
    }), this.assertiveLog = this.createLog("assertive"), this.node.appendChild(this.assertiveLog), this.politeLog = this.createLog("polite"), this.node.appendChild(this.politeLog), document.body.prepend(this.node);
  }
}
function KC(e) {
  return e && e.__esModule ? e.default : e;
}
function Tg(e, t) {
  let r = Ht(KC(ja), "@react-aria/calendar"), n = _e(e), i = uc(t.visibleRange.start, t.visibleRange.end, t.timeZone, !1), a = uc(t.visibleRange.start, t.visibleRange.end, t.timeZone, !0);
  Sh(() => {
    t.isFocused || ri(a);
  }, [
    a
  ]);
  let o = VC(t);
  Sh(() => {
    o && ri(o, "polite", 4e3);
  }, [
    o
  ]);
  let s = di([
    !!e.errorMessage,
    e.isInvalid,
    e.validationState
  ]);
  jd.set(t, {
    ariaLabel: e["aria-label"],
    ariaLabelledBy: e["aria-labelledby"],
    errorMessageId: s,
    selectedDateDescription: o
  });
  let [u, l] = ee(!1), c = e.isDisabled || t.isNextVisibleRangeInvalid();
  c && u && (l(!1), t.setFocused(!0));
  let [d, f] = ee(!1), h = e.isDisabled || t.isPreviousVisibleRangeInvalid();
  h && d && (f(!1), t.setFocused(!0));
  let p = mn({
    id: e.id,
    "aria-label": [
      e["aria-label"],
      a
    ].filter(Boolean).join(", "),
    "aria-labelledby": e["aria-labelledby"]
  });
  return {
    calendarProps: ve(n, p, {
      role: "application",
      "aria-describedby": e["aria-describedby"] || void 0
    }),
    nextButtonProps: {
      onPress: () => t.focusNextPage(),
      "aria-label": r.format("next"),
      isDisabled: c,
      onFocusChange: l
    },
    prevButtonProps: {
      onPress: () => t.focusPreviousPage(),
      "aria-label": r.format("previous"),
      isDisabled: h,
      onFocusChange: f
    },
    errorMessageProps: {
      id: s
    },
    title: i
  };
}
function UC(e, t) {
  return Tg(e, t);
}
function qC(e, t, r) {
  let n = Tg(e, t), i = q(!1), a = q(typeof window < "u" ? window : null);
  return Jn(a, "pointerdown", (s) => {
    i.current = s.width === 0 && s.height === 0;
  }), Jn(a, "pointerup", (s) => {
    if (i.current) {
      i.current = !1;
      return;
    }
    if (t.setDragging(!1), !t.anchorDate) return;
    let u = s.target;
    r.current && r.current.contains(document.activeElement) && (!r.current.contains(u) || !u.closest('button, [role="button"]')) && t.selectFocusedDate();
  }), n.calendarProps.onBlur = (s) => {
    r.current && (!s.relatedTarget || !r.current.contains(s.relatedTarget)) && t.anchorDate && t.selectFocusedDate();
  }, Jn(r, "touchmove", (s) => {
    t.isDragging && s.preventDefault();
  }, {
    passive: !1,
    capture: !0
  }), n;
}
function HC(e, t) {
  let { startDate: r = t.visibleRange.start, endDate: n = t.visibleRange.end } = e, { direction: i } = st(), a = (h) => {
    switch (h.key) {
      case "Enter":
      case " ":
        h.preventDefault(), t.selectFocusedDate();
        break;
      case "PageUp":
        h.preventDefault(), h.stopPropagation(), t.focusPreviousSection(h.shiftKey);
        break;
      case "PageDown":
        h.preventDefault(), h.stopPropagation(), t.focusNextSection(h.shiftKey);
        break;
      case "End":
        h.preventDefault(), h.stopPropagation(), t.focusSectionEnd();
        break;
      case "Home":
        h.preventDefault(), h.stopPropagation(), t.focusSectionStart();
        break;
      case "ArrowLeft":
        h.preventDefault(), h.stopPropagation(), i === "rtl" ? t.focusNextDay() : t.focusPreviousDay();
        break;
      case "ArrowUp":
        h.preventDefault(), h.stopPropagation(), t.focusPreviousRow();
        break;
      case "ArrowRight":
        h.preventDefault(), h.stopPropagation(), i === "rtl" ? t.focusPreviousDay() : t.focusNextDay();
        break;
      case "ArrowDown":
        h.preventDefault(), h.stopPropagation(), t.focusNextRow();
        break;
      case "Escape":
        "setAnchorDate" in t && (h.preventDefault(), t.setAnchorDate(null));
        break;
    }
  }, o = uc(r, n, t.timeZone, !0), { ariaLabel: s, ariaLabelledBy: u } = jd.get(t), l = mn({
    "aria-label": [
      s,
      o
    ].filter(Boolean).join(", "),
    "aria-labelledby": u
  }), c = Qt({
    weekday: e.weekdayStyle || "narrow",
    timeZone: t.timeZone
  }), { locale: d } = st(), f = G(() => {
    let h = bn(Js(t.timeZone), d);
    return [
      ...new Array(7).keys()
    ].map((p) => {
      let g = h.add({
        days: p
      }).toDate(t.timeZone);
      return c.format(g);
    });
  }, [
    d,
    t.timeZone,
    c
  ]);
  return {
    gridProps: ve(l, {
      role: "grid",
      "aria-readonly": t.isReadOnly || null,
      "aria-disabled": t.isDisabled || null,
      "aria-multiselectable": "highlightedRange" in t || void 0,
      onKeyDown: a,
      onFocus: () => t.setFocused(!0),
      onBlur: () => t.setFocused(!1)
    }),
    headerProps: {
      // Column headers are hidden to screen readers to make navigating with a touch screen reader easier.
      // The day names are already included in the label of each cell, so there's no need to announce them twice.
      "aria-hidden": !0
    },
    weekDays: f
  };
}
function WC(e) {
  return e && e.__esModule ? e.default : e;
}
function QC(e, t, r) {
  let { date: n, isDisabled: i } = e, { errorMessageId: a, selectedDateDescription: o } = jd.get(t), s = Ht(WC(ja), "@react-aria/calendar"), u = Qt({
    weekday: "long",
    day: "numeric",
    month: "long",
    year: "numeric",
    era: Ea(n),
    timeZone: t.timeZone
  }), l = t.isSelected(n), c = t.isCellFocused(n);
  i = i || t.isCellDisabled(n);
  let d = t.isCellUnavailable(n), f = !i && !d, h = t.isValueInvalid && ("highlightedRange" in t ? !t.anchorDate && t.highlightedRange && n.compare(t.highlightedRange.start) >= 0 && n.compare(t.highlightedRange.end) <= 0 : t.value && tt(t.value, n));
  h && (l = !0), n = ey(n, Xl);
  let p = G(() => n.toDate(t.timeZone), [
    n,
    t.timeZone
  ]), v = Nw(n, t.timeZone), g = G(() => {
    let E = "";
    return "highlightedRange" in t && t.value && !t.anchorDate && (tt(n, t.value.start) || tt(n, t.value.end)) && (E = o + ", "), E += u.format(p), v ? E = s.format(l ? "todayDateSelected" : "todayDate", {
      date: E
    }) : l && (E = s.format("dateSelected", {
      date: E
    })), t.minValue && tt(n, t.minValue) ? E += ", " + s.format("minimumDate") : t.maxValue && tt(n, t.maxValue) && (E += ", " + s.format("maximumDate")), E;
  }, [
    u,
    p,
    s,
    l,
    v,
    n,
    t,
    o
  ]), $ = "";
  "anchorDate" in t && c && !t.isReadOnly && f && (t.anchorDate ? $ = s.format("finishRangeSelectionPrompt") : $ = s.format("startRangeSelectionPrompt"));
  let m = Gs($), b = q(!1), D = q(!1), S = q(null), { pressProps: T, isPressed: B } = Va({
    // When dragging to select a range, we don't want dragging over the original anchor
    // again to trigger onPressStart. Cancel presses immediately when the pointer exits.
    shouldCancelOnPointerExit: "anchorDate" in t && !!t.anchorDate,
    preventFocusOnPress: !0,
    isDisabled: !f || t.isReadOnly,
    onPressStart(E) {
      if (t.isReadOnly) {
        t.setFocusedDate(n);
        return;
      }
      if ("highlightedRange" in t && !t.anchorDate && (E.pointerType === "mouse" || E.pointerType === "touch")) {
        if (t.highlightedRange && !h) {
          if (tt(n, t.highlightedRange.start)) {
            t.setAnchorDate(t.highlightedRange.end), t.setFocusedDate(n), t.setDragging(!0), D.current = !0;
            return;
          } else if (tt(n, t.highlightedRange.end)) {
            t.setAnchorDate(t.highlightedRange.start), t.setFocusedDate(n), t.setDragging(!0), D.current = !0;
            return;
          }
        }
        let k = () => {
          t.setDragging(!0), S.current = null, t.selectDate(n), t.setFocusedDate(n), b.current = !0;
        };
        E.pointerType === "touch" ? S.current = setTimeout(k, 200) : k();
      }
    },
    onPressEnd() {
      D.current = !1, b.current = !1, clearTimeout(S.current), S.current = null;
    },
    onPress() {
      !("anchorDate" in t) && !t.isReadOnly && (t.selectDate(n), t.setFocusedDate(n));
    },
    onPressUp(E) {
      if (!t.isReadOnly && ("anchorDate" in t && S.current && (t.selectDate(n), t.setFocusedDate(n)), "anchorDate" in t))
        if (D.current)
          t.setAnchorDate(n);
        else if (t.anchorDate && !b.current)
          t.selectDate(n), t.setFocusedDate(n);
        else if (E.pointerType === "keyboard" && !t.anchorDate) {
          t.selectDate(n);
          let k = n.add({
            days: 1
          });
          t.isInvalid(k) && (k = n.subtract({
            days: 1
          })), t.isInvalid(k) || t.setFocusedDate(k);
        } else E.pointerType === "virtual" && (t.selectDate(n), t.setFocusedDate(n));
    }
  }), y = null;
  i || (y = tt(n, t.focusedDate) ? 0 : -1), oe(() => {
    c && r.current && (Wt(r.current), Yo() !== "pointer" && document.activeElement === r.current && Wo(r.current, {
      containingElement: Qs(r.current)
    }));
  }, [
    c,
    r
  ]);
  let _ = Qt({
    day: "numeric",
    timeZone: t.timeZone,
    calendar: n.calendar.identifier
  }), w = G(() => _.formatToParts(p).find((E) => E.type === "day").value, [
    _,
    p
  ]);
  return {
    cellProps: {
      role: "gridcell",
      "aria-disabled": !f || null,
      "aria-selected": l || null,
      "aria-invalid": h || null
    },
    buttonProps: ve(T, {
      onFocus() {
        i || t.setFocusedDate(n);
      },
      tabIndex: y,
      role: "button",
      "aria-disabled": !f || null,
      "aria-label": g,
      "aria-invalid": h || null,
      "aria-describedby": [
        h ? a : null,
        m["aria-describedby"]
      ].filter(Boolean).join(" ") || void 0,
      onPointerEnter(E) {
        "highlightDate" in t && (E.pointerType !== "touch" || t.isDragging) && f && t.highlightDate(n);
      },
      onPointerDown(E) {
        "releasePointerCapture" in E.target && E.target.releasePointerCapture(E.pointerId);
      },
      onContextMenu(E) {
        E.preventDefault();
      }
    }),
    isPressed: B,
    isFocused: c,
    isSelected: l,
    isDisabled: i,
    isUnavailable: d,
    isOutsideVisibleRange: n.compare(t.visibleRange.start) < 0 || n.compare(t.visibleRange.end) > 0,
    isInvalid: h,
    formattedDate: w
  };
}
function Kd(e, t, r) {
  let { validationBehavior: n, focus: i } = e;
  Re(() => {
    if (n === "native" && (r != null && r.current)) {
      let u = t.realtimeValidation.isInvalid ? t.realtimeValidation.validationErrors.join(" ") || "Invalid value." : "";
      r.current.setCustomValidity(u), r.current.hasAttribute("title") || (r.current.title = ""), t.realtimeValidation.isInvalid || t.updateValidation(ZC(r.current));
    }
  });
  let a = lt(() => {
    t.resetValidation();
  }), o = lt((u) => {
    var l;
    t.displayValidation.isInvalid || t.commitValidation();
    let c = r == null || (l = r.current) === null || l === void 0 ? void 0 : l.form;
    if (!u.defaultPrevented && r && c && YC(c) === r.current) {
      var d;
      i ? i() : (d = r.current) === null || d === void 0 || d.focus(), ly("keyboard");
    }
    u.preventDefault();
  }), s = lt(() => {
    t.commitValidation();
  });
  oe(() => {
    let u = r == null ? void 0 : r.current;
    if (!u) return;
    let l = u.form;
    return u.addEventListener("invalid", o), u.addEventListener("change", s), l == null || l.addEventListener("reset", a), () => {
      u.removeEventListener("invalid", o), u.removeEventListener("change", s), l == null || l.removeEventListener("reset", a);
    };
  }, [
    r,
    o,
    s,
    a,
    n
  ]);
}
function GC(e) {
  let t = e.validity;
  return {
    badInput: t.badInput,
    customError: t.customError,
    patternMismatch: t.patternMismatch,
    rangeOverflow: t.rangeOverflow,
    rangeUnderflow: t.rangeUnderflow,
    stepMismatch: t.stepMismatch,
    tooLong: t.tooLong,
    tooShort: t.tooShort,
    typeMismatch: t.typeMismatch,
    valueMissing: t.valueMissing,
    valid: t.valid
  };
}
function ZC(e) {
  return {
    isInvalid: !e.validity.valid,
    validationDetails: GC(e),
    validationErrors: e.validationMessage ? [
      e.validationMessage
    ] : []
  };
}
function YC(e) {
  for (let t = 0; t < e.elements.length; t++) {
    let r = e.elements[t];
    if (!r.validity.valid) return r;
  }
  return null;
}
const ru = {
  badInput: !1,
  customError: !1,
  patternMismatch: !1,
  rangeOverflow: !1,
  rangeUnderflow: !1,
  stepMismatch: !1,
  tooLong: !1,
  tooShort: !1,
  typeMismatch: !1,
  valueMissing: !1,
  valid: !0
}, Ag = {
  ...ru,
  customError: !0,
  valid: !1
}, rn = {
  isInvalid: !1,
  validationDetails: ru,
  validationErrors: []
}, _g = ce({}), wa = "__formValidationState" + Date.now();
function Ka(e) {
  if (e[wa]) {
    let { realtimeValidation: t, displayValidation: r, updateValidation: n, resetValidation: i, commitValidation: a } = e[wa];
    return {
      realtimeValidation: t,
      displayValidation: r,
      updateValidation: n,
      resetValidation: i,
      commitValidation: a
    };
  }
  return JC(e);
}
function JC(e) {
  let { isInvalid: t, validationState: r, name: n, value: i, builtinValidation: a, validate: o, validationBehavior: s = "aria" } = e;
  r && (t || (t = r === "invalid"));
  let u = t !== void 0 ? {
    isInvalid: t,
    validationErrors: [],
    validationDetails: Ag
  } : null, l = G(() => lp(XC(o, i)), [
    o,
    i
  ]);
  a != null && a.validationDetails.valid && (a = null);
  let c = le(_g), d = G(() => n ? Array.isArray(n) ? n.flatMap((w) => cc(c[w])) : cc(c[n]) : [], [
    c,
    n
  ]), [f, h] = ee(c), [p, v] = ee(!1);
  c !== f && (h(c), v(!1));
  let g = G(() => lp(p ? [] : d), [
    p,
    d
  ]), $ = q(rn), [m, b] = ee(rn), D = q(rn), S = () => {
    if (!T) return;
    B(!1);
    let w = l || a || $.current;
    Xu(w, D.current) || (D.current = w, b(w));
  }, [T, B] = ee(!1);
  return oe(S), {
    realtimeValidation: u || g || l || a || rn,
    displayValidation: s === "native" ? u || g || m : u || g || l || a || m,
    updateValidation(w) {
      s === "aria" && !Xu(m, w) ? b(w) : $.current = w;
    },
    resetValidation() {
      let w = rn;
      Xu(w, D.current) || (D.current = w, b(w)), s === "native" && B(!1), v(!0);
    },
    commitValidation() {
      s === "native" && B(!0), v(!0);
    }
  };
}
function cc(e) {
  return e ? Array.isArray(e) ? e : [
    e
  ] : [];
}
function XC(e, t) {
  if (typeof e == "function") {
    let r = e(t);
    if (r && typeof r != "boolean") return cc(r);
  }
  return [];
}
function lp(e) {
  return e.length ? {
    isInvalid: !0,
    validationErrors: e,
    validationDetails: Ag
  } : null;
}
function Xu(e, t) {
  return e === t ? !0 : e && t && e.isInvalid === t.isInvalid && e.validationErrors.length === t.validationErrors.length && e.validationErrors.every((r, n) => r === t.validationErrors[n]) && Object.entries(e.validationDetails).every(([r, n]) => t.validationDetails[r] === n);
}
function us(...e) {
  let t = /* @__PURE__ */ new Set(), r = !1, n = {
    ...ru
  };
  for (let o of e) {
    var i, a;
    for (let s of o.validationErrors) t.add(s);
    r || (r = o.isInvalid);
    for (let s in n) (i = n)[a = s] || (i[a] = o.validationDetails[s]);
  }
  return n.valid = !r, {
    isInvalid: r,
    validationErrors: [
      ...t
    ],
    validationDetails: n
  };
}
function Fg(e) {
  let { id: t, label: r, "aria-labelledby": n, "aria-label": i, labelElementType: a = "label" } = e;
  t = kt(t);
  let o = kt(), s = {};
  r ? (n = n ? `${o} ${n}` : o, s = {
    id: o,
    htmlFor: a === "label" ? t : void 0
  }) : !n && !i && console.warn("If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility");
  let u = mn({
    id: t,
    "aria-label": i,
    "aria-labelledby": n
  });
  return {
    labelProps: s,
    fieldProps: u
  };
}
function nu(e) {
  let { description: t, errorMessage: r, isInvalid: n, validationState: i } = e, { labelProps: a, fieldProps: o } = Fg(e), s = di([
    !!t,
    !!r,
    n,
    i
  ]), u = di([
    !!t,
    !!r,
    n,
    i
  ]);
  return o = ve(o, {
    "aria-describedby": [
      s,
      // Use aria-describedby for error message because aria-errormessage is unsupported using VoiceOver or NVDA. See https://github.com/adobe/react-spectrum/issues/1346#issuecomment-740136268
      u,
      e["aria-describedby"]
    ].filter(Boolean).join(" ") || void 0
  }), {
    labelProps: a,
    fieldProps: o,
    descriptionProps: {
      id: s
    },
    errorMessageProps: {
      id: u
    }
  };
}
var Og = {};
Og = {
  buttonLabel: " ",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} `,
    other: () => `${t.number(e.optionCount)} `
  })} .`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `  ${e.groupTitle},  ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} `,
      other: () => `${t.number(e.groupCount)} `
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", ",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "",
  selectedAnnouncement: (e) => `${e.optionText} `
};
var Ig = {};
Ig = {
  buttonLabel: " ",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} `,
    other: () => `${t.number(e.optionCount)} `
  })}  .`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `  ${e.groupTitle},  ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} `,
      other: () => `${t.number(e.groupCount)} `
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", ",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "",
  selectedAnnouncement: (e) => `${e.optionText}, `
};
var Rg = {};
Rg = {
  buttonLabel: "Zobrazit doporuen",
  countAnnouncement: (e, t) => `K dispozici ${t.plural(e.optionCount, {
    one: () => `je ${t.number(e.optionCount)} monost`,
    other: () => `jsou/je ${t.number(e.optionCount)} monosti/-`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Zadan skupina ${e.groupTitle} ${t.plural(e.groupCount, {
      one: () => `s ${t.number(e.groupCount)} monost`,
      other: () => `se ${t.number(e.groupCount)} monostmi`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: " (vybrno)",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Nvrhy",
  selectedAnnouncement: (e) => `${e.optionText}, vybrno`
};
var Bg = {};
Bg = {
  buttonLabel: "Vis forslag",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} mulighed tilgngelig`,
    other: () => `${t.number(e.optionCount)} muligheder tilgngelige`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Angivet gruppe ${e.groupTitle}, med ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} mulighed`,
      other: () => `${t.number(e.groupCount)} muligheder`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", valgt",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Forslag",
  selectedAnnouncement: (e) => `${e.optionText}, valgt`
};
var Mg = {};
Mg = {
  buttonLabel: "Empfehlungen anzeigen",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} Option`,
    other: () => `${t.number(e.optionCount)} Optionen`
  })} verfgbar.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Eingetretene Gruppe ${e.groupTitle}, mit ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} Option`,
      other: () => `${t.number(e.groupCount)} Optionen`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", ausgewhlt",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Empfehlungen",
  selectedAnnouncement: (e) => `${e.optionText}, ausgewhlt`
};
var Ng = {};
Ng = {
  buttonLabel: " ",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} `,
    other: () => `${t.number(e.optionCount)}  `
  })} .`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `  ${e.groupTitle},  ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} `,
      other: () => `${t.number(e.groupCount)} `
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", ",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "",
  selectedAnnouncement: (e) => `${e.optionText}, `
};
var Lg = {};
Lg = {
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Entered group ${e.groupTitle}, with ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} option`,
      other: () => `${t.number(e.groupCount)} options`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", selected",
    other: ""
  }, e.isSelected)}`,
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} option`,
    other: () => `${t.number(e.optionCount)} options`
  })} available.`,
  selectedAnnouncement: (e) => `${e.optionText}, selected`,
  buttonLabel: "Show suggestions",
  listboxLabel: "Suggestions"
};
var Vg = {};
Vg = {
  buttonLabel: "Mostrar sugerencias",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opcin`,
    other: () => `${t.number(e.optionCount)} opciones`
  })} disponible(s).`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Se ha unido al grupo ${e.groupTitle}, con ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opcin`,
      other: () => `${t.number(e.groupCount)} opciones`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", seleccionado",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Sugerencias",
  selectedAnnouncement: (e) => `${e.optionText}, seleccionado`
};
var zg = {};
zg = {
  buttonLabel: "Kuva soovitused",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} valik`,
    other: () => `${t.number(e.optionCount)} valikud`
  })} saadaval.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Sisestatud rhm ${e.groupTitle}, valikuga ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} valik`,
      other: () => `${t.number(e.groupCount)} valikud`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", valitud",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Soovitused",
  selectedAnnouncement: (e) => `${e.optionText}, valitud`
};
var jg = {};
jg = {
  buttonLabel: "Nyt ehdotukset",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} vaihtoehto`,
    other: () => `${t.number(e.optionCount)} vaihtoehdot`
  })} saatavilla.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Mentiin ryhmn ${e.groupTitle}, ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} vaihtoehdon`,
      other: () => `${t.number(e.groupCount)} vaihtoehdon`
    })} kanssa.`,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", valittu",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Ehdotukset",
  selectedAnnouncement: (e) => `${e.optionText}, valittu`
};
var Kg = {};
Kg = {
  buttonLabel: "Afficher les suggestions",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} option`,
    other: () => `${t.number(e.optionCount)} options`
  })} disponible(s).`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Groupe ${e.groupTitle} rejoint, avec ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} option`,
      other: () => `${t.number(e.groupCount)} options`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", slectionn(s)",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Suggestions",
  selectedAnnouncement: (e) => `${e.optionText}, slectionn`
};
var Ug = {};
Ug = {
  buttonLabel: " ",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => ` ${t.number(e.optionCount)}`,
    other: () => `${t.number(e.optionCount)} `
  })}  .`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `  ${e.groupTitle},  ${t.plural(e.groupCount, {
      one: () => ` ${t.number(e.groupCount)}`,
      other: () => `${t.number(e.groupCount)} `
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", ",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "",
  selectedAnnouncement: (e) => `${e.optionText}, `
};
var qg = {};
qg = {
  buttonLabel: "Prikai prijedloge",
  countAnnouncement: (e, t) => `Dostupno jo: ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opcija`,
    other: () => `${t.number(e.optionCount)} opcije/a`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Unesena skupina ${e.groupTitle}, s ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opcijom`,
      other: () => `${t.number(e.groupCount)} opcije/a`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", odabranih",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Prijedlozi",
  selectedAnnouncement: (e) => `${e.optionText}, odabrano`
};
var Hg = {};
Hg = {
  buttonLabel: "Javaslatok megjelentse",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} lehetsg`,
    other: () => `${t.number(e.optionCount)} lehetsg`
  })} ll rendelkezsre.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Belpett a(z) ${e.groupTitle} csoportba, amely ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} lehetsget`,
      other: () => `${t.number(e.groupCount)} lehetsget`
    })} tartalmaz. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", kijellve",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Javaslatok",
  selectedAnnouncement: (e) => `${e.optionText}, kijellve`
};
var Wg = {};
Wg = {
  buttonLabel: "Mostra suggerimenti",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opzione disponibile`,
    other: () => `${t.number(e.optionCount)} opzioni disponibili`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Ingresso nel gruppo ${e.groupTitle}, con ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opzione`,
      other: () => `${t.number(e.groupCount)} opzioni`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", selezionato",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Suggerimenti",
  selectedAnnouncement: (e) => `${e.optionText}, selezionato`
};
var Qg = {};
Qg = {
  buttonLabel: "",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} `,
    other: () => `${t.number(e.optionCount)} `
  })}`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => ` ${e.groupTitle}${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} `,
      other: () => `${t.number(e.groupCount)} `
    })}`,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: "",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "",
  selectedAnnouncement: (e) => `${e.optionText}`
};
var Gg = {};
Gg = {
  buttonLabel: "  ",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} `,
    other: () => `${t.number(e.optionCount)} `
  })}   .`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `  ${e.groupTitle}, ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} `,
      other: () => `${t.number(e.groupCount)} `
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", ",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "",
  selectedAnnouncement: (e) => `${e.optionText}, `
};
var Zg = {};
Zg = {
  buttonLabel: "Rodyti pasilymus",
  countAnnouncement: (e, t) => `Yra ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} parinktis`,
    other: () => `${t.number(e.optionCount)} parinktys (-i)`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `vesta grup ${e.groupTitle}, su ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} parinktimi`,
      other: () => `${t.number(e.groupCount)} parinktimis (-i)`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", pasirinkta",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Pasilymai",
  selectedAnnouncement: (e) => `${e.optionText}, pasirinkta`
};
var Yg = {};
Yg = {
  buttonLabel: "Rdt ieteikumus",
  countAnnouncement: (e, t) => `Pieejamo opciju skaits: ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opcija`,
    other: () => `${t.number(e.optionCount)} opcijas`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Ievadta grupa ${e.groupTitle}, ar ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opciju`,
      other: () => `${t.number(e.groupCount)} opcijm`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", atlasta",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Ieteikumi",
  selectedAnnouncement: (e) => `${e.optionText}, atlasta`
};
var Jg = {};
Jg = {
  buttonLabel: "Vis forslag",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} alternativ`,
    other: () => `${t.number(e.optionCount)} alternativer`
  })} finnes.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Angitt gruppe ${e.groupTitle}, med ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} alternativ`,
      other: () => `${t.number(e.groupCount)} alternativer`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", valgt",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Forslag",
  selectedAnnouncement: (e) => `${e.optionText}, valgt`
};
var Xg = {};
Xg = {
  buttonLabel: "Suggesties weergeven",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} optie`,
    other: () => `${t.number(e.optionCount)} opties`
  })} beschikbaar.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Groep ${e.groupTitle} ingevoerd met ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} optie`,
      other: () => `${t.number(e.groupCount)} opties`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", geselecteerd",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Suggesties",
  selectedAnnouncement: (e) => `${e.optionText}, geselecteerd`
};
var e0 = {};
e0 = {
  buttonLabel: "Wywietlaj sugestie",
  countAnnouncement: (e, t) => `dostpna/dostpne(-nych) ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opcja`,
    other: () => `${t.number(e.optionCount)} opcje(-i)`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Doczono do grupy ${e.groupTitle}, z ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opcj`,
      other: () => `${t.number(e.groupCount)} opcjami`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", wybrano",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Sugestie",
  selectedAnnouncement: (e) => `${e.optionText}, wybrano`
};
var t0 = {};
t0 = {
  buttonLabel: "Mostrar sugestes",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opo`,
    other: () => `${t.number(e.optionCount)} opes`
  })} disponvel.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Grupo inserido ${e.groupTitle}, com ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opo`,
      other: () => `${t.number(e.groupCount)} opes`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", selecionado",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Sugestes",
  selectedAnnouncement: (e) => `${e.optionText}, selecionado`
};
var r0 = {};
r0 = {
  buttonLabel: "Apresentar sugestes",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opo`,
    other: () => `${t.number(e.optionCount)} opes`
  })} disponvel.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Grupo introduzido ${e.groupTitle}, com ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opo`,
      other: () => `${t.number(e.groupCount)} opes`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", selecionado",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Sugestes",
  selectedAnnouncement: (e) => `${e.optionText}, selecionado`
};
var n0 = {};
n0 = {
  buttonLabel: "Afiare sugestii",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opiune`,
    other: () => `${t.number(e.optionCount)} opiuni`
  })} disponibile.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Grup ${e.groupTitle} introdus, cu ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opiune`,
      other: () => `${t.number(e.groupCount)} opiuni`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", selectat",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Sugestii",
  selectedAnnouncement: (e) => `${e.optionText}, selectat`
};
var i0 = {};
i0 = {
  buttonLabel: " ",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} `,
    other: () => `${t.number(e.optionCount)} `
  })} .`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `  ${e.groupTitle},  ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} `,
      other: () => `${t.number(e.groupCount)} `
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", ",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "",
  selectedAnnouncement: (e) => `${e.optionText}, `
};
var a0 = {};
a0 = {
  buttonLabel: "Zobrazi nvrhy",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} monos`,
    other: () => `${t.number(e.optionCount)} monosti/-`
  })} k dispozcii.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Zadan skupina ${e.groupTitle}, s ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} monosou`,
      other: () => `${t.number(e.groupCount)} monosami`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", vybrat",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Nvrhy",
  selectedAnnouncement: (e) => `${e.optionText}, vybrat`
};
var o0 = {};
o0 = {
  buttonLabel: "Prikai predloge",
  countAnnouncement: (e, t) => `Na voljo je ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opcija`,
    other: () => `${t.number(e.optionCount)} opcije`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Vnesena skupina ${e.groupTitle}, z ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opcija`,
      other: () => `${t.number(e.groupCount)} opcije`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", izbrano",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Predlogi",
  selectedAnnouncement: (e) => `${e.optionText}, izbrano`
};
var s0 = {};
s0 = {
  buttonLabel: "Prikai predloge",
  countAnnouncement: (e, t) => `Dostupno jo: ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opcija`,
    other: () => `${t.number(e.optionCount)} opcije/a`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Unesena grupa ${e.groupTitle}, s ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opcijom`,
      other: () => `${t.number(e.groupCount)} optione/a`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", izabranih",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Predlozi",
  selectedAnnouncement: (e) => `${e.optionText}, izabrano`
};
var u0 = {};
u0 = {
  buttonLabel: "Visa frslag",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} alternativ`,
    other: () => `${t.number(e.optionCount)} alternativ`
  })} tillgngliga.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Ingick i gruppen ${e.groupTitle} med ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} alternativ`,
      other: () => `${t.number(e.groupCount)} alternativ`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", valda",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Frslag",
  selectedAnnouncement: (e) => `${e.optionText}, valda`
};
var l0 = {};
l0 = {
  buttonLabel: "nerileri gster",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} seenek`,
    other: () => `${t.number(e.optionCount)} seenekler`
  })} kullanlabilir.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Girilen grup ${e.groupTitle}, ile ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} seenek`,
      other: () => `${t.number(e.groupCount)} seenekler`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", seildi",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "neriler",
  selectedAnnouncement: (e) => `${e.optionText}, seildi`
};
var c0 = {};
c0 = {
  buttonLabel: " ",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} `,
    other: () => `${t.number(e.optionCount)} (-)`
  })} .`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `  ${e.groupTitle},  ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} `,
      other: () => `${t.number(e.groupCount)} (-)`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", ",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "",
  selectedAnnouncement: (e) => `${e.optionText}, `
};
var d0 = {};
d0 = {
  buttonLabel: "",
  countAnnouncement: (e, t) => ` ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} `,
    other: () => `${t.number(e.optionCount)} `
  })}`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => ` ${e.groupTitle}  ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} `,
      other: () => `${t.number(e.groupCount)} `
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", ",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "",
  selectedAnnouncement: (e) => `${e.optionText}, `
};
var f0 = {};
f0 = {
  buttonLabel: "",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} `,
    other: () => `${t.number(e.optionCount)} `
  })} `,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => ` ${e.groupTitle},  ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} `,
      other: () => `${t.number(e.groupCount)} `
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", ",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "",
  selectedAnnouncement: (e) => `${e.optionText}, `
};
var h0 = {};
h0 = {
  "ar-AE": Og,
  "bg-BG": Ig,
  "cs-CZ": Rg,
  "da-DK": Bg,
  "de-DE": Mg,
  "el-GR": Ng,
  "en-US": Lg,
  "es-ES": Vg,
  "et-EE": zg,
  "fi-FI": jg,
  "fr-FR": Kg,
  "he-IL": Ug,
  "hr-HR": qg,
  "hu-HU": Hg,
  "it-IT": Wg,
  "ja-JP": Qg,
  "ko-KR": Gg,
  "lt-LT": Zg,
  "lv-LV": Yg,
  "nb-NO": Jg,
  "nl-NL": Xg,
  "pl-PL": e0,
  "pt-BR": t0,
  "pt-PT": r0,
  "ro-RO": n0,
  "ru-RU": i0,
  "sk-SK": a0,
  "sl-SI": o0,
  "sr-SP": s0,
  "sv-SE": u0,
  "tr-TR": l0,
  "uk-UA": c0,
  "zh-CN": d0,
  "zh-TW": f0
};
const qn = {
  top: "top",
  bottom: "top",
  left: "left",
  right: "left"
}, ls = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
}, e7 = {
  top: "left",
  left: "top"
}, dc = {
  top: "height",
  left: "width"
}, p0 = {
  width: "totalWidth",
  height: "totalHeight"
}, yo = {};
let vt = typeof document < "u" && window.visualViewport;
function cp(e) {
  let t = 0, r = 0, n = 0, i = 0, a = 0, o = 0, s = {}, u = (vt == null ? void 0 : vt.scale) > 1;
  if (e.tagName === "BODY") {
    let d = document.documentElement;
    n = d.clientWidth, i = d.clientHeight;
    var l;
    t = (l = vt == null ? void 0 : vt.width) !== null && l !== void 0 ? l : n;
    var c;
    r = (c = vt == null ? void 0 : vt.height) !== null && c !== void 0 ? c : i, s.top = d.scrollTop || e.scrollTop, s.left = d.scrollLeft || e.scrollLeft, vt && (a = vt.offsetTop, o = vt.offsetLeft);
  } else
    ({ width: t, height: r, top: a, left: o } = ni(e)), s.top = e.scrollTop, s.left = e.scrollLeft, n = t, i = r;
  return Dd() && (e.tagName === "BODY" || e.tagName === "HTML") && u && (s.top = 0, s.left = 0, a = vt.pageTop, o = vt.pageLeft), {
    width: t,
    height: r,
    totalWidth: n,
    totalHeight: i,
    scroll: s,
    top: a,
    left: o
  };
}
function t7(e) {
  return {
    top: e.scrollTop,
    left: e.scrollLeft,
    width: e.scrollWidth,
    height: e.scrollHeight
  };
}
function dp(e, t, r, n, i, a, o) {
  let s = i.scroll[e], u = n[dc[e]], l = n.scroll[qn[e]] + a, c = u + n.scroll[qn[e]] - a, d = t - s + o[e] - n[qn[e]], f = t - s + r + o[e] - n[qn[e]];
  return d < l ? l - d : f > c ? Math.max(c - f, l - d) : 0;
}
function r7(e) {
  let t = window.getComputedStyle(e);
  return {
    top: parseInt(t.marginTop, 10) || 0,
    bottom: parseInt(t.marginBottom, 10) || 0,
    left: parseInt(t.marginLeft, 10) || 0,
    right: parseInt(t.marginRight, 10) || 0
  };
}
function fp(e) {
  if (yo[e]) return yo[e];
  let [t, r] = e.split(" "), n = qn[t] || "right", i = e7[n];
  qn[r] || (r = "center");
  let a = dc[n], o = dc[i];
  return yo[e] = {
    placement: t,
    crossPlacement: r,
    axis: n,
    crossAxis: i,
    size: a,
    crossSize: o
  }, yo[e];
}
function el(e, t, r, n, i, a, o, s, u, l) {
  let { placement: c, crossPlacement: d, axis: f, crossAxis: h, size: p, crossSize: v } = n, g = {};
  g[h] = e[h], d === "center" ? g[h] += (e[v] - r[v]) / 2 : d !== h && (g[h] += e[v] - r[v]), g[h] += a;
  const $ = e[h] - r[v] + u + l, m = e[h] + e[v] - u - l;
  if (g[h] = Wl(g[h], $, m), c === f) {
    const b = s ? o[p] : t[p0[p]];
    g[ls[f]] = Math.floor(b - e[f] + i);
  } else g[f] = Math.floor(e[f] + e[p] + i);
  return g;
}
function n7(e, t, r, n, i, a, o, s) {
  const u = n ? r.height : t[p0.height];
  let l = e.top != null ? r.top + e.top : r.top + (u - e.bottom - o), c = s !== "top" ? (
    // We want the distance between the top of the overlay to the bottom of the boundary
    Math.max(0, t.height + t.top + t.scroll.top - l - (i.top + i.bottom + a))
  ) : Math.max(0, l + o - (t.top + t.scroll.top) - (i.top + i.bottom + a));
  return Math.min(t.height - a * 2, c);
}
function hp(e, t, r, n, i, a) {
  let { placement: o, axis: s, size: u } = a;
  return o === s ? Math.max(0, r[s] - e[s] - e.scroll[s] + t[s] - n[s] - n[ls[s]] - i) : Math.max(0, e[u] + e[s] + e.scroll[s] - t[s] - r[s] - r[u] - n[s] - n[ls[s]] - i);
}
function i7(e, t, r, n, i, a, o, s, u, l, c, d, f, h, p, v) {
  let g = fp(e), { size: $, crossAxis: m, crossSize: b, placement: D, crossPlacement: S } = g, T = el(t, s, r, g, c, d, l, f, p, v), B = c, y = hp(s, l, t, i, a + c, g);
  if (o && n[$] > y) {
    let K = fp(`${ls[D]} ${S}`), z = el(t, s, r, K, c, d, l, f, p, v);
    hp(s, l, t, i, a + c, K) > y && (g = K, T = z, B = c);
  }
  let _ = "bottom";
  g.axis === "top" ? g.placement === "top" ? _ = "top" : g.placement === "bottom" && (_ = "bottom") : g.crossAxis === "top" && (g.crossPlacement === "top" ? _ = "bottom" : g.crossPlacement === "bottom" && (_ = "top"));
  let w = dp(m, T[m], r[b], s, u, a, l);
  T[m] += w;
  let E = n7(T, s, l, f, i, a, r.height, _);
  h && h < E && (E = h), r.height = Math.min(r.height, E), T = el(t, s, r, g, B, d, l, f, p, v), w = dp(m, T[m], r[b], s, u, a, l), T[m] += w;
  let k = {}, C = t[m] + 0.5 * t[b] - T[m];
  const A = p / 2 + v, L = r[b] - p / 2 - v, I = t[m] - T[m] + p / 2, x = t[m] + t[b] - T[m] - p / 2, U = Wl(C, I, x);
  return k[m] = Wl(U, A, L), {
    position: T,
    maxHeight: E,
    arrowOffsetLeft: k.left,
    arrowOffsetTop: k.top,
    placement: g.placement
  };
}
function a7(e) {
  let { placement: t, targetNode: r, overlayNode: n, scrollNode: i, padding: a, shouldFlip: o, boundaryElement: s, offset: u, crossOffset: l, maxHeight: c, arrowSize: d = 0, arrowBoundaryOffset: f = 0 } = e, h = n instanceof HTMLElement ? o7(n) : document.documentElement, p = h === document.documentElement;
  const v = window.getComputedStyle(h).position;
  let g = !!v && v !== "static", $ = p ? ni(r) : pp(r, h);
  if (!p) {
    let { marginTop: y, marginLeft: _ } = window.getComputedStyle(r);
    $.top += parseInt(y, 10) || 0, $.left += parseInt(_, 10) || 0;
  }
  let m = ni(n), b = r7(n);
  m.width += b.left + b.right, m.height += b.top + b.bottom;
  let D = t7(i), S = cp(s), T = cp(h), B = s.tagName === "BODY" ? ni(h) : pp(h, s);
  return h.tagName === "HTML" && s.tagName === "BODY" && (T.scroll.top = 0, T.scroll.left = 0), i7(t, $, m, D, b, a, o, S, T, B, u, l, g, c, d, f);
}
function ni(e) {
  let { top: t, left: r, width: n, height: i } = e.getBoundingClientRect(), { scrollTop: a, scrollLeft: o, clientTop: s, clientLeft: u } = document.documentElement;
  return {
    top: t + a - s,
    left: r + o - u,
    width: n,
    height: i
  };
}
function pp(e, t) {
  let r = window.getComputedStyle(e), n;
  if (r.position === "fixed") {
    let { top: i, left: a, width: o, height: s } = e.getBoundingClientRect();
    n = {
      top: i,
      left: a,
      width: o,
      height: s
    };
  } else {
    n = ni(e);
    let i = ni(t), a = window.getComputedStyle(t);
    i.top += (parseInt(a.borderTopWidth, 10) || 0) - t.scrollTop, i.left += (parseInt(a.borderLeftWidth, 10) || 0) - t.scrollLeft, n.top -= i.top, n.left -= i.left;
  }
  return n.top -= parseInt(r.marginTop, 10) || 0, n.left -= parseInt(r.marginLeft, 10) || 0, n;
}
function o7(e) {
  let t = e.offsetParent;
  if (t && t === document.body && window.getComputedStyle(t).position === "static" && !mp(t) && (t = document.documentElement), t == null)
    for (t = e.parentElement; t && !mp(t); ) t = t.parentElement;
  return t || document.documentElement;
}
function mp(e) {
  let t = window.getComputedStyle(e);
  return t.transform !== "none" || /transform|perspective/.test(t.willChange) || t.filter !== "none" || t.contain === "paint" || // @ts-ignore
  "backdropFilter" in t && t.backdropFilter !== "none" || // @ts-ignore
  "WebkitBackdropFilter" in t && t.WebkitBackdropFilter !== "none";
}
const m0 = /* @__PURE__ */ new WeakMap();
function s7(e) {
  let { triggerRef: t, isOpen: r, onClose: n } = e;
  oe(() => {
    if (!r || n === null) return;
    let i = (a) => {
      let o = a.target;
      if (!t.current || o instanceof Node && !o.contains(t.current)) return;
      let s = n || m0.get(t.current);
      s && s();
    };
    return window.addEventListener("scroll", i, !0), () => {
      window.removeEventListener("scroll", i, !0);
    };
  }, [
    r,
    n,
    t
  ]);
}
let Qe = typeof document < "u" && window.visualViewport;
function u7(e) {
  let { direction: t } = st(), { arrowSize: r = 0, targetRef: n, overlayRef: i, scrollRef: a = i, placement: o = "bottom", containerPadding: s = 12, shouldFlip: u = !0, boundaryElement: l = typeof document < "u" ? document.body : null, offset: c = 0, crossOffset: d = 0, shouldUpdatePosition: f = !0, isOpen: h = !0, onClose: p, maxHeight: v, arrowBoundaryOffset: g = 0 } = e, [$, m] = ee({
    position: {},
    arrowOffsetLeft: void 0,
    arrowOffsetTop: void 0,
    maxHeight: void 0,
    placement: void 0
  }), b = [
    f,
    o,
    i.current,
    n.current,
    a.current,
    s,
    u,
    l,
    c,
    d,
    h,
    t,
    v,
    g,
    r
  ], D = q(Qe == null ? void 0 : Qe.scale);
  oe(() => {
    h && (D.current = Qe == null ? void 0 : Qe.scale);
  }, [
    h
  ]);
  let S = be(() => {
    if (f === !1 || !h || !i.current || !n.current || !a.current || !l || (Qe == null ? void 0 : Qe.scale) !== D.current) return;
    let y = i.current;
    if (!v && i.current) {
      var _;
      y.style.top = "0px", y.style.bottom = "";
      var w;
      y.style.maxHeight = ((w = (_ = window.visualViewport) === null || _ === void 0 ? void 0 : _.height) !== null && w !== void 0 ? w : window.innerHeight) + "px";
    }
    let E = a7({
      placement: c7(o, t),
      overlayNode: i.current,
      targetNode: n.current,
      scrollNode: a.current,
      padding: s,
      shouldFlip: u,
      boundaryElement: l,
      offset: c,
      crossOffset: d,
      maxHeight: v,
      arrowSize: r,
      arrowBoundaryOffset: g
    });
    y.style.top = "", y.style.bottom = "", Object.keys(E.position).forEach((k) => y.style[k] = E.position[k] + "px"), y.style.maxHeight = E.maxHeight != null ? E.maxHeight + "px" : void 0, m(E);
  }, b);
  Re(S, b), l7(S), Ws({
    ref: i,
    onResize: S
  });
  let T = q(!1);
  Re(() => {
    let y, _ = () => {
      T.current = !0, clearTimeout(y), y = setTimeout(() => {
        T.current = !1;
      }, 500), S();
    }, w = () => {
      T.current && _();
    };
    return Qe == null || Qe.addEventListener("resize", _), Qe == null || Qe.addEventListener("scroll", w), () => {
      Qe == null || Qe.removeEventListener("resize", _), Qe == null || Qe.removeEventListener("scroll", w);
    };
  }, [
    S
  ]);
  let B = be(() => {
    T.current || p();
  }, [
    p,
    T
  ]);
  return s7({
    triggerRef: n,
    isOpen: h,
    onClose: p && B
  }), {
    overlayProps: {
      style: {
        position: "absolute",
        zIndex: 1e5,
        ...$.position,
        maxHeight: $.maxHeight
      }
    },
    placement: $.placement,
    arrowProps: {
      "aria-hidden": "true",
      role: "presentation",
      style: {
        left: $.arrowOffsetLeft,
        top: $.arrowOffsetTop
      }
    },
    updatePosition: S
  };
}
function l7(e) {
  Re(() => (window.addEventListener("resize", e, !1), () => {
    window.removeEventListener("resize", e, !1);
  }), [
    e
  ]);
}
function c7(e, t) {
  return t === "rtl" ? e.replace("start", "right").replace("end", "left") : e.replace("start", "left").replace("end", "right");
}
const ar = [];
function v0(e, t) {
  let { onClose: r, shouldCloseOnBlur: n, isOpen: i, isDismissable: a = !1, isKeyboardDismissDisabled: o = !1, shouldCloseOnInteractOutside: s } = e;
  oe(() => (i && ar.push(t), () => {
    let p = ar.indexOf(t);
    p >= 0 && ar.splice(p, 1);
  }), [
    i,
    t
  ]);
  let u = () => {
    ar[ar.length - 1] === t && r && r();
  }, l = (p) => {
    (!s || s(p.target)) && ar[ar.length - 1] === t && (p.stopPropagation(), p.preventDefault());
  }, c = (p) => {
    (!s || s(p.target)) && (ar[ar.length - 1] === t && (p.stopPropagation(), p.preventDefault()), u());
  }, d = (p) => {
    p.key === "Escape" && !o && !p.nativeEvent.isComposing && (p.stopPropagation(), p.preventDefault(), u());
  };
  uw({
    ref: t,
    onInteractOutside: a && i ? c : null,
    onInteractOutsideStart: l
  });
  let { focusWithinProps: f } = $i({
    isDisabled: !n,
    onBlurWithin: (p) => {
      !p.relatedTarget || yw(p.relatedTarget) || (!s || s(p.relatedTarget)) && r();
    }
  }), h = (p) => {
    p.target === p.currentTarget && p.preventDefault();
  };
  return {
    overlayProps: {
      onKeyDown: d,
      ...f
    },
    underlayProps: {
      onPointerDown: h
    }
  };
}
function y0(e, t, r) {
  let { type: n } = e, { isOpen: i } = t;
  oe(() => {
    r && r.current && m0.set(r.current, t.close);
  });
  let a;
  n === "menu" ? a = !0 : n === "listbox" && (a = "listbox");
  let o = kt();
  return {
    triggerProps: {
      "aria-haspopup": a,
      "aria-expanded": i,
      "aria-controls": i ? o : null,
      onPress: t.toggle
    },
    overlayProps: {
      id: o
    }
  };
}
const tl = typeof document < "u" && window.visualViewport, d7 = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
let go = 0, rl;
function g0(e = {}) {
  let { isDisabled: t } = e;
  Re(() => {
    if (!t)
      return go++, go === 1 && (Na() ? rl = h7() : rl = f7()), () => {
        go--, go === 0 && rl();
      };
  }, [
    t
  ]);
}
function f7() {
  return Hr(Hn(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), Hn(document.documentElement, "overflow", "hidden"));
}
function h7() {
  let e, t, r = (l) => {
    e = Qs(l.target, !0), !(e === document.documentElement && e === document.body) && e instanceof HTMLElement && window.getComputedStyle(e).overscrollBehavior === "auto" && (t = Hn(e, "overscrollBehavior", "contain"));
  }, n = (l) => {
    if (!e || e === document.documentElement || e === document.body) {
      l.preventDefault();
      return;
    }
    e.scrollHeight === e.clientHeight && e.scrollWidth === e.clientWidth && l.preventDefault();
  }, i = (l) => {
    let c = l.target;
    yp(c) && c !== document.activeElement && (l.preventDefault(), s(), c.style.transform = "translateY(-2000px)", c.focus(), requestAnimationFrame(() => {
      c.style.transform = "";
    })), t && t();
  }, a = (l) => {
    let c = l.target;
    yp(c) && (s(), c.style.transform = "translateY(-2000px)", requestAnimationFrame(() => {
      c.style.transform = "", tl && (tl.height < window.innerHeight ? requestAnimationFrame(() => {
        vp(c);
      }) : tl.addEventListener("resize", () => vp(c), {
        once: !0
      }));
    }));
  }, o = null, s = () => {
    if (o) return;
    let l = () => {
      window.scrollTo(0, 0);
    }, c = window.pageXOffset, d = window.pageYOffset;
    o = Hr(Bi(window, "scroll", l), Hn(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), Hn(document.documentElement, "overflow", "hidden"), Hn(document.body, "marginTop", `-${d}px`), () => {
      window.scrollTo(c, d);
    }), window.scrollTo(0, 0);
  }, u = Hr(Bi(document, "touchstart", r, {
    passive: !1,
    capture: !0
  }), Bi(document, "touchmove", n, {
    passive: !1,
    capture: !0
  }), Bi(document, "touchend", i, {
    passive: !1,
    capture: !0
  }), Bi(document, "focus", a, !0));
  return () => {
    t == null || t(), o == null || o(), u();
  };
}
function Hn(e, t, r) {
  let n = e.style[t];
  return e.style[t] = r, () => {
    e.style[t] = n;
  };
}
function Bi(e, t, r, n) {
  return e.addEventListener(t, r, n), () => {
    e.removeEventListener(t, r, n);
  };
}
function vp(e) {
  let t = document.scrollingElement || document.documentElement;
  for (; e && e !== t; ) {
    let r = Qs(e);
    if (r !== document.documentElement && r !== document.body && r !== e) {
      let n = r.getBoundingClientRect().top, i = e.getBoundingClientRect().top;
      i > n + e.clientHeight && (r.scrollTop += i - n);
    }
    e = r.parentElement;
  }
}
function yp(e) {
  return e instanceof HTMLInputElement && !d7.has(e.type) || e instanceof HTMLTextAreaElement || e instanceof HTMLElement && e.isContentEditable;
}
var b0 = {};
b0 = {
  dismiss: ""
};
var $0 = {};
$0 = {
  dismiss: ""
};
var x0 = {};
x0 = {
  dismiss: "Odstranit"
};
var D0 = {};
D0 = {
  dismiss: "Luk"
};
var E0 = {};
E0 = {
  dismiss: "Schlieen"
};
var w0 = {};
w0 = {
  dismiss: ""
};
var C0 = {};
C0 = {
  dismiss: "Dismiss"
};
var S0 = {};
S0 = {
  dismiss: "Descartar"
};
var k0 = {};
k0 = {
  dismiss: "Lpeta"
};
var P0 = {};
P0 = {
  dismiss: "Hylk"
};
var T0 = {};
T0 = {
  dismiss: "Rejeter"
};
var A0 = {};
A0 = {
  dismiss: ""
};
var _0 = {};
_0 = {
  dismiss: "Odbaci"
};
var F0 = {};
F0 = {
  dismiss: "Elutasts"
};
var O0 = {};
O0 = {
  dismiss: "Ignora"
};
var I0 = {};
I0 = {
  dismiss: ""
};
var R0 = {};
R0 = {
  dismiss: ""
};
var B0 = {};
B0 = {
  dismiss: "Atmesti"
};
var M0 = {};
M0 = {
  dismiss: "Nerdt"
};
var N0 = {};
N0 = {
  dismiss: "Lukk"
};
var L0 = {};
L0 = {
  dismiss: "Negeren"
};
var V0 = {};
V0 = {
  dismiss: "Zignoruj"
};
var z0 = {};
z0 = {
  dismiss: "Descartar"
};
var j0 = {};
j0 = {
  dismiss: "Dispensar"
};
var K0 = {};
K0 = {
  dismiss: "Revocare"
};
var U0 = {};
U0 = {
  dismiss: ""
};
var q0 = {};
q0 = {
  dismiss: "Zrui"
};
var H0 = {};
H0 = {
  dismiss: "Opusti"
};
var W0 = {};
W0 = {
  dismiss: "Odbaci"
};
var Q0 = {};
Q0 = {
  dismiss: "Avvisa"
};
var G0 = {};
G0 = {
  dismiss: "Kapat"
};
var Z0 = {};
Z0 = {
  dismiss: ""
};
var Y0 = {};
Y0 = {
  dismiss: ""
};
var J0 = {};
J0 = {
  dismiss: ""
};
var X0 = {};
X0 = {
  "ar-AE": b0,
  "bg-BG": $0,
  "cs-CZ": x0,
  "da-DK": D0,
  "de-DE": E0,
  "el-GR": w0,
  "en-US": C0,
  "es-ES": S0,
  "et-EE": k0,
  "fi-FI": P0,
  "fr-FR": T0,
  "he-IL": A0,
  "hr-HR": _0,
  "hu-HU": F0,
  "it-IT": O0,
  "ja-JP": I0,
  "ko-KR": R0,
  "lt-LT": B0,
  "lv-LV": M0,
  "nb-NO": N0,
  "nl-NL": L0,
  "pl-PL": V0,
  "pt-BR": z0,
  "pt-PT": j0,
  "ro-RO": K0,
  "ru-RU": U0,
  "sk-SK": q0,
  "sl-SI": H0,
  "sr-SP": W0,
  "sv-SE": Q0,
  "tr-TR": G0,
  "uk-UA": Z0,
  "zh-CN": Y0,
  "zh-TW": J0
};
const gp = {
  border: 0,
  clip: "rect(0 0 0 0)",
  clipPath: "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap"
};
function eb(e = {}) {
  let { style: t, isFocusable: r } = e, [n, i] = ee(!1), { focusWithinProps: a } = $i({
    isDisabled: !r,
    onFocusWithinChange: (s) => i(s)
  }), o = G(() => n ? t : t ? {
    ...gp,
    ...t
  } : gp, [
    n
  ]);
  return {
    visuallyHiddenProps: {
      ...a,
      style: o
    }
  };
}
function Ca(e) {
  let { children: t, elementType: r = "div", isFocusable: n, style: i, ...a } = e, { visuallyHiddenProps: o } = eb(e);
  return /* @__PURE__ */ P.createElement(r, ve(a, o), t);
}
function p7(e) {
  return e && e.__esModule ? e.default : e;
}
function fc(e) {
  let { onDismiss: t, ...r } = e, n = Ht(p7(X0), "@react-aria/overlays"), i = mn(r, n.format("dismiss")), a = () => {
    t && t();
  };
  return /* @__PURE__ */ P.createElement(Ca, null, /* @__PURE__ */ P.createElement("button", {
    ...i,
    tabIndex: -1,
    onClick: a,
    style: {
      width: 1,
      height: 1
    }
  }));
}
let Mi = /* @__PURE__ */ new WeakMap(), Tt = [];
function Ud(e, t = document.body) {
  let r = new Set(e), n = /* @__PURE__ */ new Set(), i = (u) => {
    for (let f of u.querySelectorAll("[data-live-announcer], [data-react-aria-top-layer]")) r.add(f);
    let l = (f) => {
      if (r.has(f) || n.has(f.parentElement) && f.parentElement.getAttribute("role") !== "row") return NodeFilter.FILTER_REJECT;
      for (let h of r)
        if (f.contains(h)) return NodeFilter.FILTER_SKIP;
      return NodeFilter.FILTER_ACCEPT;
    }, c = document.createTreeWalker(u, NodeFilter.SHOW_ELEMENT, {
      acceptNode: l
    }), d = l(u);
    if (d === NodeFilter.FILTER_ACCEPT && a(u), d !== NodeFilter.FILTER_REJECT) {
      let f = c.nextNode();
      for (; f != null; )
        a(f), f = c.nextNode();
    }
  }, a = (u) => {
    var l;
    let c = (l = Mi.get(u)) !== null && l !== void 0 ? l : 0;
    u.getAttribute("aria-hidden") === "true" && c === 0 || (c === 0 && u.setAttribute("aria-hidden", "true"), n.add(u), Mi.set(u, c + 1));
  };
  Tt.length && Tt[Tt.length - 1].disconnect(), i(t);
  let o = new MutationObserver((u) => {
    for (let l of u)
      if (!(l.type !== "childList" || l.addedNodes.length === 0) && ![
        ...r,
        ...n
      ].some((c) => c.contains(l.target))) {
        for (let c of l.removedNodes) c instanceof Element && (r.delete(c), n.delete(c));
        for (let c of l.addedNodes)
          (c instanceof HTMLElement || c instanceof SVGElement) && (c.dataset.liveAnnouncer === "true" || c.dataset.reactAriaTopLayer === "true") ? r.add(c) : c instanceof Element && i(c);
      }
  });
  o.observe(t, {
    childList: !0,
    subtree: !0
  });
  let s = {
    observe() {
      o.observe(t, {
        childList: !0,
        subtree: !0
      });
    },
    disconnect() {
      o.disconnect();
    }
  };
  return Tt.push(s), () => {
    o.disconnect();
    for (let u of n) {
      let l = Mi.get(u);
      l === 1 ? (u.removeAttribute("aria-hidden"), Mi.delete(u)) : Mi.set(u, l - 1);
    }
    s === Tt[Tt.length - 1] ? (Tt.pop(), Tt.length && Tt[Tt.length - 1].observe()) : Tt.splice(Tt.indexOf(s), 1);
  };
}
function m7(e, t) {
  let { triggerRef: r, popoverRef: n, isNonModal: i, isKeyboardDismissDisabled: a, shouldCloseOnInteractOutside: o, ...s } = e, { overlayProps: u, underlayProps: l } = v0({
    isOpen: t.isOpen,
    onClose: t.close,
    shouldCloseOnBlur: !0,
    isDismissable: !i,
    isKeyboardDismissDisabled: a,
    shouldCloseOnInteractOutside: o
  }, n), { overlayProps: c, arrowProps: d, placement: f } = u7({
    ...s,
    targetRef: r,
    overlayRef: n,
    isOpen: t.isOpen,
    onClose: i ? t.close : null
  });
  return g0({
    isDisabled: i || !t.isOpen
  }), Re(() => {
    if (t.isOpen && !i && n.current) return Ud([
      n.current
    ]);
  }, [
    i,
    t.isOpen,
    n
  ]), {
    popoverProps: ve(u, c),
    arrowProps: d,
    underlayProps: l,
    placement: f
  };
}
const v7 = /* @__PURE__ */ ce({});
function y7() {
  var e;
  return (e = le(v7)) !== null && e !== void 0 ? e : {};
}
const tb = /* @__PURE__ */ P.createContext(null);
function rb(e) {
  let t = wr(), { portalContainer: r = t ? null : document.body, isExiting: n } = e, [i, a] = ee(!1), o = G(() => ({
    contain: i,
    setContain: a
  }), [
    i,
    a
  ]), { getContainer: s } = y7();
  if (!e.portalContainer && s && (r = s()), !r) return null;
  let u = e.children;
  return e.disableFocusManagement || (u = /* @__PURE__ */ P.createElement(fy, {
    restoreFocus: !0,
    contain: i && !n
  }, u)), u = /* @__PURE__ */ P.createElement(tb.Provider, {
    value: o
  }, /* @__PURE__ */ P.createElement(J6, null, u)), /* @__PURE__ */ Lc.createPortal(u, r);
}
function nb() {
  let e = le(tb), t = e == null ? void 0 : e.setContain;
  Re(() => {
    t == null || t(!0);
  }, [
    t
  ]);
}
function g7(e, t, r) {
  let { overlayProps: n, underlayProps: i } = v0({
    ...e,
    isOpen: t.isOpen,
    onClose: t.close
  }, r);
  return g0({
    isDisabled: !t.isOpen
  }), nb(), oe(() => {
    if (t.isOpen) return Ud([
      r.current
    ]);
  }, [
    t.isOpen,
    r
  ]), {
    modalProps: ve(n),
    underlayProps: i
  };
}
const iu = /* @__PURE__ */ new WeakMap();
function b7(e) {
  return typeof e == "string" ? e.replace(/\s*/g, "") : "" + e;
}
function ib(e, t) {
  let r = iu.get(e);
  if (!r) throw new Error("Unknown list");
  return `${r.id}-option-${b7(t)}`;
}
function hc(e) {
  return _o() ? e.altKey : e.ctrlKey;
}
function Nn(e) {
  return gr() ? e.metaKey : e.ctrlKey;
}
const $7 = 1e3;
function ab(e) {
  let { keyboardDelegate: t, selectionManager: r, onTypeSelect: n } = e, i = q({
    search: "",
    timeout: null
  }).current, a = (o) => {
    let s = x7(o.key);
    if (!s || o.ctrlKey || o.metaKey || !o.currentTarget.contains(o.target)) return;
    s === " " && i.search.trim().length > 0 && (o.preventDefault(), "continuePropagation" in o || o.stopPropagation()), i.search += s;
    let u = t.getKeyForSearch(i.search, r.focusedKey);
    u == null && (u = t.getKeyForSearch(i.search)), u != null && (r.setFocusedKey(u), n && n(u)), clearTimeout(i.timeout), i.timeout = setTimeout(() => {
      i.search = "";
    }, $7);
  };
  return {
    typeSelectProps: {
      // Using a capturing listener to catch the keydown event before
      // other hooks in order to handle the Spacebar event.
      onKeyDownCapture: t.getKeyForSearch ? a : null
    }
  };
}
function x7(e) {
  return e.length === 1 || !/^[A-Z]/i.test(e) ? e : "";
}
function ob(e) {
  let { selectionManager: t, keyboardDelegate: r, ref: n, autoFocus: i = !1, shouldFocusWrap: a = !1, disallowEmptySelection: o = !1, disallowSelectAll: s = !1, selectOnFocus: u = t.selectionBehavior === "replace", disallowTypeAhead: l = !1, shouldUseVirtualFocus: c, allowsTabNavigation: d = !1, isVirtualized: f, scrollRef: h = n, linkBehavior: p = "action" } = e, { direction: v } = st(), g = Hs(), $ = (w) => {
    if (w.altKey && w.key === "Tab" && w.preventDefault(), !n.current.contains(w.target)) return;
    const E = (z, ae) => {
      if (z != null) {
        if (t.isLink(z) && p === "selection" && u && !hc(w)) {
          ex(() => {
            t.setFocusedKey(z, ae);
          });
          let ne = h.current.querySelector(`[data-key="${CSS.escape(z.toString())}"]`), ye = t.getItemProps(z);
          g.open(ne, w, ye.href, ye.routerOptions);
          return;
        }
        if (t.setFocusedKey(z, ae), t.isLink(z) && p === "override") return;
        w.shiftKey && t.selectionMode === "multiple" ? t.extendSelection(z) : u && !hc(w) && t.replaceSelection(z);
      }
    };
    switch (w.key) {
      case "ArrowDown":
        if (r.getKeyBelow) {
          var k, C;
          w.preventDefault();
          let z = t.focusedKey != null ? r.getKeyBelow(t.focusedKey) : (k = r.getFirstKey) === null || k === void 0 ? void 0 : k.call(r);
          z == null && a && (z = (C = r.getFirstKey) === null || C === void 0 ? void 0 : C.call(r, t.focusedKey)), E(z);
        }
        break;
      case "ArrowUp":
        if (r.getKeyAbove) {
          var A, L;
          w.preventDefault();
          let z = t.focusedKey != null ? r.getKeyAbove(t.focusedKey) : (A = r.getLastKey) === null || A === void 0 ? void 0 : A.call(r);
          z == null && a && (z = (L = r.getLastKey) === null || L === void 0 ? void 0 : L.call(r, t.focusedKey)), E(z);
        }
        break;
      case "ArrowLeft":
        if (r.getKeyLeftOf) {
          var I, x;
          w.preventDefault();
          let z = r.getKeyLeftOf(t.focusedKey);
          z == null && a && (z = v === "rtl" ? (I = r.getFirstKey) === null || I === void 0 ? void 0 : I.call(r, t.focusedKey) : (x = r.getLastKey) === null || x === void 0 ? void 0 : x.call(r, t.focusedKey)), E(z, v === "rtl" ? "first" : "last");
        }
        break;
      case "ArrowRight":
        if (r.getKeyRightOf) {
          var U, K;
          w.preventDefault();
          let z = r.getKeyRightOf(t.focusedKey);
          z == null && a && (z = v === "rtl" ? (U = r.getLastKey) === null || U === void 0 ? void 0 : U.call(r, t.focusedKey) : (K = r.getFirstKey) === null || K === void 0 ? void 0 : K.call(r, t.focusedKey)), E(z, v === "rtl" ? "last" : "first");
        }
        break;
      case "Home":
        if (r.getFirstKey) {
          w.preventDefault();
          let z = r.getFirstKey(t.focusedKey, Nn(w));
          t.setFocusedKey(z), Nn(w) && w.shiftKey && t.selectionMode === "multiple" ? t.extendSelection(z) : u && t.replaceSelection(z);
        }
        break;
      case "End":
        if (r.getLastKey) {
          w.preventDefault();
          let z = r.getLastKey(t.focusedKey, Nn(w));
          t.setFocusedKey(z), Nn(w) && w.shiftKey && t.selectionMode === "multiple" ? t.extendSelection(z) : u && t.replaceSelection(z);
        }
        break;
      case "PageDown":
        if (r.getKeyPageBelow) {
          w.preventDefault();
          let z = r.getKeyPageBelow(t.focusedKey);
          E(z);
        }
        break;
      case "PageUp":
        if (r.getKeyPageAbove) {
          w.preventDefault();
          let z = r.getKeyPageAbove(t.focusedKey);
          E(z);
        }
        break;
      case "a":
        Nn(w) && t.selectionMode === "multiple" && s !== !0 && (w.preventDefault(), t.selectAll());
        break;
      case "Escape":
        !o && t.selectedKeys.size !== 0 && (w.stopPropagation(), w.preventDefault(), t.clearSelection());
        break;
      case "Tab":
        if (!d) {
          if (w.shiftKey) n.current.focus();
          else {
            let z = bt(n.current, {
              tabbable: !0
            }), ae, ne;
            do
              ne = z.lastChild(), ne && (ae = ne);
            while (ne);
            ae && !ae.contains(document.activeElement) && Wt(ae);
          }
          break;
        }
    }
  }, m = q({
    top: 0,
    left: 0
  });
  Jn(h, "scroll", f ? null : () => {
    m.current = {
      top: h.current.scrollTop,
      left: h.current.scrollLeft
    };
  });
  let b = (w) => {
    if (t.isFocused) {
      w.currentTarget.contains(w.target) || t.setFocused(!1);
      return;
    }
    if (w.currentTarget.contains(w.target)) {
      if (t.setFocused(!0), t.focusedKey == null) {
        let C = (L) => {
          L != null && (t.setFocusedKey(L), u && t.replaceSelection(L));
        }, A = w.relatedTarget;
        var E, k;
        A && w.currentTarget.compareDocumentPosition(A) & Node.DOCUMENT_POSITION_FOLLOWING ? C((E = t.lastSelectedKey) !== null && E !== void 0 ? E : r.getLastKey()) : C((k = t.firstSelectedKey) !== null && k !== void 0 ? k : r.getFirstKey());
      } else f || (h.current.scrollTop = m.current.top, h.current.scrollLeft = m.current.left);
      if (!f && t.focusedKey != null) {
        let C = h.current.querySelector(`[data-key="${CSS.escape(t.focusedKey.toString())}"]`);
        C && (C.contains(document.activeElement) || Wt(C), Yo() === "keyboard" && Wo(C, {
          containingElement: n.current
        }));
      }
    }
  }, D = (w) => {
    w.currentTarget.contains(w.relatedTarget) || t.setFocused(!1);
  };
  const S = q(i);
  oe(() => {
    if (S.current) {
      let w = null;
      i === "first" && (w = r.getFirstKey()), i === "last" && (w = r.getLastKey());
      let E = t.selectedKeys;
      if (E.size) {
        for (let k of E) if (t.canSelectItem(k)) {
          w = k;
          break;
        }
      }
      t.setFocused(!0), t.setFocusedKey(w), w == null && !c && yn(n.current);
    }
  }, []);
  let T = q(t.focusedKey);
  oe(() => {
    let w = Yo();
    if (t.isFocused && t.focusedKey != null && (h != null && h.current)) {
      let E = h.current.querySelector(`[data-key="${CSS.escape(t.focusedKey.toString())}"]`);
      E && (w === "keyboard" || S.current) && (f || Xv(h.current, E), w !== "virtual" && Wo(E, {
        containingElement: n.current
      }));
    }
    t.isFocused && t.focusedKey == null && T.current != null && yn(n.current), T.current = t.focusedKey, S.current = !1;
  }, [
    f,
    h,
    t.focusedKey,
    t.isFocused,
    n
  ]);
  let B = {
    onKeyDown: $,
    onFocus: b,
    onBlur: D,
    onMouseDown(w) {
      h.current === w.target && w.preventDefault();
    }
  }, { typeSelectProps: y } = ab({
    keyboardDelegate: r,
    selectionManager: t
  });
  l || (B = ve(y, B));
  let _;
  return c || (_ = t.focusedKey == null ? 0 : -1), {
    collectionProps: {
      ...B,
      tabIndex: _
    }
  };
}
function D7(e) {
  let { selectionManager: t, key: r, ref: n, shouldSelectOnPressUp: i, shouldUseVirtualFocus: a, focus: o, isDisabled: s, onAction: u, allowsDifferentPressOrigin: l, linkBehavior: c = "action" } = e, d = Hs(), f = (x) => {
    if (x.pointerType === "keyboard" && hc(x)) t.toggleSelection(r);
    else {
      if (t.selectionMode === "none") return;
      if (t.isLink(r)) {
        if (c === "selection") {
          let U = t.getItemProps(r);
          d.open(n.current, x, U.href, U.routerOptions), t.setSelectedKeys(t.selectedKeys);
          return;
        } else if (c === "override" || c === "none") return;
      }
      t.selectionMode === "single" ? t.isSelected(r) && !t.disallowEmptySelection ? t.toggleSelection(r) : t.replaceSelection(r) : x && x.shiftKey ? t.extendSelection(r) : t.selectionBehavior === "toggle" || x && (Nn(x) || x.pointerType === "touch" || x.pointerType === "virtual") ? t.toggleSelection(r) : t.replaceSelection(r);
    }
  };
  oe(() => {
    r === t.focusedKey && t.isFocused && !a && (o ? o() : document.activeElement !== n.current && yn(n.current));
  }, [
    n,
    r,
    t.focusedKey,
    t.childFocusStrategy,
    t.isFocused,
    a
  ]), s = s || t.isDisabled(r);
  let h = {};
  !a && !s ? h = {
    tabIndex: r === t.focusedKey ? 0 : -1,
    onFocus(x) {
      x.target === n.current && t.setFocusedKey(r);
    }
  } : s && (h.onMouseDown = (x) => {
    x.preventDefault();
  });
  let p = t.isLink(r) && c === "override", v = t.isLink(r) && c !== "selection" && c !== "none", g = !s && t.canSelectItem(r) && !p, $ = (u || v) && !s, m = $ && (t.selectionBehavior === "replace" ? !g : !g || t.isEmpty), b = $ && g && t.selectionBehavior === "replace", D = m || b, S = q(null), T = D && g, B = q(!1), y = q(!1), _ = (x) => {
    if (u && u(), v) {
      let U = t.getItemProps(r);
      d.open(n.current, x, U.href, U.routerOptions);
    }
  }, w = {};
  i ? (w.onPressStart = (x) => {
    S.current = x.pointerType, B.current = T, x.pointerType === "keyboard" && (!D || $p()) && f(x);
  }, l ? (w.onPressUp = m ? null : (x) => {
    x.pointerType !== "keyboard" && g && f(x);
  }, w.onPress = m ? _ : null) : w.onPress = (x) => {
    if (m || b && x.pointerType !== "mouse") {
      if (x.pointerType === "keyboard" && !bp()) return;
      _(x);
    } else x.pointerType !== "keyboard" && g && f(x);
  }) : (w.onPressStart = (x) => {
    S.current = x.pointerType, B.current = T, y.current = m, g && (x.pointerType === "mouse" && !m || x.pointerType === "keyboard" && (!$ || $p())) && f(x);
  }, w.onPress = (x) => {
    (x.pointerType === "touch" || x.pointerType === "pen" || x.pointerType === "virtual" || x.pointerType === "keyboard" && D && bp() || x.pointerType === "mouse" && y.current) && (D ? _(x) : g && f(x));
  }), h["data-key"] = r, w.preventFocusOnPress = a;
  let { pressProps: E, isPressed: k } = Va(w), C = b ? (x) => {
    S.current === "mouse" && (x.stopPropagation(), x.preventDefault(), _(x));
  } : void 0, { longPressProps: A } = cy({
    isDisabled: !T,
    onLongPress(x) {
      x.pointerType === "touch" && (f(x), t.setSelectionBehavior("toggle"));
    }
  }), L = (x) => {
    S.current === "touch" && B.current && x.preventDefault();
  }, I = t.isLink(r) ? (x) => {
    pn.isOpening || x.preventDefault();
  } : void 0;
  return {
    itemProps: ve(h, g || m ? E : {}, T ? A : {}, {
      onDoubleClick: C,
      onDragStartCapture: L,
      onClick: I
    }),
    isPressed: k,
    isSelected: t.isSelected(r),
    isFocused: t.isFocused && t.focusedKey === r,
    isDisabled: s,
    allowsSelection: g,
    hasAction: D
  };
}
function bp() {
  let e = window.event;
  return (e == null ? void 0 : e.key) === "Enter";
}
function $p() {
  let e = window.event;
  return (e == null ? void 0 : e.key) === " " || (e == null ? void 0 : e.code) === "Space";
}
class au {
  isDisabled(t) {
    var r;
    return this.disabledBehavior === "all" && (((r = t.props) === null || r === void 0 ? void 0 : r.isDisabled) || this.disabledKeys.has(t.key));
  }
  getNextKey(t) {
    for (t = this.collection.getKeyAfter(t); t != null; ) {
      let r = this.collection.getItem(t);
      if (r.type === "item" && !this.isDisabled(r)) return t;
      t = this.collection.getKeyAfter(t);
    }
    return null;
  }
  getPreviousKey(t) {
    for (t = this.collection.getKeyBefore(t); t != null; ) {
      let r = this.collection.getItem(t);
      if (r.type === "item" && !this.isDisabled(r)) return t;
      t = this.collection.getKeyBefore(t);
    }
    return null;
  }
  findKey(t, r, n) {
    let i = this.getItem(t);
    if (!i) return null;
    let a = i.getBoundingClientRect();
    do
      t = r(t), i = this.getItem(t);
    while (i && n(a, i.getBoundingClientRect()));
    return t;
  }
  isSameRow(t, r) {
    return t.top === r.top || t.left !== r.left;
  }
  isSameColumn(t, r) {
    return t.left === r.left || t.top !== r.top;
  }
  getKeyBelow(t) {
    return this.layout === "grid" && this.orientation === "vertical" ? this.findKey(t, (r) => this.getNextKey(r), this.isSameRow) : this.getNextKey(t);
  }
  getKeyAbove(t) {
    return this.layout === "grid" && this.orientation === "vertical" ? this.findKey(t, (r) => this.getPreviousKey(r), this.isSameRow) : this.getPreviousKey(t);
  }
  getNextColumn(t, r) {
    return r ? this.getPreviousKey(t) : this.getNextKey(t);
  }
  getKeyRightOf(t) {
    return this.layout === "grid" ? this.orientation === "vertical" ? this.getNextColumn(t, this.direction === "rtl") : this.findKey(t, (r) => this.getNextColumn(r, this.direction === "rtl"), this.isSameColumn) : this.orientation === "horizontal" ? this.getNextColumn(t, this.direction === "rtl") : null;
  }
  getKeyLeftOf(t) {
    return this.layout === "grid" ? this.orientation === "vertical" ? this.getNextColumn(t, this.direction === "ltr") : this.findKey(t, (r) => this.getNextColumn(r, this.direction === "ltr"), this.isSameColumn) : this.orientation === "horizontal" ? this.getNextColumn(t, this.direction === "ltr") : null;
  }
  getFirstKey() {
    let t = this.collection.getFirstKey();
    for (; t != null; ) {
      let r = this.collection.getItem(t);
      if ((r == null ? void 0 : r.type) === "item" && !this.isDisabled(r)) return t;
      t = this.collection.getKeyAfter(t);
    }
    return null;
  }
  getLastKey() {
    let t = this.collection.getLastKey();
    for (; t != null; ) {
      let r = this.collection.getItem(t);
      if (r.type === "item" && !this.isDisabled(r)) return t;
      t = this.collection.getKeyBefore(t);
    }
    return null;
  }
  getItem(t) {
    return t !== null ? this.ref.current.querySelector(`[data-key="${CSS.escape(t.toString())}"]`) : null;
  }
  getKeyPageAbove(t) {
    let r = this.ref.current, n = this.getItem(t);
    if (!n) return null;
    if (!ga(r)) return this.getFirstKey();
    let i = r.getBoundingClientRect(), a = n.getBoundingClientRect();
    if (this.orientation === "horizontal") {
      let o = i.x - r.scrollLeft, s = Math.max(0, a.x - o + a.width - i.width);
      for (; n && a.x - o > s; )
        t = this.getKeyAbove(t), n = t == null ? null : this.getItem(t), a = n == null ? void 0 : n.getBoundingClientRect();
    } else {
      let o = i.y - r.scrollTop, s = Math.max(0, a.y - o + a.height - i.height);
      for (; n && a.y - o > s; )
        t = this.getKeyAbove(t), n = t == null ? null : this.getItem(t), a = n == null ? void 0 : n.getBoundingClientRect();
    }
    return t ?? this.getFirstKey();
  }
  getKeyPageBelow(t) {
    let r = this.ref.current, n = this.getItem(t);
    if (!n) return null;
    if (!ga(r)) return this.getLastKey();
    let i = r.getBoundingClientRect(), a = n.getBoundingClientRect();
    if (this.orientation === "horizontal") {
      let o = i.x - r.scrollLeft, s = Math.min(r.scrollWidth, a.x - o - a.width + i.width);
      for (; n && a.x - o < s; )
        t = this.getKeyBelow(t), n = t == null ? null : this.getItem(t), a = n == null ? void 0 : n.getBoundingClientRect();
    } else {
      let o = i.y - r.scrollTop, s = Math.min(r.scrollHeight, a.y - o - a.height + i.height);
      for (; n && a.y - o < s; )
        t = this.getKeyBelow(t), n = t == null ? null : this.getItem(t), a = n == null ? void 0 : n.getBoundingClientRect();
    }
    return t ?? this.getLastKey();
  }
  getKeyForSearch(t, r) {
    if (!this.collator) return null;
    let n = this.collection, i = r || this.getFirstKey();
    for (; i != null; ) {
      let a = n.getItem(i), o = a.textValue.slice(0, t.length);
      if (a.textValue && this.collator.compare(o, t) === 0) return i;
      i = this.getKeyBelow(i);
    }
    return null;
  }
  constructor(...t) {
    if (t.length === 1) {
      let r = t[0];
      this.collection = r.collection, this.ref = r.ref, this.collator = r.collator, this.disabledKeys = r.disabledKeys || /* @__PURE__ */ new Set(), this.disabledBehavior = r.disabledBehavior || "all", this.orientation = r.orientation, this.direction = r.direction, this.layout = r.layout || "stack";
    } else
      this.collection = t[0], this.disabledKeys = t[1], this.ref = t[2], this.collator = t[3], this.layout = "stack", this.orientation = "vertical", this.disabledBehavior = "all";
    this.layout === "stack" && this.orientation === "vertical" && (this.getKeyLeftOf = void 0, this.getKeyRightOf = void 0);
  }
}
function E7(e) {
  let { selectionManager: t, collection: r, disabledKeys: n, ref: i, keyboardDelegate: a } = e, o = tu({
    usage: "search",
    sensitivity: "base"
  }), s = t.disabledBehavior, u = G(() => a || new au({
    collection: r,
    disabledKeys: n,
    disabledBehavior: s,
    ref: i,
    collator: o
  }), [
    a,
    r,
    n,
    i,
    o,
    s
  ]), { collectionProps: l } = ob({
    ...e,
    ref: i,
    selectionManager: t,
    keyboardDelegate: u
  });
  return {
    listProps: l
  };
}
function w7(e, t, r) {
  let n = _e(e, {
    labelable: !0
  }), i = e.selectionBehavior || "toggle", a = e.linkBehavior || (i === "replace" ? "action" : "override");
  i === "toggle" && a === "action" && (a = "override");
  let { listProps: o } = E7({
    ...e,
    ref: r,
    selectionManager: t.selectionManager,
    collection: t.collection,
    disabledKeys: t.disabledKeys,
    linkBehavior: a
  }), { focusWithinProps: s } = $i({
    onFocusWithin: e.onFocus,
    onBlurWithin: e.onBlur,
    onFocusWithinChange: e.onFocusChange
  }), u = kt(e.id);
  iu.set(t, {
    id: u,
    shouldUseVirtualFocus: e.shouldUseVirtualFocus,
    shouldSelectOnPressUp: e.shouldSelectOnPressUp,
    shouldFocusOnHover: e.shouldFocusOnHover,
    isVirtualized: e.isVirtualized,
    onAction: e.onAction,
    linkBehavior: a
  });
  let { labelProps: l, fieldProps: c } = Fg({
    ...e,
    id: u,
    // listbox is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span"
  });
  return {
    labelProps: l,
    listBoxProps: ve(n, s, t.selectionManager.selectionMode === "multiple" ? {
      "aria-multiselectable": "true"
    } : {}, {
      role: "listbox",
      ...ve(c, o)
    })
  };
}
class C7 {
  build(t, r) {
    return this.context = r, xp(() => this.iterateCollection(t));
  }
  *iterateCollection(t) {
    let { children: r, items: n } = t;
    if (typeof r == "function") {
      if (!n) throw new Error("props.children was a function but props.items is missing");
      for (let i of t.items) yield* this.getFullNode({
        value: i
      }, {
        renderer: r
      });
    } else {
      let i = [];
      P.Children.forEach(r, (o) => {
        i.push(o);
      });
      let a = 0;
      for (let o of i) {
        let s = this.getFullNode({
          element: o,
          index: a
        }, {});
        for (let u of s)
          a++, yield u;
      }
    }
  }
  getKey(t, r, n, i) {
    if (t.key != null) return t.key;
    if (r.type === "cell" && r.key != null) return `${i}${r.key}`;
    let a = r.value;
    if (a != null) {
      var o;
      let s = (o = a.key) !== null && o !== void 0 ? o : a.id;
      if (s == null) throw new Error("No key found for item");
      return s;
    }
    return i ? `${i}.${r.index}` : `$.${r.index}`;
  }
  getChildState(t, r) {
    return {
      renderer: r.renderer || t.renderer
    };
  }
  *getFullNode(t, r, n, i) {
    let a = t.element;
    if (!a && t.value && r && r.renderer) {
      let u = this.cache.get(t.value);
      if (u && (!u.shouldInvalidate || !u.shouldInvalidate(this.context))) {
        u.index = t.index, u.parentKey = i ? i.key : null, yield u;
        return;
      }
      a = r.renderer(t.value);
    }
    if (P.isValidElement(a)) {
      let u = a.type;
      if (typeof u != "function" && typeof u.getCollectionNode != "function") {
        let f = typeof a.type == "function" ? a.type.name : a.type;
        throw new Error(`Unknown element <${f}> in collection.`);
      }
      let l = u.getCollectionNode(a.props, this.context), c = t.index, d = l.next();
      for (; !d.done && d.value; ) {
        let f = d.value;
        t.index = c;
        let h = f.key;
        h || (h = f.element ? null : this.getKey(a, t, r, n));
        let v = [
          ...this.getFullNode({
            ...f,
            key: h,
            index: c,
            wrapper: S7(t.wrapper, f.wrapper)
          }, this.getChildState(r, f), n ? `${n}${a.key}` : a.key, i)
        ];
        for (let g of v) {
          if (g.value = f.value || t.value, g.value && this.cache.set(g.value, g), t.type && g.type !== t.type) throw new Error(`Unsupported type <${nl(g.type)}> in <${nl(i.type)}>. Only <${nl(t.type)}> is supported.`);
          c++, yield g;
        }
        d = l.next(v);
      }
      return;
    }
    if (t.key == null) return;
    let o = this, s = {
      type: t.type,
      props: t.props,
      key: t.key,
      parentKey: i ? i.key : null,
      value: t.value,
      level: i ? i.level + 1 : 0,
      index: t.index,
      rendered: t.rendered,
      textValue: t.textValue,
      "aria-label": t["aria-label"],
      wrapper: t.wrapper,
      shouldInvalidate: t.shouldInvalidate,
      hasChildNodes: t.hasChildNodes,
      childNodes: xp(function* () {
        if (!t.hasChildNodes) return;
        let u = 0;
        for (let l of t.childNodes()) {
          l.key != null && (l.key = `${s.key}${l.key}`), l.index = u;
          let c = o.getFullNode(l, o.getChildState(r, l), s.key, s);
          for (let d of c)
            u++, yield d;
        }
      })
    };
    yield s;
  }
  constructor() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
}
function xp(e) {
  let t = [], r = null;
  return {
    *[Symbol.iterator]() {
      for (let n of t) yield n;
      r || (r = e());
      for (let n of r)
        t.push(n), yield n;
    }
  };
}
function S7(e, t) {
  if (e && t) return (r) => e(t(r));
  if (e) return e;
  if (t) return t;
}
function nl(e) {
  return e[0].toUpperCase() + e.slice(1);
}
function k7(e, t, r) {
  let n = G(() => new C7(), []), { children: i, items: a, collection: o } = e;
  return G(() => {
    if (o) return o;
    let u = n.build({
      children: i,
      items: a
    }, r);
    return t(u);
  }, [
    n,
    i,
    a,
    o,
    r,
    t
  ]);
}
function ou(e, t) {
  return typeof t.getChildren == "function" ? t.getChildren(e.key) : e.childNodes;
}
function P7(e) {
  return T7(e);
}
function T7(e, t) {
  for (let r of e)
    return r;
}
function il(e, t, r) {
  if (t.parentKey === r.parentKey) return t.index - r.index;
  let n = [
    ...Dp(e, t),
    t
  ], i = [
    ...Dp(e, r),
    r
  ], a = n.slice(0, i.length).findIndex((o, s) => o !== i[s]);
  return a !== -1 ? (t = n[a], r = i[a], t.index - r.index) : n.findIndex((o) => o === r) >= 0 ? 1 : (i.findIndex((o) => o === t) >= 0, -1);
}
function Dp(e, t) {
  let r = [];
  for (; (t == null ? void 0 : t.parentKey) != null; )
    t = e.getItem(t.parentKey), r.unshift(t);
  return r;
}
const Ep = /* @__PURE__ */ new WeakMap();
function sb(e) {
  let t = Ep.get(e);
  if (t != null) return t;
  t = 0;
  let r = (n) => {
    for (let i of n) i.type === "section" ? r(ou(i, e)) : t++;
  };
  return r(e), Ep.set(e, t), t;
}
function A7(e, t, r) {
  var n, i;
  let { key: a } = e, o = iu.get(t);
  var s;
  let u = (s = e.isDisabled) !== null && s !== void 0 ? s : t.selectionManager.isDisabled(a);
  var l;
  let c = (l = e.isSelected) !== null && l !== void 0 ? l : t.selectionManager.isSelected(a);
  var d;
  let f = (d = e.shouldSelectOnPressUp) !== null && d !== void 0 ? d : o == null ? void 0 : o.shouldSelectOnPressUp;
  var h;
  let p = (h = e.shouldFocusOnHover) !== null && h !== void 0 ? h : o == null ? void 0 : o.shouldFocusOnHover;
  var v;
  let g = (v = e.shouldUseVirtualFocus) !== null && v !== void 0 ? v : o == null ? void 0 : o.shouldUseVirtualFocus;
  var $;
  let m = ($ = e.isVirtualized) !== null && $ !== void 0 ? $ : o == null ? void 0 : o.isVirtualized, b = di(), D = di(), S = {
    role: "option",
    "aria-disabled": u || void 0,
    "aria-selected": t.selectionManager.selectionMode !== "none" ? c : void 0
  };
  gr() && Dd() || (S["aria-label"] = e["aria-label"], S["aria-labelledby"] = b, S["aria-describedby"] = D);
  let T = t.collection.getItem(a);
  if (m) {
    let I = Number(T == null ? void 0 : T.index);
    S["aria-posinset"] = Number.isNaN(I) ? void 0 : I + 1, S["aria-setsize"] = sb(t.collection);
  }
  let B = o != null && o.onAction ? () => {
    var I;
    return o == null || (I = o.onAction) === null || I === void 0 ? void 0 : I.call(o, a);
  } : void 0, { itemProps: y, isPressed: _, isFocused: w, hasAction: E, allowsSelection: k } = D7({
    selectionManager: t.selectionManager,
    key: a,
    ref: r,
    shouldSelectOnPressUp: f,
    allowsDifferentPressOrigin: f && p,
    isVirtualized: m,
    shouldUseVirtualFocus: g,
    isDisabled: u,
    onAction: B || !(T == null || (n = T.props) === null || n === void 0) && n.onAction ? Hr(T == null || (i = T.props) === null || i === void 0 ? void 0 : i.onAction, B) : void 0,
    linkBehavior: o == null ? void 0 : o.linkBehavior
  }), { hoverProps: C } = Sn({
    isDisabled: u || !p,
    onHoverStart() {
      Zo() || (t.selectionManager.setFocused(!0), t.selectionManager.setFocusedKey(a));
    }
  }), A = _e(T == null ? void 0 : T.props);
  delete A.id;
  let L = B6(T == null ? void 0 : T.props);
  return {
    optionProps: {
      ...S,
      ...ve(A, y, C, L),
      id: ib(t, a)
    },
    labelProps: {
      id: b
    },
    descriptionProps: {
      id: D
    },
    isFocused: w,
    isFocusVisible: w && Zo(),
    isSelected: c,
    isDisabled: u,
    isPressed: _,
    allowsSelection: k,
    hasAction: E
  };
}
function _7(e) {
  let { heading: t, "aria-label": r } = e, n = kt();
  return {
    itemProps: {
      role: "presentation"
    },
    headingProps: t ? {
      // Techincally, listbox cannot contain headings according to ARIA.
      // We hide the heading from assistive technology, using role="presentation",
      // and only use it as a visual label for the nested group.
      id: n,
      role: "presentation"
    } : {},
    groupProps: {
      role: "group",
      "aria-label": r,
      "aria-labelledby": t ? n : void 0
    }
  };
}
var ub = {};
ub = {
  longPressMessage: "     Alt +    "
};
var lb = {};
lb = {
  longPressMessage: "    Alt+  ,    "
};
var cb = {};
cb = {
  longPressMessage: "Dlouhm stiskem nebo stisknutm klves Alt + ipka dol otevete nabdku"
};
var db = {};
db = {
  longPressMessage: "Langt tryk eller tryk p Alt + pil ned for at bne menuen"
};
var fb = {};
fb = {
  longPressMessage: "Drcken Sie lange oder drcken Sie Alt + Nach-unten, um das Men zu ffnen"
};
var hb = {};
hb = {
  longPressMessage: "    Alt +       "
};
var pb = {};
pb = {
  longPressMessage: "Long press or press Alt + ArrowDown to open menu"
};
var mb = {};
mb = {
  longPressMessage: "Mantenga pulsado o pulse Alt + flecha abajo para abrir el men"
};
var vb = {};
vb = {
  longPressMessage: "Men avamiseks vajutage pikalt vi vajutage klahve Alt + allanool"
};
var yb = {};
yb = {
  longPressMessage: "Avaa valikko painamalla pohjassa tai nppinyhdistelmll Alt + Alanuoli"
};
var gb = {};
gb = {
  longPressMessage: "Appuyez de manire prolonge ou appuyez sur Alt+Flche vers le bas pour ouvrir le menu."
};
var bb = {};
bb = {
  longPressMessage: "     Alt + ArrowDown    "
};
var $b = {};
$b = {
  longPressMessage: "Dugo pritisnite ili pritisnite Alt + strelicu prema dolje za otvaranje izbornika"
};
var xb = {};
xb = {
  longPressMessage: "Nyomja meg hosszan, vagy nyomja meg az Alt + lefele nyl gombot a men megnyitshoz"
};
var Db = {};
Db = {
  longPressMessage: "Premere a lungo o premere Alt + Freccia gi per aprire il menu"
};
var Eb = {};
Eb = {
  longPressMessage: " Alt+"
};
var wb = {};
wb = {
  longPressMessage: "  Alt +     "
};
var Cb = {};
Cb = {
  longPressMessage: "Nordami atidaryti meniu, nuspaud palaikykite arba paspauskite Alt + ArrowDown."
};
var Sb = {};
Sb = {
  longPressMessage: "Lai atvrtu izvlni, turiet nospiestu vai nospiediet taustiu kombinciju Alt + lejupvrst bultia"
};
var kb = {};
kb = {
  longPressMessage: "Langt trykk eller trykk Alt + PilNed for  pne menyen"
};
var Pb = {};
Pb = {
  longPressMessage: "Druk lang op Alt + pijl-omlaag of druk op Alt om het menu te openen"
};
var Tb = {};
Tb = {
  longPressMessage: "Nacinij i przytrzymaj lub nacinij klawisze Alt + Strzaka w d, aby otworzy menu"
};
var Ab = {};
Ab = {
  longPressMessage: "Pressione e segure ou pressione Alt + Seta para baixo para abrir o menu"
};
var _b = {};
_b = {
  longPressMessage: "Prima continuamente ou prima Alt + Seta Para Baixo para abrir o menu"
};
var Fb = {};
Fb = {
  longPressMessage: "Apsai lung sau apsai pe Alt + sgeat n jos pentru a deschide meniul"
};
var Ob = {};
Ob = {
  longPressMessage: "     Alt +  ,   "
};
var Ib = {};
Ib = {
  longPressMessage: "Ponuku otvorte dlhm stlaenm alebo stlaenm klvesu Alt + klvesu so pkou nadol"
};
var Rb = {};
Rb = {
  longPressMessage: "Za odprtje menija pritisnite in drite gumb ali pritisnite Alt+puica navzdol"
};
var Bb = {};
Bb = {
  longPressMessage: "Dugo pritisnite ili pritisnite Alt + strelicu prema dole da otvorite meni"
};
var Mb = {};
Mb = {
  longPressMessage: "Hll nedtryckt eller tryck p Alt + pil nedt fr att ppna menyn"
};
var Nb = {};
Nb = {
  longPressMessage: "Meny amak iin uzun basn veya Alt + Aa Ok tuuna basn"
};
var Lb = {};
Lb = {
  longPressMessage: "      Alt   ,   "
};
var Vb = {};
Vb = {
  longPressMessage: " Alt + "
};
var zb = {};
zb = {
  longPressMessage: " Alt+"
};
var jb = {};
jb = {
  "ar-AE": ub,
  "bg-BG": lb,
  "cs-CZ": cb,
  "da-DK": db,
  "de-DE": fb,
  "el-GR": hb,
  "en-US": pb,
  "es-ES": mb,
  "et-EE": vb,
  "fi-FI": yb,
  "fr-FR": gb,
  "he-IL": bb,
  "hr-HR": $b,
  "hu-HU": xb,
  "it-IT": Db,
  "ja-JP": Eb,
  "ko-KR": wb,
  "lt-LT": Cb,
  "lv-LV": Sb,
  "nb-NO": kb,
  "nl-NL": Pb,
  "pl-PL": Tb,
  "pt-BR": Ab,
  "pt-PT": _b,
  "ro-RO": Fb,
  "ru-RU": Ob,
  "sk-SK": Ib,
  "sl-SI": Rb,
  "sr-SP": Bb,
  "sv-SE": Mb,
  "tr-TR": Nb,
  "uk-UA": Lb,
  "zh-CN": Vb,
  "zh-TW": zb
};
function F7(e) {
  return e && e.__esModule ? e.default : e;
}
function Kb(e, t, r) {
  let { type: n = "menu", isDisabled: i, trigger: a = "press" } = e, o = kt(), { triggerProps: s, overlayProps: u } = y0({
    type: n
  }, t, r), l = (h) => {
    if (!i && !(a === "longPress" && !h.altKey) && r && r.current)
      switch (h.key) {
        case "Enter":
        case " ":
          if (a === "longPress") return;
        case "ArrowDown":
          "continuePropagation" in h || h.stopPropagation(), h.preventDefault(), t.toggle("first");
          break;
        case "ArrowUp":
          "continuePropagation" in h || h.stopPropagation(), h.preventDefault(), t.toggle("last");
          break;
        default:
          "continuePropagation" in h && h.continuePropagation();
      }
  }, c = Ht(F7(jb), "@react-aria/menu"), { longPressProps: d } = cy({
    isDisabled: i || a !== "longPress",
    accessibilityDescription: c.format("longPressMessage"),
    onLongPressStart() {
      t.close();
    },
    onLongPress() {
      t.open("first");
    }
  }), f = {
    onPressStart(h) {
      h.pointerType !== "touch" && h.pointerType !== "keyboard" && !i && t.open(h.pointerType === "virtual" ? "first" : null);
    },
    onPress(h) {
      h.pointerType === "touch" && !i && t.toggle();
    }
  };
  return delete s.onPress, {
    menuTriggerProps: {
      ...s,
      ...a === "press" ? f : d,
      id: o,
      onKeyDown: l
    },
    menuProps: {
      ...u,
      "aria-labelledby": o,
      autoFocus: t.focusStrategy || !0,
      onClose: t.close
    }
  };
}
function Ub(e, t) {
  let { inputElementType: r = "input", isDisabled: n = !1, isRequired: i = !1, isReadOnly: a = !1, type: o = "text", validationBehavior: s = "aria" } = e, [u, l] = tr(e.value, e.defaultValue || "", e.onChange), { focusableProps: c } = py(e, t), d = Ka({
    ...e,
    value: u
  }), { isInvalid: f, validationErrors: h, validationDetails: p } = d.displayValidation, { labelProps: v, fieldProps: g, descriptionProps: $, errorMessageProps: m } = nu({
    ...e,
    isInvalid: f,
    errorMessage: e.errorMessage || h
  }), b = _e(e, {
    labelable: !0
  });
  const D = {
    type: o,
    pattern: e.pattern
  };
  return Cd(t, u, l), Kd(e, d, t), oe(() => {
    if (t.current instanceof It(t.current).HTMLTextAreaElement) {
      let S = t.current;
      Object.defineProperty(S, "defaultValue", {
        get: () => S.value,
        set: () => {
        },
        configurable: !0
      });
    }
  }, [
    t
  ]), {
    labelProps: v,
    inputProps: ve(b, r === "input" && D, {
      disabled: n,
      readOnly: a,
      required: i && s === "native",
      "aria-required": i && s === "aria" || void 0,
      "aria-invalid": f || void 0,
      "aria-errormessage": e["aria-errormessage"],
      "aria-activedescendant": e["aria-activedescendant"],
      "aria-autocomplete": e["aria-autocomplete"],
      "aria-haspopup": e["aria-haspopup"],
      value: u,
      onChange: (S) => l(S.target.value),
      autoComplete: e.autoComplete,
      autoCapitalize: e.autoCapitalize,
      maxLength: e.maxLength,
      minLength: e.minLength,
      name: e.name,
      placeholder: e.placeholder,
      inputMode: e.inputMode,
      // Clipboard events
      onCopy: e.onCopy,
      onCut: e.onCut,
      onPaste: e.onPaste,
      // Composition events
      onCompositionEnd: e.onCompositionEnd,
      onCompositionStart: e.onCompositionStart,
      onCompositionUpdate: e.onCompositionUpdate,
      // Selection events
      onSelect: e.onSelect,
      // Input events
      onBeforeInput: e.onBeforeInput,
      onInput: e.onInput,
      ...c,
      ...g
    }),
    descriptionProps: $,
    errorMessageProps: m,
    isInvalid: f,
    validationErrors: h,
    validationDetails: p
  };
}
function O7(e) {
  return e && e.__esModule ? e.default : e;
}
function I7(e, t) {
  let { buttonRef: r, popoverRef: n, inputRef: i, listBoxRef: a, keyboardDelegate: o, shouldFocusWrap: s, isReadOnly: u, isDisabled: l } = e, c = Ht(O7(h0), "@react-aria/combobox"), { menuTriggerProps: d, menuProps: f } = Kb({
    type: "listbox",
    isDisabled: l || u
  }, t, r);
  iu.set(t, {
    id: f.id
  });
  let h = G(() => o || new au(t.collection, t.disabledKeys, a), [
    o,
    t.collection,
    t.disabledKeys,
    a
  ]), { collectionProps: p } = ob({
    selectionManager: t.selectionManager,
    keyboardDelegate: h,
    disallowTypeAhead: !0,
    disallowEmptySelection: !0,
    shouldFocusWrap: s,
    ref: i,
    // Prevent item scroll behavior from being applied here, should be handled in the user's Popover + ListBox component
    isVirtualized: !0
  }), v = Hs(), g = (V) => {
    switch (V.key) {
      case "Enter":
      case "Tab":
        if (t.isOpen && V.key === "Enter" && V.preventDefault(), t.isOpen && t.selectionManager.focusedKey != null && t.selectionManager.isLink(t.selectionManager.focusedKey)) {
          if (V.key === "Enter") {
            let ie = a.current.querySelector(`[data-key="${CSS.escape(t.selectionManager.focusedKey.toString())}"]`);
            if (ie instanceof HTMLAnchorElement) {
              let we = t.collection.getItem(t.selectionManager.focusedKey);
              v.open(ie, V, we.props.href, we.props.routerOptions);
            }
          }
          t.close();
        } else t.commit();
        break;
      case "Escape":
        (t.selectedKey !== null || t.inputValue === "" || e.allowsCustomValue) && V.continuePropagation(), t.revert();
        break;
      case "ArrowDown":
        t.open("first", "manual");
        break;
      case "ArrowUp":
        t.open("last", "manual");
        break;
      case "ArrowLeft":
      case "ArrowRight":
        t.selectionManager.setFocusedKey(null);
        break;
    }
  }, $ = (V) => {
    var ie;
    let we = (r == null ? void 0 : r.current) && r.current === V.relatedTarget, Ke = (ie = n.current) === null || ie === void 0 ? void 0 : ie.contains(V.relatedTarget);
    we || Ke || (e.onBlur && e.onBlur(V), t.setFocused(!1));
  }, m = (V) => {
    t.isFocused || (e.onFocus && e.onFocus(V), t.setFocused(!0));
  }, { isInvalid: b, validationErrors: D, validationDetails: S } = t.displayValidation, { labelProps: T, inputProps: B, descriptionProps: y, errorMessageProps: _ } = Ub({
    ...e,
    onChange: t.setInputValue,
    onKeyDown: u ? e.onKeyDown : Hr(t.isOpen && p.onKeyDown, g, e.onKeyDown),
    onBlur: $,
    value: t.inputValue,
    onFocus: m,
    autoComplete: "off",
    validate: void 0,
    [wa]: t
  }, i), w = (V) => {
    V.pointerType === "touch" && (i.current.focus(), t.toggle(null, "manual"));
  }, E = (V) => {
    V.pointerType !== "touch" && (i.current.focus(), t.toggle(V.pointerType === "keyboard" || V.pointerType === "virtual" ? "first" : null, "manual"));
  }, k = mn({
    id: d.id,
    "aria-label": c.format("buttonLabel"),
    "aria-labelledby": e["aria-labelledby"] || T.id
  }), C = mn({
    id: f.id,
    "aria-label": c.format("listboxLabel"),
    "aria-labelledby": e["aria-labelledby"] || T.id
  }), A = q(0), L = (V) => {
    if (l || u) return;
    if (V.timeStamp - A.current < 500) {
      V.preventDefault(), i.current.focus();
      return;
    }
    let ie = V.target.getBoundingClientRect(), we = V.changedTouches[0], Ke = Math.ceil(ie.left + 0.5 * ie.width), We = Math.ceil(ie.top + 0.5 * ie.height);
    we.clientX === Ke && we.clientY === We && (V.preventDefault(), i.current.focus(), t.toggle(null, "manual"), A.current = V.timeStamp);
  }, I = t.selectionManager.focusedKey != null && t.isOpen ? t.collection.getItem(t.selectionManager.focusedKey) : void 0;
  var x;
  let U = (x = I == null ? void 0 : I.parentKey) !== null && x !== void 0 ? x : null;
  var K;
  let z = (K = t.selectionManager.focusedKey) !== null && K !== void 0 ? K : null, ae = q(U), ne = q(z);
  oe(() => {
    if (_o() && I != null && z !== ne.current) {
      let V = t.selectionManager.isSelected(z), ie = U != null ? t.collection.getItem(U) : null, we = (ie == null ? void 0 : ie["aria-label"]) || (typeof (ie == null ? void 0 : ie.rendered) == "string" ? ie.rendered : "") || "", Ke = c.format("focusAnnouncement", {
        isGroupChange: ie && U !== ae.current,
        groupTitle: we,
        groupCount: ie ? [
          ...ou(ie, t.collection)
        ].length : 0,
        optionText: I["aria-label"] || I.textValue || "",
        isSelected: V
      });
      ri(Ke);
    }
    ae.current = U, ne.current = z;
  });
  let ye = sb(t.collection), De = q(ye), Fe = q(t.isOpen);
  oe(() => {
    let V = t.isOpen !== Fe.current && (t.selectionManager.focusedKey == null || _o());
    if (t.isOpen && (V || ye !== De.current)) {
      let ie = c.format("countAnnouncement", {
        optionCount: ye
      });
      ri(ie);
    }
    De.current = ye, Fe.current = t.isOpen;
  });
  let Oe = q(t.selectedKey);
  return oe(() => {
    if (_o() && t.isFocused && t.selectedItem && t.selectedKey !== Oe.current) {
      let V = t.selectedItem["aria-label"] || t.selectedItem.textValue || "", ie = c.format("selectedAnnouncement", {
        optionText: V
      });
      ri(ie);
    }
    Oe.current = t.selectedKey;
  }), oe(() => {
    if (t.isOpen) return Ud([
      i.current,
      n.current
    ]);
  }, [
    t.isOpen,
    i,
    n
  ]), {
    labelProps: T,
    buttonProps: {
      ...d,
      ...k,
      excludeFromTabOrder: !0,
      onPress: w,
      onPressStart: E,
      isDisabled: l || u
    },
    inputProps: ve(B, {
      role: "combobox",
      "aria-expanded": d["aria-expanded"],
      "aria-controls": t.isOpen ? f.id : void 0,
      // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)
      "aria-autocomplete": "list",
      "aria-activedescendant": I ? ib(t, I.key) : void 0,
      onTouchEnd: L,
      // This disable's iOS's autocorrect suggestions, since the combo box provides its own suggestions.
      autoCorrect: "off",
      // This disable's the macOS Safari spell check auto corrections.
      spellCheck: "false"
    }),
    listBoxProps: ve(f, C, {
      autoFocus: t.focusStrategy,
      shouldUseVirtualFocus: !0,
      shouldSelectOnPressUp: !0,
      shouldFocusOnHover: !0,
      linkBehavior: "selection"
    }),
    descriptionProps: y,
    errorMessageProps: _,
    isInvalid: b,
    validationErrors: D,
    validationDetails: S
  };
}
var qb = {};
qb = {
  calendar: "",
  day: "",
  dayPeriod: "/",
  endDate: " ",
  era: "",
  hour: "",
  minute: "",
  month: "",
  second: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => `  : ${e.startDate}  ${e.endDate}`,
  selectedTimeDescription: (e) => ` : ${e.time}`,
  startDate: " ",
  timeZoneName: "",
  weekday: "",
  year: ""
};
var Hb = {};
Hb = {
  calendar: "",
  day: "",
  dayPeriod: "../..",
  endDate: " ",
  era: "",
  hour: "",
  minute: "",
  month: "",
  second: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` : ${e.startDate}  ${e.endDate}`,
  selectedTimeDescription: (e) => ` : ${e.time}`,
  startDate: " ",
  timeZoneName: " ",
  weekday: "  ",
  year: ""
};
var Wb = {};
Wb = {
  calendar: "Kalend",
  day: "den",
  dayPeriod: "st dne",
  endDate: "Konen datum",
  era: "letopoet",
  hour: "hodina",
  minute: "minuta",
  month: "msc",
  second: "sekunda",
  selectedDateDescription: (e) => `Vybran datum: ${e.date}`,
  selectedRangeDescription: (e) => `Vybran obdob: ${e.startDate} a ${e.endDate}`,
  selectedTimeDescription: (e) => `Vybran as: ${e.time}`,
  startDate: "Poten datum",
  timeZoneName: "asov psmo",
  weekday: "den v tdnu",
  year: "rok"
};
var Qb = {};
Qb = {
  calendar: "Kalender",
  day: "dag",
  dayPeriod: "AM/PM",
  endDate: "Slutdato",
  era: "ra",
  hour: "time",
  minute: "minut",
  month: "mned",
  second: "sekund",
  selectedDateDescription: (e) => `Valgt dato: ${e.date}`,
  selectedRangeDescription: (e) => `Valgt interval: ${e.startDate} til ${e.endDate}`,
  selectedTimeDescription: (e) => `Valgt tidspunkt: ${e.time}`,
  startDate: "Startdato",
  timeZoneName: "tidszone",
  weekday: "ugedag",
  year: "r"
};
var Gb = {};
Gb = {
  calendar: "Kalender",
  day: "Tag",
  dayPeriod: "Tageshlfte",
  endDate: "Enddatum",
  era: "Epoche",
  hour: "Stunde",
  minute: "Minute",
  month: "Monat",
  second: "Sekunde",
  selectedDateDescription: (e) => `Ausgewhltes Datum: ${e.date}`,
  selectedRangeDescription: (e) => `Ausgewhlter Bereich: ${e.startDate} bis ${e.endDate}`,
  selectedTimeDescription: (e) => `Ausgewhlte Zeit: ${e.time}`,
  startDate: "Anfangsdatum",
  timeZoneName: "Zeitzone",
  weekday: "Wochentag",
  year: "Jahr"
};
var Zb = {};
Zb = {
  calendar: "",
  day: "",
  dayPeriod: "../..",
  endDate: " ",
  era: "",
  hour: "",
  minute: "",
  month: "",
  second: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` : ${e.startDate}  ${e.endDate}`,
  selectedTimeDescription: (e) => ` : ${e.time}`,
  startDate: " ",
  timeZoneName: " ",
  weekday: "",
  year: ""
};
var Yb = {};
Yb = {
  era: "era",
  year: "year",
  month: "month",
  day: "day",
  hour: "hour",
  minute: "minute",
  second: "second",
  dayPeriod: "AM/PM",
  calendar: "Calendar",
  startDate: "Start Date",
  endDate: "End Date",
  weekday: "day of the week",
  timeZoneName: "time zone",
  selectedDateDescription: (e) => `Selected Date: ${e.date}`,
  selectedRangeDescription: (e) => `Selected Range: ${e.startDate} to ${e.endDate}`,
  selectedTimeDescription: (e) => `Selected Time: ${e.time}`
};
var Jb = {};
Jb = {
  calendar: "Calendario",
  day: "da",
  dayPeriod: "a.m./p.m.",
  endDate: "Fecha final",
  era: "era",
  hour: "hora",
  minute: "minuto",
  month: "mes",
  second: "segundo",
  selectedDateDescription: (e) => `Fecha seleccionada: ${e.date}`,
  selectedRangeDescription: (e) => `Rango seleccionado: ${e.startDate} a ${e.endDate}`,
  selectedTimeDescription: (e) => `Hora seleccionada: ${e.time}`,
  startDate: "Fecha de inicio",
  timeZoneName: "zona horaria",
  weekday: "da de la semana",
  year: "ao"
};
var Xb = {};
Xb = {
  calendar: "Kalender",
  day: "pev",
  dayPeriod: "enne/prast lunat",
  endDate: "Lppkuupev",
  era: "ajastu",
  hour: "tund",
  minute: "minut",
  month: "kuu",
  second: "sekund",
  selectedDateDescription: (e) => `Valitud kuupev: ${e.date}`,
  selectedRangeDescription: (e) => `Valitud vahemik: ${e.startDate} kuni ${e.endDate}`,
  selectedTimeDescription: (e) => `Valitud aeg: ${e.time}`,
  startDate: "Alguskuupev",
  timeZoneName: "ajavnd",
  weekday: "ndalapev",
  year: "aasta"
};
var e4 = {};
e4 = {
  calendar: "Kalenteri",
  day: "piv",
  dayPeriod: "vuorokaudenaika",
  endDate: "Pttymispiv",
  era: "aikakausi",
  hour: "tunti",
  minute: "minuutti",
  month: "kuukausi",
  second: "sekunti",
  selectedDateDescription: (e) => `Valittu pivmr: ${e.date}`,
  selectedRangeDescription: (e) => `Valittu aikavli: ${e.startDate}  ${e.endDate}`,
  selectedTimeDescription: (e) => `Valittu aika: ${e.time}`,
  startDate: "Alkamispiv",
  timeZoneName: "aikavyhyke",
  weekday: "viikonpiv",
  year: "vuosi"
};
var t4 = {};
t4 = {
  calendar: "Calendrier",
  day: "jour",
  dayPeriod: "cadran",
  endDate: "Date de fin",
  era: "re",
  hour: "heure",
  minute: "minute",
  month: "mois",
  second: "seconde",
  selectedDateDescription: (e) => `Date slectionne: ${e.date}`,
  selectedRangeDescription: (e) => `Plage slectionne: ${e.startDate} au ${e.endDate}`,
  selectedTimeDescription: (e) => `Heure choisie: ${e.time}`,
  startDate: "Date de dbut",
  timeZoneName: "fuseau horaire",
  weekday: "jour de la semaine",
  year: "anne"
};
var r4 = {};
r4 = {
  calendar: " ",
  day: "",
  dayPeriod: "/",
  endDate: " ",
  era: "",
  hour: "",
  minute: "",
  month: "",
  second: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` : ${e.startDate}  ${e.endDate}`,
  selectedTimeDescription: (e) => ` : ${e.time}`,
  startDate: " ",
  timeZoneName: " ",
  weekday: " ",
  year: ""
};
var n4 = {};
n4 = {
  calendar: "Kalendar",
  day: "dan",
  dayPeriod: "AM/PM",
  endDate: "Datum zavretka",
  era: "era",
  hour: "sat",
  minute: "minuta",
  month: "mjesec",
  second: "sekunda",
  selectedDateDescription: (e) => `Odabrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Odabrani raspon: ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Odabrano vrijeme: ${e.time}`,
  startDate: "Datum poetka",
  timeZoneName: "vremenska zona",
  weekday: "dan u tjednu",
  year: "godina"
};
var i4 = {};
i4 = {
  calendar: "Naptr",
  day: "nap",
  dayPeriod: "napszak",
  endDate: "Befejez dtum",
  era: "ra",
  hour: "ra",
  minute: "perc",
  month: "hnap",
  second: "msodperc",
  selectedDateDescription: (e) => `Kijellt dtum: ${e.date}`,
  selectedRangeDescription: (e) => `Kijellt tartomny: ${e.startDate}${e.endDate}`,
  selectedTimeDescription: (e) => `Kijellt id: ${e.time}`,
  startDate: "Kezd dtum",
  timeZoneName: "idzna",
  weekday: "ht napja",
  year: "v"
};
var a4 = {};
a4 = {
  calendar: "Calendario",
  day: "giorno",
  dayPeriod: "AM/PM",
  endDate: "Data finale",
  era: "era",
  hour: "ora",
  minute: "minuto",
  month: "mese",
  second: "secondo",
  selectedDateDescription: (e) => `Data selezionata: ${e.date}`,
  selectedRangeDescription: (e) => `Intervallo selezionato: da ${e.startDate} a ${e.endDate}`,
  selectedTimeDescription: (e) => `Ora selezionata: ${e.time}`,
  startDate: "Data iniziale",
  timeZoneName: "fuso orario",
  weekday: "giorno della settimana",
  year: "anno"
};
var o4 = {};
o4 = {
  calendar: "",
  day: "",
  dayPeriod: "/",
  endDate: "",
  era: "",
  hour: "",
  minute: "",
  month: "",
  second: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` : ${e.startDate}  ${e.endDate}`,
  selectedTimeDescription: (e) => ` : ${e.time}`,
  startDate: "",
  timeZoneName: "",
  weekday: "",
  year: ""
};
var s4 = {};
s4 = {
  calendar: "",
  day: "",
  dayPeriod: "/",
  endDate: "",
  era: "",
  hour: "",
  minute: "",
  month: "",
  second: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` : ${e.startDate} ~ ${e.endDate}`,
  selectedTimeDescription: (e) => ` : ${e.time}`,
  startDate: "",
  timeZoneName: "",
  weekday: "",
  year: ""
};
var u4 = {};
u4 = {
  calendar: "Kalendorius",
  day: "diena",
  dayPeriod: "iki piet / po piet",
  endDate: "Pabaigos data",
  era: "era",
  hour: "valanda",
  minute: "minut",
  month: "mnuo",
  second: "sekund",
  selectedDateDescription: (e) => `Pasirinkta data: ${e.date}`,
  selectedRangeDescription: (e) => `Pasirinktas intervalas: nuo ${e.startDate} iki ${e.endDate}`,
  selectedTimeDescription: (e) => `Pasirinktas laikas: ${e.time}`,
  startDate: "Pradios data",
  timeZoneName: "laiko juosta",
  weekday: "savaits diena",
  year: "metai"
};
var l4 = {};
l4 = {
  calendar: "Kalendrs",
  day: "diena",
  dayPeriod: "priekpusdien/pcpusdien",
  endDate: "Beigu datums",
  era: "ra",
  hour: "stundas",
  minute: "mintes",
  month: "mnesis",
  second: "sekundes",
  selectedDateDescription: (e) => `Atlastais datums: ${e.date}`,
  selectedRangeDescription: (e) => `Atlastais diapazons: no ${e.startDate} ldz ${e.endDate}`,
  selectedTimeDescription: (e) => `Atlastais laiks: ${e.time}`,
  startDate: "Skuma datums",
  timeZoneName: "laika josla",
  weekday: "nedas diena",
  year: "gads"
};
var c4 = {};
c4 = {
  calendar: "Kalender",
  day: "dag",
  dayPeriod: "a.m./p.m.",
  endDate: "Sluttdato",
  era: "tidsalder",
  hour: "time",
  minute: "minutt",
  month: "mned",
  second: "sekund",
  selectedDateDescription: (e) => `Valgt dato: ${e.date}`,
  selectedRangeDescription: (e) => `Valgt omrde: ${e.startDate} til ${e.endDate}`,
  selectedTimeDescription: (e) => `Valgt tid: ${e.time}`,
  startDate: "Startdato",
  timeZoneName: "tidssone",
  weekday: "ukedag",
  year: "r"
};
var d4 = {};
d4 = {
  calendar: "Kalender",
  day: "dag",
  dayPeriod: "a.m./p.m.",
  endDate: "Einddatum",
  era: "tijdperk",
  hour: "uur",
  minute: "minuut",
  month: "maand",
  second: "seconde",
  selectedDateDescription: (e) => `Geselecteerde datum: ${e.date}`,
  selectedRangeDescription: (e) => `Geselecteerd bereik: ${e.startDate} tot ${e.endDate}`,
  selectedTimeDescription: (e) => `Geselecteerde tijd: ${e.time}`,
  startDate: "Startdatum",
  timeZoneName: "tijdzone",
  weekday: "dag van de week",
  year: "jaar"
};
var f4 = {};
f4 = {
  calendar: "Kalendarz",
  day: "dzie",
  dayPeriod: "rano / po poudniu / wieczorem",
  endDate: "Data kocowa",
  era: "era",
  hour: "godzina",
  minute: "minuta",
  month: "miesic",
  second: "sekunda",
  selectedDateDescription: (e) => `Wybrana data: ${e.date}`,
  selectedRangeDescription: (e) => `Wybrany zakres: ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Wybrany czas: ${e.time}`,
  startDate: "Data pocztkowa",
  timeZoneName: "strefa czasowa",
  weekday: "dzie tygodnia",
  year: "rok"
};
var h4 = {};
h4 = {
  calendar: "Calendrio",
  day: "dia",
  dayPeriod: "AM/PM",
  endDate: "Data final",
  era: "era",
  hour: "hora",
  minute: "minuto",
  month: "ms",
  second: "segundo",
  selectedDateDescription: (e) => `Data selecionada: ${e.date}`,
  selectedRangeDescription: (e) => `Intervalo selecionado: ${e.startDate} a ${e.endDate}`,
  selectedTimeDescription: (e) => `Hora selecionada: ${e.time}`,
  startDate: "Data inicial",
  timeZoneName: "fuso horrio",
  weekday: "dia da semana",
  year: "ano"
};
var p4 = {};
p4 = {
  calendar: "Calendrio",
  day: "dia",
  dayPeriod: "am/pm",
  endDate: "Data de Trmino",
  era: "era",
  hour: "hora",
  minute: "minuto",
  month: "ms",
  second: "segundo",
  selectedDateDescription: (e) => `Data selecionada: ${e.date}`,
  selectedRangeDescription: (e) => `Intervalo selecionado: ${e.startDate} a ${e.endDate}`,
  selectedTimeDescription: (e) => `Hora selecionada: ${e.time}`,
  startDate: "Data de Incio",
  timeZoneName: "fuso horrio",
  weekday: "dia da semana",
  year: "ano"
};
var m4 = {};
m4 = {
  calendar: "Calendar",
  day: "zi",
  dayPeriod: "a.m/p.m.",
  endDate: "Dat final",
  era: "er",
  hour: "or",
  minute: "minut",
  month: "lun",
  second: "secund",
  selectedDateDescription: (e) => `Dat selectat: ${e.date}`,
  selectedRangeDescription: (e) => `Interval selectat: de la ${e.startDate} pn la ${e.endDate}`,
  selectedTimeDescription: (e) => `Ora selectat: ${e.time}`,
  startDate: "Dat nceput",
  timeZoneName: "fus orar",
  weekday: "ziua din sptmn",
  year: "an"
};
var v4 = {};
v4 = {
  calendar: "",
  day: "",
  dayPeriod: "AM/PM",
  endDate: " ",
  era: "",
  hour: "",
  minute: "",
  month: "",
  second: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` :  ${e.startDate}  ${e.endDate}`,
  selectedTimeDescription: (e) => ` : ${e.time}`,
  startDate: " ",
  timeZoneName: " ",
  weekday: " ",
  year: ""
};
var y4 = {};
y4 = {
  calendar: "Kalendr",
  day: "de",
  dayPeriod: "AM/PM",
  endDate: "Dtum ukonenia",
  era: "letopoet",
  hour: "hodina",
  minute: "minta",
  month: "mesiac",
  second: "sekunda",
  selectedDateDescription: (e) => `Vybrat dtum: ${e.date}`,
  selectedRangeDescription: (e) => `Vybrat rozsah: od ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Vybrat as: ${e.time}`,
  startDate: "Dtum zaatia",
  timeZoneName: "asov psmo",
  weekday: "de tda",
  year: "rok"
};
var g4 = {};
g4 = {
  calendar: "Koledar",
  day: "dan",
  dayPeriod: "dop/pop",
  endDate: "Datum konca",
  era: "doba",
  hour: "ura",
  minute: "minuta",
  month: "mesec",
  second: "sekunda",
  selectedDateDescription: (e) => `Izbrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Izbrano obmoje: ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Izbrani as: ${e.time}`,
  startDate: "Datum zaetka",
  timeZoneName: "asovni pas",
  weekday: "dan v tednu",
  year: "leto"
};
var b4 = {};
b4 = {
  calendar: "Kalendar",
  day: "",
  dayPeriod: " / ",
  endDate: "Datum zavretka",
  era: "",
  hour: "",
  minute: "",
  month: "",
  second: "",
  selectedDateDescription: (e) => `Izabrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Izabrani opseg: od ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Izabrano vreme: ${e.time}`,
  startDate: "Datum poetka",
  timeZoneName: " ",
  weekday: "  ",
  year: ""
};
var $4 = {};
$4 = {
  calendar: "Kalender",
  day: "dag",
  dayPeriod: "fm/em",
  endDate: "Slutdatum",
  era: "era",
  hour: "timme",
  minute: "minut",
  month: "mnad",
  second: "sekund",
  selectedDateDescription: (e) => `Valt datum: ${e.date}`,
  selectedRangeDescription: (e) => `Valt intervall: ${e.startDate} till ${e.endDate}`,
  selectedTimeDescription: (e) => `Vald tid: ${e.time}`,
  startDate: "Startdatum",
  timeZoneName: "tidszon",
  weekday: "veckodag",
  year: "r"
};
var x4 = {};
x4 = {
  calendar: "Takvim",
  day: "gn",
  dayPeriod: "/S",
  endDate: "Biti Tarihi",
  era: "a",
  hour: "saat",
  minute: "dakika",
  month: "ay",
  second: "saniye",
  selectedDateDescription: (e) => `Seilen Tarih: ${e.date}`,
  selectedRangeDescription: (e) => `Seilen Aralk: ${e.startDate} - ${e.endDate}`,
  selectedTimeDescription: (e) => `Seilen Zaman: ${e.time}`,
  startDate: "Balang Tarihi",
  timeZoneName: "saat dilimi",
  weekday: "haftann gn",
  year: "yl"
};
var D4 = {};
D4 = {
  calendar: "",
  day: "",
  dayPeriod: "/",
  endDate: " ",
  era: "",
  hour: "",
  minute: "",
  month: "",
  second: "",
  selectedDateDescription: (e) => ` : ${e.date}`,
  selectedRangeDescription: (e) => ` : ${e.startDate}  ${e.endDate}`,
  selectedTimeDescription: (e) => ` : ${e.time}`,
  startDate: " ",
  timeZoneName: " ",
  weekday: " ",
  year: ""
};
var E4 = {};
E4 = {
  calendar: "",
  day: "",
  dayPeriod: "/",
  endDate: "",
  era: "",
  hour: "",
  minute: "",
  month: "",
  second: "",
  selectedDateDescription: (e) => `${e.date}`,
  selectedRangeDescription: (e) => `${e.startDate}  ${e.endDate}`,
  selectedTimeDescription: (e) => `${e.time}`,
  startDate: "",
  timeZoneName: "",
  weekday: "",
  year: ""
};
var w4 = {};
w4 = {
  calendar: "",
  day: "",
  dayPeriod: "/",
  endDate: "",
  era: "",
  hour: "",
  minute: "",
  month: "",
  second: "",
  selectedDateDescription: (e) => `${e.date}`,
  selectedRangeDescription: (e) => `${e.startDate}  ${e.endDate}`,
  selectedTimeDescription: (e) => `${e.time}`,
  startDate: "",
  timeZoneName: "",
  weekday: "",
  year: ""
};
var su = {};
su = {
  "ar-AE": qb,
  "bg-BG": Hb,
  "cs-CZ": Wb,
  "da-DK": Qb,
  "de-DE": Gb,
  "el-GR": Zb,
  "en-US": Yb,
  "es-ES": Jb,
  "et-EE": Xb,
  "fi-FI": e4,
  "fr-FR": t4,
  "he-IL": r4,
  "hr-HR": n4,
  "hu-HU": i4,
  "it-IT": a4,
  "ja-JP": o4,
  "ko-KR": s4,
  "lt-LT": u4,
  "lv-LV": l4,
  "nb-NO": c4,
  "nl-NL": d4,
  "pl-PL": f4,
  "pt-BR": h4,
  "pt-PT": p4,
  "ro-RO": m4,
  "ru-RU": v4,
  "sk-SK": y4,
  "sl-SI": g4,
  "sr-SP": b4,
  "sv-SE": $4,
  "tr-TR": x4,
  "uk-UA": D4,
  "zh-CN": E4,
  "zh-TW": w4
};
function C4(e, t, r) {
  let { direction: n } = st(), i = G(() => Pd(t), [
    t
  ]), a = (u) => {
    if (u.currentTarget.contains(u.target) && (u.altKey && (u.key === "ArrowDown" || u.key === "ArrowUp") && "setOpen" in e && (u.preventDefault(), u.stopPropagation(), e.setOpen(!0)), !r))
      switch (u.key) {
        case "ArrowLeft":
          u.preventDefault(), u.stopPropagation(), n === "rtl" ? i.focusNext() : i.focusPrevious();
          break;
        case "ArrowRight":
          u.preventDefault(), u.stopPropagation(), n === "rtl" ? i.focusPrevious() : i.focusNext();
          break;
      }
  }, o = () => {
    var u;
    let l = (u = window.event) === null || u === void 0 ? void 0 : u.target, c = bt(t.current, {
      tabbable: !0
    });
    if (l && (c.currentNode = l, l = c.previousNode()), !l) {
      let d;
      do
        d = c.lastChild(), d && (l = d);
      while (d);
    }
    for (; l != null && l.hasAttribute("data-placeholder"); ) {
      let d = c.previousNode();
      if (d && d.hasAttribute("data-placeholder")) l = d;
      else break;
    }
    l && l.focus();
  }, { pressProps: s } = Va({
    preventFocusOnPress: !0,
    allowTextSelectionOnPress: !0,
    onPressStart(u) {
      u.pointerType === "mouse" && o();
    },
    onPress(u) {
      u.pointerType !== "mouse" && o();
    }
  });
  return ve(s, {
    onKeyDown: a
  });
}
function R7(e) {
  return e && e.__esModule ? e.default : e;
}
const S4 = /* @__PURE__ */ new WeakMap(), Bo = "__role_" + Date.now(), k4 = "__focusManager_" + Date.now();
function P4(e, t, r) {
  var n;
  let { isInvalid: i, validationErrors: a, validationDetails: o } = t.displayValidation, { labelProps: s, fieldProps: u, descriptionProps: l, errorMessageProps: c } = nu({
    ...e,
    labelElementType: "span",
    isInvalid: i,
    errorMessage: e.errorMessage || a
  }), d = q(null), { focusWithinProps: f } = $i({
    ...e,
    onFocusWithin(w) {
      var E;
      d.current = t.value, (E = e.onFocus) === null || E === void 0 || E.call(e, w);
    },
    onBlurWithin: (w) => {
      var E;
      t.confirmPlaceholder(), t.value !== d.current && t.commitValidation(), (E = e.onBlur) === null || E === void 0 || E.call(e, w);
    },
    onFocusWithinChange: e.onFocusChange
  }), h = Ht(R7(su), "@react-aria/datepicker"), p = t.maxGranularity === "hour" ? "selectedTimeDescription" : "selectedDateDescription", v = t.maxGranularity === "hour" ? "time" : "date", g = t.value ? h.format(p, {
    [v]: t.formatValue({
      month: "long"
    })
  }) : "", $ = Gs(g), m = e[Bo] === "presentation" ? u["aria-describedby"] : [
    $["aria-describedby"],
    u["aria-describedby"]
  ].filter(Boolean).join(" ") || void 0, b = e[k4], D = G(() => b || Pd(r), [
    b,
    r
  ]), S = C4(t, r, e[Bo] === "presentation");
  S4.set(t, {
    ariaLabel: e["aria-label"],
    ariaLabelledBy: [
      s.id,
      e["aria-labelledby"]
    ].filter(Boolean).join(" ") || void 0,
    ariaDescribedBy: m,
    focusManager: D
  });
  let T = q(e.autoFocus), B;
  e[Bo] === "presentation" ? B = {
    role: "presentation"
  } : B = ve(u, {
    role: "group",
    "aria-disabled": e.isDisabled || void 0,
    "aria-describedby": m
  }), oe(() => {
    T.current && D.focusFirst(), T.current = !1;
  }, [
    D
  ]), Cd(e.inputRef, t.value, t.setValue), Kd({
    ...e,
    focus() {
      D.focusFirst();
    }
  }, t, e.inputRef);
  let y = {
    type: "hidden",
    name: e.name,
    value: ((n = t.value) === null || n === void 0 ? void 0 : n.toString()) || ""
  };
  e.validationBehavior === "native" && (y.type = "text", y.hidden = !0, y.required = e.isRequired, y.onChange = () => {
  });
  let _ = _e(e);
  return {
    labelProps: {
      ...s,
      onClick: () => {
        D.focusFirst();
      }
    },
    fieldProps: ve(_, B, S, f, {
      onKeyDown(w) {
        e.onKeyDown && e.onKeyDown(w);
      },
      onKeyUp(w) {
        e.onKeyUp && e.onKeyUp(w);
      }
    }),
    inputProps: y,
    descriptionProps: l,
    errorMessageProps: c,
    isInvalid: i,
    validationErrors: a,
    validationDetails: o
  };
}
function B7(e) {
  return e && e.__esModule ? e.default : e;
}
function M7() {
  let { locale: e } = st(), t = yy(B7(su), "@react-aria/datepicker");
  return G(() => {
    try {
      return new Intl.DisplayNames(e, {
        type: "dateTimeField"
      });
    } catch {
      return new N7(e, t);
    }
  }, [
    e,
    t
  ]);
}
class N7 {
  of(t) {
    return this.dictionary.getStringForLocale(t, this.locale);
  }
  constructor(t, r) {
    this.locale = t, this.dictionary = r;
  }
}
var T4 = {};
T4 = {
  Empty: ""
};
var A4 = {};
A4 = {
  Empty: ""
};
var _4 = {};
_4 = {
  Empty: "Przdn"
};
var F4 = {};
F4 = {
  Empty: "Tom"
};
var O4 = {};
O4 = {
  Empty: "Leer"
};
var I4 = {};
I4 = {
  Empty: ""
};
var R4 = {};
R4 = {
  Empty: "Empty"
};
var B4 = {};
B4 = {
  Empty: "Vaco"
};
var M4 = {};
M4 = {
  Empty: "Thjenda"
};
var N4 = {};
N4 = {
  Empty: "Tyhj"
};
var L4 = {};
L4 = {
  Empty: "Vide"
};
var V4 = {};
V4 = {
  Empty: ""
};
var z4 = {};
z4 = {
  Empty: "Prazno"
};
var j4 = {};
j4 = {
  Empty: "res"
};
var K4 = {};
K4 = {
  Empty: "Vuoto"
};
var U4 = {};
U4 = {
  Empty: ""
};
var q4 = {};
q4 = {
  Empty: " "
};
var H4 = {};
H4 = {
  Empty: "Tuias"
};
var W4 = {};
W4 = {
  Empty: "Tuks"
};
var Q4 = {};
Q4 = {
  Empty: "Tom"
};
var G4 = {};
G4 = {
  Empty: "Leeg"
};
var Z4 = {};
Z4 = {
  Empty: "Pusty"
};
var Y4 = {};
Y4 = {
  Empty: "Vazio"
};
var J4 = {};
J4 = {
  Empty: "Vazio"
};
var X4 = {};
X4 = {
  Empty: "Gol"
};
var e3 = {};
e3 = {
  Empty: " "
};
var t3 = {};
t3 = {
  Empty: "Przdne"
};
var r3 = {};
r3 = {
  Empty: "Prazen"
};
var n3 = {};
n3 = {
  Empty: "Prazno"
};
var i3 = {};
i3 = {
  Empty: "Tomt"
};
var a3 = {};
a3 = {
  Empty: "Bo"
};
var o3 = {};
o3 = {
  Empty: ""
};
var s3 = {};
s3 = {
  Empty: ""
};
var u3 = {};
u3 = {
  Empty: ""
};
var l3 = {};
l3 = {
  "ar-AE": T4,
  "bg-BG": A4,
  "cs-CZ": _4,
  "da-DK": F4,
  "de-DE": O4,
  "el-GR": I4,
  "en-US": R4,
  "es-ES": B4,
  "et-EE": M4,
  "fi-FI": N4,
  "fr-FR": L4,
  "he-IL": V4,
  "hr-HR": z4,
  "hu-HU": j4,
  "it-IT": K4,
  "ja-JP": U4,
  "ko-KR": q4,
  "lt-LT": H4,
  "lv-LV": W4,
  "nb-NO": Q4,
  "nl-NL": G4,
  "pl-PL": Z4,
  "pt-BR": Y4,
  "pt-PT": J4,
  "ro-RO": X4,
  "ru-RU": e3,
  "sk-SK": t3,
  "sl-SI": r3,
  "sr-SP": n3,
  "sv-SE": i3,
  "tr-TR": a3,
  "uk-UA": o3,
  "zh-CN": s3,
  "zh-TW": u3
};
function L7(e) {
  return e && e.__esModule ? e.default : e;
}
function V7(e) {
  const t = q();
  let { value: r, textValue: n, minValue: i, maxValue: a, isDisabled: o, isReadOnly: s, isRequired: u, onIncrement: l, onIncrementPage: c, onDecrement: d, onDecrementPage: f, onDecrementToMin: h, onIncrementToMax: p } = e;
  const v = Ht(L7(l3), "@react-aria/spinbutton"), g = () => clearTimeout(t.current);
  oe(() => () => g(), []);
  let $ = (E) => {
    if (!(E.ctrlKey || E.metaKey || E.shiftKey || E.altKey || s))
      switch (E.key) {
        case "PageUp":
          if (c) {
            E.preventDefault(), c == null || c();
            break;
          }
        case "ArrowUp":
        case "Up":
          l && (E.preventDefault(), l == null || l());
          break;
        case "PageDown":
          if (f) {
            E.preventDefault(), f == null || f();
            break;
          }
        case "ArrowDown":
        case "Down":
          d && (E.preventDefault(), d == null || d());
          break;
        case "Home":
          h && (E.preventDefault(), h == null || h());
          break;
        case "End":
          p && (E.preventDefault(), p == null || p());
          break;
      }
  }, m = q(!1), b = () => {
    m.current = !0;
  }, D = () => {
    m.current = !1;
  }, S = n === "" ? v.format("Empty") : (n || `${r}`).replace("-", "");
  oe(() => {
    m.current && (zC("assertive"), ri(S, "assertive"));
  }, [
    S
  ]);
  const T = lt((E) => {
    g(), l == null || l(), t.current = window.setTimeout(() => {
      (a === void 0 || isNaN(a) || r === void 0 || isNaN(r) || r < a) && T(60);
    }, E);
  }), B = lt((E) => {
    g(), d == null || d(), t.current = window.setTimeout(() => {
      (i === void 0 || isNaN(i) || r === void 0 || isNaN(r) || r > i) && B(60);
    }, E);
  });
  let y = (E) => {
    E.preventDefault();
  }, { addGlobalListener: _, removeAllGlobalListeners: w } = Ed();
  return {
    spinButtonProps: {
      role: "spinbutton",
      "aria-valuenow": r !== void 0 && !isNaN(r) ? r : void 0,
      "aria-valuetext": S,
      "aria-valuemin": i,
      "aria-valuemax": a,
      "aria-disabled": o || void 0,
      "aria-readonly": s || void 0,
      "aria-required": u || void 0,
      onKeyDown: $,
      onFocus: b,
      onBlur: D
    },
    incrementButtonProps: {
      onPressStart: () => {
        T(400), _(window, "contextmenu", y);
      },
      onPressEnd: () => {
        g(), w();
      },
      onFocus: b,
      onBlur: D
    },
    decrementButtonProps: {
      onPressStart: () => {
        B(400), _(window, "contextmenu", y);
      },
      onPressEnd: () => {
        g(), w();
      },
      onFocus: b,
      onBlur: D
    }
  };
}
function z7(e, t, r) {
  let n = q(""), { locale: i } = st(), a = M7(), { ariaLabel: o, ariaLabelledBy: s, ariaDescribedBy: u, focusManager: l } = S4.get(t), c = e.isPlaceholder ? "" : e.text, d = G(() => t.dateFormatter.resolvedOptions(), [
    t.dateFormatter
  ]), f = Qt({
    month: "long",
    timeZone: d.timeZone
  }), h = Qt({
    hour: "numeric",
    hour12: d.hour12,
    timeZone: d.timeZone
  });
  if (e.type === "month" && !e.isPlaceholder) {
    let x = f.format(t.dateValue);
    c = x !== c ? `${c}  ${x}` : x;
  } else e.type === "hour" && !e.isPlaceholder && (c = h.format(t.dateValue));
  let { spinButtonProps: p } = V7({
    // The ARIA spec says aria-valuenow is optional if there's no value, but aXe seems to require it.
    // This doesn't seem to have any negative effects with real AT since we also use aria-valuetext.
    // https://github.com/dequelabs/axe-core/issues/3505
    value: e.value,
    textValue: c,
    minValue: e.minValue,
    maxValue: e.maxValue,
    isDisabled: t.isDisabled,
    isReadOnly: t.isReadOnly || !e.isEditable,
    isRequired: t.isRequired,
    onIncrement: () => {
      n.current = "", t.increment(e.type);
    },
    onDecrement: () => {
      n.current = "", t.decrement(e.type);
    },
    onIncrementPage: () => {
      n.current = "", t.incrementPage(e.type);
    },
    onDecrementPage: () => {
      n.current = "", t.decrementPage(e.type);
    },
    onIncrementToMax: () => {
      n.current = "", t.setSegment(e.type, e.maxValue);
    },
    onDecrementToMin: () => {
      n.current = "", t.setSegment(e.type, e.minValue);
    }
  }), v = G(() => new qy(i, {
    maximumFractionDigits: 0
  }), [
    i
  ]), g = () => {
    if (e.text === e.placeholder && l.focusPrevious(), v.isValidPartialNumber(e.text) && !t.isReadOnly && !e.isPlaceholder) {
      let x = e.text.slice(0, -1), U = v.parse(x);
      x = U === 0 ? "" : x, x.length === 0 || U === 0 ? t.clearSegment(e.type) : t.setSegment(e.type, U), n.current = x;
    } else e.type === "dayPeriod" && t.clearSegment(e.type);
  }, $ = (x) => {
    if (x.key === "a" && (gr() ? x.metaKey : x.ctrlKey) && x.preventDefault(), !(x.ctrlKey || x.metaKey || x.shiftKey || x.altKey))
      switch (x.key) {
        case "Backspace":
        case "Delete":
          x.preventDefault(), x.stopPropagation(), g();
          break;
      }
  }, { startsWith: m } = Hy({
    sensitivity: "base"
  }), b = Qt({
    hour: "numeric",
    hour12: !0
  }), D = G(() => {
    let x = /* @__PURE__ */ new Date();
    return x.setHours(0), b.formatToParts(x).find((U) => U.type === "dayPeriod").value;
  }, [
    b
  ]), S = G(() => {
    let x = /* @__PURE__ */ new Date();
    return x.setHours(12), b.formatToParts(x).find((U) => U.type === "dayPeriod").value;
  }, [
    b
  ]), T = Qt({
    year: "numeric",
    era: "narrow",
    timeZone: "UTC"
  }), B = G(() => {
    if (e.type !== "era") return [];
    let x = ze(new rt(1, 1, 1), t.calendar), U = t.calendar.getEras().map((z) => {
      let ae = x.set({
        year: 1,
        month: 1,
        day: 1,
        era: z
      }).toDate("UTC"), ye = T.formatToParts(ae).find((De) => De.type === "era").value;
      return {
        era: z,
        formatted: ye
      };
    }), K = j7(U.map((z) => z.formatted));
    if (K) for (let z of U) z.formatted = z.formatted.slice(K);
    return U;
  }, [
    T,
    t.calendar,
    e.type
  ]), y = (x) => {
    if (t.isDisabled || t.isReadOnly) return;
    let U = n.current + x;
    switch (e.type) {
      case "dayPeriod":
        if (m(D, x)) t.setSegment("dayPeriod", 0);
        else if (m(S, x)) t.setSegment("dayPeriod", 12);
        else break;
        l.focusNext();
        break;
      case "era": {
        let K = B.find((z) => m(z.formatted, x));
        K && (t.setSegment("era", K.era), l.focusNext());
        break;
      }
      case "day":
      case "hour":
      case "minute":
      case "second":
      case "month":
      case "year": {
        if (!v.isValidPartialNumber(U)) return;
        let K = v.parse(U), z = K, ae = e.minValue === 0;
        if (e.type === "hour" && t.dateFormatter.resolvedOptions().hour12) {
          switch (t.dateFormatter.resolvedOptions().hourCycle) {
            case "h11":
              K > 11 && (z = v.parse(x));
              break;
            case "h12":
              ae = !1, K > 12 && (z = v.parse(x));
              break;
          }
          e.value >= 12 && K > 1 && (K += 12);
        } else K > e.maxValue && (z = v.parse(x));
        if (isNaN(K)) return;
        let ne = z !== 0 || ae;
        ne && t.setSegment(e.type, z), +(K + "0") > e.maxValue || U.length >= String(e.maxValue).length ? (n.current = "", ne && l.focusNext()) : n.current = U;
        break;
      }
    }
  }, _ = () => {
    n.current = "", Wo(r.current, {
      containingElement: Qs(r.current)
    }), window.getSelection().collapse(r.current);
  }, w = q("");
  Jn(r, "beforeinput", (x) => {
    switch (x.preventDefault(), x.inputType) {
      case "deleteContentBackward":
      case "deleteContentForward":
        v.isValidPartialNumber(e.text) && !t.isReadOnly && g();
        break;
      case "insertCompositionText":
        w.current = r.current.textContent, r.current.textContent = r.current.textContent;
        break;
      default:
        x.data != null && y(x.data);
        break;
    }
  }), Jn(r, "input", (x) => {
    let { inputType: U, data: K } = x;
    switch (U) {
      case "insertCompositionText":
        r.current.textContent = w.current, (m(D, K) || m(S, K)) && y(K);
        break;
    }
  }), Re(() => {
    let x = r.current;
    return () => {
      document.activeElement === x && (l.focusPrevious() || l.focusNext());
    };
  }, [
    r,
    l
  ]);
  let E = Na() || e.type === "timeZoneName" ? {
    role: "textbox",
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuetext": null,
    "aria-valuenow": null
  } : {}, k = G(() => t.segments.find((x) => x.isEditable), [
    t.segments
  ]);
  e !== k && !t.isInvalid && (u = void 0);
  let C = kt(), A = !t.isDisabled && !t.isReadOnly && e.isEditable, L = e.type === "literal" ? "" : a.of(e.type), I = mn({
    "aria-label": `${L}${o ? `, ${o}` : ""}${s ? ", " : ""}`,
    "aria-labelledby": s
  });
  return e.type === "literal" ? {
    segmentProps: {
      "aria-hidden": !0
    }
  } : {
    segmentProps: ve(p, I, {
      id: C,
      ...E,
      "aria-invalid": t.isInvalid ? "true" : void 0,
      "aria-describedby": u,
      "aria-readonly": t.isReadOnly || !e.isEditable ? "true" : void 0,
      "data-placeholder": e.isPlaceholder || void 0,
      contentEditable: A,
      suppressContentEditableWarning: A,
      spellCheck: A ? "false" : void 0,
      autoCapitalize: A ? "off" : void 0,
      autoCorrect: A ? "off" : void 0,
      // Capitalization was changed in React 17...
      [parseInt(P.version, 10) >= 17 ? "enterKeyHint" : "enterkeyhint"]: A ? "next" : void 0,
      inputMode: t.isDisabled || e.type === "dayPeriod" || e.type === "era" || !A ? void 0 : "numeric",
      tabIndex: t.isDisabled ? void 0 : 0,
      onKeyDown: $,
      onFocus: _,
      style: {
        caretColor: "transparent"
      },
      // Prevent pointer events from reaching useDatePickerGroup, and allow native browser behavior to focus the segment.
      onPointerDown(x) {
        x.stopPropagation();
      },
      onMouseDown(x) {
        x.stopPropagation();
      }
    })
  };
}
function j7(e) {
  e.sort();
  let t = e[0], r = e[e.length - 1];
  for (let n = 0; n < t.length; n++)
    if (t[n] !== r[n]) return n;
  return 0;
}
function K7(e) {
  return e && e.__esModule ? e.default : e;
}
function U7(e, t, r) {
  var n, i;
  let a = Ht(K7(su), "@react-aria/datepicker"), { isInvalid: o, validationErrors: s, validationDetails: u } = t.displayValidation, { labelProps: l, fieldProps: c, descriptionProps: d, errorMessageProps: f } = nu({
    ...e,
    labelElementType: "span",
    isInvalid: o,
    errorMessage: e.errorMessage || s
  }), h = c["aria-labelledby"] || c.id, { locale: p } = st(), v = t.formatValue(p, {
    month: "long"
  }), g = v ? a.format("selectedRangeDescription", {
    startDate: v.start,
    endDate: v.end
  }) : "", $ = Gs(g), m = {
    "aria-label": a.format("startDate"),
    "aria-labelledby": h
  }, b = {
    "aria-label": a.format("endDate"),
    "aria-labelledby": h
  }, D = kt(), S = kt(), T = C4(t, r), B = [
    $["aria-describedby"],
    c["aria-describedby"]
  ].filter(Boolean).join(" ") || void 0, y = G(() => Pd(r, {
    // Exclude the button from the focus manager.
    accept: (A) => A.id !== D
  }), [
    r,
    D
  ]), _ = {
    [k4]: y,
    [Bo]: "presentation",
    "aria-describedby": B,
    placeholderValue: e.placeholderValue,
    hideTimeZone: e.hideTimeZone,
    hourCycle: e.hourCycle,
    granularity: e.granularity,
    shouldForceLeadingZeros: e.shouldForceLeadingZeros,
    isDisabled: e.isDisabled,
    isReadOnly: e.isReadOnly,
    isRequired: e.isRequired,
    validationBehavior: e.validationBehavior
  }, w = _e(e), { focusWithinProps: E } = $i({
    ...e,
    isDisabled: t.isOpen,
    onBlurWithin: e.onBlur,
    onFocusWithin: e.onFocus,
    onFocusWithinChange: e.onFocusChange
  }), k = q(rn), C = q(rn);
  return {
    groupProps: ve(w, T, c, $, E, {
      role: "group",
      "aria-disabled": e.isDisabled || null,
      "aria-describedby": B,
      onKeyDown(A) {
        t.isOpen || e.onKeyDown && e.onKeyDown(A);
      },
      onKeyUp(A) {
        t.isOpen || e.onKeyUp && e.onKeyUp(A);
      }
    }),
    labelProps: {
      ...l,
      onClick: () => {
        y.focusFirst();
      }
    },
    buttonProps: {
      ...$,
      id: D,
      "aria-haspopup": "dialog",
      "aria-label": a.format("calendar"),
      "aria-labelledby": `${D} ${h}`,
      "aria-describedby": B,
      "aria-expanded": t.isOpen,
      isDisabled: e.isDisabled || e.isReadOnly,
      onPress: () => t.setOpen(!0)
    },
    dialogProps: {
      id: S,
      "aria-labelledby": `${D} ${h}`
    },
    startFieldProps: {
      ...m,
      ..._,
      value: (n = t.value) === null || n === void 0 ? void 0 : n.start,
      onChange: (A) => t.setDateTime("start", A),
      autoFocus: e.autoFocus,
      name: e.startName,
      [wa]: {
        realtimeValidation: t.realtimeValidation,
        displayValidation: t.displayValidation,
        updateValidation(A) {
          k.current = A, t.updateValidation(us(A, C.current));
        },
        resetValidation: t.resetValidation,
        commitValidation: t.commitValidation
      }
    },
    endFieldProps: {
      ...b,
      ..._,
      value: (i = t.value) === null || i === void 0 ? void 0 : i.end,
      onChange: (A) => t.setDateTime("end", A),
      name: e.endName,
      [wa]: {
        realtimeValidation: t.realtimeValidation,
        displayValidation: t.displayValidation,
        updateValidation(A) {
          C.current = A, t.updateValidation(us(k.current, A));
        },
        resetValidation: t.resetValidation,
        commitValidation: t.commitValidation
      }
    },
    descriptionProps: d,
    errorMessageProps: f,
    calendarProps: {
      autoFocus: !0,
      value: t.dateRange,
      onChange: t.setDateRange,
      minValue: e.minValue,
      maxValue: e.maxValue,
      isDisabled: e.isDisabled,
      isReadOnly: e.isReadOnly,
      isDateUnavailable: e.isDateUnavailable,
      allowsNonContiguousRanges: e.allowsNonContiguousRanges,
      defaultFocusedValue: t.dateRange ? void 0 : e.placeholderValue,
      isInvalid: t.isInvalid,
      errorMessage: typeof e.errorMessage == "function" ? e.errorMessage(t.displayValidation) : e.errorMessage || t.displayValidation.validationErrors.join(" ")
    },
    isInvalid: o,
    validationErrors: s,
    validationDetails: u
  };
}
function q7(e, t) {
  let { role: r = "dialog" } = e, n = di();
  n = e["aria-label"] ? void 0 : n;
  let i = q(!1);
  return oe(() => {
    if (t.current && !t.current.contains(document.activeElement)) {
      yn(t.current);
      let a = setTimeout(() => {
        document.activeElement === t.current && (i.current = !0, t.current && (t.current.blur(), yn(t.current)), i.current = !1);
      }, 500);
      return () => {
        clearTimeout(a);
      };
    }
  }, [
    t
  ]), nb(), {
    dialogProps: {
      ..._e(e, {
        labelable: !0
      }),
      role: r,
      tabIndex: -1,
      "aria-labelledby": e["aria-labelledby"] || n,
      // Prevent blur events from reaching useOverlay, which may cause
      // popovers to close. Since focus is contained within the dialog,
      // we don't want this to occur due to the above useEffect.
      onBlur: (a) => {
        i.current && a.stopPropagation();
      }
    },
    titleProps: {
      id: n
    }
  };
}
const c3 = /* @__PURE__ */ new WeakMap();
function H7(e, t, r) {
  let { keyboardDelegate: n, isDisabled: i, isRequired: a, name: o, validationBehavior: s = "aria" } = e, u = tu({
    usage: "search",
    sensitivity: "base"
  }), l = G(() => n || new au(t.collection, t.disabledKeys, null, u), [
    n,
    t.collection,
    t.disabledKeys,
    u
  ]), { menuTriggerProps: c, menuProps: d } = Kb({
    isDisabled: i,
    type: "listbox"
  }, t, r), f = (y) => {
    switch (y.key) {
      case "ArrowLeft": {
        y.preventDefault();
        let _ = t.selectedKey != null ? l.getKeyAbove(t.selectedKey) : l.getFirstKey();
        _ && t.setSelectedKey(_);
        break;
      }
      case "ArrowRight": {
        y.preventDefault();
        let _ = t.selectedKey != null ? l.getKeyBelow(t.selectedKey) : l.getFirstKey();
        _ && t.setSelectedKey(_);
        break;
      }
    }
  }, { typeSelectProps: h } = ab({
    keyboardDelegate: l,
    selectionManager: t.selectionManager,
    onTypeSelect(y) {
      t.setSelectedKey(y);
    }
  }), { isInvalid: p, validationErrors: v, validationDetails: g } = t.displayValidation, { labelProps: $, fieldProps: m, descriptionProps: b, errorMessageProps: D } = nu({
    ...e,
    labelElementType: "span",
    isInvalid: p,
    errorMessage: e.errorMessage || v
  });
  h.onKeyDown = h.onKeyDownCapture, delete h.onKeyDownCapture;
  let S = _e(e, {
    labelable: !0
  }), T = ve(h, c, m), B = kt();
  return c3.set(t, {
    isDisabled: i,
    isRequired: a,
    name: o,
    validationBehavior: s
  }), {
    labelProps: {
      ...$,
      onClick: () => {
        e.isDisabled || (r.current.focus(), ly("keyboard"));
      }
    },
    triggerProps: ve(S, {
      ...T,
      isDisabled: i,
      onKeyDown: Hr(T.onKeyDown, f, e.onKeyDown),
      onKeyUp: e.onKeyUp,
      "aria-labelledby": [
        B,
        T["aria-labelledby"],
        T["aria-label"] && !T["aria-labelledby"] ? T.id : null
      ].filter(Boolean).join(" "),
      onFocus(y) {
        t.isFocused || (e.onFocus && e.onFocus(y), e.onFocusChange && e.onFocusChange(!0), t.setFocused(!0));
      },
      onBlur(y) {
        t.isOpen || (e.onBlur && e.onBlur(y), e.onFocusChange && e.onFocusChange(!1), t.setFocused(!1));
      }
    }),
    valueProps: {
      id: B
    },
    menuProps: {
      ...d,
      autoFocus: t.focusStrategy || !0,
      shouldSelectOnPressUp: !0,
      shouldFocusOnHover: !0,
      disallowEmptySelection: !0,
      linkBehavior: "selection",
      onBlur: (y) => {
        y.currentTarget.contains(y.relatedTarget) || (e.onBlur && e.onBlur(y), e.onFocusChange && e.onFocusChange(!1), t.setFocused(!1));
      },
      "aria-labelledby": [
        m["aria-labelledby"],
        T["aria-label"] && !m["aria-labelledby"] ? T.id : null
      ].filter(Boolean).join(" ")
    },
    descriptionProps: b,
    errorMessageProps: D,
    isInvalid: p,
    validationErrors: v,
    validationDetails: g
  };
}
function W7(e, t, r) {
  let n = c3.get(t) || {}, { autoComplete: i, name: a = n.name, isDisabled: o = n.isDisabled } = e, { validationBehavior: s, isRequired: u } = n, l = nw(), { visuallyHiddenProps: c } = eb();
  Cd(e.selectRef, t.selectedKey, t.setSelectedKey), Kd({
    validationBehavior: s,
    focus: () => r.current.focus()
  }, t, e.selectRef);
  var d;
  return {
    containerProps: {
      ...c,
      "aria-hidden": !0,
      "data-react-aria-prevent-focus": !0,
      "data-a11y-ignore": "aria-hidden-focus"
    },
    inputProps: {
      type: "text",
      tabIndex: l == null || t.isFocused || t.isOpen ? -1 : 0,
      style: {
        fontSize: 16
      },
      onFocus: () => r.current.focus(),
      disabled: o
    },
    selectProps: {
      tabIndex: -1,
      autoComplete: i,
      disabled: o,
      required: s === "native" && u,
      name: a,
      value: (d = t.selectedKey) !== null && d !== void 0 ? d : "",
      onChange: (f) => t.setSelectedKey(f.target.value)
    }
  };
}
function Q7(e) {
  let { state: t, triggerRef: r, label: n, name: i, isDisabled: a } = e, o = q(null), { containerProps: s, inputProps: u, selectProps: l } = W7({
    ...e,
    selectRef: o
  }, t, r);
  var c;
  return t.collection.size <= 300 ? /* @__PURE__ */ P.createElement("div", {
    ...s,
    "data-testid": "hidden-select-container"
  }, /* @__PURE__ */ P.createElement("input", u), /* @__PURE__ */ P.createElement("label", null, n, /* @__PURE__ */ P.createElement("select", {
    ...l,
    ref: o
  }, /* @__PURE__ */ P.createElement("option", null), [
    ...t.collection.getKeys()
  ].map((d) => {
    let f = t.collection.getItem(d);
    if (f.type === "item") return /* @__PURE__ */ P.createElement("option", {
      key: f.key,
      value: f.key
    }, f.textValue);
  })))) : i ? /* @__PURE__ */ P.createElement("input", {
    type: "hidden",
    autoComplete: l.autoComplete,
    name: i,
    disabled: a,
    value: (c = t.selectedKey) !== null && c !== void 0 ? c : ""
  }) : null;
}
function G7(e) {
  let t = _e(e, {
    labelable: !0
  }), r;
  return e.orientation === "vertical" && (r = "vertical"), e.elementType !== "hr" ? {
    separatorProps: {
      ...t,
      role: "separator",
      "aria-orientation": r
    }
  } : {
    separatorProps: t
  };
}
var pc = { exports: {} }, al = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wp;
function Z7() {
  if (wp) return al;
  wp = 1;
  var e = P;
  function t(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var r = typeof Object.is == "function" ? Object.is : t, n = e.useState, i = e.useEffect, a = e.useLayoutEffect, o = e.useDebugValue;
  function s(d, f) {
    var h = f(), p = n({ inst: { value: h, getSnapshot: f } }), v = p[0].inst, g = p[1];
    return a(function() {
      v.value = h, v.getSnapshot = f, u(v) && g({ inst: v });
    }, [d, h, f]), i(function() {
      return u(v) && g({ inst: v }), d(function() {
        u(v) && g({ inst: v });
      });
    }, [d]), o(h), h;
  }
  function u(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var h = f();
      return !r(d, h);
    } catch {
      return !0;
    }
  }
  function l(d, f) {
    return f();
  }
  var c = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? l : s;
  return al.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : c, al;
}
var ol = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cp;
function Y7() {
  return Cp || (Cp = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = P, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(b) {
      {
        for (var D = arguments.length, S = new Array(D > 1 ? D - 1 : 0), T = 1; T < D; T++)
          S[T - 1] = arguments[T];
        n("error", b, S);
      }
    }
    function n(b, D, S) {
      {
        var T = t.ReactDebugCurrentFrame, B = T.getStackAddendum();
        B !== "" && (D += "%s", S = S.concat([B]));
        var y = S.map(function(_) {
          return String(_);
        });
        y.unshift("Warning: " + D), Function.prototype.apply.call(console[b], console, y);
      }
    }
    function i(b, D) {
      return b === D && (b !== 0 || 1 / b === 1 / D) || b !== b && D !== D;
    }
    var a = typeof Object.is == "function" ? Object.is : i, o = e.useState, s = e.useEffect, u = e.useLayoutEffect, l = e.useDebugValue, c = !1, d = !1;
    function f(b, D, S) {
      c || e.startTransition !== void 0 && (c = !0, r("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var T = D();
      if (!d) {
        var B = D();
        a(T, B) || (r("The result of getSnapshot should be cached to avoid an infinite loop"), d = !0);
      }
      var y = o({
        inst: {
          value: T,
          getSnapshot: D
        }
      }), _ = y[0].inst, w = y[1];
      return u(function() {
        _.value = T, _.getSnapshot = D, h(_) && w({
          inst: _
        });
      }, [b, T, D]), s(function() {
        h(_) && w({
          inst: _
        });
        var E = function() {
          h(_) && w({
            inst: _
          });
        };
        return b(E);
      }, [b]), l(T), T;
    }
    function h(b) {
      var D = b.getSnapshot, S = b.value;
      try {
        var T = D();
        return !a(S, T);
      } catch {
        return !0;
      }
    }
    function p(b, D, S) {
      return D();
    }
    var v = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", g = !v, $ = g ? p : f, m = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : $;
    ol.useSyncExternalStore = m, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), ol;
}
process.env.NODE_ENV === "production" ? pc.exports = Z7() : pc.exports = Y7();
var J7 = pc.exports;
class qd {
  get childNodes() {
    throw new Error("childNodes is not supported");
  }
  clone() {
    let t = new qd(this.type, this.key);
    return t.value = this.value, t.level = this.level, t.hasChildNodes = this.hasChildNodes, t.rendered = this.rendered, t.textValue = this.textValue, t["aria-label"] = this["aria-label"], t.index = this.index, t.parentKey = this.parentKey, t.prevKey = this.prevKey, t.nextKey = this.nextKey, t.firstChildKey = this.firstChildKey, t.lastChildKey = this.lastChildKey, t.props = this.props, t;
  }
  constructor(t, r) {
    this.value = null, this.level = 0, this.hasChildNodes = !1, this.rendered = null, this.textValue = "", this["aria-label"] = void 0, this.index = 0, this.parentKey = null, this.prevKey = null, this.nextKey = null, this.firstChildKey = null, this.lastChildKey = null, this.props = {}, this.type = t, this.key = r;
  }
}
class d3 {
  *[Symbol.iterator]() {
    let t = this.firstChild;
    for (; t; )
      yield t, t = t.nextSibling;
  }
  get firstChild() {
    return this._firstChild;
  }
  set firstChild(t) {
    this._firstChild = t, this.ownerDocument.markDirty(this);
  }
  get lastChild() {
    return this._lastChild;
  }
  set lastChild(t) {
    this._lastChild = t, this.ownerDocument.markDirty(this);
  }
  get previousSibling() {
    return this._previousSibling;
  }
  set previousSibling(t) {
    this._previousSibling = t, this.ownerDocument.markDirty(this);
  }
  get nextSibling() {
    return this._nextSibling;
  }
  set nextSibling(t) {
    this._nextSibling = t, this.ownerDocument.markDirty(this);
  }
  get parentNode() {
    return this._parentNode;
  }
  set parentNode(t) {
    this._parentNode = t, this.ownerDocument.markDirty(this);
  }
  get isConnected() {
    var t;
    return ((t = this.parentNode) === null || t === void 0 ? void 0 : t.isConnected) || !1;
  }
  appendChild(t) {
    this.ownerDocument.startTransaction(), t.parentNode && t.parentNode.removeChild(t), this.firstChild == null && (this.firstChild = t), this.lastChild ? (this.lastChild.nextSibling = t, t.index = this.lastChild.index + 1, t.previousSibling = this.lastChild) : (t.previousSibling = null, t.index = 0), t.parentNode = this, t.nextSibling = null, this.lastChild = t, this.ownerDocument.markDirty(this), t.hasSetProps && this.ownerDocument.addNode(t), this.ownerDocument.endTransaction(), this.ownerDocument.queueUpdate();
  }
  insertBefore(t, r) {
    if (r == null) return this.appendChild(t);
    this.ownerDocument.startTransaction(), t.parentNode && t.parentNode.removeChild(t), t.nextSibling = r, t.previousSibling = r.previousSibling, t.index = r.index, this.firstChild === r ? this.firstChild = t : r.previousSibling && (r.previousSibling.nextSibling = t), r.previousSibling = t, t.parentNode = r.parentNode;
    let n = r;
    for (; n; )
      n.index++, n = n.nextSibling;
    t.hasSetProps && this.ownerDocument.addNode(t), this.ownerDocument.endTransaction(), this.ownerDocument.queueUpdate();
  }
  removeChild(t) {
    if (t.parentNode !== this) return;
    this.ownerDocument.startTransaction();
    let r = t.nextSibling;
    for (; r; )
      r.index--, r = r.nextSibling;
    t.nextSibling && (t.nextSibling.previousSibling = t.previousSibling), t.previousSibling && (t.previousSibling.nextSibling = t.nextSibling), this.firstChild === t && (this.firstChild = t.nextSibling), this.lastChild === t && (this.lastChild = t.previousSibling), t.parentNode = null, t.nextSibling = null, t.previousSibling = null, t.index = 0, this.ownerDocument.removeNode(t), this.ownerDocument.endTransaction(), this.ownerDocument.queueUpdate();
  }
  addEventListener() {
  }
  removeEventListener() {
  }
  constructor(t) {
    this._firstChild = null, this._lastChild = null, this._previousSibling = null, this._nextSibling = null, this._parentNode = null, this.ownerDocument = t;
  }
}
class Sa extends d3 {
  get index() {
    return this._index;
  }
  set index(t) {
    this._index = t, this.ownerDocument.markDirty(this);
  }
  get level() {
    return this.parentNode instanceof Sa ? this.parentNode.level + (this.node.type === "item" ? 1 : 0) : 0;
  }
  updateNode() {
    var t, r, n, i;
    let a = this.ownerDocument.getMutableNode(this);
    a.index = this.index, a.level = this.level, a.parentKey = this.parentNode instanceof Sa ? this.parentNode.node.key : null;
    var o;
    a.prevKey = (o = (t = this.previousSibling) === null || t === void 0 ? void 0 : t.node.key) !== null && o !== void 0 ? o : null;
    var s;
    a.nextKey = (s = (r = this.nextSibling) === null || r === void 0 ? void 0 : r.node.key) !== null && s !== void 0 ? s : null, a.hasChildNodes = !!this.firstChild;
    var u;
    a.firstChildKey = (u = (n = this.firstChild) === null || n === void 0 ? void 0 : n.node.key) !== null && u !== void 0 ? u : null;
    var l;
    a.lastChildKey = (l = (i = this.lastChild) === null || i === void 0 ? void 0 : i.node.key) !== null && l !== void 0 ? l : null;
  }
  setProps(t, r, n) {
    let i = this.ownerDocument.getMutableNode(this), { value: a, textValue: o, id: s, ...u } = t;
    if (u.ref = r, i.props = u, i.rendered = n, i.value = a, i.textValue = o || (typeof n == "string" ? n : "") || t["aria-label"] || "", s != null && s !== i.key) {
      if (this.hasSetProps) throw new Error("Cannot change the id of an item");
      i.key = s;
    }
    this.hasSetProps || (this.ownerDocument.addNode(this), this.ownerDocument.endTransaction(), this.hasSetProps = !0), this.ownerDocument.queueUpdate();
  }
  get style() {
    return {};
  }
  hasAttribute() {
  }
  setAttribute() {
  }
  setAttributeNS() {
  }
  removeAttribute() {
  }
  constructor(t, r) {
    super(r), this.nodeType = 8, this._index = 0, this.hasSetProps = !1, this.node = new qd(t, `react-aria-${++r.nodeId}`), this.ownerDocument.startTransaction();
  }
}
class X7 {
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  *[Symbol.iterator]() {
    let t = this.firstKey != null ? this.keyMap.get(this.firstKey) : void 0;
    for (; t; )
      yield t, t = t.nextKey != null ? this.keyMap.get(t.nextKey) : void 0;
  }
  getChildren(t) {
    let r = this.keyMap;
    return {
      *[Symbol.iterator]() {
        let n = r.get(t), i = (n == null ? void 0 : n.firstChildKey) != null ? r.get(n.firstChildKey) : null;
        for (; i; )
          yield i, i = i.nextKey != null ? r.get(i.nextKey) : void 0;
      }
    };
  }
  getKeyBefore(t) {
    let r = this.keyMap.get(t);
    if (!r) return null;
    if (r.prevKey != null) {
      for (r = this.keyMap.get(r.prevKey); r && r.type !== "item" && r.lastChildKey != null; ) r = this.keyMap.get(r.lastChildKey);
      var n;
      return (n = r == null ? void 0 : r.key) !== null && n !== void 0 ? n : null;
    }
    return r.parentKey;
  }
  getKeyAfter(t) {
    let r = this.keyMap.get(t);
    if (!r) return null;
    if (r.type !== "item" && r.firstChildKey != null) return r.firstChildKey;
    for (; r; ) {
      if (r.nextKey != null) return r.nextKey;
      if (r.parentKey != null) r = this.keyMap.get(r.parentKey);
      else return null;
    }
    return null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    let t = this.lastKey != null ? this.keyMap.get(this.lastKey) : null;
    for (; (t == null ? void 0 : t.lastChildKey) != null; ) t = this.keyMap.get(t.lastChildKey);
    var r;
    return (r = t == null ? void 0 : t.key) !== null && r !== void 0 ? r : null;
  }
  getItem(t) {
    var r;
    return (r = this.keyMap.get(t)) !== null && r !== void 0 ? r : null;
  }
  at() {
    throw new Error("Not implemented");
  }
  clone() {
    let t = this.constructor, r = new t();
    return r.keyMap = new Map(this.keyMap), r.firstKey = this.firstKey, r.lastKey = this.lastKey, r;
  }
  addNode(t) {
    if (this.frozen) throw new Error("Cannot add a node to a frozen collection");
    this.keyMap.set(t.key, t);
  }
  removeNode(t) {
    if (this.frozen) throw new Error("Cannot remove a node to a frozen collection");
    this.keyMap.delete(t);
  }
  commit(t, r, n = !1) {
    if (this.frozen) throw new Error("Cannot commit a frozen collection");
    this.firstKey = t, this.lastKey = r, this.frozen = !n;
  }
  constructor() {
    this.keyMap = /* @__PURE__ */ new Map(), this.firstKey = null, this.lastKey = null, this.frozen = !1;
  }
}
class eS extends d3 {
  get isConnected() {
    return !0;
  }
  createElement(t) {
    return new Sa(t, this);
  }
  /**
  * Lazily gets a mutable instance of a Node. If the node has already
  * been cloned during this update cycle, it just returns the existing one.
  */
  getMutableNode(t) {
    let r = t.node;
    return this.mutatedNodes.has(t) || (r = t.node.clone(), this.mutatedNodes.add(t), t.node = r), this.markDirty(t), r;
  }
  getMutableCollection() {
    return !this.isSSR && !this.collectionMutated && (this.collection = this.collection.clone(), this.collectionMutated = !0), this.collection;
  }
  markDirty(t) {
    this.dirtyNodes.add(t);
  }
  startTransaction() {
    this.transactionCount++;
  }
  endTransaction() {
    this.transactionCount--;
  }
  addNode(t) {
    let r = this.getMutableCollection();
    if (!r.getItem(t.node.key)) {
      r.addNode(t.node);
      for (let n of t) this.addNode(n);
    }
    this.markDirty(t);
  }
  removeNode(t) {
    for (let n of t) this.removeNode(n);
    this.getMutableCollection().removeNode(t.node.key), this.markDirty(t);
  }
  /** Finalizes the collection update, updating all nodes and freezing the collection. */
  getCollection() {
    return this.transactionCount > 0 ? this.collection : (this.updateCollection(), this.collection);
  }
  updateCollection() {
    for (let a of this.dirtyNodes) a instanceof Sa && a.isConnected && a.updateNode();
    if (this.dirtyNodes.clear(), this.mutatedNodes.size || this.collectionMutated) {
      var t, r;
      let a = this.getMutableCollection();
      for (let o of this.mutatedNodes) o.isConnected && a.addNode(o.node);
      var n, i;
      a.commit((n = (t = this.firstChild) === null || t === void 0 ? void 0 : t.node.key) !== null && n !== void 0 ? n : null, (i = (r = this.lastChild) === null || r === void 0 ? void 0 : r.node.key) !== null && i !== void 0 ? i : null, this.isSSR), this.mutatedNodes.clear();
    }
    this.collectionMutated = !1;
  }
  queueUpdate() {
    if (!(this.dirtyNodes.size === 0 || this.transactionCount > 0))
      for (let t of this.subscriptions) t();
  }
  subscribe(t) {
    return this.subscriptions.add(t), () => this.subscriptions.delete(t);
  }
  resetAfterSSR() {
    this.isSSR && (this.isSSR = !1, this.firstChild = null, this.lastChild = null, this.nodeId = 0);
  }
  constructor(t) {
    super(null), this.nodeType = 11, this.ownerDocument = this, this.dirtyNodes = /* @__PURE__ */ new Set(), this.isSSR = !1, this.nodeId = 0, this.nodesByProps = /* @__PURE__ */ new WeakMap(), this.mutatedNodes = /* @__PURE__ */ new Set(), this.subscriptions = /* @__PURE__ */ new Set(), this.transactionCount = 0, this.collection = t, this.collectionMutated = !0;
  }
}
function Hd(e) {
  let { children: t, items: r, idScope: n, addIdAndValue: i, dependencies: a = [] } = e, o = G(() => /* @__PURE__ */ new WeakMap(), a);
  return G(() => {
    if (r && typeof t == "function") {
      let l = [];
      for (let c of r) {
        let d = o.get(c);
        if (!d) {
          d = t(c);
          var s, u;
          let f = (u = (s = d.props.id) !== null && s !== void 0 ? s : c.key) !== null && u !== void 0 ? u : c.id;
          if (f == null) throw new Error("Could not determine key for item");
          n && (f = n + ":" + f), d = /* @__PURE__ */ sa(d, i ? {
            key: f,
            id: f,
            value: c
          } : {
            key: f
          }), o.set(c, d);
        }
        l.push(d);
      }
      return l;
    } else if (typeof t != "function") return t;
  }, [
    t,
    r,
    o,
    n,
    i
  ]);
}
function Wd(e) {
  return Hd({
    ...e,
    addIdAndValue: !0
  });
}
const f3 = /* @__PURE__ */ ce(!1);
function tS(e, t) {
  let { collection: r, document: n } = Qd(t);
  return {
    portal: h3(e, n),
    collection: r
  };
}
function rS(e, t, r) {
  let n = wr(), i = q(n);
  i.current = n;
  let a = be(() => i.current ? r() : t(), [
    t,
    r
  ]);
  return J7.useSyncExternalStore(e, a);
}
const nS = typeof P.useSyncExternalStore == "function" ? P.useSyncExternalStore : rS;
function Qd(e) {
  let t = G(() => new eS(e || new X7()), [
    e
  ]), r = be((o) => t.subscribe(o), [
    t
  ]), n = be(() => {
    let o = t.getCollection();
    return t.isSSR && t.resetAfterSSR(), o;
  }, [
    t
  ]), i = be(() => (t.isSSR = !0, t.getCollection()), [
    t
  ]);
  return {
    collection: nS(r, n, i),
    document: t
  };
}
const mc = /* @__PURE__ */ ce(null), uu = /* @__PURE__ */ ce(null);
function h3(e, t) {
  let r = le(uu), n = t ?? r, i = Wd(e), a = G(() => /* @__PURE__ */ P.createElement(f3.Provider, {
    value: !0
  }, i), [
    i
  ]);
  return wr() ? /* @__PURE__ */ P.createElement(mc.Provider, {
    value: n
  }, a) : /* @__PURE__ */ tx(a, n);
}
function iS(e) {
  return /* @__PURE__ */ P.createElement(P.Fragment, null, h3(e));
}
function p3(e, t, r) {
  let n = le(f3);
  var i;
  return n ? (i = Gd(e, t, r, "children" in t ? t.children : null)) !== null && i !== void 0 ? i : /* @__PURE__ */ P.createElement(P.Fragment, null) : null;
}
function aS(e, t, r) {
  return be((n) => {
    n == null || n.setProps(e, t, r);
  }, [
    e,
    t,
    r
  ]);
}
function Gd(e, t, r, n, i) {
  let a = aS(t, r, n), o = le(mc);
  if (o) {
    let s = o.ownerDocument.nodesByProps.get(t);
    return s || (s = o.ownerDocument.createElement(e), s.setProps(t, r, n), o.appendChild(s), o.ownerDocument.updateCollection(), o.ownerDocument.nodesByProps.set(t, s)), i ? /* @__PURE__ */ P.createElement(mc.Provider, {
      value: s
    }, i) : null;
  }
  return /* @__PURE__ */ P.createElement(e, {
    ref: a
  }, i);
}
function oS(e, t) {
  let r = Wd(e);
  return Gd("section", e, t, null, r);
}
const sS = /* @__PURE__ */ xe(oS), uS = /* @__PURE__ */ ce(null), lS = /* @__PURE__ */ ce(null);
function cS(e) {
  let t = le(uS);
  e = ve(t, e), e.dependencies = ((t == null ? void 0 : t.dependencies) || []).concat(e.dependencies);
  let r = typeof e.children == "function" ? e.children : null;
  return /* @__PURE__ */ P.createElement(lS.Provider, {
    value: r
  }, Wd(e));
}
const vc = Symbol("default");
function pt({ values: e, children: t }) {
  for (let [r, n] of e)
    t = /* @__PURE__ */ P.createElement(r.Provider, {
      value: n
    }, t);
  return t;
}
function Ye(e) {
  let { className: t, style: r, children: n, defaultClassName: i, defaultChildren: a, defaultStyle: o, values: s } = e;
  return G(() => {
    let u, l, c;
    return typeof t == "function" ? u = t({
      ...s,
      defaultClassName: i
    }) : u = t, typeof r == "function" ? l = r({
      ...s,
      defaultStyle: o || {}
    }) : l = r, typeof n == "function" ? c = n({
      ...s,
      defaultChildren: a
    }) : n == null ? c = a : c = n, {
      className: u ?? i,
      style: l || o ? {
        ...o,
        ...l
      } : void 0,
      children: c ?? a,
      "data-rac": ""
    };
  }, [
    t,
    r,
    n,
    i,
    a,
    o,
    s
  ]);
}
function xi(e, t) {
  return (r) => t(typeof e == "function" ? e(r) : e, r);
}
function Zr(e, t) {
  let r = le(e);
  if (t === null)
    return null;
  if (r && typeof r == "object" && "slots" in r && r.slots) {
    let n = new Intl.ListFormat().format(Object.keys(r.slots).map((a) => `"${a}"`));
    if (!t && !r.slots[vc]) throw new Error(`A slot prop is required. Valid slot names are ${n}.`);
    let i = t || vc;
    if (!r.slots[i])
      throw new Error(`Invalid slot "${t}". Valid slot names are ${n}.`);
    return r.slots[i];
  }
  return r;
}
function je(e, t, r) {
  let n = Zr(r, e.slot) || {}, { ref: i, ...a } = n, o = Cn(G(() => $d(t, i), [
    t,
    i
  ])), s = ve(a, e);
  return "style" in a && a.style && "style" in e && e.style && (typeof a.style == "function" || typeof e.style == "function" ? s.style = (u) => {
    let l = typeof a.style == "function" ? a.style(u) : a.style, c = {
      ...u.defaultStyle,
      ...l
    }, d = typeof e.style == "function" ? e.style({
      ...u,
      defaultStyle: c
    }) : e.style;
    return {
      ...c,
      ...d
    };
  } : s.style = {
    ...a.style,
    ...e.style
  }), [
    s,
    o
  ];
}
function Di() {
  let [e, t] = ee(!0), r = q(!1), n = be((i) => {
    r.current = !0, t(!!i);
  }, []);
  return Re(() => {
    r.current || t(!1);
  }, []), [
    n,
    e
  ];
}
function Zd(e, t = !0) {
  let [r, n] = ee(!0);
  return m3(e, r && t, be(() => n(!1), [])), r && t;
}
function yc(e, t) {
  let [r, n] = ee(!1), [i, a] = ee("idle");
  return !t && e.current && i === "idle" && (r = !0, n(!0), a("exiting")), !e.current && i === "exited" && a("idle"), m3(e, r, be(() => {
    a("exited"), n(!1);
  }, [])), r;
}
function m3(e, t, r) {
  let n = q(null);
  t && e.current && (n.current = window.getComputedStyle(e.current).animation), Re(() => {
    if (t && e.current) {
      let i = window.getComputedStyle(e.current);
      if (i.animationName && i.animationName !== "none" && i.animation !== n.current) {
        let a = (s) => {
          s.target === e.current && (o.removeEventListener("animationend", a), Lc.flushSync(() => {
            r();
          }));
        }, o = e.current;
        return o.addEventListener("animationend", a), () => {
          o.removeEventListener("animationend", a);
        };
      } else r();
    }
  }, [
    e,
    t,
    r
  ]);
}
if (typeof HTMLTemplateElement < "u") {
  const e = Object.getOwnPropertyDescriptor(Node.prototype, "firstChild").get;
  Object.defineProperty(HTMLTemplateElement.prototype, "firstChild", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.dataset.reactAriaHidden ? this.content.firstChild : e.call(this);
    }
  });
}
const ka = /* @__PURE__ */ ce(!1), dS = typeof DocumentFragment < "u" ? new DocumentFragment() : null;
function v3(e) {
  let t = le(ka), r = wr();
  if (t)
    return /* @__PURE__ */ P.createElement(P.Fragment, null, e.children);
  let n = /* @__PURE__ */ P.createElement(ka.Provider, {
    value: !0
  }, e.children);
  return r ? /* @__PURE__ */ P.createElement("template", {
    "data-react-aria-hidden": !0
  }, n) : /* @__PURE__ */ Lc.createPortal(n, dS);
}
function Yd(e) {
  let t = (r, n) => le(ka) ? null : e(r, n);
  return t.displayName = e.displayName || e.name, P.forwardRef(t);
}
function pi(e) {
  const t = /^(data-.*)$/;
  let r = {};
  for (const n in e) t.test(n) || (r[n] = e[n]);
  return r;
}
const fS = /* @__PURE__ */ new Set([
  "form",
  "formAction",
  "formEncType",
  "formMethod",
  "formNoValidate",
  "formTarget",
  "name",
  "value"
]), Ei = /* @__PURE__ */ ce({});
function hS(e, t) {
  [e, t] = je(e, t, Ei);
  let r = e, { buttonProps: n, isPressed: i } = LC(e, t), { focusProps: a, isFocused: o, isFocusVisible: s } = Qr(e), { hoverProps: u, isHovered: l } = Sn(e), c = Ye({
    ...e,
    values: {
      isHovered: l,
      isPressed: i,
      isFocused: o,
      isFocusVisible: s,
      isDisabled: e.isDisabled || !1
    },
    defaultClassName: "react-aria-Button"
  });
  return /* @__PURE__ */ P.createElement("button", {
    ..._e(e, {
      propNames: fS
    }),
    ...ve(n, a, u),
    ...c,
    ref: t,
    slot: e.slot || void 0,
    "data-disabled": e.isDisabled || void 0,
    "data-pressed": r.isPressed || i || void 0,
    "data-hovered": l || void 0,
    "data-focused": o || void 0,
    "data-focus-visible": s || void 0
  });
}
const y3 = /* @__PURE__ */ Yd(hS), nr = /* @__PURE__ */ ce({});
function pS(e, t) {
  [e, t] = je(e, t, nr);
  let { elementType: r = "span", ...n } = e;
  return /* @__PURE__ */ P.createElement(r, {
    className: "react-aria-Text",
    ...n,
    ref: t
  });
}
const lu = /* @__PURE__ */ xe(pS);
function ii(e, t, r) {
  return t != null && e.compare(t) < 0 || r != null && e.compare(r) > 0;
}
function gc(e, t, r, n, i) {
  let a = {};
  for (let s in t)
    a[s] = Math.floor(t[s] / 2), a[s] > 0 && t[s] % 2 === 0 && a[s]--;
  let o = un(e, t, r).subtract(a);
  return Pa(e, o, t, r, n, i);
}
function un(e, t, r, n, i) {
  let a = e;
  return t.years ? a = ec(e) : t.months ? a = $r(e) : t.weeks && (a = bn(e, r)), Pa(e, a, t, r, n, i);
}
function bc(e, t, r, n, i) {
  let a = {
    ...t
  };
  t.days ? a.days-- : t.weeks ? a.weeks-- : t.months ? a.months-- : t.years && a.years--;
  let o = un(e, t, r).subtract(a);
  return Pa(e, o, t, r, n, i);
}
function Pa(e, t, r, n, i, a) {
  return i && e.compare(i) >= 0 && (t = Fd(t, un($t(i), r, n))), a && e.compare(a) <= 0 && (t = _d(t, bc($t(a), r, n))), t;
}
function Fr(e, t, r) {
  return t && (e = Fd(e, $t(t))), r && (e = _d(e, $t(r))), e;
}
function g3(e, t, r) {
  if (!r) return e;
  for (; e.compare(t) >= 0 && r(e); ) e = e.subtract({
    days: 1
  });
  if (e.compare(t) >= 0) return e;
}
function b3(e) {
  let t = G(() => new Yt(e.locale), [
    e.locale
  ]), r = G(() => t.resolvedOptions(), [
    t
  ]), { locale: n, createCalendar: i, visibleDuration: a = {
    months: 1
  }, minValue: o, maxValue: s, selectionAlignment: u, isDateUnavailable: l, pageBehavior: c = "visible" } = e, d = G(() => i(r.calendar), [
    i,
    r.calendar
  ]), [f, h] = tr(e.value, e.defaultValue, e.onChange), p = G(() => f ? ze($t(f), d) : null, [
    f,
    d
  ]), v = G(() => f && "timeZone" in f ? f.timeZone : r.timeZone, [
    f,
    r.timeZone
  ]), g = G(() => e.focusedValue ? Fr(ze($t(e.focusedValue), d), o, s) : void 0, [
    e.focusedValue,
    d,
    o,
    s
  ]), $ = G(() => Fr(e.defaultFocusedValue ? ze($t(e.defaultFocusedValue), d) : p || ze(Js(v), d), o, s), [
    e.defaultFocusedValue,
    p,
    v,
    d,
    o,
    s
  ]), [m, b] = tr(g, $, e.onFocusChange), [D, S] = ee(() => {
    switch (u) {
      case "start":
        return un(m, a, n, o, s);
      case "end":
        return bc(m, a, n, o, s);
      case "center":
      default:
        return gc(m, a, n, o, s);
    }
  }), [T, B] = ee(e.autoFocus || !1), y = G(() => {
    let x = {
      ...a
    };
    return x.days ? x.days-- : x.days = -1, D.add(x);
  }, [
    D,
    a
  ]), [_, w] = ee(d.identifier);
  if (d.identifier !== _) {
    let x = ze(m, d);
    S(gc(x, a, n, o, s)), b(x), w(d.identifier);
  }
  ii(m, o, s) ? b(Fr(m, o, s)) : m.compare(D) < 0 ? S(bc(m, a, n, o, s)) : m.compare(y) > 0 && S(un(m, a, n, o, s));
  function E(x) {
    x = Fr(x, o, s), b(x);
  }
  function k(x) {
    if (!e.isDisabled && !e.isReadOnly) {
      if (x === null) {
        h(null);
        return;
      }
      if (x = Fr(x, o, s), x = g3(x, D, l), !x) return;
      x = ze(x, (f == null ? void 0 : f.calendar) || new xt()), f && "hour" in f ? h(f.set(x)) : h(x);
    }
  }
  let C = G(() => p ? l && l(p) ? !0 : ii(p, o, s) : !1, [
    p,
    l,
    o,
    s
  ]), A = e.isInvalid || e.validationState === "invalid" || C, L = A ? "invalid" : null, I = G(() => c === "visible" ? a : sl(a), [
    c,
    a
  ]);
  return {
    isDisabled: e.isDisabled,
    isReadOnly: e.isReadOnly,
    value: p,
    setValue: k,
    visibleRange: {
      start: D,
      end: y
    },
    minValue: o,
    maxValue: s,
    focusedDate: m,
    timeZone: v,
    validationState: L,
    isValueInvalid: A,
    setFocusedDate(x) {
      E(x), B(!0);
    },
    focusNextDay() {
      E(m.add({
        days: 1
      }));
    },
    focusPreviousDay() {
      E(m.subtract({
        days: 1
      }));
    },
    focusNextRow() {
      a.days ? this.focusNextPage() : (a.weeks || a.months || a.years) && E(m.add({
        weeks: 1
      }));
    },
    focusPreviousRow() {
      a.days ? this.focusPreviousPage() : (a.weeks || a.months || a.years) && E(m.subtract({
        weeks: 1
      }));
    },
    focusNextPage() {
      let x = D.add(I);
      b(Fr(m.add(I), o, s)), S(un(Pa(m, x, I, n, o, s), I, n));
    },
    focusPreviousPage() {
      let x = D.subtract(I);
      b(Fr(m.subtract(I), o, s)), S(un(Pa(m, x, I, n, o, s), I, n));
    },
    focusSectionStart() {
      a.days ? E(D) : a.weeks ? E(bn(m, n)) : (a.months || a.years) && E($r(m));
    },
    focusSectionEnd() {
      a.days ? E(y) : a.weeks ? E(Dy(m, n)) : (a.months || a.years) && E(fi(m));
    },
    focusNextSection(x) {
      if (!x && !a.days) {
        E(m.add(sl(a)));
        return;
      }
      a.days ? this.focusNextPage() : a.weeks ? E(m.add({
        months: 1
      })) : (a.months || a.years) && E(m.add({
        years: 1
      }));
    },
    focusPreviousSection(x) {
      if (!x && !a.days) {
        E(m.subtract(sl(a)));
        return;
      }
      a.days ? this.focusPreviousPage() : a.weeks ? E(m.subtract({
        months: 1
      })) : (a.months || a.years) && E(m.subtract({
        years: 1
      }));
    },
    selectFocusedDate() {
      k(m);
    },
    selectDate(x) {
      k(x);
    },
    isFocused: T,
    setFocused: B,
    isInvalid(x) {
      return ii(x, o, s);
    },
    isSelected(x) {
      return p != null && tt(x, p) && !this.isCellDisabled(x) && !this.isCellUnavailable(x);
    },
    isCellFocused(x) {
      return T && m && tt(x, m);
    },
    isCellDisabled(x) {
      return e.isDisabled || x.compare(D) < 0 || x.compare(y) > 0 || this.isInvalid(x, o, s);
    },
    isCellUnavailable(x) {
      return e.isDateUnavailable && e.isDateUnavailable(x);
    },
    isPreviousVisibleRangeInvalid() {
      let x = D.subtract({
        days: 1
      });
      return tt(x, D) || this.isInvalid(x, o, s);
    },
    isNextVisibleRangeInvalid() {
      let x = y.add({
        days: 1
      });
      return tt(x, y) || this.isInvalid(x, o, s);
    },
    getDatesInWeek(x, U = D) {
      let K = U.add({
        weeks: x
      }), z = [];
      K = bn(K, n);
      let ae = Ad(K, n);
      for (let ne = 0; ne < ae; ne++) z.push(null);
      for (; z.length < 7; ) {
        z.push(K);
        let ne = K.add({
          days: 1
        });
        if (tt(K, ne)) break;
        K = ne;
      }
      for (; z.length < 7; ) z.push(null);
      return z;
    }
  };
}
function sl(e) {
  let t = {
    ...e
  };
  for (let r in e) t[r] = 1;
  return t;
}
function mS(e) {
  let { value: t, defaultValue: r, onChange: n, createCalendar: i, locale: a, visibleDuration: o = {
    months: 1
  }, minValue: s, maxValue: u, ...l } = e, [c, d] = tr(t, r || null, n), [f, h] = ee(null), p = "center";
  if (c && c.start && c.end) {
    let U = gc($t(c.start), o, a, s, u).add(o).subtract({
      days: 1
    });
    c.end.compare(U) > 0 && (p = "start");
  }
  let v = q(null), [g, $] = ee(null), m = G(() => Fd(s, g == null ? void 0 : g.start), [
    s,
    g
  ]), b = G(() => _d(u, g == null ? void 0 : g.end), [
    u,
    g
  ]), D = b3({
    ...l,
    value: c && c.start,
    createCalendar: i,
    locale: a,
    visibleDuration: o,
    minValue: m,
    maxValue: b,
    selectionAlignment: p
  }), S = (x) => {
    x && e.isDateUnavailable && !e.allowsNonContiguousRanges ? (v.current = {
      start: kp(x, D, -1),
      end: kp(x, D, 1)
    }, $(v.current)) : (v.current = null, $(null));
  }, [T, B] = ee(D.visibleRange);
  (!Xl(D.visibleRange.start, T.start) || !Xl(D.visibleRange.end, T.end)) && (S(f), B(D.visibleRange));
  let y = (x) => {
    x ? (h(x), S(x)) : (h(null), S(null));
  }, _ = f ? ul(f, D.focusedDate) : c && ul(c.start, c.end), w = (x) => {
    if (!e.isReadOnly && (x = Fr(x, m, b), x = g3(x, D.visibleRange.start, e.isDateUnavailable), !!x))
      if (!f) y(x);
      else {
        let U = ul(f, x);
        d({
          start: Sp(U.start, c == null ? void 0 : c.start),
          end: Sp(U.end, c == null ? void 0 : c.end)
        }), y(null);
      }
  }, [E, k] = ee(!1), { isDateUnavailable: C } = e, A = G(() => !c || f ? !1 : C && (C(c.start) || C(c.end)) ? !0 : ii(c.start, s, u) || ii(c.end, s, u), [
    C,
    c,
    f,
    s,
    u
  ]), L = e.isInvalid || e.validationState === "invalid" || A;
  return {
    ...D,
    value: c,
    setValue: d,
    anchorDate: f,
    setAnchorDate: y,
    highlightedRange: _,
    validationState: L ? "invalid" : null,
    isValueInvalid: L,
    selectFocusedDate() {
      w(D.focusedDate);
    },
    selectDate: w,
    highlightDate(x) {
      f && D.setFocusedDate(x);
    },
    isSelected(x) {
      return _ && x.compare(_.start) >= 0 && x.compare(_.end) <= 0 && !D.isCellDisabled(x) && !D.isCellUnavailable(x);
    },
    isInvalid(x) {
      var U, K;
      return D.isInvalid(x) || ii(x, (U = v.current) === null || U === void 0 ? void 0 : U.start, (K = v.current) === null || K === void 0 ? void 0 : K.end);
    },
    isDragging: E,
    setDragging: k
  };
}
function ul(e, t) {
  return !e || !t ? null : (t.compare(e) < 0 && ([e, t] = [
    t,
    e
  ]), {
    start: $t(e),
    end: $t(t)
  });
}
function Sp(e, t) {
  return e = ze(e, (t == null ? void 0 : t.calendar) || new xt()), t && "hour" in t ? t.set(e) : e;
}
function kp(e, t, r) {
  let n = e.add({
    days: r
  });
  for (; (r < 0 ? n.compare(t.visibleRange.start) >= 0 : n.compare(t.visibleRange.end) <= 0) && !t.isCellUnavailable(n); ) n = n.add({
    days: r
  });
  return t.isCellUnavailable(n) ? n.add({
    days: -r
  }) : null;
}
class $c {
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(t) {
    let r = this.keyMap.get(t);
    return r ? r.prevKey : null;
  }
  getKeyAfter(t) {
    let r = this.keyMap.get(t);
    return r ? r.nextKey : null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(t) {
    return this.keyMap.get(t);
  }
  at(t) {
    const r = [
      ...this.getKeys()
    ];
    return this.getItem(r[t]);
  }
  getChildren(t) {
    let r = this.keyMap.get(t);
    return (r == null ? void 0 : r.childNodes) || [];
  }
  constructor(t) {
    this.keyMap = /* @__PURE__ */ new Map(), this.iterable = t;
    let r = (a) => {
      if (this.keyMap.set(a.key, a), a.childNodes && a.type === "section") for (let o of a.childNodes) r(o);
    };
    for (let a of t) r(a);
    let n, i = 0;
    for (let [a, o] of this.keyMap)
      n ? (n.nextKey = a, o.prevKey = n.key) : (this.firstKey = a, o.prevKey = void 0), o.type === "item" && (o.index = i++), n = o, n.nextKey = void 0;
    this.lastKey = n == null ? void 0 : n.key;
  }
}
class Lt extends Set {
  constructor(t, r, n) {
    super(t), t instanceof Lt ? (this.anchorKey = r || t.anchorKey, this.currentKey = n || t.currentKey) : (this.anchorKey = r, this.currentKey = n);
  }
}
function vS(e, t) {
  if (e.size !== t.size) return !1;
  for (let r of e)
    if (!t.has(r)) return !1;
  return !0;
}
function yS(e) {
  let { selectionMode: t = "none", disallowEmptySelection: r, allowDuplicateSelectionEvents: n, selectionBehavior: i = "toggle", disabledBehavior: a = "all" } = e, o = q(!1), [, s] = ee(!1), u = q(null), l = q(null), [, c] = ee(null), d = G(() => Pp(e.selectedKeys), [
    e.selectedKeys
  ]), f = G(() => Pp(e.defaultSelectedKeys, new Lt()), [
    e.defaultSelectedKeys
  ]), [h, p] = tr(d, f, e.onSelectionChange), v = G(() => e.disabledKeys ? new Set(e.disabledKeys) : /* @__PURE__ */ new Set(), [
    e.disabledKeys
  ]), [g, $] = ee(i);
  i === "replace" && g === "toggle" && typeof h == "object" && h.size === 0 && $("replace");
  let m = q(i);
  return oe(() => {
    i !== m.current && ($(i), m.current = i);
  }, [
    i
  ]), {
    selectionMode: t,
    disallowEmptySelection: r,
    selectionBehavior: g,
    setSelectionBehavior: $,
    get isFocused() {
      return o.current;
    },
    setFocused(b) {
      o.current = b, s(b);
    },
    get focusedKey() {
      return u.current;
    },
    get childFocusStrategy() {
      return l.current;
    },
    setFocusedKey(b, D = "first") {
      u.current = b, l.current = D, c(b);
    },
    selectedKeys: h,
    setSelectedKeys(b) {
      (n || !vS(b, h)) && p(b);
    },
    disabledKeys: v,
    disabledBehavior: a
  };
}
function Pp(e, t) {
  return e ? e === "all" ? "all" : new Lt(e) : t;
}
class gS {
  /**
  * The type of selection that is allowed in the collection.
  */
  get selectionMode() {
    return this.state.selectionMode;
  }
  /**
  * Whether the collection allows empty selection.
  */
  get disallowEmptySelection() {
    return this.state.disallowEmptySelection;
  }
  /**
  * The selection behavior for the collection.
  */
  get selectionBehavior() {
    return this.state.selectionBehavior;
  }
  /**
  * Sets the selection behavior for the collection.
  */
  setSelectionBehavior(t) {
    this.state.setSelectionBehavior(t);
  }
  /**
  * Whether the collection is currently focused.
  */
  get isFocused() {
    return this.state.isFocused;
  }
  /**
  * Sets whether the collection is focused.
  */
  setFocused(t) {
    this.state.setFocused(t);
  }
  /**
  * The current focused key in the collection.
  */
  get focusedKey() {
    return this.state.focusedKey;
  }
  /** Whether the first or last child of the focused key should receive focus. */
  get childFocusStrategy() {
    return this.state.childFocusStrategy;
  }
  /**
  * Sets the focused key.
  */
  setFocusedKey(t, r) {
    (t == null || this.collection.getItem(t)) && this.state.setFocusedKey(t, r);
  }
  /**
  * The currently selected keys in the collection.
  */
  get selectedKeys() {
    return this.state.selectedKeys === "all" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;
  }
  /**
  * The raw selection value for the collection.
  * Either 'all' for select all, or a set of keys.
  */
  get rawSelection() {
    return this.state.selectedKeys;
  }
  /**
  * Returns whether a key is selected.
  */
  isSelected(t) {
    return this.state.selectionMode === "none" ? !1 : (t = this.getKey(t), this.state.selectedKeys === "all" ? this.canSelectItem(t) : this.state.selectedKeys.has(t));
  }
  /**
  * Whether the selection is empty.
  */
  get isEmpty() {
    return this.state.selectedKeys !== "all" && this.state.selectedKeys.size === 0;
  }
  /**
  * Whether all items in the collection are selected.
  */
  get isSelectAll() {
    if (this.isEmpty) return !1;
    if (this.state.selectedKeys === "all") return !0;
    if (this._isSelectAll != null) return this._isSelectAll;
    let t = this.getSelectAllKeys(), r = this.state.selectedKeys;
    return this._isSelectAll = t.every((n) => r.has(n)), this._isSelectAll;
  }
  get firstSelectedKey() {
    let t = null;
    for (let r of this.state.selectedKeys) {
      let n = this.collection.getItem(r);
      (!t || n && il(this.collection, n, t) < 0) && (t = n);
    }
    return t == null ? void 0 : t.key;
  }
  get lastSelectedKey() {
    let t = null;
    for (let r of this.state.selectedKeys) {
      let n = this.collection.getItem(r);
      (!t || n && il(this.collection, n, t) > 0) && (t = n);
    }
    return t == null ? void 0 : t.key;
  }
  get disabledKeys() {
    return this.state.disabledKeys;
  }
  get disabledBehavior() {
    return this.state.disabledBehavior;
  }
  /**
  * Extends the selection to the given key.
  */
  extendSelection(t) {
    if (this.selectionMode === "none") return;
    if (this.selectionMode === "single") {
      this.replaceSelection(t);
      return;
    }
    t = this.getKey(t);
    let r;
    if (this.state.selectedKeys === "all") r = new Lt([
      t
    ], t, t);
    else {
      let n = this.state.selectedKeys, i = n.anchorKey || t;
      r = new Lt(n, i, t);
      for (let a of this.getKeyRange(i, n.currentKey || t)) r.delete(a);
      for (let a of this.getKeyRange(t, i)) this.canSelectItem(a) && r.add(a);
    }
    this.state.setSelectedKeys(r);
  }
  getKeyRange(t, r) {
    let n = this.collection.getItem(t), i = this.collection.getItem(r);
    return n && i ? il(this.collection, n, i) <= 0 ? this.getKeyRangeInternal(t, r) : this.getKeyRangeInternal(r, t) : [];
  }
  getKeyRangeInternal(t, r) {
    let n = [], i = t;
    for (; i; ) {
      let a = this.collection.getItem(i);
      if ((a && a.type === "item" || a.type === "cell" && this.allowsCellSelection) && n.push(i), i === r) return n;
      i = this.collection.getKeyAfter(i);
    }
    return [];
  }
  getKey(t) {
    let r = this.collection.getItem(t);
    if (!r || r.type === "cell" && this.allowsCellSelection) return t;
    for (; r.type !== "item" && r.parentKey != null; ) r = this.collection.getItem(r.parentKey);
    return !r || r.type !== "item" ? null : r.key;
  }
  /**
  * Toggles whether the given key is selected.
  */
  toggleSelection(t) {
    if (this.selectionMode === "none") return;
    if (this.selectionMode === "single" && !this.isSelected(t)) {
      this.replaceSelection(t);
      return;
    }
    if (t = this.getKey(t), t == null) return;
    let r = new Lt(this.state.selectedKeys === "all" ? this.getSelectAllKeys() : this.state.selectedKeys);
    r.has(t) ? r.delete(t) : this.canSelectItem(t) && (r.add(t), r.anchorKey = t, r.currentKey = t), !(this.disallowEmptySelection && r.size === 0) && this.state.setSelectedKeys(r);
  }
  /**
  * Replaces the selection with only the given key.
  */
  replaceSelection(t) {
    if (this.selectionMode === "none" || (t = this.getKey(t), t == null)) return;
    let r = this.canSelectItem(t) ? new Lt([
      t
    ], t, t) : new Lt();
    this.state.setSelectedKeys(r);
  }
  /**
  * Replaces the selection with the given keys.
  */
  setSelectedKeys(t) {
    if (this.selectionMode === "none") return;
    let r = new Lt();
    for (let n of t)
      if (n = this.getKey(n), n != null && (r.add(n), this.selectionMode === "single"))
        break;
    this.state.setSelectedKeys(r);
  }
  getSelectAllKeys() {
    let t = [], r = (n) => {
      for (; n; ) {
        if (this.canSelectItem(n)) {
          let i = this.collection.getItem(n);
          i.type === "item" && t.push(n), i.hasChildNodes && (this.allowsCellSelection || i.type !== "item") && r(P7(ou(i, this.collection)).key);
        }
        n = this.collection.getKeyAfter(n);
      }
    };
    return r(this.collection.getFirstKey()), t;
  }
  /**
  * Selects all items in the collection.
  */
  selectAll() {
    !this.isSelectAll && this.selectionMode === "multiple" && this.state.setSelectedKeys("all");
  }
  /**
  * Removes all keys from the selection.
  */
  clearSelection() {
    !this.disallowEmptySelection && (this.state.selectedKeys === "all" || this.state.selectedKeys.size > 0) && this.state.setSelectedKeys(new Lt());
  }
  /**
  * Toggles between select all and an empty selection.
  */
  toggleSelectAll() {
    this.isSelectAll ? this.clearSelection() : this.selectAll();
  }
  select(t, r) {
    this.selectionMode !== "none" && (this.selectionMode === "single" ? this.isSelected(t) && !this.disallowEmptySelection ? this.toggleSelection(t) : this.replaceSelection(t) : this.selectionBehavior === "toggle" || r && (r.pointerType === "touch" || r.pointerType === "virtual") ? this.toggleSelection(t) : this.replaceSelection(t));
  }
  /**
  * Returns whether the current selection is equal to the given selection.
  */
  isSelectionEqual(t) {
    if (t === this.state.selectedKeys) return !0;
    let r = this.selectedKeys;
    if (t.size !== r.size) return !1;
    for (let n of t)
      if (!r.has(n)) return !1;
    for (let n of r)
      if (!t.has(n)) return !1;
    return !0;
  }
  canSelectItem(t) {
    var r;
    if (this.state.selectionMode === "none" || this.state.disabledKeys.has(t)) return !1;
    let n = this.collection.getItem(t);
    return !(!n || !(n == null || (r = n.props) === null || r === void 0) && r.isDisabled || n.type === "cell" && !this.allowsCellSelection);
  }
  isDisabled(t) {
    var r, n;
    return this.state.disabledBehavior === "all" && (this.state.disabledKeys.has(t) || !!(!((n = this.collection.getItem(t)) === null || n === void 0 || (r = n.props) === null || r === void 0) && r.isDisabled));
  }
  isLink(t) {
    var r, n;
    return !!(!((n = this.collection.getItem(t)) === null || n === void 0 || (r = n.props) === null || r === void 0) && r.href);
  }
  getItemProps(t) {
    var r;
    return (r = this.collection.getItem(t)) === null || r === void 0 ? void 0 : r.props;
  }
  constructor(t, r, n) {
    this.collection = t, this.state = r;
    var i;
    this.allowsCellSelection = (i = n == null ? void 0 : n.allowsCellSelection) !== null && i !== void 0 ? i : !1, this._isSelectAll = null;
  }
}
function $3(e) {
  let { filter: t } = e, r = yS(e), n = G(() => e.disabledKeys ? new Set(e.disabledKeys) : /* @__PURE__ */ new Set(), [
    e.disabledKeys
  ]), i = be((l) => t ? new $c(t(l)) : new $c(l), [
    t
  ]), a = G(() => ({
    suppressTextValueWarning: e.suppressTextValueWarning
  }), [
    e.suppressTextValueWarning
  ]), o = k7(e, i, a), s = G(() => new gS(o, r), [
    o,
    r
  ]);
  const u = q(null);
  return oe(() => {
    if (r.focusedKey != null && !o.getItem(r.focusedKey)) {
      const l = u.current.getItem(r.focusedKey), c = [
        ...u.current.getKeys()
      ].map((v) => {
        const g = u.current.getItem(v);
        return g.type === "item" ? g : null;
      }).filter((v) => v !== null), d = [
        ...o.getKeys()
      ].map((v) => {
        const g = o.getItem(v);
        return g.type === "item" ? g : null;
      }).filter((v) => v !== null), f = c.length - d.length;
      let h = Math.min(f > 1 ? Math.max(l.index - f + 1, 0) : l.index, d.length - 1), p;
      for (; h >= 0; ) {
        if (!s.isDisabled(d[h].key)) {
          p = d[h];
          break;
        }
        h < d.length - 1 ? h++ : (h > l.index && (h = l.index), h--);
      }
      r.setFocusedKey(p ? p.key : null);
    }
    u.current = o;
  }, [
    o,
    s,
    r,
    r.focusedKey
  ]), {
    collection: o,
    disabledKeys: n,
    selectionManager: s
  };
}
function x3(e) {
  var t;
  let [r, n] = tr(e.selectedKey, (t = e.defaultSelectedKey) !== null && t !== void 0 ? t : null, e.onSelectionChange), i = G(() => r != null ? [
    r
  ] : [], [
    r
  ]), { collection: a, disabledKeys: o, selectionManager: s } = $3({
    ...e,
    selectionMode: "single",
    disallowEmptySelection: !0,
    allowDuplicateSelectionEvents: !0,
    selectedKeys: i,
    onSelectionChange: (l) => {
      var c;
      let d = (c = l.values().next().value) !== null && c !== void 0 ? c : null;
      d === r && e.onSelectionChange && e.onSelectionChange(d), n(d);
    }
  }), u = r != null ? a.getItem(r) : null;
  return {
    collection: a,
    disabledKeys: o,
    selectionManager: s,
    selectedKey: r,
    setSelectedKey: n,
    selectedItem: u
  };
}
function wi(e) {
  let [t, r] = tr(e.isOpen, e.defaultOpen || !1, e.onOpenChange);
  const n = be(() => {
    r(!0);
  }, [
    r
  ]), i = be(() => {
    r(!1);
  }, [
    r
  ]), a = be(() => {
    r(!t);
  }, [
    r,
    t
  ]);
  return {
    isOpen: t,
    setOpen: r,
    open: n,
    close: i,
    toggle: a
  };
}
function bS(e) {
  var t, r;
  let { defaultFilter: n, menuTrigger: i = "input", allowsEmptyCollection: a = !1, allowsCustomValue: o, shouldCloseOnBlur: s = !0 } = e, [u, l] = ee(!1), [c, d] = ee(!1), [f, h] = ee(null), p = (R) => {
    e.onSelectionChange && e.onSelectionChange(R), R === m && (De(), ae());
  };
  var v;
  let { collection: g, selectionManager: $, selectedKey: m, setSelectedKey: b, selectedItem: D, disabledKeys: S } = x3({
    ...e,
    onSelectionChange: p,
    items: (v = e.items) !== null && v !== void 0 ? v : e.defaultItems
  });
  var T, B;
  let [y, _] = tr(e.inputValue, (B = (T = e.defaultInputValue) !== null && T !== void 0 ? T : (t = g.getItem(m)) === null || t === void 0 ? void 0 : t.textValue) !== null && B !== void 0 ? B : "", e.onInputChange), w = g, E = G(() => (
    // No default filter if items are controlled.
    e.items != null || !n ? g : $S(g, y, n)
  ), [
    g,
    y,
    n,
    e.items
  ]), [k, C] = ee(E), A = q("focus"), I = wi({
    ...e,
    onOpenChange: (R) => {
      e.onOpenChange && e.onOpenChange(R, R ? A.current : void 0), $.setFocused(R), R || $.setFocusedKey(null);
    },
    isOpen: void 0,
    defaultOpen: void 0
  }), x = (R = null, N) => {
    let W = N === "manual" || N === "focus" && i === "focus";
    (a || E.size > 0 || W && w.size > 0 || e.items) && (W && !I.isOpen && e.items === void 0 && l(!0), A.current = N, h(R), I.open());
  }, U = (R = null, N) => {
    let W = N === "manual" || N === "focus" && i === "focus";
    !(a || E.size > 0 || W && w.size > 0 || e.items) && !I.isOpen || (W && !I.isOpen && e.items === void 0 && l(!0), I.isOpen || (A.current = N), z(R));
  }, K = be(() => {
    C(u ? w : E);
  }, [
    u,
    w,
    E
  ]), z = be((R = null) => {
    I.isOpen && K(), h(R), I.toggle();
  }, [
    I,
    K
  ]), ae = be(() => {
    I.isOpen && (K(), I.close());
  }, [
    I,
    K
  ]), [ne, ye] = ee(y), De = () => {
    var R, N;
    let W = (N = (R = g.getItem(m)) === null || R === void 0 ? void 0 : R.textValue) !== null && N !== void 0 ? N : "";
    ye(W), _(W);
  };
  var Fe, Oe;
  let V = q((Oe = (Fe = e.selectedKey) !== null && Fe !== void 0 ? Fe : e.defaultSelectedKey) !== null && Oe !== void 0 ? Oe : null);
  var ie;
  let we = q((ie = (r = g.getItem(m)) === null || r === void 0 ? void 0 : r.textValue) !== null && ie !== void 0 ? ie : "");
  oe(() => {
    var R;
    c && (E.size > 0 || a) && !I.isOpen && y !== ne && i !== "manual" && x(null, "input"), !u && !a && I.isOpen && E.size === 0 && ae(), m != null && m !== V.current && ae(), y !== ne && ($.setFocusedKey(null), l(!1), y === "" && (e.inputValue === void 0 || e.selectedKey === void 0) && b(null)), m !== V.current && (e.inputValue === void 0 || e.selectedKey === void 0) ? De() : ne !== y && ye(y);
    var N;
    let W = (N = (R = g.getItem(m)) === null || R === void 0 ? void 0 : R.textValue) !== null && N !== void 0 ? N : "";
    !c && m != null && e.inputValue === void 0 && m === V.current && we.current !== W && (ye(W), _(W)), V.current = m, we.current = W;
  });
  let Ke = Ka({
    ...e,
    value: G(() => ({
      inputValue: y,
      selectedKey: m
    }), [
      y,
      m
    ])
  }), We = () => {
    o && m == null ? kr() : Jr();
  }, kr = () => {
    V.current = null, b(null), ae();
  }, Jr = () => {
    if (e.selectedKey !== void 0 && e.inputValue !== void 0) {
      var R;
      e.onSelectionChange(m);
      var N;
      let W = (N = (R = g.getItem(m)) === null || R === void 0 ? void 0 : R.textValue) !== null && N !== void 0 ? N : "";
      ye(W), ae();
    } else
      De(), ae();
  };
  const Tn = () => {
    if (o) {
      var R, N;
      const W = (N = (R = g.getItem(m)) === null || R === void 0 ? void 0 : R.textValue) !== null && N !== void 0 ? N : "";
      y === W ? Jr() : kr();
    } else
      Jr();
  };
  let mf = () => {
    I.isOpen && $.focusedKey != null ? m === $.focusedKey ? Jr() : b($.focusedKey) : Tn();
  }, mu = q(y), vf = (R) => {
    R ? (mu.current = y, i === "focus" && x(null, "focus")) : (s && Tn(), y !== mu.current && Ke.commitValidation()), d(R);
  }, F = G(() => I.isOpen ? u ? w : E : k, [
    I.isOpen,
    w,
    E,
    u,
    k
  ]);
  return {
    ...Ke,
    ...I,
    focusStrategy: f,
    toggle: U,
    open: x,
    close: Tn,
    selectionManager: $,
    selectedKey: m,
    setSelectedKey: b,
    disabledKeys: S,
    isFocused: c,
    setFocused: vf,
    selectedItem: D,
    collection: F,
    inputValue: y,
    setInputValue: _,
    commit: mf,
    revert: We
  };
}
function $S(e, t, r) {
  return new $c(D3(e, e, t, r));
}
function D3(e, t, r, n) {
  let i = [];
  for (let a of t)
    if (a.type === "section" && a.hasChildNodes) {
      let o = D3(e, ou(a, e), r, n);
      [
        ...o
      ].some((s) => s.type === "item") && i.push({
        ...a,
        childNodes: o
      });
    } else a.type === "item" && n(a.textValue, r) ? i.push({
      ...a
    }) : a.type !== "item" && i.push({
      ...a
    });
  return i;
}
var E3 = {};
E3 = {
  rangeOverflow: (e) => `    ${e.maxValue}   .`,
  rangeReversed: "       .",
  rangeUnderflow: (e) => `    ${e.minValue}   .`,
  unavailableDate: "   ."
};
var w3 = {};
w3 = {
  rangeOverflow: (e) => `    ${e.maxValue}  -.`,
  rangeReversed: "      .",
  rangeUnderflow: (e) => `    ${e.minValue}  -.`,
  unavailableDate: "    ."
};
var C3 = {};
C3 = {
  rangeOverflow: (e) => `Hodnota mus bt ${e.maxValue} nebo dvj.`,
  rangeReversed: "Datum zahjen mus pedchzet datu ukonen.",
  rangeUnderflow: (e) => `Hodnota mus bt ${e.minValue} nebo pozdj.`,
  unavailableDate: "Vybran datum nen k dispozici."
};
var S3 = {};
S3 = {
  rangeOverflow: (e) => `Vrdien skal vre ${e.maxValue} eller tidligere.`,
  rangeReversed: "Startdatoen skal vre fr slutdatoen.",
  rangeUnderflow: (e) => `Vrdien skal vre ${e.minValue} eller nyere.`,
  unavailableDate: "Den valgte dato er ikke tilgngelig."
};
var k3 = {};
k3 = {
  rangeOverflow: (e) => `Der Wert muss ${e.maxValue} oder frher sein.`,
  rangeReversed: "Das Anfangsdatum muss vor dem Enddatum liegen.",
  rangeUnderflow: (e) => `Der Wert muss ${e.minValue} oder spter sein.`,
  unavailableDate: "Das ausgewhlte Datum ist nicht verfgbar."
};
var P3 = {};
P3 = {
  rangeOverflow: (e) => `     ${e.maxValue}  .`,
  rangeReversed: "          .",
  rangeUnderflow: (e) => `     ${e.minValue}  .`,
  unavailableDate: "     ."
};
var T3 = {};
T3 = {
  rangeUnderflow: (e) => `Value must be ${e.minValue} or later.`,
  rangeOverflow: (e) => `Value must be ${e.maxValue} or earlier.`,
  rangeReversed: "Start date must be before end date.",
  unavailableDate: "Selected date unavailable."
};
var A3 = {};
A3 = {
  rangeOverflow: (e) => `El valor debe ser ${e.maxValue} o anterior.`,
  rangeReversed: "La fecha de inicio debe ser anterior a la fecha de finalizacin.",
  rangeUnderflow: (e) => `El valor debe ser ${e.minValue} o posterior.`,
  unavailableDate: "Fecha seleccionada no disponible."
};
var _3 = {};
_3 = {
  rangeOverflow: (e) => `Vrtus peab olema ${e.maxValue} vi varasem.`,
  rangeReversed: "Alguskuupev peab olema enne lppkuupeva.",
  rangeUnderflow: (e) => `Vrtus peab olema ${e.minValue} vi hilisem.`,
  unavailableDate: "Valitud kuupev pole saadaval."
};
var F3 = {};
F3 = {
  rangeOverflow: (e) => `Arvon on oltava ${e.maxValue} tai sit aikaisempi.`,
  rangeReversed: "Aloituspivn on oltava ennen lopetuspiv.",
  rangeUnderflow: (e) => `Arvon on oltava ${e.minValue} tai sit myhisempi.`,
  unavailableDate: "Valittu pivmr ei ole kytettviss."
};
var O3 = {};
O3 = {
  rangeOverflow: (e) => `La valeur doit tre ${e.maxValue} ou antrieure.`,
  rangeReversed: "La date de dbut doit tre antrieure  la date de fin.",
  rangeUnderflow: (e) => `La valeur doit tre ${e.minValue} ou ultrieure.`,
  unavailableDate: "La date slectionne nest pas disponible."
};
var I3 = {};
I3 = {
  rangeOverflow: (e) => `   ${e.maxValue}   .`,
  rangeReversed: "      .",
  rangeUnderflow: (e) => `   ${e.minValue}   .`,
  unavailableDate: "   ."
};
var R3 = {};
R3 = {
  rangeOverflow: (e) => `Vrijednost mora biti ${e.maxValue} ili ranije.`,
  rangeReversed: "Datum poetka mora biti prije datuma zavretka.",
  rangeUnderflow: (e) => `Vrijednost mora biti ${e.minValue} ili kasnije.`,
  unavailableDate: "Odabrani datum nije dostupan."
};
var B3 = {};
B3 = {
  rangeOverflow: (e) => `Az rtknek ${e.maxValue} vagy korbbinak kell lennie.`,
  rangeReversed: "A kezd dtumnak a befejez dtumnl korbbinak kell lennie.",
  rangeUnderflow: (e) => `Az rtknek ${e.minValue} vagy ksbbinek kell lennie.`,
  unavailableDate: "A kivlasztott dtum nem rhet el."
};
var M3 = {};
M3 = {
  rangeOverflow: (e) => `Il valore deve essere ${e.maxValue} o precedente.`,
  rangeReversed: "La data di inizio deve essere antecedente alla data di fine.",
  rangeUnderflow: (e) => `Il valore deve essere ${e.minValue} o successivo.`,
  unavailableDate: "Data selezionata non disponibile."
};
var N3 = {};
N3 = {
  rangeOverflow: (e) => ` ${e.maxValue} `,
  rangeReversed: "",
  rangeUnderflow: (e) => ` ${e.minValue} `,
  unavailableDate: ""
};
var L3 = {};
L3 = {
  rangeOverflow: (e) => ` ${e.maxValue}  .`,
  rangeReversed: "   .",
  rangeUnderflow: (e) => ` ${e.minValue}  .`,
  unavailableDate: "    ."
};
var V3 = {};
V3 = {
  rangeOverflow: (e) => `Reikm turi bti ${e.maxValue} arba ankstesn.`,
  rangeReversed: "Pradios data turi bti ankstesn nei pabaigos data.",
  rangeUnderflow: (e) => `Reikm turi bti ${e.minValue} arba naujesn.`,
  unavailableDate: "Pasirinkta data nepasiekiama."
};
var z3 = {};
z3 = {
  rangeOverflow: (e) => `Vrtbai ir jbt ${e.maxValue} vai agrkai.`,
  rangeReversed: "Skuma datumam ir jbt pirms beigu datuma.",
  rangeUnderflow: (e) => `Vrtbai ir jbt ${e.minValue} vai vlkai.`,
  unavailableDate: "Atlastais datums nav pieejams."
};
var j3 = {};
j3 = {
  rangeOverflow: (e) => `Verdien m vre ${e.maxValue} eller tidligere.`,
  rangeReversed: "Startdatoen m vre fr sluttdatoen.",
  rangeUnderflow: (e) => `Verdien m vre ${e.minValue} eller senere.`,
  unavailableDate: "Valgt dato utilgjengelig."
};
var K3 = {};
K3 = {
  rangeOverflow: (e) => `Waarde moet ${e.maxValue} of eerder zijn.`,
  rangeReversed: "De startdatum moet voor de einddatum liggen.",
  rangeUnderflow: (e) => `Waarde moet ${e.minValue} of later zijn.`,
  unavailableDate: "Geselecteerde datum niet beschikbaar."
};
var U3 = {};
U3 = {
  rangeOverflow: (e) => `Warto musi mie warto ${e.maxValue} lub wczeniejsz.`,
  rangeReversed: "Data rozpoczcia musi by wczeniejsza ni data zakoczenia.",
  rangeUnderflow: (e) => `Warto musi mie warto ${e.minValue} lub pniejsz.`,
  unavailableDate: "Wybrana data jest niedostpna."
};
var q3 = {};
q3 = {
  rangeOverflow: (e) => `O valor deve ser ${e.maxValue} ou anterior.`,
  rangeReversed: "A data inicial deve ser anterior  data final.",
  rangeUnderflow: (e) => `O valor deve ser ${e.minValue} ou posterior.`,
  unavailableDate: "Data selecionada indisponvel."
};
var H3 = {};
H3 = {
  rangeOverflow: (e) => `O valor tem de ser ${e.maxValue} ou anterior.`,
  rangeReversed: "A data de incio deve ser anterior  data de fim.",
  rangeUnderflow: (e) => `O valor tem de ser ${e.minValue} ou posterior.`,
  unavailableDate: "Data selecionada indisponvel."
};
var W3 = {};
W3 = {
  rangeOverflow: (e) => `Valoarea trebuie s fie ${e.maxValue} sau anterioar.`,
  rangeReversed: "Data de nceput trebuie s fie anterioar datei de sfrit.",
  rangeUnderflow: (e) => `Valoarea trebuie s fie ${e.minValue} sau ulterioar.`,
  unavailableDate: "Data selectat nu este disponibil."
};
var Q3 = {};
Q3 = {
  rangeOverflow: (e) => `     ${e.maxValue}.`,
  rangeReversed: "     .",
  rangeUnderflow: (e) => `     ${e.minValue}.`,
  unavailableDate: "  ."
};
var G3 = {};
G3 = {
  rangeOverflow: (e) => `Hodnota mus by ${e.maxValue} alebo skoria.`,
  rangeReversed: "Dtum zaiatku mus by skor ako dtum konca.",
  rangeUnderflow: (e) => `Hodnota mus by ${e.minValue} alebo neskoria.`,
  unavailableDate: "Vybrat dtum je nedostupn."
};
var Z3 = {};
Z3 = {
  rangeOverflow: (e) => `Vrednost mora biti ${e.maxValue} ali stareja.`,
  rangeReversed: "Zaetni datum mora biti pred konnim datumom.",
  rangeUnderflow: (e) => `Vrednost mora biti ${e.minValue} ali noveja.`,
  unavailableDate: "Izbrani datum ni na voljo."
};
var Y3 = {};
Y3 = {
  rangeOverflow: (e) => `Vrednost mora da bude ${e.maxValue} ili starija.`,
  rangeReversed: "Datum poetka mora biti pre datuma zavretka.",
  rangeUnderflow: (e) => `Vrednost mora da bude ${e.minValue} ili novija.`,
  unavailableDate: "Izabrani datum nije dostupan."
};
var J3 = {};
J3 = {
  rangeOverflow: (e) => `Vrdet mste vara ${e.maxValue} eller tidigare.`,
  rangeReversed: "Startdatumet mste vara fre slutdatumet.",
  rangeUnderflow: (e) => `Vrdet mste vara ${e.minValue} eller senare.`,
  unavailableDate: "Det valda datumet r inte tillgngligt."
};
var X3 = {};
X3 = {
  rangeOverflow: (e) => `Deer, ${e.maxValue} veya ncesi olmaldr.`,
  rangeReversed: "Balang tarihi biti tarihinden nce olmaldr.",
  rangeUnderflow: (e) => `Deer, ${e.minValue} veya sonras olmaldr.`,
  unavailableDate: "Seilen tarih kullanlamyor."
};
var e1 = {};
e1 = {
  rangeOverflow: (e) => `     ${e.maxValue}.`,
  rangeReversed: "     .",
  rangeUnderflow: (e) => `     ${e.minValue}.`,
  unavailableDate: "  ."
};
var t1 = {};
t1 = {
  rangeOverflow: (e) => ` ${e.maxValue} `,
  rangeReversed: "",
  rangeUnderflow: (e) => ` ${e.minValue} `,
  unavailableDate: ""
};
var r1 = {};
r1 = {
  rangeOverflow: (e) => ` ${e.maxValue} `,
  rangeReversed: "",
  rangeUnderflow: (e) => ` ${e.minValue} `,
  unavailableDate: ""
};
var n1 = {};
n1 = {
  "ar-AE": E3,
  "bg-BG": w3,
  "cs-CZ": C3,
  "da-DK": S3,
  "de-DE": k3,
  "el-GR": P3,
  "en-US": T3,
  "es-ES": A3,
  "et-EE": _3,
  "fi-FI": F3,
  "fr-FR": O3,
  "he-IL": I3,
  "hr-HR": R3,
  "hu-HU": B3,
  "it-IT": M3,
  "ja-JP": N3,
  "ko-KR": L3,
  "lt-LT": V3,
  "lv-LV": z3,
  "nb-NO": j3,
  "nl-NL": K3,
  "pl-PL": U3,
  "pt-BR": q3,
  "pt-PT": H3,
  "ro-RO": W3,
  "ru-RU": Q3,
  "sk-SK": G3,
  "sl-SI": Z3,
  "sr-SP": Y3,
  "sv-SE": J3,
  "tr-TR": X3,
  "uk-UA": e1,
  "zh-CN": t1,
  "zh-TW": r1
};
function xS(e) {
  return e && e.__esModule ? e.default : e;
}
const i1 = new Gr(xS(n1));
function a1() {
  return typeof navigator < "u" && (navigator.language || navigator.userLanguage) || "en-US";
}
function xc(e, t, r, n, i) {
  let a = e != null && r != null && e.compare(r) > 0, o = e != null && t != null && e.compare(t) < 0, s = e != null && (n == null ? void 0 : n(e)) || !1, u = a || o || s, l = [];
  if (u) {
    let c = a1(), d = Gr.getGlobalDictionaryForPackage("@react-stately/datepicker") || i1, f = new vy(c, d), h = new Yt(c, Ta({}, i)), p = h.resolvedOptions().timeZone;
    o && l.push(f.format("rangeUnderflow", {
      minValue: h.format(t.toDate(p))
    })), a && l.push(f.format("rangeOverflow", {
      maxValue: h.format(r.toDate(p))
    })), s && l.push(f.format("unavailableDate"));
  }
  return {
    isInvalid: u,
    validationErrors: l,
    validationDetails: {
      badInput: s,
      customError: !1,
      patternMismatch: !1,
      rangeOverflow: a,
      rangeUnderflow: o,
      stepMismatch: !1,
      tooLong: !1,
      tooShort: !1,
      typeMismatch: !1,
      valueMissing: !1,
      valid: !u
    }
  };
}
function DS(e, t, r, n, i) {
  let a = xc(e == null ? void 0 : e.start, t, r, n, i), o = xc(e == null ? void 0 : e.end, t, r, n, i), s = us(a, o);
  if (e.end != null && e.start != null && e.end.compare(e.start) < 0) {
    let u = Gr.getGlobalDictionaryForPackage("@react-stately/datepicker") || i1;
    s = us(s, {
      isInvalid: !0,
      validationErrors: [
        u.getStringForLocale("rangeReversed", a1())
      ],
      validationDetails: {
        ...ru,
        rangeUnderflow: !0,
        rangeOverflow: !0,
        valid: !1
      }
    });
  }
  return s;
}
const ES = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "2-digit",
  second: "2-digit"
}, wS = {
  year: "numeric",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit"
};
function Ta(e, t) {
  e = {
    ...t.shouldForceLeadingZeros ? wS : ES,
    ...e
  };
  let n = t.granularity || "minute", i = Object.keys(e);
  var a;
  let o = i.indexOf((a = t.maxGranularity) !== null && a !== void 0 ? a : "year");
  o < 0 && (o = 0);
  let s = i.indexOf(n);
  if (s < 0 && (s = 2), o > s) throw new Error("maxGranularity must be greater than granularity");
  let u = i.slice(o, s + 1).reduce((c, d) => (c[d] = e[d], c), {});
  return t.hourCycle != null && (u.hour12 = t.hourCycle === 12), u.timeZone = t.timeZone || "UTC", (n === "hour" || n === "minute" || n === "second") && t.timeZone && !t.hideTimeZone && (u.timeZoneName = "short"), t.showEra && o === 0 && (u.era = "short"), u;
}
function bo(e) {
  return e && "hour" in e ? e : new Nd();
}
function o1(e, t) {
  if (e === null) return null;
  if (e)
    return ze(e, t);
}
function Ni(e, t, r, n) {
  if (e) return o1(e, r);
  let i = ze(by(n).set({
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  }), r);
  return t === "year" || t === "month" || t === "day" ? $t(i) : n ? i : xr(i);
}
function s1(e, t) {
  let r = e && "timeZone" in e ? e.timeZone : void 0, n = e && "minute" in e ? "minute" : "day";
  if (e && t && !(t in e)) throw new Error("Invalid granularity " + t + " for value " + e.toString());
  let [i, a] = ee([
    n,
    r
  ]);
  e && (i[0] !== n || i[1] !== r) && a([
    n,
    r
  ]), t || (t = e ? n : i[0]);
  let o = e ? r : i[1];
  return [
    t,
    o
  ];
}
const CS = new Gr({
  ach: {
    year: "mwaka",
    month: "dwe",
    day: "nino"
  },
  af: {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  am: {
    year: "",
    month: "",
    day: ""
  },
  an: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  ar: {
    year: "",
    month: "",
    day: ""
  },
  ast: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  az: {
    year: "iiii",
    month: "aa",
    day: "gg"
  },
  be: {
    year: "",
    month: "",
    day: ""
  },
  bg: {
    year: "",
    month: "",
    day: ""
  },
  bn: {
    year: "yyyy",
    month: "",
    day: "dd"
  },
  br: {
    year: "bbbb",
    month: "mm",
    day: "dd"
  },
  bs: {
    year: "gggg",
    month: "mm",
    day: "dd"
  },
  ca: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  cak: {
    year: "jjjj",
    month: "ii",
    day: "q'q'"
  },
  ckb: {
    year: "",
    month: "",
    day: ""
  },
  cs: {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  cy: {
    year: "bbbb",
    month: "mm",
    day: "dd"
  },
  da: {
    year: "",
    month: "mm",
    day: "dd"
  },
  de: {
    year: "jjjj",
    month: "mm",
    day: "tt"
  },
  dsb: {
    year: "llll",
    month: "mm",
    day: ""
  },
  el: {
    year: "",
    month: "",
    day: ""
  },
  en: {
    year: "yyyy",
    month: "mm",
    day: "dd"
  },
  eo: {
    year: "jjjj",
    month: "mm",
    day: "tt"
  },
  es: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  et: {
    year: "aaaa",
    month: "kk",
    day: "pp"
  },
  eu: {
    year: "uuuu",
    month: "hh",
    day: "ee"
  },
  fa: {
    year: "",
    month: "",
    day: ""
  },
  ff: {
    year: "hhhh",
    month: "ll",
    day: ""
  },
  fi: {
    year: "vvvv",
    month: "kk",
    day: "pp"
  },
  fr: {
    year: "aaaa",
    month: "mm",
    day: "jj"
  },
  fy: {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  ga: {
    year: "bbbb",
    month: "mm",
    day: "ll"
  },
  gd: {
    year: "bbbb",
    month: "mm",
    day: "ll"
  },
  gl: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  he: {
    year: "",
    month: "",
    day: ""
  },
  hr: {
    year: "gggg",
    month: "mm",
    day: "dd"
  },
  hsb: {
    year: "llll",
    month: "mm",
    day: "dd"
  },
  hu: {
    year: "",
    month: "hh",
    day: "nn"
  },
  ia: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  id: {
    year: "tttt",
    month: "bb",
    day: "hh"
  },
  it: {
    year: "aaaa",
    month: "mm",
    day: "gg"
  },
  ja: {
    year: "  ",
    month: "",
    day: ""
  },
  ka: {
    year: "",
    month: "",
    day: ""
  },
  kk: {
    year: "",
    month: "",
    day: ""
  },
  kn: {
    year: "",
    month: "",
    day: ""
  },
  ko: {
    year: "",
    month: "",
    day: ""
  },
  lb: {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  lo: {
    year: "",
    month: "",
    day: ""
  },
  lt: {
    year: "mmmm",
    month: "mm",
    day: "dd"
  },
  lv: {
    year: "gggg",
    month: "mm",
    day: "dd"
  },
  meh: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  ml: {
    year: "",
    month: "",
    day: ""
  },
  ms: {
    year: "tttt",
    month: "mm",
    day: "hh"
  },
  nl: {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  nn: {
    year: "",
    month: "mm",
    day: "dd"
  },
  no: {
    year: "",
    month: "mm",
    day: "dd"
  },
  oc: {
    year: "aaaa",
    month: "mm",
    day: "jj"
  },
  pl: {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  pt: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  rm: {
    year: "oooo",
    month: "mm",
    day: "dd"
  },
  ro: {
    year: "aaaa",
    month: "ll",
    day: "zz"
  },
  ru: {
    year: "",
    month: "",
    day: ""
  },
  sc: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  scn: {
    year: "aaaa",
    month: "mm",
    day: "jj"
  },
  sk: {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  sl: {
    year: "llll",
    month: "mm",
    day: "dd"
  },
  sr: {
    year: "",
    month: "",
    day: ""
  },
  sv: {
    year: "",
    month: "mm",
    day: "dd"
  },
  szl: {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  tg: {
    year: "",
    month: "",
    day: ""
  },
  th: {
    year: "",
    month: "",
    day: ""
  },
  tr: {
    year: "yyyy",
    month: "aa",
    day: "gg"
  },
  uk: {
    year: "",
    month: "",
    day: ""
  },
  "zh-CN": {
    year: "",
    month: "",
    day: ""
  },
  "zh-TW": {
    year: "",
    month: "",
    day: ""
  }
}, "en");
function SS(e, t, r) {
  return e === "era" || e === "dayPeriod" ? t : e === "year" || e === "month" || e === "day" ? CS.getStringForLocale(e, r) : "";
}
const $o = {
  year: !0,
  month: !0,
  day: !0,
  hour: !0,
  minute: !0,
  second: !0,
  dayPeriod: !0,
  era: !0
}, Tp = {
  year: 5,
  month: 2,
  day: 7,
  hour: 2,
  minute: 15,
  second: 15
}, kS = {
  dayperiod: "dayPeriod"
};
function u1(e) {
  let { locale: t, createCalendar: r, hideTimeZone: n, isDisabled: i, isReadOnly: a, isRequired: o, minValue: s, maxValue: u, isDateUnavailable: l } = e, c = e.value || e.defaultValue || e.placeholderValue, [d, f] = s1(c, e.granularity), h = f || "UTC";
  if (c && !(d in c)) throw new Error("Invalid granularity " + d + " for value " + c.toString());
  let p = G(() => new Yt(t), [
    t
  ]), v = G(() => r(p.resolvedOptions().calendar), [
    r,
    p
  ]), [g, $] = tr(e.value, e.defaultValue, e.onChange), m = G(() => o1(g, v), [
    g,
    v
  ]), [b, D] = ee(() => Ni(e.placeholderValue, d, v, f)), S = m || b, T = v.identifier === "gregory" && S.era === "BC", B = G(() => {
    var V;
    return {
      granularity: d,
      maxGranularity: (V = e.maxGranularity) !== null && V !== void 0 ? V : "year",
      timeZone: f,
      hideTimeZone: n,
      hourCycle: e.hourCycle,
      showEra: T,
      shouldForceLeadingZeros: e.shouldForceLeadingZeros
    };
  }, [
    e.maxGranularity,
    d,
    e.hourCycle,
    e.shouldForceLeadingZeros,
    f,
    n,
    T
  ]), y = G(() => Ta({}, B), [
    B
  ]), _ = G(() => new Yt(t, y), [
    t,
    y
  ]), w = G(() => _.resolvedOptions(), [
    _
  ]), E = G(() => _.formatToParts(/* @__PURE__ */ new Date()).filter((V) => $o[V.type]).reduce((V, ie) => (V[ie.type] = !0, V), {}), [
    _
  ]), [k, C] = ee(() => e.value || e.defaultValue ? {
    ...E
  } : {}), A = q(), L = q(v.identifier);
  oe(() => {
    v.identifier !== L.current && (L.current = v.identifier, D((V) => Object.keys(k).length > 0 ? ze(V, v) : Ni(e.placeholderValue, d, v, f)));
  }, [
    v,
    d,
    k,
    f,
    e.placeholderValue
  ]), g && Object.keys(k).length < Object.keys(E).length && (k = {
    ...E
  }, C(k)), g == null && Object.keys(k).length === Object.keys(E).length && (k = {}, C(k), D(Ni(e.placeholderValue, d, v, f)));
  let I = m && Object.keys(k).length >= Object.keys(E).length ? m : b, x = (V) => {
    if (e.isDisabled || e.isReadOnly) return;
    let ie = Object.keys(k), we = Object.keys(E);
    V == null ? ($(null), D(Ni(e.placeholderValue, d, v, f)), C({})) : ie.length >= we.length || ie.length === we.length - 1 && E.dayPeriod && !k.dayPeriod && A.current !== "dayPeriod" ? (V = ze(V, (c == null ? void 0 : c.calendar) || new xt()), $(V)) : D(V), A.current = null;
  }, U = G(() => I.toDate(h), [
    I,
    h
  ]), K = G(() => _.formatToParts(U).map((V) => {
    let ie = $o[V.type];
    V.type === "era" && v.getEras().length === 1 && (ie = !1);
    let we = $o[V.type] && !k[V.type], Ke = $o[V.type] ? SS(V.type, V.value, t) : null;
    return {
      type: kS[V.type] || V.type,
      text: we ? Ke : V.value,
      ...PS(I, V.type, w),
      isPlaceholder: we,
      placeholder: Ke,
      isEditable: ie
    };
  }), [
    U,
    k,
    _,
    w,
    I,
    v,
    t
  ]);
  E.era && k.year && !k.era ? (k.era = !0, C({
    ...k
  })) : !E.era && k.era && (delete k.era, C({
    ...k
  }));
  let z = (V) => {
    k[V] = !0, V === "year" && E.era && (k.era = !0), C({
      ...k
    });
  }, ae = (V, ie) => {
    if (k[V])
      x(TS(I, V, ie, w));
    else {
      z(V);
      let we = Object.keys(k), Ke = Object.keys(E);
      (we.length >= Ke.length || we.length === Ke.length - 1 && E.dayPeriod && !k.dayPeriod) && x(I);
    }
  }, ne = G(() => xc(g, s, u, l, B), [
    g,
    s,
    u,
    l,
    B
  ]), ye = Ka({
    ...e,
    value: g,
    builtinValidation: ne
  }), De = ye.displayValidation.isInvalid, Fe = e.validationState || (De ? "invalid" : null);
  var Oe;
  return {
    ...ye,
    value: m,
    dateValue: U,
    calendar: v,
    setValue: x,
    segments: K,
    dateFormatter: _,
    validationState: Fe,
    isInvalid: De,
    granularity: d,
    maxGranularity: (Oe = e.maxGranularity) !== null && Oe !== void 0 ? Oe : "year",
    isDisabled: i,
    isReadOnly: a,
    isRequired: o,
    increment(V) {
      ae(V, 1);
    },
    decrement(V) {
      ae(V, -1);
    },
    incrementPage(V) {
      ae(V, Tp[V] || 1);
    },
    decrementPage(V) {
      ae(V, -(Tp[V] || 1));
    },
    setSegment(V, ie) {
      z(V), x(AS(I, V, ie, w));
    },
    confirmPlaceholder() {
      if (e.isDisabled || e.isReadOnly) return;
      let V = Object.keys(k), ie = Object.keys(E);
      V.length === ie.length - 1 && E.dayPeriod && !k.dayPeriod && (k = {
        ...E
      }, C(k), x(I.copy()));
    },
    clearSegment(V) {
      delete k[V], A.current = V, C({
        ...k
      });
      let ie = Ni(e.placeholderValue, d, v, f), we = I;
      if (V === "dayPeriod" && "hour" in I && "hour" in ie) {
        let Ke = I.hour >= 12, We = ie.hour >= 12;
        Ke && !We ? we = I.set({
          hour: I.hour - 12
        }) : !Ke && We && (we = I.set({
          hour: I.hour + 12
        }));
      } else V in I && (we = I.set({
        [V]: ie[V]
      }));
      $(null), x(we);
    },
    formatValue(V) {
      if (!m) return "";
      let ie = Ta(V, B);
      return new Yt(t, ie).format(U);
    }
  };
}
function PS(e, t, r) {
  switch (t) {
    case "era": {
      let n = e.calendar.getEras();
      return {
        value: n.indexOf(e.era),
        minValue: 0,
        maxValue: n.length - 1
      };
    }
    case "year":
      return {
        value: e.year,
        minValue: 1,
        maxValue: e.calendar.getYearsInEra(e)
      };
    case "month":
      return {
        value: e.month,
        minValue: Vw(e),
        maxValue: e.calendar.getMonthsInYear(e)
      };
    case "day":
      return {
        value: e.day,
        minValue: zw(e),
        maxValue: e.calendar.getDaysInMonth(e)
      };
  }
  if ("hour" in e) switch (t) {
    case "dayPeriod":
      return {
        value: e.hour >= 12 ? 12 : 0,
        minValue: 0,
        maxValue: 12
      };
    case "hour":
      if (r.hour12) {
        let n = e.hour >= 12;
        return {
          value: e.hour,
          minValue: n ? 12 : 0,
          maxValue: n ? 23 : 11
        };
      }
      return {
        value: e.hour,
        minValue: 0,
        maxValue: 23
      };
    case "minute":
      return {
        value: e.minute,
        minValue: 0,
        maxValue: 59
      };
    case "second":
      return {
        value: e.second,
        minValue: 0,
        maxValue: 59
      };
  }
  return {};
}
function TS(e, t, r, n) {
  switch (t) {
    case "era":
    case "year":
    case "month":
    case "day":
      return e.cycle(t, r, {
        round: t === "year"
      });
  }
  if ("hour" in e) switch (t) {
    case "dayPeriod": {
      let i = e.hour, a = i >= 12;
      return e.set({
        hour: a ? i - 12 : i + 12
      });
    }
    case "hour":
    case "minute":
    case "second":
      return e.cycle(t, r, {
        round: t !== "hour",
        hourCycle: n.hour12 ? 12 : 24
      });
  }
}
function AS(e, t, r, n) {
  switch (t) {
    case "day":
    case "month":
    case "year":
    case "era":
      return e.set({
        [t]: r
      });
  }
  if ("hour" in e) switch (t) {
    case "dayPeriod": {
      let i = e.hour, a = i >= 12;
      return r >= 12 === a ? e : e.set({
        hour: a ? i - 12 : i + 12
      });
    }
    case "hour":
      if (n.hour12) {
        let a = e.hour >= 12;
        !a && r === 12 && (r = 0), a && r < 12 && (r += 12);
      }
    case "minute":
    case "second":
      return e.set({
        [t]: r
      });
  }
}
function _S(e) {
  var t, r;
  let n = wi(e), [i, a] = tr(e.value, e.defaultValue || null, e.onChange), [o, s] = ee(() => i || {
    start: null,
    end: null
  });
  i == null && o.start && o.end && (o = {
    start: null,
    end: null
  }, s(o));
  let u = i || o, l = (I) => {
    s(I || {
      start: null,
      end: null
    }), I != null && I.start && I.end ? a(I) : a(null);
  }, c = (u == null ? void 0 : u.start) || (u == null ? void 0 : u.end) || e.placeholderValue, [d, f] = s1(c, e.granularity), h = d === "hour" || d === "minute" || d === "second";
  var p;
  let v = (p = e.shouldCloseOnSelect) !== null && p !== void 0 ? p : !0, [g, $] = ee(null), [m, b] = ee(null);
  u && u.start && u.end && (g = u, "hour" in u.start && (m = u));
  let D = (I, x) => {
    l({
      start: "timeZone" in x.start ? x.start.set($t(I.start)) : xr(I.start, x.start),
      end: "timeZone" in x.end ? x.end.set($t(I.end)) : xr(I.end, x.end)
    }), $(null), b(null), C.commitValidation();
  }, S = (I) => {
    let x = typeof v == "function" ? v() : v;
    h ? x || I.start && I.end && (m != null && m.start) && (m != null && m.end) ? D(I, {
      start: (m == null ? void 0 : m.start) || bo(e.placeholderValue),
      end: (m == null ? void 0 : m.end) || bo(e.placeholderValue)
    }) : $(I) : I.start && I.end ? (l(I), C.commitValidation()) : $(I), x && n.setOpen(!1);
  }, T = (I) => {
    g != null && g.start && (g != null && g.end) && I.start && I.end ? D(g, I) : b(I);
  }, B = (u == null || (t = u.start) === null || t === void 0 ? void 0 : t.calendar.identifier) === "gregory" && u.start.era === "BC" || (u == null || (r = u.end) === null || r === void 0 ? void 0 : r.calendar.identifier) === "gregory" && u.end.era === "BC", y = G(() => ({
    granularity: d,
    timeZone: f,
    hideTimeZone: e.hideTimeZone,
    hourCycle: e.hourCycle,
    shouldForceLeadingZeros: e.shouldForceLeadingZeros,
    showEra: B
  }), [
    d,
    e.hourCycle,
    e.shouldForceLeadingZeros,
    f,
    e.hideTimeZone,
    B
  ]), { minValue: _, maxValue: w, isDateUnavailable: E } = e, k = G(() => DS(u, _, w, E, y), [
    u,
    _,
    w,
    E,
    y
  ]), C = Ka({
    ...e,
    value: i,
    name: G(() => [
      e.startName,
      e.endName
    ], [
      e.startName,
      e.endName
    ]),
    builtinValidation: k
  }), A = C.displayValidation.isInvalid, L = e.validationState || (A ? "invalid" : null);
  return {
    ...C,
    value: u,
    setValue: l,
    dateRange: g,
    timeRange: m,
    granularity: d,
    hasTime: h,
    setDate(I, x) {
      S({
        ...g,
        [I]: x
      });
    },
    setTime(I, x) {
      T({
        ...m,
        [I]: x
      });
    },
    setDateTime(I, x) {
      l({
        ...u,
        [I]: x
      });
    },
    setDateRange: S,
    setTimeRange: T,
    ...n,
    setOpen(I) {
      !I && !(u != null && u.start && (u != null && u.end)) && (g != null && g.start) && (g != null && g.end) && h && D(g, {
        start: (m == null ? void 0 : m.start) || bo(e.placeholderValue),
        end: (m == null ? void 0 : m.end) || bo(e.placeholderValue)
      }), n.setOpen(I);
    },
    validationState: L,
    isInvalid: A,
    formatValue(I, x) {
      if (!u || !u.start || !u.end) return null;
      let U = "timeZone" in u.start ? u.start.timeZone : void 0, K = e.granularity || (u.start && "minute" in u.start ? "minute" : "day"), z = "timeZone" in u.end ? u.end.timeZone : void 0, ae = e.granularity || (u.end && "minute" in u.end ? "minute" : "day"), ne = Ta(x, {
        granularity: K,
        timeZone: U,
        hideTimeZone: e.hideTimeZone,
        hourCycle: e.hourCycle,
        showEra: u.start.calendar.identifier === "gregory" && u.start.era === "BC" || u.end.calendar.identifier === "gregory" && u.end.era === "BC"
      }), ye = u.start.toDate(U || "UTC"), De = u.end.toDate(z || "UTC"), Fe = new Yt(I, ne), Oe;
      if (U === z && K === ae && u.start.compare(u.end) !== 0) {
        try {
          let V = Fe.formatRangeToParts(ye, De), ie = -1;
          for (let We = 0; We < V.length; We++) {
            let kr = V[We];
            if (kr.source === "shared" && kr.type === "literal") ie = We;
            else if (kr.source === "endRange") break;
          }
          let we = "", Ke = "";
          for (let We = 0; We < V.length; We++)
            We < ie ? we += V[We].value : We > ie && (Ke += V[We].value);
          return {
            start: we,
            end: Ke
          };
        } catch {
        }
        Oe = Fe;
      } else {
        let V = Ta(x, {
          granularity: ae,
          timeZone: z,
          hideTimeZone: e.hideTimeZone,
          hourCycle: e.hourCycle
        });
        Oe = new Yt(I, V);
      }
      return {
        start: Fe.format(ye),
        end: Oe.format(De)
      };
    }
  };
}
function FS(e) {
  let t = wi(e), [r, n] = ee(null), i = x3({
    ...e,
    onSelectionChange: (u) => {
      e.onSelectionChange != null && e.onSelectionChange(u), t.close(), a.commitValidation();
    }
  }), a = Ka({
    ...e,
    value: i.selectedKey
  }), [o, s] = ee(!1);
  return {
    ...a,
    ...i,
    ...t,
    focusStrategy: r,
    open(u = null) {
      i.collection.size !== 0 && (n(u), t.open());
    },
    toggle(u = null) {
      i.collection.size !== 0 && (n(u), t.toggle());
    },
    isFocused: o,
    setFocused: s
  };
}
const OS = /* @__PURE__ */ ce({}), l1 = /* @__PURE__ */ ce({}), cu = /* @__PURE__ */ ce(null), du = /* @__PURE__ */ ce(null);
function IS(e, t) {
  [e, t] = je(e, t, OS);
  let { locale: r } = st(), n = b3({
    ...e,
    locale: r,
    createCalendar: eu
  }), { calendarProps: i, prevButtonProps: a, nextButtonProps: o, errorMessageProps: s, title: u } = UC(e, n), l = Ye({
    ...e,
    values: {
      state: n,
      isDisabled: e.isDisabled || !1,
      isInvalid: n.isValueInvalid
    },
    defaultClassName: "react-aria-Calendar"
  });
  return /* @__PURE__ */ P.createElement("div", {
    ...l,
    ...i,
    ref: t,
    slot: e.slot || void 0,
    "data-disabled": e.isDisabled || void 0,
    "data-invalid": n.isValueInvalid || void 0
  }, /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        Ei,
        {
          slots: {
            previous: a,
            next: o
          }
        }
      ],
      [
        Us,
        {
          "aria-hidden": !0,
          level: 2,
          children: u
        }
      ],
      [
        cu,
        n
      ],
      [
        nr,
        {
          slots: {
            errorMessage: s
          }
        }
      ]
    ]
  }, /* @__PURE__ */ P.createElement(Ca, null, /* @__PURE__ */ P.createElement("h2", null, i["aria-label"])), l.children, /* @__PURE__ */ P.createElement(Ca, null, /* @__PURE__ */ P.createElement("button", {
    "aria-label": o["aria-label"],
    disabled: o.isDisabled,
    onClick: () => n.focusNextPage(),
    tabIndex: -1
  }))));
}
const RS = /* @__PURE__ */ xe(IS);
function BS(e, t) {
  [e, t] = je(e, t, l1);
  let { locale: r } = st(), n = mS({
    ...e,
    locale: r,
    createCalendar: eu
  }), { calendarProps: i, prevButtonProps: a, nextButtonProps: o, errorMessageProps: s, title: u } = qC(e, n, t), l = Ye({
    ...e,
    values: {
      state: n,
      isDisabled: e.isDisabled || !1,
      isInvalid: n.isValueInvalid
    },
    defaultClassName: "react-aria-RangeCalendar"
  });
  return /* @__PURE__ */ P.createElement("div", {
    ...l,
    ...i,
    ref: t,
    slot: e.slot || void 0,
    "data-disabled": e.isDisabled || void 0,
    "data-invalid": n.isValueInvalid || void 0
  }, /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        Ei,
        {
          slots: {
            previous: a,
            next: o
          }
        }
      ],
      [
        Us,
        {
          "aria-hidden": !0,
          level: 2,
          children: u
        }
      ],
      [
        du,
        n
      ],
      [
        nr,
        {
          slots: {
            errorMessage: s
          }
        }
      ]
    ]
  }, /* @__PURE__ */ P.createElement(Ca, null, /* @__PURE__ */ P.createElement("h2", null, i["aria-label"])), l.children, /* @__PURE__ */ P.createElement(Ca, null, /* @__PURE__ */ P.createElement("button", {
    "aria-label": o["aria-label"],
    disabled: o.isDisabled,
    onClick: () => n.focusNextPage(),
    tabIndex: -1
  }))));
}
const MS = /* @__PURE__ */ xe(BS), fu = /* @__PURE__ */ ce(null);
function NS(e, t) {
  let r = le(cu), n = le(du), i = r ?? n, a = i.visibleRange.start;
  e.offset && (a = a.add(e.offset));
  let { gridProps: o, headerProps: s, weekDays: u } = HC({
    startDate: a,
    endDate: fi(a),
    weekdayStyle: e.weekdayStyle
  }, i);
  var l;
  return /* @__PURE__ */ P.createElement(fu.Provider, {
    value: {
      headerProps: s,
      weekDays: u,
      startDate: a
    }
  }, /* @__PURE__ */ P.createElement("table", {
    ..._e(e),
    ...o,
    ref: t,
    style: e.style,
    className: (l = e.className) !== null && l !== void 0 ? l : "react-aria-CalendarGrid"
  }, typeof e.children != "function" ? e.children : /* @__PURE__ */ P.createElement(P.Fragment, null, /* @__PURE__ */ P.createElement(d1, null, (c) => /* @__PURE__ */ P.createElement(f1, null, c)), /* @__PURE__ */ P.createElement(Jd, null, e.children))));
}
const c1 = /* @__PURE__ */ xe(NS);
function LS(e, t) {
  let { children: r, style: n, className: i } = e, { headerProps: a, weekDays: o } = le(fu);
  return /* @__PURE__ */ P.createElement("thead", {
    ..._e(e),
    ...a,
    ref: t,
    style: n,
    className: i || "react-aria-CalendarGridHeader"
  }, /* @__PURE__ */ P.createElement("tr", null, o.map((s, u) => /* @__PURE__ */ P.cloneElement(r(s), {
    key: u
  }))));
}
const d1 = /* @__PURE__ */ xe(LS);
function VS(e, t) {
  let { children: r, style: n, className: i } = e;
  return /* @__PURE__ */ P.createElement("th", {
    ..._e(e),
    ref: t,
    style: n,
    className: i || "react-aria-CalendarHeaderCell"
  }, r);
}
const f1 = /* @__PURE__ */ xe(VS);
function zS(e, t) {
  let { children: r, style: n, className: i } = e, a = le(cu), o = le(du), s = a ?? o, { startDate: u } = le(fu), { locale: l } = st(), c = Uw(u, l);
  return /* @__PURE__ */ P.createElement("tbody", {
    ..._e(e),
    ref: t,
    style: n,
    className: i || "react-aria-CalendarGridBody"
  }, [
    ...new Array(c).keys()
  ].map((d) => /* @__PURE__ */ P.createElement("tr", {
    key: d
  }, s.getDatesInWeek(d, u).map((f, h) => f ? /* @__PURE__ */ P.cloneElement(r(f), {
    key: h
  }) : /* @__PURE__ */ P.createElement("td", {
    key: h
  })))));
}
const Jd = /* @__PURE__ */ xe(zS);
function jS({ date: e, ...t }, r) {
  let n = le(cu), i = le(du), a = n ?? i;
  var o;
  let { startDate: s } = (o = le(fu)) !== null && o !== void 0 ? o : {
    startDate: a.visibleRange.start
  }, u = q(null), { cellProps: l, buttonProps: c, ...d } = QC({
    date: e
  }, a, u), { hoverProps: f, isHovered: h } = Sn({
    ...t,
    isDisabled: d.isDisabled
  }), { focusProps: p, isFocusVisible: v } = Qr();
  v && (v = d.isFocused);
  let g = !Mw(s, e), $ = !1, m = !1;
  "highlightedRange" in a && a.highlightedRange && ($ = tt(e, a.highlightedRange.start), m = tt(e, a.highlightedRange.end));
  let b = Ye({
    ...t,
    defaultChildren: d.formattedDate,
    defaultClassName: "react-aria-CalendarCell",
    values: {
      date: e,
      isHovered: h,
      isOutsideMonth: g,
      isFocusVisible: v,
      isSelectionStart: $,
      isSelectionEnd: m,
      ...d
    }
  }), D = {
    "data-focused": d.isFocused || void 0,
    "data-hovered": h || void 0,
    "data-pressed": d.isPressed || void 0,
    "data-unavailable": d.isUnavailable || void 0,
    "data-disabled": d.isDisabled || void 0,
    "data-focus-visible": v || void 0,
    "data-outside-visible-range": d.isOutsideVisibleRange || void 0,
    "data-outside-month": g || void 0,
    "data-selected": d.isSelected || void 0,
    "data-selection-start": $ || void 0,
    "data-selection-end": m || void 0,
    "data-invalid": d.isInvalid || void 0
  };
  return /* @__PURE__ */ P.createElement("td", {
    ...l,
    ref: r
  }, /* @__PURE__ */ P.createElement("div", {
    ...ve(_e(t), c, p, f, D, b),
    ref: u
  }));
}
const h1 = /* @__PURE__ */ xe(jS), kn = /* @__PURE__ */ ce(null);
function KS(e, t) {
  let r = le(kn);
  return r != null && r.isInvalid ? /* @__PURE__ */ P.createElement(qS, {
    ...e,
    ref: t
  }) : null;
}
const US = /* @__PURE__ */ xe(KS), qS = /* @__PURE__ */ xe((e, t) => {
  let r = le(kn), n = Ye({
    ...e,
    defaultClassName: "react-aria-FieldError",
    defaultChildren: r.validationErrors.length === 0 ? void 0 : r.validationErrors.join(" "),
    values: r
  });
  return n.children == null ? null : /* @__PURE__ */ P.createElement(lu, {
    slot: "errorMessage",
    ...n,
    ref: t
  });
}), xn = /* @__PURE__ */ ce(null);
function HS(e, t) {
  [e, t] = je(e, t, xn);
  let { validationErrors: r, validationBehavior: n = "native", children: i, className: a, ...o } = e;
  return /* @__PURE__ */ P.createElement("form", {
    noValidate: n !== "native",
    ...o,
    ref: t,
    className: a || "react-aria-Form"
  }, /* @__PURE__ */ P.createElement(xn.Provider, {
    value: {
      ...e,
      validationBehavior: n
    }
  }, /* @__PURE__ */ P.createElement(_g.Provider, {
    value: r ?? {}
  }, i)));
}
const WS = /* @__PURE__ */ xe(HS), Ci = /* @__PURE__ */ ce({});
function QS(e, t) {
  [e, t] = je(e, t, Ci);
  let { elementType: r = "label", ...n } = e;
  return /* @__PURE__ */ P.createElement(r, {
    className: "react-aria-Label",
    ...n,
    ref: t
  });
}
const GS = /* @__PURE__ */ Yd(QS), Ua = /* @__PURE__ */ ce({});
let ZS = (e) => {
  let { onHoverStart: t, onHoverChange: r, onHoverEnd: n, ...i } = e;
  return i;
};
function YS(e, t) {
  [e, t] = je(e, t, Ua);
  let { hoverProps: r, isHovered: n } = Sn(e), { isFocused: i, isFocusVisible: a, focusProps: o } = Qr({
    isTextInput: !0,
    autoFocus: e.autoFocus
  }), s = !!e["aria-invalid"] && e["aria-invalid"] !== "false", u = Ye({
    ...e,
    values: {
      isHovered: n,
      isFocused: i,
      isFocusVisible: a,
      isDisabled: e.disabled || !1,
      isInvalid: s
    },
    defaultClassName: "react-aria-Input"
  });
  return /* @__PURE__ */ P.createElement("input", {
    ...ve(ZS(e), o, r),
    ...u,
    ref: t,
    "data-focused": i || void 0,
    "data-disabled": e.disabled || void 0,
    "data-hovered": n || void 0,
    "data-focus-visible": a || void 0,
    "data-invalid": s || void 0
  });
}
const p1 = /* @__PURE__ */ Yd(YS);
var m1 = {};
m1 = {
  colorSwatchPicker: " ",
  dropzoneLabel: "DropZone",
  selectPlaceholder: " ",
  tableResizer: "  "
};
var v1 = {};
v1 = {
  colorSwatchPicker: " ",
  dropzoneLabel: "DropZone",
  selectPlaceholder: " ",
  tableResizer: ""
};
var y1 = {};
y1 = {
  colorSwatchPicker: "Vzorky barev",
  dropzoneLabel: "Msto pro petaen",
  selectPlaceholder: "Vyberte poloku",
  tableResizer: "Zmna velikosti"
};
var g1 = {};
g1 = {
  colorSwatchPicker: "Farveprver",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Vlg et element",
  tableResizer: "Strrelsesndring"
};
var b1 = {};
b1 = {
  colorSwatchPicker: "Farbfelder",
  dropzoneLabel: "Ablegebereich",
  selectPlaceholder: "Element whlen",
  tableResizer: "Grenanpassung"
};
var $1 = {};
$1 = {
  colorSwatchPicker: " ",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "  ",
  tableResizer: " "
};
var x1 = {};
x1 = {
  selectPlaceholder: "Select an item",
  tableResizer: "Resizer",
  dropzoneLabel: "DropZone",
  colorSwatchPicker: "Color swatches"
};
var D1 = {};
D1 = {
  colorSwatchPicker: "Muestras de colores",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Seleccionar un artculo",
  tableResizer: "Cambiador de tamao"
};
var E1 = {};
E1 = {
  colorSwatchPicker: "Vrvinidised",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Valige ksus",
  tableResizer: "Suuruse muutja"
};
var w1 = {};
w1 = {
  colorSwatchPicker: "Vrimallit",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Valitse kohde",
  tableResizer: "Koon muuttaja"
};
var C1 = {};
C1 = {
  colorSwatchPicker: "chantillons de couleurs",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Slectionner un lment",
  tableResizer: "Redimensionneur"
};
var S1 = {};
S1 = {
  colorSwatchPicker: " ",
  dropzoneLabel: "DropZone",
  selectPlaceholder: " ",
  tableResizer: " "
};
var k1 = {};
k1 = {
  colorSwatchPicker: "Uzorci boja",
  dropzoneLabel: "Zona sputanja",
  selectPlaceholder: "Odaberite stavku",
  tableResizer: "Promjena veliine"
};
var P1 = {};
P1 = {
  colorSwatchPicker: "Szntrak",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Vlasszon ki egy elemet",
  tableResizer: "tmretez"
};
var T1 = {};
T1 = {
  colorSwatchPicker: "Campioni di colore",
  dropzoneLabel: "Zona di rilascio",
  selectPlaceholder: "Seleziona un elemento",
  tableResizer: "Ridimensionamento"
};
var A1 = {};
A1 = {
  colorSwatchPicker: "",
  dropzoneLabel: "",
  selectPlaceholder: "",
  tableResizer: ""
};
var _1 = {};
_1 = {
  colorSwatchPicker: " ",
  dropzoneLabel: " ",
  selectPlaceholder: " ",
  tableResizer: " "
};
var F1 = {};
F1 = {
  colorSwatchPicker: "Spalv pavyzdiai",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Pasirinkite element",
  tableResizer: "Dydio keitiklis"
};
var O1 = {};
O1 = {
  colorSwatchPicker: "Krsu paraugi",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Izvlties vienumu",
  tableResizer: "Izmra maintjs"
};
var I1 = {};
I1 = {
  colorSwatchPicker: "Fargekart",
  dropzoneLabel: "Droppsone",
  selectPlaceholder: "Velg et element",
  tableResizer: "Strrelsesendrer"
};
var R1 = {};
R1 = {
  colorSwatchPicker: "kleurstalen",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Selecteer een item",
  tableResizer: "Resizer"
};
var B1 = {};
B1 = {
  colorSwatchPicker: "Prbki kolorw",
  dropzoneLabel: "Strefa upuszczania",
  selectPlaceholder: "Wybierz element",
  tableResizer: "Zmiana rozmiaru"
};
var M1 = {};
M1 = {
  colorSwatchPicker: "Amostras de cores",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Selecione um item",
  tableResizer: "Redimensionador"
};
var N1 = {};
N1 = {
  colorSwatchPicker: "Amostras de cores",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Selecione um item",
  tableResizer: "Redimensionador"
};
var L1 = {};
L1 = {
  colorSwatchPicker: "Specimene de culoare",
  dropzoneLabel: "Zon de plasare",
  selectPlaceholder: "Selectai un element",
  tableResizer: "Instrument de redimensionare"
};
var V1 = {};
V1 = {
  colorSwatchPicker: " ",
  dropzoneLabel: "DropZone",
  selectPlaceholder: " ",
  tableResizer: "  "
};
var z1 = {};
z1 = {
  colorSwatchPicker: "Vzorkovnky farieb",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Vyberte poloku",
  tableResizer: "Nstroj na zmenu vekosti"
};
var j1 = {};
j1 = {
  colorSwatchPicker: "Barvne palete",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Izberite element",
  tableResizer: "Spreminjanje velikosti"
};
var K1 = {};
K1 = {
  colorSwatchPicker: "Uzorci boje",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Izaberite stavku",
  tableResizer: "Promena veliine"
};
var U1 = {};
U1 = {
  colorSwatchPicker: "Frgrutor",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Vlj en artikel",
  tableResizer: "Storleksndrare"
};
var q1 = {};
q1 = {
  colorSwatchPicker: "Renk rnekleri",
  dropzoneLabel: "Brakma Blgesi",
  selectPlaceholder: "Bir e sein",
  tableResizer: "Yeniden boyutlandrc"
};
var H1 = {};
H1 = {
  colorSwatchPicker: " ",
  dropzoneLabel: "DropZone",
  selectPlaceholder: " ",
  tableResizer: "  "
};
var W1 = {};
W1 = {
  colorSwatchPicker: "",
  dropzoneLabel: "",
  selectPlaceholder: "",
  tableResizer: ""
};
var Q1 = {};
Q1 = {
  colorSwatchPicker: "",
  dropzoneLabel: "",
  selectPlaceholder: "",
  tableResizer: ""
};
var G1 = {};
G1 = {
  "ar-AE": m1,
  "bg-BG": v1,
  "cs-CZ": y1,
  "da-DK": g1,
  "de-DE": b1,
  "el-GR": $1,
  "en-US": x1,
  "es-ES": D1,
  "et-EE": E1,
  "fi-FI": w1,
  "fr-FR": C1,
  "he-IL": S1,
  "hr-HR": k1,
  "hu-HU": P1,
  "it-IT": T1,
  "ja-JP": A1,
  "ko-KR": _1,
  "lt-LT": F1,
  "lv-LV": O1,
  "nb-NO": I1,
  "nl-NL": R1,
  "pl-PL": B1,
  "pt-BR": M1,
  "pt-PT": N1,
  "ro-RO": L1,
  "ru-RU": V1,
  "sk-SK": z1,
  "sl-SI": j1,
  "sr-SP": K1,
  "sv-SE": U1,
  "tr-TR": q1,
  "uk-UA": H1,
  "zh-CN": W1,
  "zh-TW": Q1
};
const Z1 = /* @__PURE__ */ ce(null);
function JS(e, t) {
  let { render: r } = le(Z1);
  return /* @__PURE__ */ P.createElement(P.Fragment, null, r(e, t));
}
const XS = /* @__PURE__ */ xe(JS), Xd = /* @__PURE__ */ ce({}), ek = /* @__PURE__ */ ce({});
function tk(e, t) {
  let [r, n] = je(e, t, ek), i = p3("header", e, t);
  return i || /* @__PURE__ */ P.createElement("header", {
    className: "react-aria-Header",
    ...r,
    ref: n
  }, r.children);
}
const Y1 = /* @__PURE__ */ xe(tk), J1 = /* @__PURE__ */ ce({});
function rk(e, t) {
  let [r, n] = je(e, t, J1), { elementType: i, orientation: a, style: o, className: s } = r, u = i || "hr";
  u === "hr" && a === "vertical" && (u = "div");
  let { separatorProps: l } = G7({
    elementType: i,
    orientation: a
  }), c = p3("separator", e, t);
  return c || /* @__PURE__ */ P.createElement(u, {
    ..._e(r),
    ...l,
    style: o,
    className: s ?? "react-aria-Separator",
    ref: n,
    slot: r.slot || void 0
  });
}
const nk = /* @__PURE__ */ xe(rk), qa = /* @__PURE__ */ ce(null), Si = /* @__PURE__ */ ce(null);
function ik(e, t) {
  [e, t] = je(e, t, qa);
  let r = le(ka), n = le(Si);
  return le(uu) ? /* @__PURE__ */ P.createElement(iS, e) : n ? r ? null : /* @__PURE__ */ P.createElement(X1, {
    state: n,
    props: e,
    listBoxRef: t
  }) : /* @__PURE__ */ P.createElement(ak, {
    props: e,
    listBoxRef: t
  });
}
function ak({ props: e, listBoxRef: t }) {
  let { portal: r, collection: n } = tS(e);
  e = {
    ...e,
    collection: n,
    children: null,
    items: null
  };
  let i = $3(e);
  return /* @__PURE__ */ P.createElement(P.Fragment, null, r, /* @__PURE__ */ P.createElement(X1, {
    state: i,
    props: e,
    listBoxRef: t
  }));
}
const ef = /* @__PURE__ */ xe(ik);
function X1({ state: e, props: t, listBoxRef: r }) {
  let { dragAndDropHooks: n, layout: i = "stack", orientation: a = "vertical" } = t, { collection: o, selectionManager: s } = e, u = !!(n != null && n.useDraggableCollectionState), l = !!(n != null && n.useDroppableCollectionState), { direction: c } = st(), { disabledBehavior: d, disabledKeys: f } = s, h = tu({
    usage: "search",
    sensitivity: "base"
  }), p = G(() => t.keyboardDelegate || new au({
    collection: o,
    collator: h,
    ref: r,
    disabledKeys: f,
    disabledBehavior: d,
    layout: i,
    orientation: a,
    direction: c
  }), [
    o,
    h,
    r,
    d,
    f,
    a,
    c,
    t.keyboardDelegate,
    i
  ]), { listBoxProps: v } = w7({
    ...t,
    shouldSelectOnPressUp: u || t.shouldSelectOnPressUp,
    keyboardDelegate: p
  }, e, r), g = Hd({
    items: o,
    children: (L) => {
      switch (L.type) {
        case "section":
          return /* @__PURE__ */ P.createElement(ok, {
            section: L
          });
        case "separator":
          return /* @__PURE__ */ P.createElement(nk, L.props);
        case "item":
          return /* @__PURE__ */ P.createElement(t$, {
            item: L
          });
        default:
          throw new Error("Unsupported node type in Menu: " + L.type);
      }
    }
  }), $ = q(u), m = q(l);
  oe(() => {
    $.current !== u && console.warn("Drag hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior."), m.current !== l && console.warn("Drop hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.");
  }, [
    u,
    l
  ]);
  let b, D, S, T = !1, B = null, y = q(null);
  if (u && n) {
    b = n.useDraggableCollectionState({
      collection: o,
      selectionManager: s,
      preview: n.renderDragPreview ? y : void 0
    }), n.useDraggableCollection({}, b, r);
    let L = n.DragPreview;
    B = n.renderDragPreview ? /* @__PURE__ */ P.createElement(L, {
      ref: y
    }, n.renderDragPreview) : null;
  }
  if (l && n) {
    D = n.useDroppableCollectionState({
      collection: o,
      selectionManager: s
    });
    let L = n.dropTargetDelegate || new n.ListDropTargetDelegate(o, r, {
      orientation: a,
      layout: i,
      direction: c
    });
    S = n.useDroppableCollection({
      keyboardDelegate: p,
      dropTargetDelegate: L
    }, D, r), T = D.isDropTarget({
      type: "root"
    });
  }
  let { focusProps: _, isFocused: w, isFocusVisible: E } = Qr(), k = {
    isDropTarget: T,
    isEmpty: e.collection.size === 0,
    isFocused: w,
    isFocusVisible: E,
    layout: t.layout || "stack",
    state: e
  }, C = Ye({
    className: t.className,
    style: t.style,
    defaultClassName: "react-aria-ListBox",
    values: k
  }), A = null;
  return e.collection.size === 0 && t.renderEmptyState && (A = /* @__PURE__ */ P.createElement("div", {
    // eslint-disable-next-line
    role: "option",
    style: {
      display: "contents"
    }
  }, t.renderEmptyState(k))), /* @__PURE__ */ P.createElement(fy, null, /* @__PURE__ */ P.createElement("div", {
    ..._e(t),
    ...ve(v, _, S == null ? void 0 : S.collectionProps),
    ...C,
    ref: r,
    slot: t.slot || void 0,
    onScroll: t.onScroll,
    "data-drop-target": T || void 0,
    "data-empty": e.collection.size === 0 || void 0,
    "data-focused": w || void 0,
    "data-focus-visible": E || void 0,
    "data-layout": t.layout || "stack",
    "data-orientation": t.orientation || "vertical"
  }, /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        qa,
        t
      ],
      [
        Si,
        e
      ],
      [
        Xd,
        {
          dragAndDropHooks: n,
          dragState: b,
          dropState: D
        }
      ],
      [
        J1,
        {
          elementType: "div"
        }
      ],
      [
        Z1,
        {
          render: lk
        }
      ]
    ]
  }, g), A, B));
}
function ok({ section: e, className: t, style: r }) {
  var n, i;
  let a = le(Si), [o, s] = Di();
  var u;
  let { headingProps: l, groupProps: c } = _7({
    heading: s,
    "aria-label": (u = e.props["aria-label"]) !== null && u !== void 0 ? u : void 0
  }), d = Hd({
    items: a.collection.getChildren(e.key),
    children: (f) => {
      switch (f.type) {
        case "header":
          return /* @__PURE__ */ P.createElement(sk, {
            item: f,
            headingProps: l,
            headingRef: o
          });
        case "item":
          return /* @__PURE__ */ P.createElement(t$, {
            item: f
          });
        default:
          throw new Error("Unsupported element type in Section: " + f.type);
      }
    }
  });
  return /* @__PURE__ */ P.createElement("section", {
    ..._e(e.props),
    ...c,
    className: t || ((n = e.props) === null || n === void 0 ? void 0 : n.className) || "react-aria-Section",
    style: r || ((i = e.props) === null || i === void 0 ? void 0 : i.style),
    ref: e.props.ref
  }, d);
}
function sk({ item: e, headingProps: t, headingRef: r }) {
  let { ref: n, ...i } = e.props;
  return /* @__PURE__ */ P.createElement(Y1, {
    ...t,
    ...i,
    ref: $d(r, n)
  }, e.rendered);
}
function uk(e, t) {
  return Gd("item", e, t, e.children);
}
const e$ = /* @__PURE__ */ xe(uk);
function t$({ item: e }) {
  var t;
  let r = Cn(e.props.ref), n = le(Si), { dragAndDropHooks: i, dragState: a, dropState: o } = le(Xd), { optionProps: s, labelProps: u, descriptionProps: l, ...c } = A7({
    key: e.key,
    "aria-label": (t = e.props) === null || t === void 0 ? void 0 : t["aria-label"]
  }, n, r), { hoverProps: d, isHovered: f } = Sn({
    isDisabled: !c.allowsSelection && !c.hasAction,
    onHoverStart: e.props.onHoverStart,
    onHoverChange: e.props.onHoverChange,
    onHoverEnd: e.props.onHoverEnd
  }), h = null;
  a && i && (h = i.useDraggableItem({
    key: e.key
  }, a));
  let p = null;
  o && i && (p = i.useDroppableItem({
    target: {
      type: "item",
      key: e.key,
      dropPosition: "on"
    }
  }, o, r));
  let v = e.props, g = a && a.isDragging(e.key), $ = Ye({
    ...v,
    id: void 0,
    children: e.rendered,
    defaultClassName: "react-aria-ListBoxItem",
    values: {
      ...c,
      isHovered: f,
      selectionMode: n.selectionManager.selectionMode,
      selectionBehavior: n.selectionManager.selectionBehavior,
      allowsDragging: !!a,
      isDragging: g,
      isDropTarget: p == null ? void 0 : p.isDropTarget
    }
  }), m = (i == null ? void 0 : i.renderDropIndicator) || ((D) => /* @__PURE__ */ P.createElement(XS, {
    target: D
  }));
  oe(() => {
    e.textValue || console.warn("A `textValue` prop is required for <ListBoxItem> elements with non-plain text children in order to support accessibility features such as type to select.");
  }, [
    e.textValue
  ]);
  let b = v.href ? "a" : "div";
  return /* @__PURE__ */ P.createElement(P.Fragment, null, (i == null ? void 0 : i.useDropIndicator) && m({
    type: "item",
    key: e.key,
    dropPosition: "before"
  }), /* @__PURE__ */ P.createElement(b, {
    ...ve(s, d, h == null ? void 0 : h.dragProps, p == null ? void 0 : p.dropProps),
    ...$,
    ref: r,
    "data-allows-dragging": !!a || void 0,
    "data-selected": c.isSelected || void 0,
    "data-disabled": c.isDisabled || void 0,
    "data-hovered": f || void 0,
    "data-focused": c.isFocused || void 0,
    "data-focus-visible": c.isFocusVisible || void 0,
    "data-pressed": c.isPressed || void 0,
    "data-dragging": g || void 0,
    "data-drop-target": (p == null ? void 0 : p.isDropTarget) || void 0,
    "data-selection-mode": n.selectionManager.selectionMode === "none" ? void 0 : n.selectionManager.selectionMode
  }, /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        nr,
        {
          slots: {
            label: u,
            description: l
          }
        }
      ]
    ]
  }, $.children)), (i == null ? void 0 : i.useDropIndicator) && n.collection.getKeyAfter(e.key) == null && m({
    type: "item",
    key: e.key,
    dropPosition: "after"
  }));
}
function lk(e, t) {
  t = Cn(t);
  let { dragAndDropHooks: r, dropState: n } = le(Xd), { dropIndicatorProps: i, isHidden: a, isDropTarget: o } = r.useDropIndicator(e, n, t);
  return a ? null : /* @__PURE__ */ P.createElement(dk, {
    ...e,
    dropIndicatorProps: i,
    isDropTarget: o,
    ref: t
  });
}
function ck(e, t) {
  let { dropIndicatorProps: r, isDropTarget: n, ...i } = e, a = Ye({
    ...i,
    defaultClassName: "react-aria-DropIndicator",
    values: {
      isDropTarget: n
    }
  });
  return /* @__PURE__ */ P.createElement("div", {
    ...r,
    ...a,
    // eslint-disable-next-line
    role: "option",
    ref: t,
    "data-drop-target": n || void 0
  });
}
const dk = /* @__PURE__ */ xe(ck), Ha = /* @__PURE__ */ ce({});
function fk(e, t) {
  [e, t] = je(e, t, Ha);
  let { isDisabled: r, isInvalid: n, onHoverStart: i, onHoverChange: a, onHoverEnd: o, ...s } = e, { hoverProps: u, isHovered: l } = Sn({
    onHoverStart: i,
    onHoverChange: a,
    onHoverEnd: o,
    isDisabled: r
  }), { isFocused: c, isFocusVisible: d, focusProps: f } = Qr({
    within: !0
  });
  r ?? (r = !!e["aria-disabled"] && e["aria-disabled"] !== "false"), n ?? (n = !!e["aria-invalid"] && e["aria-invalid"] !== "false");
  let h = Ye({
    ...e,
    values: {
      isHovered: l,
      isFocusWithin: c,
      isFocusVisible: d,
      isDisabled: r,
      isInvalid: n
    },
    defaultClassName: "react-aria-Group"
  });
  var p, v;
  return /* @__PURE__ */ P.createElement("div", {
    ...ve(s, f, u),
    ...h,
    ref: t,
    role: (p = e.role) !== null && p !== void 0 ? p : "group",
    slot: (v = e.slot) !== null && v !== void 0 ? v : void 0,
    "data-focus-within": c || void 0,
    "data-hovered": l || void 0,
    "data-focus-visible": d || void 0,
    "data-disabled": r || void 0,
    "data-invalid": n || void 0
  }, h.children);
}
const r$ = /* @__PURE__ */ xe(fk), n$ = /* @__PURE__ */ ce({
  placement: "bottom"
});
function hk(e, t) {
  [e, t] = je(e, t, n$);
  let r = e.placement, n = {
    position: "absolute",
    [r]: "100%",
    transform: r === "top" || r === "bottom" ? "translateX(-50%)" : "translateY(-50%)"
  }, i = Ye({
    ...e,
    defaultClassName: "react-aria-OverlayArrow",
    values: {
      placement: r
    }
  });
  return i.style && Object.keys(i.style).forEach((a) => i.style[a] === void 0 && delete i.style[a]), /* @__PURE__ */ P.createElement("div", {
    ...e,
    ...i,
    style: {
      ...n,
      ...i.style
    },
    ref: t,
    "data-placement": r
  });
}
const pk = /* @__PURE__ */ xe(hk), ki = /* @__PURE__ */ ce(null);
function mk(e, t) {
  [e, t] = je(e, t, ki);
  let r = le(Cr), n = wi(e), i = e.isOpen != null || e.defaultOpen != null || !r ? n : r, a = yc(t, i.isOpen) || e.isExiting || !1;
  if (le(ka)) {
    let s = e.children;
    return typeof s == "function" && (s = s({
      trigger: e.trigger || null,
      placement: "bottom",
      isEntering: !1,
      isExiting: !1,
      defaultChildren: null
    })), /* @__PURE__ */ P.createElement(P.Fragment, null, s);
  }
  return i && !i.isOpen && !a ? null : /* @__PURE__ */ P.createElement(yk, {
    ...e,
    triggerRef: e.triggerRef,
    state: i,
    popoverRef: t,
    isExiting: a
  });
}
const vk = /* @__PURE__ */ xe(mk);
function yk({ state: e, isExiting: t, UNSTABLE_portalContainer: r, ...n }) {
  let i = q(null), [a, o] = ee(0);
  Re(() => {
    i.current && e.isOpen && o(i.current.getBoundingClientRect().width);
  }, [
    e.isOpen,
    i
  ]);
  var s;
  let { popoverProps: u, underlayProps: l, arrowProps: c, placement: d } = m7({
    ...n,
    offset: (s = n.offset) !== null && s !== void 0 ? s : 8,
    arrowSize: a
  }, e), f = n.popoverRef, h = Zd(f, !!d) || n.isEntering || !1, p = Ye({
    ...n,
    defaultClassName: "react-aria-Popover",
    values: {
      trigger: n.trigger || null,
      placement: d,
      isEntering: h,
      isExiting: t
    }
  }), v = {
    ...u.style,
    ...p.style
  };
  return /* @__PURE__ */ P.createElement(rb, {
    isExiting: t,
    portalContainer: r
  }, !n.isNonModal && e.isOpen && /* @__PURE__ */ P.createElement("div", {
    "data-testid": "underlay",
    ...l,
    style: {
      position: "fixed",
      inset: 0
    }
  }), /* @__PURE__ */ P.createElement("div", {
    ...ve(_e(n), u),
    ...p,
    ref: f,
    slot: n.slot || void 0,
    style: v,
    "data-trigger": n.trigger,
    "data-placement": d,
    "data-entering": h || void 0,
    "data-exiting": t || void 0
  }, !n.isNonModal && /* @__PURE__ */ P.createElement(fc, {
    onDismiss: e.close
  }), /* @__PURE__ */ P.createElement(n$.Provider, {
    value: {
      ...c,
      placement: d,
      ref: i
    }
  }, p.children), /* @__PURE__ */ P.createElement(fc, {
    onDismiss: e.close
  })));
}
const tf = /* @__PURE__ */ ce(null), Cr = /* @__PURE__ */ ce(null);
function i$(e) {
  let t = wi(e), r = q(null), { triggerProps: n, overlayProps: i } = y0({
    type: "dialog"
  }, t, r);
  return n.id = kt(), i["aria-labelledby"] = n.id, /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        Cr,
        t
      ],
      [
        tf,
        i
      ],
      [
        ki,
        {
          trigger: "DialogTrigger",
          triggerRef: r
        }
      ]
    ]
  }, /* @__PURE__ */ P.createElement(Y6, {
    ...n,
    ref: r,
    isPressed: t.isOpen
  }, e.children));
}
function gk(e, t) {
  let r = e["aria-labelledby"];
  [e, t] = je(e, t, tf);
  let { dialogProps: n, titleProps: i } = q7({
    ...e,
    // Only pass aria-labelledby from props, not context.
    // Context is used as a fallback below.
    "aria-labelledby": r
  }, t), a = le(Cr), o = e.children;
  typeof o == "function" && (o = o({
    close: (a == null ? void 0 : a.close) || (() => {
    })
  })), !n["aria-label"] && !n["aria-labelledby"] && (e["aria-labelledby"] ? n["aria-labelledby"] = e["aria-labelledby"] : console.warn('If a Dialog does not contain a <Heading slot="title">, it must have an aria-label or aria-labelledby attribute for accessibility.'));
  var s;
  return /* @__PURE__ */ P.createElement("section", {
    ..._e(e),
    ...n,
    ref: t,
    slot: e.slot || void 0,
    style: e.style,
    className: (s = e.className) !== null && s !== void 0 ? s : "react-aria-Dialog"
  }, /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        Us,
        {
          slots: {
            [vc]: {},
            title: {
              ...i,
              level: 2
            }
          }
        }
      ]
    ]
  }, o));
}
const bk = /* @__PURE__ */ xe(gk), $k = /* @__PURE__ */ ce(null), a$ = /* @__PURE__ */ ce(null);
function xk(e, t) {
  [e, t] = je(e, t, $k);
  let { collection: r, document: n } = Qd(), { children: i, isDisabled: a = !1, isInvalid: o = !1, isRequired: s = !1 } = e;
  i = G(() => typeof i == "function" ? i({
    isOpen: !1,
    isDisabled: a,
    isInvalid: o,
    isRequired: s,
    defaultChildren: null
  }) : i, [
    i,
    a,
    o,
    s
  ]);
  var u;
  return /* @__PURE__ */ P.createElement(P.Fragment, null, /* @__PURE__ */ P.createElement(v3, null, /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        uu,
        n
      ],
      [
        qa,
        {
          items: (u = e.items) !== null && u !== void 0 ? u : e.defaultItems
        }
      ]
    ]
  }, i)), /* @__PURE__ */ P.createElement(Dk, {
    props: e,
    collection: r,
    comboBoxRef: t
  }));
}
function Dk({ props: e, collection: t, comboBoxRef: r }) {
  let { name: n, formValue: i = "key", allowsCustomValue: a } = e;
  a && (i = "text");
  let { validationBehavior: o } = Zr(xn) || {};
  var s, u;
  let l = (u = (s = e.validationBehavior) !== null && s !== void 0 ? s : o) !== null && u !== void 0 ? u : "native", { contains: c } = Hy({
    sensitivity: "base"
  }), d = bS({
    defaultFilter: e.defaultFilter || c,
    ...e,
    // If props.items isn't provided, rely on collection filtering (aka listbox.items is provided or defaultItems provided to Combobox)
    items: e.items,
    children: void 0,
    collection: t,
    validationBehavior: l
  }), f = q(null), h = q(null), p = q(null), v = q(null), [g, $] = Di(), { buttonProps: m, inputProps: b, listBoxProps: D, labelProps: S, descriptionProps: T, errorMessageProps: B, ...y } = I7({
    ...pi(e),
    label: $,
    inputRef: h,
    buttonRef: f,
    listBoxRef: p,
    popoverRef: v,
    name: i === "text" ? n : void 0,
    validationBehavior: l
  }, d), [_, w] = ee(null), E = be(() => {
    if (h.current) {
      var L;
      let I = (L = f.current) === null || L === void 0 ? void 0 : L.getBoundingClientRect(), x = h.current.getBoundingClientRect(), U = I ? Math.min(I.left, x.left) : x.left, K = I ? Math.max(I.right, x.right) : x.right;
      w(K - U + "px");
    }
  }, [
    f,
    h,
    w
  ]);
  Ws({
    ref: h,
    onResize: E
  });
  let k = G(() => ({
    isOpen: d.isOpen,
    isDisabled: e.isDisabled || !1,
    isInvalid: y.isInvalid || !1,
    isRequired: e.isRequired || !1
  }), [
    d.isOpen,
    e.isDisabled,
    y.isInvalid,
    e.isRequired
  ]), C = Ye({
    ...e,
    values: k,
    defaultClassName: "react-aria-ComboBox"
  }), A = _e(e);
  return delete A.id, /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        a$,
        d
      ],
      [
        Ci,
        {
          ...S,
          ref: g
        }
      ],
      [
        Ei,
        {
          ...m,
          ref: f,
          isPressed: d.isOpen
        }
      ],
      [
        Ua,
        {
          ...b,
          ref: h
        }
      ],
      [
        Cr,
        d
      ],
      [
        ki,
        {
          ref: v,
          triggerRef: h,
          placement: "bottom start",
          isNonModal: !0,
          trigger: "ComboBox",
          style: {
            "--trigger-width": _
          }
        }
      ],
      [
        qa,
        {
          ...D,
          ref: p
        }
      ],
      [
        Si,
        d
      ],
      [
        nr,
        {
          slots: {
            description: T,
            errorMessage: B
          }
        }
      ],
      [
        Ha,
        {
          isInvalid: y.isInvalid,
          isDisabled: e.isDisabled || !1
        }
      ],
      [
        kn,
        y
      ]
    ]
  }, /* @__PURE__ */ P.createElement("div", {
    ...A,
    ...C,
    ref: r,
    slot: e.slot || void 0,
    "data-focused": d.isFocused || void 0,
    "data-open": d.isOpen || void 0,
    "data-disabled": e.isDisabled || void 0,
    "data-invalid": y.isInvalid || void 0,
    "data-required": e.isRequired || void 0
  }), n && i === "key" && /* @__PURE__ */ P.createElement("input", {
    type: "hidden",
    name: n,
    value: d.selectedKey
  }));
}
const Ek = /* @__PURE__ */ xe(xk), rf = /* @__PURE__ */ ce(null), Wa = /* @__PURE__ */ ce(null), nf = /* @__PURE__ */ ce(null);
function wk(e, t) {
  [e, t] = je(e, t, rf);
  let { validationBehavior: r } = Zr(xn) || {};
  var n, i;
  let a = (i = (n = e.validationBehavior) !== null && n !== void 0 ? n : r) !== null && i !== void 0 ? i : "native", { locale: o } = st(), s = u1({
    ...e,
    locale: o,
    createCalendar: eu,
    validationBehavior: a
  }), u = q(null), [l, c] = Di(), d = q(null), { labelProps: f, fieldProps: h, inputProps: p, descriptionProps: v, errorMessageProps: g, ...$ } = P4({
    ...pi(e),
    label: c,
    inputRef: d,
    validationBehavior: a
  }, s, u), m = Ye({
    ...pi(e),
    values: {
      state: s,
      isInvalid: s.isInvalid,
      isDisabled: s.isDisabled
    },
    defaultClassName: "react-aria-DateField"
  }), b = _e(e);
  return delete b.id, /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        Wa,
        s
      ],
      [
        Ha,
        {
          ...h,
          ref: u,
          isInvalid: s.isInvalid
        }
      ],
      [
        Ua,
        {
          ...p,
          ref: d
        }
      ],
      [
        Ci,
        {
          ...f,
          ref: l,
          elementType: "span"
        }
      ],
      [
        nr,
        {
          slots: {
            description: v,
            errorMessage: g
          }
        }
      ],
      [
        kn,
        $
      ]
    ]
  }, /* @__PURE__ */ P.createElement("div", {
    ...b,
    ...m,
    ref: t,
    slot: e.slot || void 0,
    "data-invalid": s.isInvalid || void 0
  }));
}
const Ck = /* @__PURE__ */ xe(wk);
function Sk(e, t) {
  let r = le(Wa), n = le(nf);
  return r || n ? /* @__PURE__ */ P.createElement(o$, {
    ...e,
    ref: t
  }) : /* @__PURE__ */ P.createElement(kk, {
    ...e,
    ref: t
  });
}
const kk = /* @__PURE__ */ xe((e, t) => {
  let [r, n] = je({
    slot: e.slot
  }, t, rf), { locale: i } = st(), a = u1({
    ...r,
    locale: i,
    createCalendar: eu
  }), o = q(null), { fieldProps: s, inputProps: u } = P4({
    ...r,
    inputRef: o
  }, a, n);
  return /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        Wa,
        a
      ],
      [
        Ua,
        {
          ...u,
          ref: o
        }
      ],
      [
        Ha,
        {
          ...s,
          ref: n,
          isInvalid: a.isInvalid
        }
      ]
    ]
  }, /* @__PURE__ */ P.createElement(o$, e));
}), o$ = /* @__PURE__ */ xe((e, t) => {
  let { className: r, children: n } = e, i = le(Wa), a = le(nf), o = i ?? a;
  return /* @__PURE__ */ P.createElement(P.Fragment, null, /* @__PURE__ */ P.createElement(r$, {
    ...e,
    ref: t,
    slot: e.slot || void 0,
    className: r ?? "react-aria-DateInput",
    isInvalid: o.isInvalid
  }, o.segments.map((s, u) => /* @__PURE__ */ sa(n(s), {
    key: u
  }))), /* @__PURE__ */ P.createElement(p1, null));
}), Pk = /* @__PURE__ */ xe(Sk);
function Tk({ segment: e, ...t }, r) {
  let n = le(Wa), i = le(nf), a = n ?? i, o = Cn(r), { segmentProps: s } = z7(e, a, o), { focusProps: u, isFocused: l, isFocusVisible: c } = Qr(), { hoverProps: d, isHovered: f } = Sn({
    ...t,
    isDisabled: a.isDisabled || e.type === "literal"
  }), h = Ye({
    ...t,
    values: {
      ...e,
      isReadOnly: !e.isEditable,
      isInvalid: a.isInvalid,
      isDisabled: a.isDisabled,
      isHovered: f,
      isFocused: l,
      isFocusVisible: c
    },
    defaultChildren: e.text,
    defaultClassName: "react-aria-DateSegment"
  });
  return /* @__PURE__ */ P.createElement("div", {
    ...ve(_e(t), s, u, d),
    ...h,
    ref: o,
    "data-placeholder": e.isPlaceholder || void 0,
    "data-invalid": a.isInvalid || void 0,
    "data-readonly": !e.isEditable || void 0,
    "data-disabled": a.isDisabled || void 0,
    "data-type": e.type,
    "data-hovered": f || void 0,
    "data-focused": l || void 0,
    "data-focus-visible": c || void 0
  });
}
const Ak = /* @__PURE__ */ xe(Tk), _k = /* @__PURE__ */ ce(null), Fk = /* @__PURE__ */ ce(null);
function Ok(e, t) {
  [e, t] = je(e, t, _k);
  let { validationBehavior: r } = Zr(xn) || {};
  var n, i;
  let a = (i = (n = e.validationBehavior) !== null && n !== void 0 ? n : r) !== null && i !== void 0 ? i : "native", o = _S({
    ...e,
    validationBehavior: a
  }), s = q(null), [u, l] = Di(), { groupProps: c, labelProps: d, startFieldProps: f, endFieldProps: h, buttonProps: p, dialogProps: v, calendarProps: g, descriptionProps: $, errorMessageProps: m, ...b } = U7({
    ...pi(e),
    label: l,
    validationBehavior: a
  }, o, s), [D, S] = ee(null), T = be(() => {
    s.current && S(s.current.offsetWidth + "px");
  }, []);
  Ws({
    ref: s,
    onResize: T
  });
  let { focusProps: B, isFocused: y, isFocusVisible: _ } = Qr({
    within: !0
  }), w = Ye({
    ...e,
    values: {
      state: o,
      isFocusWithin: y,
      isFocusVisible: _,
      isDisabled: e.isDisabled || !1,
      isInvalid: o.isInvalid,
      isOpen: o.isOpen
    },
    defaultClassName: "react-aria-DateRangePicker"
  }), E = _e(e);
  return delete E.id, /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        Fk,
        o
      ],
      [
        Ha,
        {
          ...c,
          ref: s,
          isInvalid: o.isInvalid
        }
      ],
      [
        Ei,
        {
          ...p,
          isPressed: o.isOpen
        }
      ],
      [
        Ci,
        {
          ...d,
          ref: u,
          elementType: "span"
        }
      ],
      [
        l1,
        g
      ],
      [
        Cr,
        o
      ],
      [
        ki,
        {
          trigger: "DateRangePicker",
          triggerRef: s,
          placement: "bottom start",
          style: {
            "--trigger-width": D
          }
        }
      ],
      [
        tf,
        v
      ],
      [
        rf,
        {
          slots: {
            start: f,
            end: h
          }
        }
      ],
      [
        nr,
        {
          slots: {
            description: $,
            errorMessage: m
          }
        }
      ],
      [
        kn,
        b
      ]
    ]
  }, /* @__PURE__ */ P.createElement("div", {
    ...B,
    ...E,
    ...w,
    ref: t,
    slot: e.slot || void 0,
    "data-focus-within": y || void 0,
    "data-invalid": o.isInvalid || void 0,
    "data-focus-visible": _ || void 0,
    "data-disabled": e.isDisabled || void 0,
    "data-open": o.isOpen || void 0
  }));
}
const Ik = /* @__PURE__ */ xe(Ok);
function Rk(e, t) {
  [e, t] = je(e, t, Us);
  let { children: r, level: n = 3, className: i, ...a } = e, o = `h${n}`;
  return /* @__PURE__ */ P.createElement(o, {
    ...a,
    ref: t,
    className: i ?? "react-aria-Heading"
  }, r);
}
const s$ = /* @__PURE__ */ xe(Rk), Bk = /* @__PURE__ */ ce(null), af = /* @__PURE__ */ ce(null);
function Mk(e, t) {
  if (le(af)) return /* @__PURE__ */ P.createElement(Ap, {
    ...e,
    modalRef: t
  }, e.children);
  let { isDismissable: n, isKeyboardDismissDisabled: i, isOpen: a, defaultOpen: o, onOpenChange: s, children: u, isEntering: l, isExiting: c, UNSTABLE_portalContainer: d, shouldCloseOnInteractOutside: f, ...h } = e;
  return /* @__PURE__ */ P.createElement(u$, {
    isDismissable: n,
    isKeyboardDismissDisabled: i,
    isOpen: a,
    defaultOpen: o,
    onOpenChange: s,
    isEntering: l,
    isExiting: c,
    UNSTABLE_portalContainer: d,
    shouldCloseOnInteractOutside: f
  }, /* @__PURE__ */ P.createElement(Ap, {
    ...h,
    modalRef: t
  }, u));
}
const Nk = /* @__PURE__ */ xe(Mk);
function Lk(e, t) {
  [e, t] = je(e, t, Bk);
  let r = le(Cr), n = wi(e), i = e.isOpen != null || e.defaultOpen != null || !r ? n : r, a = Cn(t), o = q(null), s = yc(a, i.isOpen), u = yc(o, i.isOpen), l = s || u || e.isExiting || !1, c = wr();
  return !i.isOpen && !l || c ? null : /* @__PURE__ */ P.createElement(Vk, {
    ...e,
    state: i,
    isExiting: l,
    overlayRef: a,
    modalRef: o
  });
}
const u$ = /* @__PURE__ */ xe(Lk);
function Vk({ UNSTABLE_portalContainer: e, ...t }) {
  let r = t.modalRef, { state: n } = t, { modalProps: i, underlayProps: a } = g7(t, n, r), o = Zd(t.overlayRef) || t.isEntering || !1, s = Ye({
    ...t,
    defaultClassName: "react-aria-ModalOverlay",
    values: {
      isEntering: o,
      isExiting: t.isExiting,
      state: n
    }
  }), u = L6(), l = {
    ...s.style,
    "--visual-viewport-height": u.height + "px"
  };
  return /* @__PURE__ */ P.createElement(rb, {
    isExiting: t.isExiting,
    portalContainer: e
  }, /* @__PURE__ */ P.createElement("div", {
    ...ve(_e(t), a),
    ...s,
    style: l,
    ref: t.overlayRef,
    "data-entering": o || void 0,
    "data-exiting": t.isExiting || void 0
  }, /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        af,
        {
          modalProps: i,
          modalRef: r,
          isExiting: t.isExiting,
          isDismissable: t.isDismissable
        }
      ],
      [
        Cr,
        n
      ]
    ]
  }, s.children)));
}
function Ap(e) {
  let { modalProps: t, modalRef: r, isExiting: n, isDismissable: i } = le(af), a = le(Cr), o = G(() => $d(e.modalRef, r), [
    e.modalRef,
    r
  ]), s = Cn(o), u = Zd(s), l = Ye({
    ...e,
    defaultClassName: "react-aria-Modal",
    values: {
      isEntering: u,
      isExiting: n,
      state: a
    }
  });
  return /* @__PURE__ */ P.createElement("div", {
    ...ve(_e(e), t),
    ...l,
    ref: s,
    "data-entering": u || void 0,
    "data-exiting": n || void 0
  }, i && /* @__PURE__ */ P.createElement(fc, {
    onDismiss: a.close
  }), l.children);
}
function zk(e) {
  return e && e.__esModule ? e.default : e;
}
const Mo = /* @__PURE__ */ ce(null), Dc = /* @__PURE__ */ ce(null);
function jk(e, t) {
  [e, t] = je(e, t, Mo);
  let { validationBehavior: r } = Zr(xn) || {};
  var n, i;
  let a = (i = (n = e.validationBehavior) !== null && n !== void 0 ? n : r) !== null && i !== void 0 ? i : "native", { collection: o, document: s } = Qd(), u = FS({
    ...e,
    collection: o,
    children: void 0,
    validationBehavior: a
  }), { isFocusVisible: l, focusProps: c } = Qr({
    within: !0
  }), d = q(null), [f, h] = Di(), { labelProps: p, triggerProps: v, valueProps: g, menuProps: $, descriptionProps: m, errorMessageProps: b, ...D } = H7({
    ...pi(e),
    label: h,
    validationBehavior: a
  }, u, d), [S, T] = ee(null), B = be(() => {
    d.current && T(d.current.offsetWidth + "px");
  }, [
    d
  ]);
  Ws({
    ref: d,
    onResize: B
  });
  let y = G(() => ({
    isOpen: u.isOpen,
    isFocused: u.isFocused,
    isFocusVisible: l,
    isDisabled: e.isDisabled || !1,
    isInvalid: D.isInvalid || !1,
    isRequired: e.isRequired || !1
  }), [
    u.isOpen,
    u.isFocused,
    l,
    e.isDisabled,
    D.isInvalid,
    e.isRequired
  ]), _ = Ye({
    ...e,
    values: y,
    defaultClassName: "react-aria-Select"
  }), w = _e(e);
  return delete w.id, /* @__PURE__ */ P.createElement(P.Fragment, null, /* @__PURE__ */ P.createElement(v3, null, /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        Mo,
        e
      ],
      [
        Dc,
        u
      ],
      [
        uu,
        s
      ]
    ]
  }, _.children)), /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        Mo,
        e
      ],
      [
        Dc,
        u
      ],
      [
        l$,
        g
      ],
      [
        Ci,
        {
          ...p,
          ref: f,
          elementType: "span"
        }
      ],
      [
        Ei,
        {
          ...v,
          ref: d,
          isPressed: u.isOpen
        }
      ],
      [
        Cr,
        u
      ],
      [
        ki,
        {
          trigger: "Select",
          triggerRef: d,
          placement: "bottom start",
          style: {
            "--trigger-width": S
          }
        }
      ],
      [
        qa,
        $
      ],
      [
        Si,
        u
      ],
      [
        nr,
        {
          slots: {
            description: m,
            errorMessage: b
          }
        }
      ],
      [
        kn,
        D
      ]
    ]
  }, /* @__PURE__ */ P.createElement("div", {
    ...w,
    ..._,
    ...c,
    ref: t,
    slot: e.slot || void 0,
    "data-focused": u.isFocused || void 0,
    "data-focus-visible": l || void 0,
    "data-open": u.isOpen || void 0,
    "data-disabled": e.isDisabled || void 0,
    "data-invalid": D.isInvalid || void 0,
    "data-required": e.isRequired || void 0
  }), /* @__PURE__ */ P.createElement(Q7, {
    state: u,
    triggerRef: d,
    label: h,
    name: e.name,
    isDisabled: e.isDisabled
  })));
}
const Kk = /* @__PURE__ */ xe(jk), l$ = /* @__PURE__ */ ce(null);
function Uk(e, t) {
  var r, n;
  [e, t] = je(e, t, l$);
  let i = le(Dc), { placeholder: a } = Zr(Mo), o = i.selectedKey != null ? i.collection.getItem(i.selectedKey) : null, s = o == null ? void 0 : o.rendered;
  typeof s == "function" && (s = s({
    isHovered: !1,
    isPressed: !1,
    isSelected: !1,
    isFocused: !1,
    isFocusVisible: !1,
    isDisabled: !1,
    selectionMode: "single",
    selectionBehavior: "toggle"
  }));
  let u = Ht(zk(G1), "react-aria-components");
  var l, c;
  let d = Ye({
    ...e,
    defaultChildren: s || a || u.format("selectPlaceholder"),
    defaultClassName: "react-aria-SelectValue",
    values: {
      selectedItem: (l = (r = i.selectedItem) === null || r === void 0 ? void 0 : r.value) !== null && l !== void 0 ? l : null,
      selectedText: (c = (n = i.selectedItem) === null || n === void 0 ? void 0 : n.textValue) !== null && c !== void 0 ? c : null,
      isPlaceholder: !o
    }
  }), f = _e(e);
  return /* @__PURE__ */ P.createElement("span", {
    ref: t,
    ...f,
    ...d,
    "data-placeholder": !o || void 0
  }, /* @__PURE__ */ P.createElement(nr.Provider, {
    value: void 0
  }, d.children));
}
const qk = /* @__PURE__ */ xe(Uk), Hk = /* @__PURE__ */ ce({}), Wk = /* @__PURE__ */ ce(null);
function Qk(e, t) {
  [e, t] = je(e, t, Wk);
  let { validationBehavior: r } = Zr(xn) || {};
  var n, i;
  let a = (i = (n = e.validationBehavior) !== null && n !== void 0 ? n : r) !== null && i !== void 0 ? i : "native", o = q(null), [s, u] = Di(), [l, c] = ee("input"), { labelProps: d, inputProps: f, descriptionProps: h, errorMessageProps: p, ...v } = Ub({
    ...pi(e),
    inputElementType: l,
    label: u,
    validationBehavior: a
  }, o), g = be((b) => {
    o.current = b, b && c(b instanceof HTMLTextAreaElement ? "textarea" : "input");
  }, []), $ = Ye({
    ...e,
    values: {
      isDisabled: e.isDisabled || !1,
      isInvalid: v.isInvalid,
      isReadOnly: e.isReadOnly || !1,
      isRequired: e.isRequired || !1
    },
    defaultClassName: "react-aria-TextField"
  }), m = _e(e);
  return delete m.id, /* @__PURE__ */ P.createElement("div", {
    ...m,
    ...$,
    ref: t,
    slot: e.slot || void 0,
    "data-disabled": e.isDisabled || void 0,
    "data-invalid": v.isInvalid || void 0,
    "data-readonly": e.isReadOnly || void 0,
    "data-required": e.isRequired || void 0
  }, /* @__PURE__ */ P.createElement(pt, {
    values: [
      [
        Ci,
        {
          ...d,
          ref: s
        }
      ],
      [
        Ua,
        {
          ...f,
          ref: g
        }
      ],
      [
        Hk,
        {
          ...f,
          ref: g
        }
      ],
      [
        nr,
        {
          slots: {
            description: h,
            errorMessage: p
          }
        }
      ],
      [
        kn,
        v
      ]
    ]
  }, $.children));
}
const Gk = /* @__PURE__ */ xe(Qk), of = "-";
function Zk(e) {
  const t = Jk(e), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = e;
  function i(o) {
    const s = o.split(of);
    return s[0] === "" && s.length !== 1 && s.shift(), c$(s, t) || Yk(o);
  }
  function a(o, s) {
    const u = r[o] || [];
    return s && n[o] ? [...u, ...n[o]] : u;
  }
  return {
    getClassGroupId: i,
    getConflictingClassGroupIds: a
  };
}
function c$(e, t) {
  var o;
  if (e.length === 0)
    return t.classGroupId;
  const r = e[0], n = t.nextPart.get(r), i = n ? c$(e.slice(1), n) : void 0;
  if (i)
    return i;
  if (t.validators.length === 0)
    return;
  const a = e.join(of);
  return (o = t.validators.find(({
    validator: s
  }) => s(a))) == null ? void 0 : o.classGroupId;
}
const _p = /^\[(.+)\]$/;
function Yk(e) {
  if (_p.test(e)) {
    const t = _p.exec(e)[1], r = t == null ? void 0 : t.substring(0, t.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}
function Jk(e) {
  const {
    theme: t,
    prefix: r
  } = e, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return e8(Object.entries(e.classGroups), r).forEach(([a, o]) => {
    Ec(o, n, a, t);
  }), n;
}
function Ec(e, t, r, n) {
  e.forEach((i) => {
    if (typeof i == "string") {
      const a = i === "" ? t : Fp(t, i);
      a.classGroupId = r;
      return;
    }
    if (typeof i == "function") {
      if (Xk(i)) {
        Ec(i(n), t, r, n);
        return;
      }
      t.validators.push({
        validator: i,
        classGroupId: r
      });
      return;
    }
    Object.entries(i).forEach(([a, o]) => {
      Ec(o, Fp(t, a), r, n);
    });
  });
}
function Fp(e, t) {
  let r = e;
  return t.split(of).forEach((n) => {
    r.nextPart.has(n) || r.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(n);
  }), r;
}
function Xk(e) {
  return e.isThemeGetter;
}
function e8(e, t) {
  return t ? e.map(([r, n]) => {
    const i = n.map((a) => typeof a == "string" ? t + a : typeof a == "object" ? Object.fromEntries(Object.entries(a).map(([o, s]) => [t + o, s])) : a);
    return [r, i];
  }) : e;
}
function t8(e) {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  function i(a, o) {
    r.set(a, o), t++, t > e && (t = 0, n = r, r = /* @__PURE__ */ new Map());
  }
  return {
    get(a) {
      let o = r.get(a);
      if (o !== void 0)
        return o;
      if ((o = n.get(a)) !== void 0)
        return i(a, o), o;
    },
    set(a, o) {
      r.has(a) ? r.set(a, o) : i(a, o);
    }
  };
}
const d$ = "!";
function r8(e) {
  const t = e.separator, r = t.length === 1, n = t[0], i = t.length;
  return function(o) {
    const s = [];
    let u = 0, l = 0, c;
    for (let v = 0; v < o.length; v++) {
      let g = o[v];
      if (u === 0) {
        if (g === n && (r || o.slice(v, v + i) === t)) {
          s.push(o.slice(l, v)), l = v + i;
          continue;
        }
        if (g === "/") {
          c = v;
          continue;
        }
      }
      g === "[" ? u++ : g === "]" && u--;
    }
    const d = s.length === 0 ? o : o.substring(l), f = d.startsWith(d$), h = f ? d.substring(1) : d, p = c && c > l ? c - l : void 0;
    return {
      modifiers: s,
      hasImportantModifier: f,
      baseClassName: h,
      maybePostfixModifierPosition: p
    };
  };
}
function n8(e) {
  if (e.length <= 1)
    return e;
  const t = [];
  let r = [];
  return e.forEach((n) => {
    n[0] === "[" ? (t.push(...r.sort(), n), r = []) : r.push(n);
  }), t.push(...r.sort()), t;
}
function i8(e) {
  return {
    cache: t8(e.cacheSize),
    splitModifiers: r8(e),
    ...Zk(e)
  };
}
const a8 = /\s+/;
function o8(e, t) {
  const {
    splitModifiers: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: i
  } = t, a = /* @__PURE__ */ new Set();
  return e.trim().split(a8).map((o) => {
    const {
      modifiers: s,
      hasImportantModifier: u,
      baseClassName: l,
      maybePostfixModifierPosition: c
    } = r(o);
    let d = n(c ? l.substring(0, c) : l), f = !!c;
    if (!d) {
      if (!c)
        return {
          isTailwindClass: !1,
          originalClassName: o
        };
      if (d = n(l), !d)
        return {
          isTailwindClass: !1,
          originalClassName: o
        };
      f = !1;
    }
    const h = n8(s).join(":");
    return {
      isTailwindClass: !0,
      modifierId: u ? h + d$ : h,
      classGroupId: d,
      originalClassName: o,
      hasPostfixModifier: f
    };
  }).reverse().filter((o) => {
    if (!o.isTailwindClass)
      return !0;
    const {
      modifierId: s,
      classGroupId: u,
      hasPostfixModifier: l
    } = o, c = s + u;
    return a.has(c) ? !1 : (a.add(c), i(u, l).forEach((d) => a.add(s + d)), !0);
  }).reverse().map((o) => o.originalClassName).join(" ");
}
function s8() {
  let e = 0, t, r, n = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (r = f$(t)) && (n && (n += " "), n += r);
  return n;
}
function f$(e) {
  if (typeof e == "string")
    return e;
  let t, r = "";
  for (let n = 0; n < e.length; n++)
    e[n] && (t = f$(e[n])) && (r && (r += " "), r += t);
  return r;
}
function wc(e, ...t) {
  let r, n, i, a = o;
  function o(u) {
    const l = t.reduce((c, d) => d(c), e());
    return r = i8(l), n = r.cache.get, i = r.cache.set, a = s, s(u);
  }
  function s(u) {
    const l = n(u);
    if (l)
      return l;
    const c = o8(u, r);
    return i(u, c), c;
  }
  return function() {
    return a(s8.apply(null, arguments));
  };
}
function Le(e) {
  const t = (r) => r[e] || [];
  return t.isThemeGetter = !0, t;
}
const h$ = /^\[(?:([a-z-]+):)?(.+)\]$/i, u8 = /^\d+\/\d+$/, l8 = /* @__PURE__ */ new Set(["px", "full", "screen"]), c8 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, d8 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, f8 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, h8 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, p8 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
function or(e) {
  return ln(e) || l8.has(e) || u8.test(e);
}
function Tr(e) {
  return Pi(e, "length", D8);
}
function ln(e) {
  return !!e && !Number.isNaN(Number(e));
}
function xo(e) {
  return Pi(e, "number", ln);
}
function Li(e) {
  return !!e && Number.isInteger(Number(e));
}
function m8(e) {
  return e.endsWith("%") && ln(e.slice(0, -1));
}
function ge(e) {
  return h$.test(e);
}
function Ar(e) {
  return c8.test(e);
}
const v8 = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
function y8(e) {
  return Pi(e, v8, p$);
}
function g8(e) {
  return Pi(e, "position", p$);
}
const b8 = /* @__PURE__ */ new Set(["image", "url"]);
function $8(e) {
  return Pi(e, b8, w8);
}
function x8(e) {
  return Pi(e, "", E8);
}
function Vi() {
  return !0;
}
function Pi(e, t, r) {
  const n = h$.exec(e);
  return n ? n[1] ? typeof t == "string" ? n[1] === t : t.has(n[1]) : r(n[2]) : !1;
}
function D8(e) {
  return d8.test(e) && !f8.test(e);
}
function p$() {
  return !1;
}
function E8(e) {
  return h8.test(e);
}
function w8(e) {
  return p8.test(e);
}
function Cc() {
  const e = Le("colors"), t = Le("spacing"), r = Le("blur"), n = Le("brightness"), i = Le("borderColor"), a = Le("borderRadius"), o = Le("borderSpacing"), s = Le("borderWidth"), u = Le("contrast"), l = Le("grayscale"), c = Le("hueRotate"), d = Le("invert"), f = Le("gap"), h = Le("gradientColorStops"), p = Le("gradientColorStopPositions"), v = Le("inset"), g = Le("margin"), $ = Le("opacity"), m = Le("padding"), b = Le("saturate"), D = Le("scale"), S = Le("sepia"), T = Le("skew"), B = Le("space"), y = Le("translate"), _ = () => ["auto", "contain", "none"], w = () => ["auto", "hidden", "clip", "visible", "scroll"], E = () => ["auto", ge, t], k = () => [ge, t], C = () => ["", or, Tr], A = () => ["auto", ln, ge], L = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], I = () => ["solid", "dashed", "dotted", "double", "none"], x = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], U = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], K = () => ["", "0", ge], z = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], ae = () => [ln, xo], ne = () => [ln, ge];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Vi],
      spacing: [or, Tr],
      blur: ["none", "", Ar, ge],
      brightness: ae(),
      borderColor: [e],
      borderRadius: ["none", "", "full", Ar, ge],
      borderSpacing: k(),
      borderWidth: C(),
      contrast: ae(),
      grayscale: K(),
      hueRotate: ne(),
      invert: K(),
      gap: k(),
      gradientColorStops: [e],
      gradientColorStopPositions: [m8, Tr],
      inset: E(),
      margin: E(),
      opacity: ae(),
      padding: k(),
      saturate: ae(),
      scale: ae(),
      sepia: K(),
      skew: ne(),
      space: k(),
      translate: k()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", ge]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Ar]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": z()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": z()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...L(), ge]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: w()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": w()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": w()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: _()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": _()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": _()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [v]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [v]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [v]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [v]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [v]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [v]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [v]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [v]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [v]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Li, ge]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: E()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", ge]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: K()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: K()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Li, ge]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Vi]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Li, ge]
        }, ge]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": A()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": A()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Vi]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Li, ge]
        }, ge]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": A()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": A()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", ge]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", ge]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [f]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [f]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [f]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...U()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...U(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...U(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [m]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [m]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [m]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [m]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [m]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [m]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [m]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [m]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [m]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [g]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [g]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [g]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [g]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [g]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [g]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [g]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [g]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [g]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [B]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [B]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ge, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [ge, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [ge, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [Ar]
        }, Ar]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [ge, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [ge, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [ge, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [ge, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Ar, Tr]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", xo]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Vi]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ge]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", ln, xo]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", or, ge]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ge]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", ge]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [$]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [$]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...I(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", or, Tr]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", or, ge]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: k()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ge]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ge]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [$]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...L(), g8]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", y8]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, $8]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [p]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [p]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [p]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [h]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [a]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [a]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [a]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [a]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [a]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [a]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [a]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [a]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [a]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [a]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [a]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [a]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [a]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [a]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [a]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [s]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [s]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [s]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [s]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [s]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [s]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [s]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [s]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [s]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [$]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...I(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [s]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [s]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [$]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: I()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...I()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [or, ge]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [or, Tr]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: C()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [$]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [or, Tr]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Ar, x8]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Vi]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [$]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...x(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": x()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [u]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Ar, ge]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [l]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [c]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [b]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [S]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [u]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [l]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [c]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [$]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [b]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [S]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [o]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [o]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [o]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ge]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: ne()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", ge]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: ne()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", ge]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [D]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [D]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [D]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Li, ge]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [y]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [y]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [T]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [T]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ge]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ge]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": k()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": k()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": k()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": k()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": k()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": k()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": k()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": k()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": k()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": k()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": k()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": k()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": k()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": k()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": k()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": k()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": k()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": k()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ge]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [or, Tr, xo]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
function C8(e, {
  cacheSize: t,
  prefix: r,
  separator: n,
  extend: i = {},
  override: a = {}
}) {
  No(e, "cacheSize", t), No(e, "prefix", r), No(e, "separator", n);
  for (const o in a)
    S8(e[o], a[o]);
  for (const o in i)
    k8(e[o], i[o]);
  return e;
}
function No(e, t, r) {
  r !== void 0 && (e[t] = r);
}
function S8(e, t) {
  if (t)
    for (const r in t)
      No(e, r, t[r]);
}
function k8(e, t) {
  if (t)
    for (const r in t) {
      const n = t[r];
      n !== void 0 && (e[r] = (e[r] || []).concat(n));
    }
}
function P8(e, ...t) {
  return typeof e == "function" ? wc(Cc, e, ...t) : wc(() => C8(Cc(), e), ...t);
}
const Sr = /* @__PURE__ */ wc(Cc);
var Op = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, yt = (e) => !e || typeof e != "object" || Object.keys(e).length === 0, T8 = (e, t) => JSON.stringify(e) === JSON.stringify(t);
function m$(e, t) {
  e.forEach(function(r) {
    Array.isArray(r) ? m$(r, t) : t.push(r);
  });
}
function v$(e) {
  let t = [];
  return m$(e, t), t;
}
var y$ = (...e) => v$(e).filter(Boolean), g$ = (e, t) => {
  let r = {}, n = Object.keys(e), i = Object.keys(t);
  for (let a of n) if (i.includes(a)) {
    let o = e[a], s = t[a];
    typeof o == "object" && typeof s == "object" ? r[a] = g$(o, s) : Array.isArray(o) || Array.isArray(s) ? r[a] = y$(s, o) : r[a] = s + " " + o;
  } else r[a] = e[a];
  for (let a of i) n.includes(a) || (r[a] = t[a]);
  return r;
}, Ip = (e) => !e || typeof e != "string" ? e : e.replace(/\s+/g, " ").trim(), A8 = { twMerge: !0, twMergeConfig: {}, responsiveVariants: !1 }, b$ = (e) => e || void 0, Aa = (...e) => b$(v$(e).filter(Boolean).join(" ")), ll = null, lr = {}, Sc = !1, zi = (...e) => (t) => t.twMerge ? ((!ll || Sc) && (Sc = !1, ll = yt(lr) ? Sr : P8({ ...lr, extend: { theme: lr.theme, classGroups: lr.classGroups, conflictingClassGroupModifiers: lr.conflictingClassGroupModifiers, conflictingClassGroups: lr.conflictingClassGroups, ...lr.extend } })), b$(ll(Aa(e)))) : Aa(e), Rp = (e, t) => {
  for (let r in t) e.hasOwnProperty(r) ? e[r] = Aa(e[r], t[r]) : e[r] = t[r];
  return e;
}, Et = (e, t) => {
  let { extend: r = null, slots: n = {}, variants: i = {}, compoundVariants: a = [], compoundSlots: o = [], defaultVariants: s = {} } = e, u = { ...A8, ...t }, l = r != null && r.base ? Aa(r.base, e == null ? void 0 : e.base) : e == null ? void 0 : e.base, c = r != null && r.variants && !yt(r.variants) ? g$(i, r.variants) : i, d = r != null && r.defaultVariants && !yt(r.defaultVariants) ? { ...r.defaultVariants, ...s } : s;
  !yt(u.twMergeConfig) && !T8(u.twMergeConfig, lr) && (Sc = !0, lr = u.twMergeConfig);
  let f = yt(r == null ? void 0 : r.slots), h = yt(n) ? {} : { base: Aa(e == null ? void 0 : e.base, f && (r == null ? void 0 : r.base)), ...n }, p = f ? h : Rp({ ...r == null ? void 0 : r.slots }, yt(h) ? { base: e == null ? void 0 : e.base } : h), v = yt(r == null ? void 0 : r.compoundVariants) ? a : y$(r == null ? void 0 : r.compoundVariants, a), g = (m) => {
    if (yt(c) && yt(n) && f) return zi(l, m == null ? void 0 : m.class, m == null ? void 0 : m.className)(u);
    if (v && !Array.isArray(v)) throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof v}`);
    if (o && !Array.isArray(o)) throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof o}`);
    let b = (k, C, A = [], L) => {
      let I = A;
      if (typeof C == "string") I = I.concat(Ip(C).split(" ").map((x) => `${k}:${x}`));
      else if (Array.isArray(C)) I = I.concat(C.reduce((x, U) => x.concat(`${k}:${U}`), []));
      else if (typeof C == "object" && typeof L == "string") {
        for (let x in C) if (C.hasOwnProperty(x) && x === L) {
          let U = C[x];
          if (U && typeof U == "string") {
            let K = Ip(U);
            I[L] ? I[L] = I[L].concat(K.split(" ").map((z) => `${k}:${z}`)) : I[L] = K.split(" ").map((z) => `${k}:${z}`);
          } else Array.isArray(U) && U.length > 0 && (I[L] = U.reduce((K, z) => K.concat(`${k}:${z}`), []));
        }
      }
      return I;
    }, D = (k, C = c, A = null, L = null) => {
      var I;
      let x = C[k];
      if (!x || yt(x)) return null;
      let U = (I = L == null ? void 0 : L[k]) != null ? I : m == null ? void 0 : m[k];
      if (U === null) return null;
      let K = Op(U), z = Array.isArray(u.responsiveVariants) && u.responsiveVariants.length > 0 || u.responsiveVariants === !0, ae = d == null ? void 0 : d[k], ne = [];
      if (typeof K == "object" && z) for (let [Fe, Oe] of Object.entries(K)) {
        let V = x[Oe];
        if (Fe === "initial") {
          ae = Oe;
          continue;
        }
        Array.isArray(u.responsiveVariants) && !u.responsiveVariants.includes(Fe) || (ne = b(Fe, V, ne, A));
      }
      let ye = K != null && typeof K != "object" ? K : Op(ae), De = x[ye || "false"];
      return typeof ne == "object" && typeof A == "string" && ne[A] ? Rp(ne, De) : ne.length > 0 ? (ne.push(De), ne) : De;
    }, S = () => c ? Object.keys(c).map((k) => D(k, c)) : null, T = (k, C) => {
      if (!c || typeof c != "object") return null;
      let A = new Array();
      for (let L in c) {
        let I = D(L, c, k, C), x = k === "base" && typeof I == "string" ? I : I && I[k];
        x && (A[A.length] = x);
      }
      return A;
    }, B = {};
    for (let k in m) m[k] !== void 0 && (B[k] = m[k]);
    let y = (k, C) => {
      var A;
      let L = typeof (m == null ? void 0 : m[k]) == "object" ? { [k]: (A = m[k]) == null ? void 0 : A.initial } : {};
      return { ...d, ...B, ...L, ...C };
    }, _ = (k = [], C) => {
      let A = [];
      for (let { class: L, className: I, ...x } of k) {
        let U = !0;
        for (let [K, z] of Object.entries(x)) {
          let ae = y(K, C);
          if (Array.isArray(z)) {
            if (!z.includes(ae[K])) {
              U = !1;
              break;
            }
          } else if (ae[K] !== z) {
            U = !1;
            break;
          }
        }
        U && (L && A.push(L), I && A.push(I));
      }
      return A;
    }, w = (k) => {
      let C = _(v, k);
      if (!Array.isArray(C)) return C;
      let A = {};
      for (let L of C) if (typeof L == "string" && (A.base = zi(A.base, L)(u)), typeof L == "object") for (let [I, x] of Object.entries(L)) A[I] = zi(A[I], x)(u);
      return A;
    }, E = (k) => {
      if (o.length < 1) return null;
      let C = {};
      for (let { slots: A = [], class: L, className: I, ...x } of o) {
        if (!yt(x)) {
          let U = !0;
          for (let K of Object.keys(x)) {
            let z = y(K, k)[K];
            if (z === void 0 || (Array.isArray(x[K]) ? !x[K].includes(z) : x[K] !== z)) {
              U = !1;
              break;
            }
          }
          if (!U) continue;
        }
        for (let U of A) C[U] = C[U] || [], C[U].push([L, I]);
      }
      return C;
    };
    if (!yt(n) || !f) {
      let k = {};
      if (typeof p == "object" && !yt(p)) for (let C of Object.keys(p)) k[C] = (A) => {
        var L, I;
        return zi(p[C], T(C, A), ((L = w(A)) != null ? L : [])[C], ((I = E(A)) != null ? I : [])[C], A == null ? void 0 : A.class, A == null ? void 0 : A.className)(u);
      };
      return k;
    }
    return zi(l, S(), _(v), m == null ? void 0 : m.class, m == null ? void 0 : m.className)(u);
  }, $ = () => {
    if (!(!c || typeof c != "object")) return Object.keys(c);
  };
  return g.variantKeys = $(), g.extend = r, g.base = l, g.slots = p, g.variants = c, g.defaultVariants = d, g.compoundSlots = o, g.compoundVariants = v, g;
};
const Pn = Et({
  base: "outline outline-spillover-600 dark:outline-spillover-500 forced-colors:outline-[Highlight] outline-offset-2",
  variants: {
    isFocusVisible: {
      false: "outline-0",
      true: "outline-2"
    }
  }
});
function Yr(e, t) {
  return xi(e, (r) => Sr(t, r));
}
function cs(e) {
  return {
    onClick: e,
    onKeyDown: (t) => {
      (t.key === "Enter" || t.key === " ") && (t.preventDefault(), e(t));
    }
  };
}
function _8({ title: e, Icon: t, noBack: r }) {
  const { goHome: n, onCloseButtonClick: i } = bd();
  return /* @__PURE__ */ pe("header", { className: "w-full h-12 flex flex-row items-center", children: [
    r ? /* @__PURE__ */ O("div", { className: "w-14" }) : /* @__PURE__ */ O(
      "div",
      {
        ...cs(n),
        className: "h-full px-4 flex flex-row items-center cursor-pointer hover:bg-gray-200 transition duration-200",
        children: /* @__PURE__ */ O(Ul, {})
      }
    ),
    /* @__PURE__ */ pe("div", { className: "flex grow justify-center items-center gap-2 py-3 text-gray-800", children: [
      t && /* @__PURE__ */ O(t, {}),
      /* @__PURE__ */ O("p", { className: "font-semibold", children: e })
    ] }),
    i && /* @__PURE__ */ O(
      "div",
      {
        ...cs(i),
        className: "h-full px-4 flex flex-row items-center cursor-pointer hover:bg-gray-200 transition duration-200",
        children: /* @__PURE__ */ O(Wv, {})
      }
    )
  ] });
}
function $$({ title: e, Icon: t, noBack: r, children: n }) {
  return /* @__PURE__ */ pe(Nc, { children: [
    /* @__PURE__ */ O(_8, { title: e, Icon: t, noBack: r }),
    /* @__PURE__ */ O("main", { className: "h-full grow w-full overflow-y-auto", children: n })
  ] });
}
function F8({ title: e, Icon: t, children: r }) {
  const { setCurrentScreen: n } = bd();
  return /* @__PURE__ */ O($$, { title: e, Icon: t, noBack: !0, children: /* @__PURE__ */ O("div", { className: "w-full h-full flex flex-col gap-2 px-2", children: r.map((i, a) => {
    const { Icon: o } = i.props;
    return /* @__PURE__ */ pe(
      "div",
      {
        ...cs(() => n(i)),
        className: "flex flex-row items-center gap-2 p-3 text-md bg-gray-200 rounded-md cursor-pointer transition duration-200 hover:bg-gray-300",
        children: [
          o && /* @__PURE__ */ O(o, {}),
          /* @__PURE__ */ O("p", { className: "m-0", children: i.props.title })
        ]
      },
      a
    );
  }) }) });
}
function O8({ title: e, Icon: t, children: r }) {
  const { currentScreen: n } = bd();
  return /* @__PURE__ */ O("div", { className: "w-full h-full flex flex-col gap-2 pb-2 text-gray-800 bg-white", children: n || /* @__PURE__ */ O(F8, { title: e, Icon: t, children: r }) });
}
function I8({ title: e, Icon: t, children: r, onCloseButtonClick: n }) {
  return /* @__PURE__ */ O(c6, { onCloseButtonClick: n, children: /* @__PURE__ */ O(O8, { title: e, Icon: t, children: r }) });
}
var Qa = (e) => e.type === "checkbox", Wn = (e) => e instanceof Date, dt = (e) => e == null;
const x$ = (e) => typeof e == "object";
var it = (e) => !dt(e) && !Array.isArray(e) && x$(e) && !Wn(e), R8 = (e) => it(e) && e.target ? Qa(e.target) ? e.target.checked : e.target.value : e, B8 = (e) => e.substring(0, e.search(/\.\d+(\.|$)/)) || e, M8 = (e, t) => e.has(B8(t)), N8 = (e) => {
  const t = e.constructor && e.constructor.prototype;
  return it(t) && t.hasOwnProperty("isPrototypeOf");
}, sf = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function At(e) {
  let t;
  const r = Array.isArray(e);
  if (e instanceof Date)
    t = new Date(e);
  else if (e instanceof Set)
    t = new Set(e);
  else if (!(sf && (e instanceof Blob || e instanceof FileList)) && (r || it(e)))
    if (t = r ? [] : {}, !r && !N8(e))
      t = e;
    else
      for (const n in e)
        e.hasOwnProperty(n) && (t[n] = At(e[n]));
  else
    return e;
  return t;
}
var Ga = (e) => Array.isArray(e) ? e.filter(Boolean) : [], Ge = (e) => e === void 0, X = (e, t, r) => {
  if (!t || !it(e))
    return r;
  const n = Ga(t.split(/[,[\].]+?/)).reduce((i, a) => dt(i) ? i : i[a], e);
  return Ge(n) || n === e ? Ge(e[t]) ? r : e[t] : n;
}, Mr = (e) => typeof e == "boolean", uf = (e) => /^\w*$/.test(e), D$ = (e) => Ga(e.replace(/["|']|\]/g, "").split(/\.|\[/)), Ve = (e, t, r) => {
  let n = -1;
  const i = uf(t) ? [t] : D$(t), a = i.length, o = a - 1;
  for (; ++n < a; ) {
    const s = i[n];
    let u = r;
    if (n !== o) {
      const l = e[s];
      u = it(l) || Array.isArray(l) ? l : isNaN(+i[n + 1]) ? {} : [];
    }
    if (s === "__proto__")
      return;
    e[s] = u, e = e[s];
  }
  return e;
};
const Bp = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
}, zt = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
}, sr = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
P.createContext(null);
var L8 = (e, t, r, n = !0) => {
  const i = {
    defaultValues: t._defaultValues
  };
  for (const a in e)
    Object.defineProperty(i, a, {
      get: () => {
        const o = a;
        return t._proxyFormState[o] !== zt.all && (t._proxyFormState[o] = !n || zt.all), e[o];
      }
    });
  return i;
}, Ct = (e) => it(e) && !Object.keys(e).length, V8 = (e, t, r, n) => {
  r(e);
  const { name: i, ...a } = e;
  return Ct(a) || Object.keys(a).length >= Object.keys(t).length || Object.keys(a).find((o) => t[o] === zt.all);
}, cl = (e) => Array.isArray(e) ? e : [e];
function z8(e) {
  const t = P.useRef(e);
  t.current = e, P.useEffect(() => {
    const r = !e.disabled && t.current.subject && t.current.subject.subscribe({
      next: t.current.next
    });
    return () => {
      r && r.unsubscribe();
    };
  }, [e.disabled]);
}
var Gt = (e) => typeof e == "string", j8 = (e, t, r, n, i) => Gt(e) ? (n && t.watch.add(e), X(r, e, i)) : Array.isArray(e) ? e.map((a) => (n && t.watch.add(a), X(r, a))) : (n && (t.watchAll = !0), r), E$ = (e, t, r, n, i) => t ? {
  ...r[e],
  types: {
    ...r[e] && r[e].types ? r[e].types : {},
    [n]: i || !0
  }
} : {}, Mp = (e) => ({
  isOnSubmit: !e || e === zt.onSubmit,
  isOnBlur: e === zt.onBlur,
  isOnChange: e === zt.onChange,
  isOnAll: e === zt.all,
  isOnTouch: e === zt.onTouched
}), Np = (e, t, r) => !r && (t.watchAll || t.watch.has(e) || [...t.watch].some((n) => e.startsWith(n) && /^\.\w+/.test(e.slice(n.length))));
const aa = (e, t, r, n) => {
  for (const i of r || Object.keys(e)) {
    const a = X(e, i);
    if (a) {
      const { _f: o, ...s } = a;
      if (o) {
        if (o.refs && o.refs[0] && t(o.refs[0], i) && !n)
          break;
        if (o.ref && t(o.ref, o.name) && !n)
          break;
        aa(s, t);
      } else it(s) && aa(s, t);
    }
  }
};
var K8 = (e, t, r) => {
  const n = Ga(X(e, r));
  return Ve(n, "root", t[r]), Ve(e, r, n), e;
}, lf = (e) => e.type === "file", Lr = (e) => typeof e == "function", ds = (e) => {
  if (!sf)
    return !1;
  const t = e ? e.ownerDocument : 0;
  return e instanceof (t && t.defaultView ? t.defaultView.HTMLElement : HTMLElement);
}, Lo = (e) => Gt(e), cf = (e) => e.type === "radio", fs = (e) => e instanceof RegExp;
const Lp = {
  value: !1,
  isValid: !1
}, Vp = { value: !0, isValid: !0 };
var w$ = (e) => {
  if (Array.isArray(e)) {
    if (e.length > 1) {
      const t = e.filter((r) => r && r.checked && !r.disabled).map((r) => r.value);
      return { value: t, isValid: !!t.length };
    }
    return e[0].checked && !e[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      e[0].attributes && !Ge(e[0].attributes.value) ? Ge(e[0].value) || e[0].value === "" ? Vp : { value: e[0].value, isValid: !0 } : Vp
    ) : Lp;
  }
  return Lp;
};
const zp = {
  isValid: !1,
  value: null
};
var C$ = (e) => Array.isArray(e) ? e.reduce((t, r) => r && r.checked && !r.disabled ? {
  isValid: !0,
  value: r.value
} : t, zp) : zp;
function jp(e, t, r = "validate") {
  if (Lo(e) || Array.isArray(e) && e.every(Lo) || Mr(e) && !e)
    return {
      type: r,
      message: Lo(e) ? e : "",
      ref: t
    };
}
var In = (e) => it(e) && !fs(e) ? e : {
  value: e,
  message: ""
}, Kp = async (e, t, r, n, i) => {
  const { ref: a, refs: o, required: s, maxLength: u, minLength: l, min: c, max: d, pattern: f, validate: h, name: p, valueAsNumber: v, mount: g, disabled: $ } = e._f, m = X(t, p);
  if (!g || $)
    return {};
  const b = o ? o[0] : a, D = (k) => {
    n && b.reportValidity && (b.setCustomValidity(Mr(k) ? "" : k || ""), b.reportValidity());
  }, S = {}, T = cf(a), B = Qa(a), y = T || B, _ = (v || lf(a)) && Ge(a.value) && Ge(m) || ds(a) && a.value === "" || m === "" || Array.isArray(m) && !m.length, w = E$.bind(null, p, r, S), E = (k, C, A, L = sr.maxLength, I = sr.minLength) => {
    const x = k ? C : A;
    S[p] = {
      type: k ? L : I,
      message: x,
      ref: a,
      ...w(k ? L : I, x)
    };
  };
  if (i ? !Array.isArray(m) || !m.length : s && (!y && (_ || dt(m)) || Mr(m) && !m || B && !w$(o).isValid || T && !C$(o).isValid)) {
    const { value: k, message: C } = Lo(s) ? { value: !!s, message: s } : In(s);
    if (k && (S[p] = {
      type: sr.required,
      message: C,
      ref: b,
      ...w(sr.required, C)
    }, !r))
      return D(C), S;
  }
  if (!_ && (!dt(c) || !dt(d))) {
    let k, C;
    const A = In(d), L = In(c);
    if (!dt(m) && !isNaN(m)) {
      const I = a.valueAsNumber || m && +m;
      dt(A.value) || (k = I > A.value), dt(L.value) || (C = I < L.value);
    } else {
      const I = a.valueAsDate || new Date(m), x = (z) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + z), U = a.type == "time", K = a.type == "week";
      Gt(A.value) && m && (k = U ? x(m) > x(A.value) : K ? m > A.value : I > new Date(A.value)), Gt(L.value) && m && (C = U ? x(m) < x(L.value) : K ? m < L.value : I < new Date(L.value));
    }
    if ((k || C) && (E(!!k, A.message, L.message, sr.max, sr.min), !r))
      return D(S[p].message), S;
  }
  if ((u || l) && !_ && (Gt(m) || i && Array.isArray(m))) {
    const k = In(u), C = In(l), A = !dt(k.value) && m.length > +k.value, L = !dt(C.value) && m.length < +C.value;
    if ((A || L) && (E(A, k.message, C.message), !r))
      return D(S[p].message), S;
  }
  if (f && !_ && Gt(m)) {
    const { value: k, message: C } = In(f);
    if (fs(k) && !m.match(k) && (S[p] = {
      type: sr.pattern,
      message: C,
      ref: a,
      ...w(sr.pattern, C)
    }, !r))
      return D(C), S;
  }
  if (h) {
    if (Lr(h)) {
      const k = await h(m, t), C = jp(k, b);
      if (C && (S[p] = {
        ...C,
        ...w(sr.validate, C.message)
      }, !r))
        return D(C.message), S;
    } else if (it(h)) {
      let k = {};
      for (const C in h) {
        if (!Ct(k) && !r)
          break;
        const A = jp(await h[C](m, t), b, C);
        A && (k = {
          ...A,
          ...w(C, A.message)
        }, D(A.message), r && (S[p] = k));
      }
      if (!Ct(k) && (S[p] = {
        ref: b,
        ...k
      }, !r))
        return S;
    }
  }
  return D(!0), S;
};
function U8(e, t) {
  const r = t.slice(0, -1).length;
  let n = 0;
  for (; n < r; )
    e = Ge(e) ? n++ : e[t[n++]];
  return e;
}
function q8(e) {
  for (const t in e)
    if (e.hasOwnProperty(t) && !Ge(e[t]))
      return !1;
  return !0;
}
function nt(e, t) {
  const r = Array.isArray(t) ? t : uf(t) ? [t] : D$(t), n = r.length === 1 ? e : U8(e, r), i = r.length - 1, a = r[i];
  return n && delete n[a], i !== 0 && (it(n) && Ct(n) || Array.isArray(n) && q8(n)) && nt(e, r.slice(0, -1)), e;
}
var dl = () => {
  let e = [];
  return {
    get observers() {
      return e;
    },
    next: (i) => {
      for (const a of e)
        a.next && a.next(i);
    },
    subscribe: (i) => (e.push(i), {
      unsubscribe: () => {
        e = e.filter((a) => a !== i);
      }
    }),
    unsubscribe: () => {
      e = [];
    }
  };
}, hs = (e) => dt(e) || !x$(e);
function cn(e, t) {
  if (hs(e) || hs(t))
    return e === t;
  if (Wn(e) && Wn(t))
    return e.getTime() === t.getTime();
  const r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length)
    return !1;
  for (const i of r) {
    const a = e[i];
    if (!n.includes(i))
      return !1;
    if (i !== "ref") {
      const o = t[i];
      if (Wn(a) && Wn(o) || it(a) && it(o) || Array.isArray(a) && Array.isArray(o) ? !cn(a, o) : a !== o)
        return !1;
    }
  }
  return !0;
}
var S$ = (e) => e.type === "select-multiple", H8 = (e) => cf(e) || Qa(e), fl = (e) => ds(e) && e.isConnected, k$ = (e) => {
  for (const t in e)
    if (Lr(e[t]))
      return !0;
  return !1;
};
function ps(e, t = {}) {
  const r = Array.isArray(e);
  if (it(e) || r)
    for (const n in e)
      Array.isArray(e[n]) || it(e[n]) && !k$(e[n]) ? (t[n] = Array.isArray(e[n]) ? [] : {}, ps(e[n], t[n])) : dt(e[n]) || (t[n] = !0);
  return t;
}
function P$(e, t, r) {
  const n = Array.isArray(e);
  if (it(e) || n)
    for (const i in e)
      Array.isArray(e[i]) || it(e[i]) && !k$(e[i]) ? Ge(t) || hs(r[i]) ? r[i] = Array.isArray(e[i]) ? ps(e[i], []) : { ...ps(e[i]) } : P$(e[i], dt(t) ? {} : t[i], r[i]) : r[i] = !cn(e[i], t[i]);
  return r;
}
var Do = (e, t) => P$(e, t, ps(t)), T$ = (e, { valueAsNumber: t, valueAsDate: r, setValueAs: n }) => Ge(e) ? e : t ? e === "" ? NaN : e && +e : r && Gt(e) ? new Date(e) : n ? n(e) : e;
function hl(e) {
  const t = e.ref;
  if (!(e.refs ? e.refs.every((r) => r.disabled) : t.disabled))
    return lf(t) ? t.files : cf(t) ? C$(e.refs).value : S$(t) ? [...t.selectedOptions].map(({ value: r }) => r) : Qa(t) ? w$(e.refs).value : T$(Ge(t.value) ? e.ref.value : t.value, e);
}
var W8 = (e, t, r, n) => {
  const i = {};
  for (const a of e) {
    const o = X(t, a);
    o && Ve(i, a, o._f);
  }
  return {
    criteriaMode: r,
    names: [...e],
    fields: i,
    shouldUseNativeValidation: n
  };
}, ji = (e) => Ge(e) ? e : fs(e) ? e.source : it(e) ? fs(e.value) ? e.value.source : e.value : e, Q8 = (e) => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate);
function Up(e, t, r) {
  const n = X(e, r);
  if (n || uf(r))
    return {
      error: n,
      name: r
    };
  const i = r.split(".");
  for (; i.length; ) {
    const a = i.join("."), o = X(t, a), s = X(e, a);
    if (o && !Array.isArray(o) && r !== a)
      return { name: r };
    if (s && s.type)
      return {
        name: a,
        error: s
      };
    i.pop();
  }
  return {
    name: r
  };
}
var G8 = (e, t, r, n, i) => i.isOnAll ? !1 : !r && i.isOnTouch ? !(t || e) : (r ? n.isOnBlur : i.isOnBlur) ? !e : (r ? n.isOnChange : i.isOnChange) ? e : !0, Z8 = (e, t) => !Ga(X(e, t)).length && nt(e, t);
const Y8 = {
  mode: zt.onSubmit,
  reValidateMode: zt.onChange,
  shouldFocusError: !0
};
function J8(e = {}) {
  let t = {
    ...Y8,
    ...e
  }, r = {
    submitCount: 0,
    isDirty: !1,
    isLoading: Lr(t.defaultValues),
    isValidating: !1,
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: t.errors || {},
    disabled: t.disabled || !1
  }, n = {}, i = it(t.defaultValues) || it(t.values) ? At(t.defaultValues || t.values) || {} : {}, a = t.shouldUnregister ? {} : At(i), o = {
    action: !1,
    mount: !1,
    watch: !1
  }, s = {
    mount: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  }, u, l = 0;
  const c = {
    isDirty: !1,
    dirtyFields: !1,
    validatingFields: !1,
    touchedFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  }, d = {
    values: dl(),
    array: dl(),
    state: dl()
  }, f = Mp(t.mode), h = Mp(t.reValidateMode), p = t.criteriaMode === zt.all, v = (F) => (R) => {
    clearTimeout(l), l = setTimeout(F, R);
  }, g = async (F) => {
    if (c.isValid || F) {
      const R = t.resolver ? Ct((await y()).errors) : await w(n, !0);
      R !== r.isValid && d.state.next({
        isValid: R
      });
    }
  }, $ = (F, R) => {
    (c.isValidating || c.validatingFields) && ((F || Array.from(s.mount)).forEach((N) => {
      N && (R ? Ve(r.validatingFields, N, R) : nt(r.validatingFields, N));
    }), d.state.next({
      validatingFields: r.validatingFields,
      isValidating: !Ct(r.validatingFields)
    }));
  }, m = (F, R = [], N, W, Z = !0, Q = !0) => {
    if (W && N) {
      if (o.action = !0, Q && Array.isArray(X(n, F))) {
        const de = N(X(n, F), W.argA, W.argB);
        Z && Ve(n, F, de);
      }
      if (Q && Array.isArray(X(r.errors, F))) {
        const de = N(X(r.errors, F), W.argA, W.argB);
        Z && Ve(r.errors, F, de), Z8(r.errors, F);
      }
      if (c.touchedFields && Q && Array.isArray(X(r.touchedFields, F))) {
        const de = N(X(r.touchedFields, F), W.argA, W.argB);
        Z && Ve(r.touchedFields, F, de);
      }
      c.dirtyFields && (r.dirtyFields = Do(i, a)), d.state.next({
        name: F,
        isDirty: k(F, R),
        dirtyFields: r.dirtyFields,
        errors: r.errors,
        isValid: r.isValid
      });
    } else
      Ve(a, F, R);
  }, b = (F, R) => {
    Ve(r.errors, F, R), d.state.next({
      errors: r.errors
    });
  }, D = (F) => {
    r.errors = F, d.state.next({
      errors: r.errors,
      isValid: !1
    });
  }, S = (F, R, N, W) => {
    const Z = X(n, F);
    if (Z) {
      const Q = X(a, F, Ge(N) ? X(i, F) : N);
      Ge(Q) || W && W.defaultChecked || R ? Ve(a, F, R ? Q : hl(Z._f)) : L(F, Q), o.mount && g();
    }
  }, T = (F, R, N, W, Z) => {
    let Q = !1, de = !1;
    const Pe = {
      name: F
    }, Je = !!(X(n, F) && X(n, F)._f && X(n, F)._f.disabled);
    if (!N || W) {
      c.isDirty && (de = r.isDirty, r.isDirty = Pe.isDirty = k(), Q = de !== Pe.isDirty);
      const wt = Je || cn(X(i, F), R);
      de = !!(!Je && X(r.dirtyFields, F)), wt || Je ? nt(r.dirtyFields, F) : Ve(r.dirtyFields, F, !0), Pe.dirtyFields = r.dirtyFields, Q = Q || c.dirtyFields && de !== !wt;
    }
    if (N) {
      const wt = X(r.touchedFields, F);
      wt || (Ve(r.touchedFields, F, N), Pe.touchedFields = r.touchedFields, Q = Q || c.touchedFields && wt !== N);
    }
    return Q && Z && d.state.next(Pe), Q ? Pe : {};
  }, B = (F, R, N, W) => {
    const Z = X(r.errors, F), Q = c.isValid && Mr(R) && r.isValid !== R;
    if (e.delayError && N ? (u = v(() => b(F, N)), u(e.delayError)) : (clearTimeout(l), u = null, N ? Ve(r.errors, F, N) : nt(r.errors, F)), (N ? !cn(Z, N) : Z) || !Ct(W) || Q) {
      const de = {
        ...W,
        ...Q && Mr(R) ? { isValid: R } : {},
        errors: r.errors,
        name: F
      };
      r = {
        ...r,
        ...de
      }, d.state.next(de);
    }
  }, y = async (F) => {
    $(F, !0);
    const R = await t.resolver(a, t.context, W8(F || s.mount, n, t.criteriaMode, t.shouldUseNativeValidation));
    return $(F), R;
  }, _ = async (F) => {
    const { errors: R } = await y(F);
    if (F)
      for (const N of F) {
        const W = X(R, N);
        W ? Ve(r.errors, N, W) : nt(r.errors, N);
      }
    else
      r.errors = R;
    return R;
  }, w = async (F, R, N = {
    valid: !0
  }) => {
    for (const W in F) {
      const Z = F[W];
      if (Z) {
        const { _f: Q, ...de } = Z;
        if (Q) {
          const Pe = s.array.has(Q.name);
          $([W], !0);
          const Je = await Kp(Z, a, p, t.shouldUseNativeValidation && !R, Pe);
          if ($([W]), Je[Q.name] && (N.valid = !1, R))
            break;
          !R && (X(Je, Q.name) ? Pe ? K8(r.errors, Je, Q.name) : Ve(r.errors, Q.name, Je[Q.name]) : nt(r.errors, Q.name));
        }
        de && await w(de, R, N);
      }
    }
    return N.valid;
  }, E = () => {
    for (const F of s.unMount) {
      const R = X(n, F);
      R && (R._f.refs ? R._f.refs.every((N) => !fl(N)) : !fl(R._f.ref)) && Oe(F);
    }
    s.unMount = /* @__PURE__ */ new Set();
  }, k = (F, R) => (F && R && Ve(a, F, R), !cn(ae(), i)), C = (F, R, N) => j8(F, s, {
    ...o.mount ? a : Ge(R) ? i : Gt(F) ? { [F]: R } : R
  }, N, R), A = (F) => Ga(X(o.mount ? a : i, F, e.shouldUnregister ? X(i, F, []) : [])), L = (F, R, N = {}) => {
    const W = X(n, F);
    let Z = R;
    if (W) {
      const Q = W._f;
      Q && (!Q.disabled && Ve(a, F, T$(R, Q)), Z = ds(Q.ref) && dt(R) ? "" : R, S$(Q.ref) ? [...Q.ref.options].forEach((de) => de.selected = Z.includes(de.value)) : Q.refs ? Qa(Q.ref) ? Q.refs.length > 1 ? Q.refs.forEach((de) => (!de.defaultChecked || !de.disabled) && (de.checked = Array.isArray(Z) ? !!Z.find((Pe) => Pe === de.value) : Z === de.value)) : Q.refs[0] && (Q.refs[0].checked = !!Z) : Q.refs.forEach((de) => de.checked = de.value === Z) : lf(Q.ref) ? Q.ref.value = "" : (Q.ref.value = Z, Q.ref.type || d.values.next({
        name: F,
        values: { ...a }
      })));
    }
    (N.shouldDirty || N.shouldTouch) && T(F, Z, N.shouldTouch, N.shouldDirty, !0), N.shouldValidate && z(F);
  }, I = (F, R, N) => {
    for (const W in R) {
      const Z = R[W], Q = `${F}.${W}`, de = X(n, Q);
      (s.array.has(F) || !hs(Z) || de && !de._f) && !Wn(Z) ? I(Q, Z, N) : L(Q, Z, N);
    }
  }, x = (F, R, N = {}) => {
    const W = X(n, F), Z = s.array.has(F), Q = At(R);
    Ve(a, F, Q), Z ? (d.array.next({
      name: F,
      values: { ...a }
    }), (c.isDirty || c.dirtyFields) && N.shouldDirty && d.state.next({
      name: F,
      dirtyFields: Do(i, a),
      isDirty: k(F, Q)
    })) : W && !W._f && !dt(Q) ? I(F, Q, N) : L(F, Q, N), Np(F, s) && d.state.next({ ...r }), d.values.next({
      name: o.mount ? F : void 0,
      values: { ...a }
    });
  }, U = async (F) => {
    o.mount = !0;
    const R = F.target;
    let N = R.name, W = !0;
    const Z = X(n, N), Q = () => R.type ? hl(Z._f) : R8(F), de = (Pe) => {
      W = Number.isNaN(Pe) || Pe === X(a, N, Pe);
    };
    if (Z) {
      let Pe, Je;
      const wt = Q(), An = F.type === Bp.BLUR || F.type === Bp.FOCUS_OUT, Z$ = !Q8(Z._f) && !t.resolver && !X(r.errors, N) && !Z._f.deps || G8(An, X(r.touchedFields, N), r.isSubmitted, h, f), vu = Np(N, s, An);
      Ve(a, N, wt), An ? (Z._f.onBlur && Z._f.onBlur(F), u && u(0)) : Z._f.onChange && Z._f.onChange(F);
      const yu = T(N, wt, An, !1), Y$ = !Ct(yu) || vu;
      if (!An && d.values.next({
        name: N,
        type: F.type,
        values: { ...a }
      }), Z$)
        return c.isValid && g(), Y$ && d.state.next({ name: N, ...vu ? {} : yu });
      if (!An && vu && d.state.next({ ...r }), t.resolver) {
        const { errors: yf } = await y([N]);
        if (de(wt), W) {
          const J$ = Up(r.errors, n, N), gf = Up(yf, n, J$.name || N);
          Pe = gf.error, N = gf.name, Je = Ct(yf);
        }
      } else
        $([N], !0), Pe = (await Kp(Z, a, p, t.shouldUseNativeValidation))[N], $([N]), de(wt), W && (Pe ? Je = !1 : c.isValid && (Je = await w(n, !0)));
      W && (Z._f.deps && z(Z._f.deps), B(N, Je, Pe, yu));
    }
  }, K = (F, R) => {
    if (X(r.errors, R) && F.focus)
      return F.focus(), 1;
  }, z = async (F, R = {}) => {
    let N, W;
    const Z = cl(F);
    if (t.resolver) {
      const Q = await _(Ge(F) ? F : Z);
      N = Ct(Q), W = F ? !Z.some((de) => X(Q, de)) : N;
    } else F ? (W = (await Promise.all(Z.map(async (Q) => {
      const de = X(n, Q);
      return await w(de && de._f ? { [Q]: de } : de);
    }))).every(Boolean), !(!W && !r.isValid) && g()) : W = N = await w(n);
    return d.state.next({
      ...!Gt(F) || c.isValid && N !== r.isValid ? {} : { name: F },
      ...t.resolver || !F ? { isValid: N } : {},
      errors: r.errors
    }), R.shouldFocus && !W && aa(n, K, F ? Z : s.mount), W;
  }, ae = (F) => {
    const R = {
      ...o.mount ? a : i
    };
    return Ge(F) ? R : Gt(F) ? X(R, F) : F.map((N) => X(R, N));
  }, ne = (F, R) => ({
    invalid: !!X((R || r).errors, F),
    isDirty: !!X((R || r).dirtyFields, F),
    error: X((R || r).errors, F),
    isValidating: !!X(r.validatingFields, F),
    isTouched: !!X((R || r).touchedFields, F)
  }), ye = (F) => {
    F && cl(F).forEach((R) => nt(r.errors, R)), d.state.next({
      errors: F ? r.errors : {}
    });
  }, De = (F, R, N) => {
    const W = (X(n, F, { _f: {} })._f || {}).ref, Z = X(r.errors, F) || {}, { ref: Q, message: de, type: Pe, ...Je } = Z;
    Ve(r.errors, F, {
      ...Je,
      ...R,
      ref: W
    }), d.state.next({
      name: F,
      errors: r.errors,
      isValid: !1
    }), N && N.shouldFocus && W && W.focus && W.focus();
  }, Fe = (F, R) => Lr(F) ? d.values.subscribe({
    next: (N) => F(C(void 0, R), N)
  }) : C(F, R, !0), Oe = (F, R = {}) => {
    for (const N of F ? cl(F) : s.mount)
      s.mount.delete(N), s.array.delete(N), R.keepValue || (nt(n, N), nt(a, N)), !R.keepError && nt(r.errors, N), !R.keepDirty && nt(r.dirtyFields, N), !R.keepTouched && nt(r.touchedFields, N), !R.keepIsValidating && nt(r.validatingFields, N), !t.shouldUnregister && !R.keepDefaultValue && nt(i, N);
    d.values.next({
      values: { ...a }
    }), d.state.next({
      ...r,
      ...R.keepDirty ? { isDirty: k() } : {}
    }), !R.keepIsValid && g();
  }, V = ({ disabled: F, name: R, field: N, fields: W, value: Z }) => {
    if (Mr(F) && o.mount || F) {
      const Q = F ? void 0 : Ge(Z) ? hl(N ? N._f : X(W, R)._f) : Z;
      Ve(a, R, Q), T(R, Q, !1, !1, !0);
    }
  }, ie = (F, R = {}) => {
    let N = X(n, F);
    const W = Mr(R.disabled);
    return Ve(n, F, {
      ...N || {},
      _f: {
        ...N && N._f ? N._f : { ref: { name: F } },
        name: F,
        mount: !0,
        ...R
      }
    }), s.mount.add(F), N ? V({
      field: N,
      disabled: R.disabled,
      name: F,
      value: R.value
    }) : S(F, !0, R.value), {
      ...W ? { disabled: R.disabled } : {},
      ...t.progressive ? {
        required: !!R.required,
        min: ji(R.min),
        max: ji(R.max),
        minLength: ji(R.minLength),
        maxLength: ji(R.maxLength),
        pattern: ji(R.pattern)
      } : {},
      name: F,
      onChange: U,
      onBlur: U,
      ref: (Z) => {
        if (Z) {
          ie(F, R), N = X(n, F);
          const Q = Ge(Z.value) && Z.querySelectorAll && Z.querySelectorAll("input,select,textarea")[0] || Z, de = H8(Q), Pe = N._f.refs || [];
          if (de ? Pe.find((Je) => Je === Q) : Q === N._f.ref)
            return;
          Ve(n, F, {
            _f: {
              ...N._f,
              ...de ? {
                refs: [
                  ...Pe.filter(fl),
                  Q,
                  ...Array.isArray(X(i, F)) ? [{}] : []
                ],
                ref: { type: Q.type, name: F }
              } : { ref: Q }
            }
          }), S(F, !1, void 0, Q);
        } else
          N = X(n, F, {}), N._f && (N._f.mount = !1), (t.shouldUnregister || R.shouldUnregister) && !(M8(s.array, F) && o.action) && s.unMount.add(F);
      }
    };
  }, we = () => t.shouldFocusError && aa(n, K, s.mount), Ke = (F) => {
    Mr(F) && (d.state.next({ disabled: F }), aa(n, (R, N) => {
      const W = X(n, N);
      W && (R.disabled = W._f.disabled || F, Array.isArray(W._f.refs) && W._f.refs.forEach((Z) => {
        Z.disabled = W._f.disabled || F;
      }));
    }, 0, !1));
  }, We = (F, R) => async (N) => {
    let W;
    N && (N.preventDefault && N.preventDefault(), N.persist && N.persist());
    let Z = At(a);
    if (d.state.next({
      isSubmitting: !0
    }), t.resolver) {
      const { errors: Q, values: de } = await y();
      r.errors = Q, Z = de;
    } else
      await w(n);
    if (nt(r.errors, "root"), Ct(r.errors)) {
      d.state.next({
        errors: {}
      });
      try {
        await F(Z, N);
      } catch (Q) {
        W = Q;
      }
    } else
      R && await R({ ...r.errors }, N), we(), setTimeout(we);
    if (d.state.next({
      isSubmitted: !0,
      isSubmitting: !1,
      isSubmitSuccessful: Ct(r.errors) && !W,
      submitCount: r.submitCount + 1,
      errors: r.errors
    }), W)
      throw W;
  }, kr = (F, R = {}) => {
    X(n, F) && (Ge(R.defaultValue) ? x(F, At(X(i, F))) : (x(F, R.defaultValue), Ve(i, F, At(R.defaultValue))), R.keepTouched || nt(r.touchedFields, F), R.keepDirty || (nt(r.dirtyFields, F), r.isDirty = R.defaultValue ? k(F, At(X(i, F))) : k()), R.keepError || (nt(r.errors, F), c.isValid && g()), d.state.next({ ...r }));
  }, Jr = (F, R = {}) => {
    const N = F ? At(F) : i, W = At(N), Z = Ct(F), Q = Z ? i : W;
    if (R.keepDefaultValues || (i = N), !R.keepValues) {
      if (R.keepDirtyValues)
        for (const de of s.mount)
          X(r.dirtyFields, de) ? Ve(Q, de, X(a, de)) : x(de, X(Q, de));
      else {
        if (sf && Ge(F))
          for (const de of s.mount) {
            const Pe = X(n, de);
            if (Pe && Pe._f) {
              const Je = Array.isArray(Pe._f.refs) ? Pe._f.refs[0] : Pe._f.ref;
              if (ds(Je)) {
                const wt = Je.closest("form");
                if (wt) {
                  wt.reset();
                  break;
                }
              }
            }
          }
        n = {};
      }
      a = e.shouldUnregister ? R.keepDefaultValues ? At(i) : {} : At(Q), d.array.next({
        values: { ...Q }
      }), d.values.next({
        values: { ...Q }
      });
    }
    s = {
      mount: R.keepDirtyValues ? s.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: !1,
      focus: ""
    }, o.mount = !c.isValid || !!R.keepIsValid || !!R.keepDirtyValues, o.watch = !!e.shouldUnregister, d.state.next({
      submitCount: R.keepSubmitCount ? r.submitCount : 0,
      isDirty: Z ? !1 : R.keepDirty ? r.isDirty : !!(R.keepDefaultValues && !cn(F, i)),
      isSubmitted: R.keepIsSubmitted ? r.isSubmitted : !1,
      dirtyFields: Z ? [] : R.keepDirtyValues ? R.keepDefaultValues && a ? Do(i, a) : r.dirtyFields : R.keepDefaultValues && F ? Do(i, F) : R.keepDirty ? r.dirtyFields : {},
      touchedFields: R.keepTouched ? r.touchedFields : {},
      errors: R.keepErrors ? r.errors : {},
      isSubmitSuccessful: R.keepIsSubmitSuccessful ? r.isSubmitSuccessful : !1,
      isSubmitting: !1
    });
  }, Tn = (F, R) => Jr(Lr(F) ? F(a) : F, R);
  return {
    control: {
      register: ie,
      unregister: Oe,
      getFieldState: ne,
      handleSubmit: We,
      setError: De,
      _executeSchema: y,
      _getWatch: C,
      _getDirty: k,
      _updateValid: g,
      _removeUnmounted: E,
      _updateFieldArray: m,
      _updateDisabledField: V,
      _getFieldArray: A,
      _reset: Jr,
      _resetDefaultValues: () => Lr(t.defaultValues) && t.defaultValues().then((F) => {
        Tn(F, t.resetOptions), d.state.next({
          isLoading: !1
        });
      }),
      _updateFormState: (F) => {
        r = {
          ...r,
          ...F
        };
      },
      _disableForm: Ke,
      _subjects: d,
      _proxyFormState: c,
      _setErrors: D,
      get _fields() {
        return n;
      },
      get _formValues() {
        return a;
      },
      get _state() {
        return o;
      },
      set _state(F) {
        o = F;
      },
      get _defaultValues() {
        return i;
      },
      get _names() {
        return s;
      },
      set _names(F) {
        s = F;
      },
      get _formState() {
        return r;
      },
      set _formState(F) {
        r = F;
      },
      get _options() {
        return t;
      },
      set _options(F) {
        t = {
          ...t,
          ...F
        };
      }
    },
    trigger: z,
    register: ie,
    handleSubmit: We,
    watch: Fe,
    setValue: x,
    getValues: ae,
    reset: Tn,
    resetField: kr,
    clearErrors: ye,
    unregister: Oe,
    setError: De,
    setFocus: (F, R = {}) => {
      const N = X(n, F), W = N && N._f;
      if (W) {
        const Z = W.refs ? W.refs[0] : W.ref;
        Z.focus && (Z.focus(), R.shouldSelect && Z.select());
      }
    },
    getFieldState: ne
  };
}
function A$(e = {}) {
  const t = P.useRef(), r = P.useRef(), [n, i] = P.useState({
    isDirty: !1,
    isValidating: !1,
    isLoading: Lr(e.defaultValues),
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: e.errors || {},
    disabled: e.disabled || !1,
    defaultValues: Lr(e.defaultValues) ? void 0 : e.defaultValues
  });
  t.current || (t.current = {
    ...J8(e),
    formState: n
  });
  const a = t.current.control;
  return a._options = e, z8({
    subject: a._subjects.state,
    next: (o) => {
      V8(o, a._proxyFormState, a._updateFormState) && i({ ...a._formState });
    }
  }), P.useEffect(() => a._disableForm(e.disabled), [a, e.disabled]), P.useEffect(() => {
    if (a._proxyFormState.isDirty) {
      const o = a._getDirty();
      o !== n.isDirty && a._subjects.state.next({
        isDirty: o
      });
    }
  }, [a, n.isDirty]), P.useEffect(() => {
    e.values && !cn(e.values, r.current) ? (a._reset(e.values, a._options.resetOptions), r.current = e.values, i((o) => ({ ...o }))) : a._resetDefaultValues();
  }, [e.values, a]), P.useEffect(() => {
    e.errors && a._setErrors(e.errors);
  }, [e.errors, a]), P.useEffect(() => {
    a._state.mount || (a._updateValid(), a._state.mount = !0), a._state.watch && (a._state.watch = !1, a._subjects.state.next({ ...a._formState })), a._removeUnmounted();
  }), P.useEffect(() => {
    e.shouldUnregister && a._subjects.values.next({
      values: a._getWatch()
    });
  }, [e.shouldUnregister, a]), t.current.formState = L8(n, a), t.current;
}
var qp = function(e, t, r) {
  if (e && "reportValidity" in e) {
    var n = X(r, t);
    e.setCustomValidity(n && n.message || ""), e.reportValidity();
  }
}, _$ = function(e, t) {
  var r = function(i) {
    var a = t.fields[i];
    a && a.ref && "reportValidity" in a.ref ? qp(a.ref, i, e) : a.refs && a.refs.forEach(function(o) {
      return qp(o, i, e);
    });
  };
  for (var n in t.fields) r(n);
}, X8 = function(e) {
  return e instanceof Date;
}, eP = function(e) {
  return e == null;
}, tP = function(e) {
  return typeof e == "object";
}, rP = function(e) {
  return !eP(e) && !Array.isArray(e) && tP(e) && !X8(e);
}, nP = function(e) {
  return /^\w*$/.test(e);
}, pl = function(e, t, r) {
  for (var n = -1, i = nP(t) ? [t] : function(c) {
    return d = c.replace(/["|']|\]/g, "").split(/\.|\[/), Array.isArray(d) ? d.filter(Boolean) : [];
    var d;
  }(t), a = i.length, o = a - 1; ++n < a; ) {
    var s = i[n], u = r;
    if (n !== o) {
      var l = e[s];
      u = rP(l) || Array.isArray(l) ? l : isNaN(+i[n + 1]) ? {} : [];
    }
    e[s] = u, e = e[s];
  }
  return e;
}, iP = function(e, t) {
  t.shouldUseNativeValidation && _$(e, t);
  var r = {};
  for (var n in e) {
    var i = X(t.fields, n), a = Object.assign(e[n] || {}, { ref: i && i.ref });
    if (aP(t.names || Object.keys(e), n)) {
      var o = Object.assign({}, X(r, n));
      pl(o, "root", a), pl(r, n, o);
    } else pl(r, n, a);
  }
  return r;
}, aP = function(e, t) {
  return e.some(function(r) {
    return r.startsWith(t + ".");
  });
}, oP = function(e, t) {
  for (var r = {}; e.length; ) {
    var n = e[0], i = n.code, a = n.message, o = n.path.join(".");
    if (!r[o]) if ("unionErrors" in n) {
      var s = n.unionErrors[0].errors[0];
      r[o] = { message: s.message, type: s.code };
    } else r[o] = { message: a, type: i };
    if ("unionErrors" in n && n.unionErrors.forEach(function(c) {
      return c.errors.forEach(function(d) {
        return e.push(d);
      });
    }), t) {
      var u = r[o].types, l = u && u[n.code];
      r[o] = E$(o, t, r, i, l ? [].concat(l, n.message) : n.message);
    }
    e.shift();
  }
  return r;
}, F$ = function(e, t, r) {
  return r === void 0 && (r = {}), function(n, i, a) {
    try {
      return Promise.resolve(function(o, s) {
        try {
          var u = Promise.resolve(e[r.mode === "sync" ? "parse" : "parseAsync"](n, t)).then(function(l) {
            return a.shouldUseNativeValidation && _$({}, a), { errors: {}, values: r.raw ? n : l };
          });
        } catch (l) {
          return s(l);
        }
        return u && u.then ? u.then(void 0, s) : u;
      }(0, function(o) {
        if (function(s) {
          return s.errors != null;
        }(o)) return { values: {}, errors: iP(oP(o.errors, !a.shouldUseNativeValidation && a.criteriaMode === "all"), a) };
        throw o;
      }));
    } catch (o) {
      return Promise.reject(o);
    }
  };
}, Se;
(function(e) {
  e.assertEqual = (i) => i;
  function t(i) {
  }
  e.assertIs = t;
  function r(i) {
    throw new Error();
  }
  e.assertNever = r, e.arrayToEnum = (i) => {
    const a = {};
    for (const o of i)
      a[o] = o;
    return a;
  }, e.getValidEnumValues = (i) => {
    const a = e.objectKeys(i).filter((s) => typeof i[i[s]] != "number"), o = {};
    for (const s of a)
      o[s] = i[s];
    return e.objectValues(o);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(a) {
    return i[a];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const a = [];
    for (const o in i)
      Object.prototype.hasOwnProperty.call(i, o) && a.push(o);
    return a;
  }, e.find = (i, a) => {
    for (const o of i)
      if (a(o))
        return o;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function n(i, a = " | ") {
    return i.map((o) => typeof o == "string" ? `'${o}'` : o).join(a);
  }
  e.joinValues = n, e.jsonStringifyReplacer = (i, a) => typeof a == "bigint" ? a.toString() : a;
})(Se || (Se = {}));
var Hp;
(function(e) {
  e.mergeShapes = (t, r) => ({
    ...t,
    ...r
    // second overwrites first
  });
})(Hp || (Hp = {}));
const J = Se.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), nn = (e) => {
  switch (typeof e) {
    case "undefined":
      return J.undefined;
    case "string":
      return J.string;
    case "number":
      return isNaN(e) ? J.nan : J.number;
    case "boolean":
      return J.boolean;
    case "function":
      return J.function;
    case "bigint":
      return J.bigint;
    case "symbol":
      return J.symbol;
    case "object":
      return Array.isArray(e) ? J.array : e === null ? J.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? J.promise : typeof Map < "u" && e instanceof Map ? J.map : typeof Set < "u" && e instanceof Set ? J.set : typeof Date < "u" && e instanceof Date ? J.date : J.object;
    default:
      return J.unknown;
  }
}, H = Se.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class Rt extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(a) {
      return a.message;
    }, n = { _errors: [] }, i = (a) => {
      for (const o of a.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(i);
        else if (o.code === "invalid_return_type")
          i(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          i(o.argumentsError);
        else if (o.path.length === 0)
          n._errors.push(r(o));
        else {
          let s = n, u = 0;
          for (; u < o.path.length; ) {
            const l = o.path[u];
            u === o.path.length - 1 ? (s[l] = s[l] || { _errors: [] }, s[l]._errors.push(r(o))) : s[l] = s[l] || { _errors: [] }, s = s[l], u++;
          }
        }
    };
    return i(this), n;
  }
  static assert(t) {
    if (!(t instanceof Rt))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Se.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, n = [];
    for (const i of this.issues)
      i.path.length > 0 ? (r[i.path[0]] = r[i.path[0]] || [], r[i.path[0]].push(t(i))) : n.push(t(i));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
Rt.create = (e) => new Rt(e);
const _a = (e, t) => {
  let r;
  switch (e.code) {
    case H.invalid_type:
      e.received === J.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case H.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, Se.jsonStringifyReplacer)}`;
      break;
    case H.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Se.joinValues(e.keys, ", ")}`;
      break;
    case H.invalid_union:
      r = "Invalid input";
      break;
    case H.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Se.joinValues(e.options)}`;
      break;
    case H.invalid_enum_value:
      r = `Invalid enum value. Expected ${Se.joinValues(e.options)}, received '${e.received}'`;
      break;
    case H.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case H.invalid_return_type:
      r = "Invalid function return type";
      break;
    case H.invalid_date:
      r = "Invalid date";
      break;
    case H.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : Se.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case H.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case H.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case H.custom:
      r = "Invalid input";
      break;
    case H.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case H.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case H.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, Se.assertNever(e);
  }
  return { message: r };
};
let sP = _a;
function kc() {
  return sP;
}
const Pc = (e) => {
  const { data: t, path: r, errorMaps: n, issueData: i } = e, a = [...r, ...i.path || []], o = {
    ...i,
    path: a
  };
  if (i.message !== void 0)
    return {
      ...i,
      path: a,
      message: i.message
    };
  let s = "";
  const u = n.filter((l) => !!l).slice().reverse();
  for (const l of u)
    s = l(o, { data: t, defaultError: s }).message;
  return {
    ...i,
    path: a,
    message: s
  };
};
function Y(e, t) {
  const r = kc(), n = Pc({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      r,
      r === _a ? void 0 : _a
      // then global default map
    ].filter((i) => !!i)
  });
  e.common.issues.push(n);
}
class mt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, r) {
    const n = [];
    for (const i of r) {
      if (i.status === "aborted")
        return he;
      i.status === "dirty" && t.dirty(), n.push(i.value);
    }
    return { status: t.value, value: n };
  }
  static async mergeObjectAsync(t, r) {
    const n = [];
    for (const i of r) {
      const a = await i.key, o = await i.value;
      n.push({
        key: a,
        value: o
      });
    }
    return mt.mergeObjectSync(t, n);
  }
  static mergeObjectSync(t, r) {
    const n = {};
    for (const i of r) {
      const { key: a, value: o } = i;
      if (a.status === "aborted" || o.status === "aborted")
        return he;
      a.status === "dirty" && t.dirty(), o.status === "dirty" && t.dirty(), a.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (n[a.value] = o.value);
    }
    return { status: t.value, value: n };
  }
}
const he = Object.freeze({
  status: "aborted"
}), Wi = (e) => ({ status: "dirty", value: e }), Dt = (e) => ({ status: "valid", value: e }), Wp = (e) => e.status === "aborted", Qp = (e) => e.status === "dirty", ms = (e) => e.status === "valid", vs = (e) => typeof Promise < "u" && e instanceof Promise;
function ys(e, t, r, n) {
  if (typeof t == "function" ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t.get(e);
}
function O$(e, t, r, n, i) {
  if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(e, r), r;
}
var se;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(se || (se = {}));
var Qi, Gi;
class rr {
  constructor(t, r, n, i) {
    this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const Gp = (e, t) => {
  if (ms(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new Rt(e.common.issues);
      return this._error = r, this._error;
    }
  };
};
function me(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: r, required_error: n, description: i } = e;
  if (t && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (o, s) => {
    var u, l;
    const { message: c } = e;
    return o.code === "invalid_enum_value" ? { message: c ?? s.defaultError } : typeof s.data > "u" ? { message: (u = c ?? n) !== null && u !== void 0 ? u : s.defaultError } : o.code !== "invalid_type" ? { message: s.defaultError } : { message: (l = c ?? r) !== null && l !== void 0 ? l : s.defaultError };
  }, description: i };
}
class $e {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return nn(t.data);
  }
  _getOrReturnCtx(t, r) {
    return r || {
      common: t.parent.common,
      data: t.data,
      parsedType: nn(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new mt(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: nn(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const r = this._parse(t);
    if (vs(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(t) {
    const r = this._parse(t);
    return Promise.resolve(r);
  }
  parse(t, r) {
    const n = this.safeParse(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(t, r) {
    var n;
    const i = {
      common: {
        issues: [],
        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: nn(t)
    }, a = this._parseSync({ data: t, path: i.path, parent: i });
    return Gp(i, a);
  }
  async parseAsync(t, r) {
    const n = await this.safeParseAsync(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(t, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: !0
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: nn(t)
    }, i = this._parse({ data: t, path: n.path, parent: n }), a = await (vs(i) ? i : Promise.resolve(i));
    return Gp(n, a);
  }
  refine(t, r) {
    const n = (i) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(i) : r;
    return this._refinement((i, a) => {
      const o = t(i), s = () => a.addIssue({
        code: H.custom,
        ...n(i)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((u) => u ? !0 : (s(), !1)) : o ? !0 : (s(), !1);
    });
  }
  refinement(t, r) {
    return this._refinement((n, i) => t(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1));
  }
  _refinement(t) {
    return new Er({
      schema: this,
      typeName: fe.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return vr.create(this, this._def);
  }
  nullable() {
    return En.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Jt.create(this, this._def);
  }
  promise() {
    return Oa.create(this, this._def);
  }
  or(t) {
    return $s.create([this, t], this._def);
  }
  and(t) {
    return xs.create(this, t, this._def);
  }
  transform(t) {
    return new Er({
      ...me(this._def),
      schema: this,
      typeName: fe.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const r = typeof t == "function" ? t : () => t;
    return new Ss({
      ...me(this._def),
      innerType: this,
      defaultValue: r,
      typeName: fe.ZodDefault
    });
  }
  brand() {
    return new M$({
      typeName: fe.ZodBranded,
      type: this,
      ...me(this._def)
    });
  }
  catch(t) {
    const r = typeof t == "function" ? t : () => t;
    return new ks({
      ...me(this._def),
      innerType: this,
      catchValue: r,
      typeName: fe.ZodCatch
    });
  }
  describe(t) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return hu.create(this, t);
  }
  readonly() {
    return Ps.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const uP = /^c[^\s-]{8,}$/i, lP = /^[0-9a-z]+$/, cP = /^[0-9A-HJKMNP-TV-Z]{26}$/, dP = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, fP = /^[a-z0-9_-]{21}$/i, hP = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, pP = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, mP = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let ml;
const vP = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, yP = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, gP = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, I$ = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", bP = new RegExp(`^${I$}$`);
function R$(e) {
  let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t;
}
function $P(e) {
  return new RegExp(`^${R$(e)}$`);
}
function xP(e) {
  let t = `${I$}T${R$(e)}`;
  const r = [];
  return r.push(e.local ? "Z?" : "Z"), e.offset && r.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${r.join("|")})`, new RegExp(`^${t}$`);
}
function DP(e, t) {
  return !!((t === "v4" || !t) && vP.test(e) || (t === "v6" || !t) && yP.test(e));
}
class mr extends $e {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== J.string) {
      const a = this._getOrReturnCtx(t);
      return Y(a, {
        code: H.invalid_type,
        expected: J.string,
        received: a.parsedType
      }), he;
    }
    const n = new mt();
    let i;
    for (const a of this._def.checks)
      if (a.kind === "min")
        t.data.length < a.value && (i = this._getOrReturnCtx(t, i), Y(i, {
          code: H.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), n.dirty());
      else if (a.kind === "max")
        t.data.length > a.value && (i = this._getOrReturnCtx(t, i), Y(i, {
          code: H.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), n.dirty());
      else if (a.kind === "length") {
        const o = t.data.length > a.value, s = t.data.length < a.value;
        (o || s) && (i = this._getOrReturnCtx(t, i), o ? Y(i, {
          code: H.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : s && Y(i, {
          code: H.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), n.dirty());
      } else if (a.kind === "email")
        pP.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "email",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "emoji")
        ml || (ml = new RegExp(mP, "u")), ml.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "emoji",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "uuid")
        dP.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "uuid",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "nanoid")
        fP.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "nanoid",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "cuid")
        uP.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "cuid",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "cuid2")
        lP.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "cuid2",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "ulid")
        cP.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "ulid",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), Y(i, {
            validation: "url",
            code: H.invalid_string,
            message: a.message
          }), n.dirty();
        }
      else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
        validation: "regex",
        code: H.invalid_string,
        message: a.message
      }), n.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.invalid_string,
        validation: { includes: a.value, position: a.position },
        message: a.message
      }), n.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a.kind === "startsWith" ? t.data.startsWith(a.value) || (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.invalid_string,
        validation: { startsWith: a.value },
        message: a.message
      }), n.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.invalid_string,
        validation: { endsWith: a.value },
        message: a.message
      }), n.dirty()) : a.kind === "datetime" ? xP(a).test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.invalid_string,
        validation: "datetime",
        message: a.message
      }), n.dirty()) : a.kind === "date" ? bP.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.invalid_string,
        validation: "date",
        message: a.message
      }), n.dirty()) : a.kind === "time" ? $P(a).test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.invalid_string,
        validation: "time",
        message: a.message
      }), n.dirty()) : a.kind === "duration" ? hP.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
        validation: "duration",
        code: H.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "ip" ? DP(t.data, a.version) || (i = this._getOrReturnCtx(t, i), Y(i, {
        validation: "ip",
        code: H.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "base64" ? gP.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
        validation: "base64",
        code: H.invalid_string,
        message: a.message
      }), n.dirty()) : Se.assertNever(a);
    return { status: n.value, value: t.data };
  }
  _regex(t, r, n) {
    return this.refinement((i) => t.test(i), {
      validation: r,
      code: H.invalid_string,
      ...se.errToObj(n)
    });
  }
  _addCheck(t) {
    return new mr({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...se.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...se.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...se.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...se.errToObj(t) });
  }
  nanoid(t) {
    return this._addCheck({ kind: "nanoid", ...se.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...se.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...se.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...se.errToObj(t) });
  }
  base64(t) {
    return this._addCheck({ kind: "base64", ...se.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...se.errToObj(t) });
  }
  datetime(t) {
    var r, n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
      local: (n = t == null ? void 0 : t.local) !== null && n !== void 0 ? n : !1,
      ...se.errToObj(t == null ? void 0 : t.message)
    });
  }
  date(t) {
    return this._addCheck({ kind: "date", message: t });
  }
  time(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: t
    }) : this._addCheck({
      kind: "time",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      ...se.errToObj(t == null ? void 0 : t.message)
    });
  }
  duration(t) {
    return this._addCheck({ kind: "duration", ...se.errToObj(t) });
  }
  regex(t, r) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...se.errToObj(r)
    });
  }
  includes(t, r) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: r == null ? void 0 : r.position,
      ...se.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(t, r) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...se.errToObj(r)
    });
  }
  endsWith(t, r) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...se.errToObj(r)
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...se.errToObj(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...se.errToObj(r)
    });
  }
  length(t, r) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...se.errToObj(r)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, se.errToObj(t));
  }
  trim() {
    return new mr({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new mr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new mr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((t) => t.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((t) => t.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((t) => t.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((t) => t.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((t) => t.kind === "base64");
  }
  get minLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
mr.create = (e) => {
  var t;
  return new mr({
    checks: [],
    typeName: fe.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...me(e)
  });
};
function EP(e, t) {
  const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, i = r > n ? r : n, a = parseInt(e.toFixed(i).replace(".", "")), o = parseInt(t.toFixed(i).replace(".", ""));
  return a % o / Math.pow(10, i);
}
class mi extends $e {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== J.number) {
      const a = this._getOrReturnCtx(t);
      return Y(a, {
        code: H.invalid_type,
        expected: J.number,
        received: a.parsedType
      }), he;
    }
    let n;
    const i = new mt();
    for (const a of this._def.checks)
      a.kind === "int" ? Se.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), i.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? EP(t.data, a.value) !== 0 && (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.not_finite,
        message: a.message
      }), i.dirty()) : Se.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, se.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, se.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, se.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, se.toString(r));
  }
  setLimit(t, r, n, i) {
    return new mi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: se.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new mi({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: se.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: se.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: se.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: se.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: se.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: se.toString(r)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: se.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: se.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: se.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && Se.isInteger(t.value));
  }
  get isFinite() {
    let t = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(t);
  }
}
mi.create = (e) => new mi({
  checks: [],
  typeName: fe.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...me(e)
});
class vi extends $e {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== J.bigint) {
      const a = this._getOrReturnCtx(t);
      return Y(a, {
        code: H.invalid_type,
        expected: J.bigint,
        received: a.parsedType
      }), he;
    }
    let n;
    const i = new mt();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : Se.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, se.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, se.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, se.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, se.toString(r));
  }
  setLimit(t, r, n, i) {
    return new vi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: se.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new vi({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: se.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: se.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: se.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: se.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: se.toString(r)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
vi.create = (e) => {
  var t;
  return new vi({
    checks: [],
    typeName: fe.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...me(e)
  });
};
class Tc extends $e {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== J.boolean) {
      const n = this._getOrReturnCtx(t);
      return Y(n, {
        code: H.invalid_type,
        expected: J.boolean,
        received: n.parsedType
      }), he;
    }
    return Dt(t.data);
  }
}
Tc.create = (e) => new Tc({
  typeName: fe.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...me(e)
});
class Fa extends $e {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== J.date) {
      const a = this._getOrReturnCtx(t);
      return Y(a, {
        code: H.invalid_type,
        expected: J.date,
        received: a.parsedType
      }), he;
    }
    if (isNaN(t.data.getTime())) {
      const a = this._getOrReturnCtx(t);
      return Y(a, {
        code: H.invalid_date
      }), he;
    }
    const n = new mt();
    let i;
    for (const a of this._def.checks)
      a.kind === "min" ? t.data.getTime() < a.value && (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), n.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), n.dirty()) : Se.assertNever(a);
    return {
      status: n.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Fa({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: se.toString(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: se.toString(r)
    });
  }
  get minDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
}
Fa.create = (e) => new Fa({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: fe.ZodDate,
  ...me(e)
});
class Ac extends $e {
  _parse(t) {
    if (this._getType(t) !== J.symbol) {
      const n = this._getOrReturnCtx(t);
      return Y(n, {
        code: H.invalid_type,
        expected: J.symbol,
        received: n.parsedType
      }), he;
    }
    return Dt(t.data);
  }
}
Ac.create = (e) => new Ac({
  typeName: fe.ZodSymbol,
  ...me(e)
});
class gs extends $e {
  _parse(t) {
    if (this._getType(t) !== J.undefined) {
      const n = this._getOrReturnCtx(t);
      return Y(n, {
        code: H.invalid_type,
        expected: J.undefined,
        received: n.parsedType
      }), he;
    }
    return Dt(t.data);
  }
}
gs.create = (e) => new gs({
  typeName: fe.ZodUndefined,
  ...me(e)
});
class bs extends $e {
  _parse(t) {
    if (this._getType(t) !== J.null) {
      const n = this._getOrReturnCtx(t);
      return Y(n, {
        code: H.invalid_type,
        expected: J.null,
        received: n.parsedType
      }), he;
    }
    return Dt(t.data);
  }
}
bs.create = (e) => new bs({
  typeName: fe.ZodNull,
  ...me(e)
});
class _c extends $e {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Dt(t.data);
  }
}
_c.create = (e) => new _c({
  typeName: fe.ZodAny,
  ...me(e)
});
class ai extends $e {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Dt(t.data);
  }
}
ai.create = (e) => new ai({
  typeName: fe.ZodUnknown,
  ...me(e)
});
class Wr extends $e {
  _parse(t) {
    const r = this._getOrReturnCtx(t);
    return Y(r, {
      code: H.invalid_type,
      expected: J.never,
      received: r.parsedType
    }), he;
  }
}
Wr.create = (e) => new Wr({
  typeName: fe.ZodNever,
  ...me(e)
});
class Fc extends $e {
  _parse(t) {
    if (this._getType(t) !== J.undefined) {
      const n = this._getOrReturnCtx(t);
      return Y(n, {
        code: H.invalid_type,
        expected: J.void,
        received: n.parsedType
      }), he;
    }
    return Dt(t.data);
  }
}
Fc.create = (e) => new Fc({
  typeName: fe.ZodVoid,
  ...me(e)
});
class Jt extends $e {
  _parse(t) {
    const { ctx: r, status: n } = this._processInputParams(t), i = this._def;
    if (r.parsedType !== J.array)
      return Y(r, {
        code: H.invalid_type,
        expected: J.array,
        received: r.parsedType
      }), he;
    if (i.exactLength !== null) {
      const o = r.data.length > i.exactLength.value, s = r.data.length < i.exactLength.value;
      (o || s) && (Y(r, {
        code: o ? H.too_big : H.too_small,
        minimum: s ? i.exactLength.value : void 0,
        maximum: o ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), n.dirty());
    }
    if (i.minLength !== null && r.data.length < i.minLength.value && (Y(r, {
      code: H.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), n.dirty()), i.maxLength !== null && r.data.length > i.maxLength.value && (Y(r, {
      code: H.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((o, s) => i.type._parseAsync(new rr(r, o, r.path, s)))).then((o) => mt.mergeArray(n, o));
    const a = [...r.data].map((o, s) => i.type._parseSync(new rr(r, o, r.path, s)));
    return mt.mergeArray(n, a);
  }
  get element() {
    return this._def.type;
  }
  min(t, r) {
    return new Jt({
      ...this._def,
      minLength: { value: t, message: se.toString(r) }
    });
  }
  max(t, r) {
    return new Jt({
      ...this._def,
      maxLength: { value: t, message: se.toString(r) }
    });
  }
  length(t, r) {
    return new Jt({
      ...this._def,
      exactLength: { value: t, message: se.toString(r) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Jt.create = (e, t) => new Jt({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: fe.ZodArray,
  ...me(t)
});
function Ln(e) {
  if (e instanceof Ue) {
    const t = {};
    for (const r in e.shape) {
      const n = e.shape[r];
      t[r] = vr.create(Ln(n));
    }
    return new Ue({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof Jt ? new Jt({
    ...e._def,
    type: Ln(e.element)
  }) : e instanceof vr ? vr.create(Ln(e.unwrap())) : e instanceof En ? En.create(Ln(e.unwrap())) : e instanceof Dr ? Dr.create(e.items.map((t) => Ln(t))) : e;
}
class Ue extends $e {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), r = Se.objectKeys(t);
    return this._cached = { shape: t, keys: r };
  }
  _parse(t) {
    if (this._getType(t) !== J.object) {
      const l = this._getOrReturnCtx(t);
      return Y(l, {
        code: H.invalid_type,
        expected: J.object,
        received: l.parsedType
      }), he;
    }
    const { status: n, ctx: i } = this._processInputParams(t), { shape: a, keys: o } = this._getCached(), s = [];
    if (!(this._def.catchall instanceof Wr && this._def.unknownKeys === "strip"))
      for (const l in i.data)
        o.includes(l) || s.push(l);
    const u = [];
    for (const l of o) {
      const c = a[l], d = i.data[l];
      u.push({
        key: { status: "valid", value: l },
        value: c._parse(new rr(i, d, i.path, l)),
        alwaysSet: l in i.data
      });
    }
    if (this._def.catchall instanceof Wr) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const c of s)
          u.push({
            key: { status: "valid", value: c },
            value: { status: "valid", value: i.data[c] }
          });
      else if (l === "strict")
        s.length > 0 && (Y(i, {
          code: H.unrecognized_keys,
          keys: s
        }), n.dirty());
      else if (l !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const c of s) {
        const d = i.data[c];
        u.push({
          key: { status: "valid", value: c },
          value: l._parse(
            new rr(i, d, i.path, c)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: c in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const c of u) {
        const d = await c.key, f = await c.value;
        l.push({
          key: d,
          value: f,
          alwaysSet: c.alwaysSet
        });
      }
      return l;
    }).then((l) => mt.mergeObjectSync(n, l)) : mt.mergeObjectSync(n, u);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return se.errToObj, new Ue({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (r, n) => {
          var i, a, o, s;
          const u = (o = (a = (i = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(i, r, n).message) !== null && o !== void 0 ? o : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (s = se.errToObj(t).message) !== null && s !== void 0 ? s : u
          } : {
            message: u
          };
        }
      } : {}
    });
  }
  strip() {
    return new Ue({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Ue({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new Ue({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new Ue({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: fe.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, r) {
    return this.augment({ [t]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new Ue({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const r = {};
    return Se.objectKeys(t).forEach((n) => {
      t[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new Ue({
      ...this._def,
      shape: () => r
    });
  }
  omit(t) {
    const r = {};
    return Se.objectKeys(this.shape).forEach((n) => {
      t[n] || (r[n] = this.shape[n]);
    }), new Ue({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Ln(this);
  }
  partial(t) {
    const r = {};
    return Se.objectKeys(this.shape).forEach((n) => {
      const i = this.shape[n];
      t && !t[n] ? r[n] = i : r[n] = i.optional();
    }), new Ue({
      ...this._def,
      shape: () => r
    });
  }
  required(t) {
    const r = {};
    return Se.objectKeys(this.shape).forEach((n) => {
      if (t && !t[n])
        r[n] = this.shape[n];
      else {
        let a = this.shape[n];
        for (; a instanceof vr; )
          a = a._def.innerType;
        r[n] = a;
      }
    }), new Ue({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return B$(Se.objectKeys(this.shape));
  }
}
Ue.create = (e, t) => new Ue({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Wr.create(),
  typeName: fe.ZodObject,
  ...me(t)
});
Ue.strictCreate = (e, t) => new Ue({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Wr.create(),
  typeName: fe.ZodObject,
  ...me(t)
});
Ue.lazycreate = (e, t) => new Ue({
  shape: e,
  unknownKeys: "strip",
  catchall: Wr.create(),
  typeName: fe.ZodObject,
  ...me(t)
});
class $s extends $e {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = this._def.options;
    function i(a) {
      for (const s of a)
        if (s.result.status === "valid")
          return s.result;
      for (const s of a)
        if (s.result.status === "dirty")
          return r.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((s) => new Rt(s.ctx.common.issues));
      return Y(r, {
        code: H.invalid_union,
        unionErrors: o
      }), he;
    }
    if (r.common.async)
      return Promise.all(n.map(async (a) => {
        const o = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: r.data,
            path: r.path,
            parent: o
          }),
          ctx: o
        };
      })).then(i);
    {
      let a;
      const o = [];
      for (const u of n) {
        const l = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, c = u._parseSync({
          data: r.data,
          path: r.path,
          parent: l
        });
        if (c.status === "valid")
          return c;
        c.status === "dirty" && !a && (a = { result: c, ctx: l }), l.common.issues.length && o.push(l.common.issues);
      }
      if (a)
        return r.common.issues.push(...a.ctx.common.issues), a.result;
      const s = o.map((u) => new Rt(u));
      return Y(r, {
        code: H.invalid_union,
        unionErrors: s
      }), he;
    }
  }
  get options() {
    return this._def.options;
  }
}
$s.create = (e, t) => new $s({
  options: e,
  typeName: fe.ZodUnion,
  ...me(t)
});
const ur = (e) => e instanceof Es ? ur(e.schema) : e instanceof Er ? ur(e.innerType()) : e instanceof ws ? [e.value] : e instanceof Dn ? e.options : e instanceof Cs ? Se.objectValues(e.enum) : e instanceof Ss ? ur(e._def.innerType) : e instanceof gs ? [void 0] : e instanceof bs ? [null] : e instanceof vr ? [void 0, ...ur(e.unwrap())] : e instanceof En ? [null, ...ur(e.unwrap())] : e instanceof M$ || e instanceof Ps ? ur(e.unwrap()) : e instanceof ks ? ur(e._def.innerType) : [];
class df extends $e {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== J.object)
      return Y(r, {
        code: H.invalid_type,
        expected: J.object,
        received: r.parsedType
      }), he;
    const n = this.discriminator, i = r.data[n], a = this.optionsMap.get(i);
    return a ? r.common.async ? a._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : a._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (Y(r, {
      code: H.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), he);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, r, n) {
    const i = /* @__PURE__ */ new Map();
    for (const a of r) {
      const o = ur(a.shape[t]);
      if (!o.length)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const s of o) {
        if (i.has(s))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
        i.set(s, a);
      }
    }
    return new df({
      typeName: fe.ZodDiscriminatedUnion,
      discriminator: t,
      options: r,
      optionsMap: i,
      ...me(n)
    });
  }
}
function Oc(e, t) {
  const r = nn(e), n = nn(t);
  if (e === t)
    return { valid: !0, data: e };
  if (r === J.object && n === J.object) {
    const i = Se.objectKeys(t), a = Se.objectKeys(e).filter((s) => i.indexOf(s) !== -1), o = { ...e, ...t };
    for (const s of a) {
      const u = Oc(e[s], t[s]);
      if (!u.valid)
        return { valid: !1 };
      o[s] = u.data;
    }
    return { valid: !0, data: o };
  } else if (r === J.array && n === J.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let a = 0; a < e.length; a++) {
      const o = e[a], s = t[a], u = Oc(o, s);
      if (!u.valid)
        return { valid: !1 };
      i.push(u.data);
    }
    return { valid: !0, data: i };
  } else return r === J.date && n === J.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class xs extends $e {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), i = (a, o) => {
      if (Wp(a) || Wp(o))
        return he;
      const s = Oc(a.value, o.value);
      return s.valid ? ((Qp(a) || Qp(o)) && r.dirty(), { status: r.value, value: s.data }) : (Y(n, {
        code: H.invalid_intersection_types
      }), he);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([a, o]) => i(a, o)) : i(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
xs.create = (e, t, r) => new xs({
  left: e,
  right: t,
  typeName: fe.ZodIntersection,
  ...me(r)
});
class Dr extends $e {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== J.array)
      return Y(n, {
        code: H.invalid_type,
        expected: J.array,
        received: n.parsedType
      }), he;
    if (n.data.length < this._def.items.length)
      return Y(n, {
        code: H.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), he;
    !this._def.rest && n.data.length > this._def.items.length && (Y(n, {
      code: H.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const a = [...n.data].map((o, s) => {
      const u = this._def.items[s] || this._def.rest;
      return u ? u._parse(new rr(n, o, n.path, s)) : null;
    }).filter((o) => !!o);
    return n.common.async ? Promise.all(a).then((o) => mt.mergeArray(r, o)) : mt.mergeArray(r, a);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new Dr({
      ...this._def,
      rest: t
    });
  }
}
Dr.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Dr({
    items: e,
    typeName: fe.ZodTuple,
    rest: null,
    ...me(t)
  });
};
class Ds extends $e {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== J.object)
      return Y(n, {
        code: H.invalid_type,
        expected: J.object,
        received: n.parsedType
      }), he;
    const i = [], a = this._def.keyType, o = this._def.valueType;
    for (const s in n.data)
      i.push({
        key: a._parse(new rr(n, s, n.path, s)),
        value: o._parse(new rr(n, n.data[s], n.path, s)),
        alwaysSet: s in n.data
      });
    return n.common.async ? mt.mergeObjectAsync(r, i) : mt.mergeObjectSync(r, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, r, n) {
    return r instanceof $e ? new Ds({
      keyType: t,
      valueType: r,
      typeName: fe.ZodRecord,
      ...me(n)
    }) : new Ds({
      keyType: mr.create(),
      valueType: t,
      typeName: fe.ZodRecord,
      ...me(r)
    });
  }
}
class Ic extends $e {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== J.map)
      return Y(n, {
        code: H.invalid_type,
        expected: J.map,
        received: n.parsedType
      }), he;
    const i = this._def.keyType, a = this._def.valueType, o = [...n.data.entries()].map(([s, u], l) => ({
      key: i._parse(new rr(n, s, n.path, [l, "key"])),
      value: a._parse(new rr(n, u, n.path, [l, "value"]))
    }));
    if (n.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const u of o) {
          const l = await u.key, c = await u.value;
          if (l.status === "aborted" || c.status === "aborted")
            return he;
          (l.status === "dirty" || c.status === "dirty") && r.dirty(), s.set(l.value, c.value);
        }
        return { status: r.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const u of o) {
        const l = u.key, c = u.value;
        if (l.status === "aborted" || c.status === "aborted")
          return he;
        (l.status === "dirty" || c.status === "dirty") && r.dirty(), s.set(l.value, c.value);
      }
      return { status: r.value, value: s };
    }
  }
}
Ic.create = (e, t, r) => new Ic({
  valueType: t,
  keyType: e,
  typeName: fe.ZodMap,
  ...me(r)
});
class yi extends $e {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== J.set)
      return Y(n, {
        code: H.invalid_type,
        expected: J.set,
        received: n.parsedType
      }), he;
    const i = this._def;
    i.minSize !== null && n.data.size < i.minSize.value && (Y(n, {
      code: H.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), r.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (Y(n, {
      code: H.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), r.dirty());
    const a = this._def.valueType;
    function o(u) {
      const l = /* @__PURE__ */ new Set();
      for (const c of u) {
        if (c.status === "aborted")
          return he;
        c.status === "dirty" && r.dirty(), l.add(c.value);
      }
      return { status: r.value, value: l };
    }
    const s = [...n.data.values()].map((u, l) => a._parse(new rr(n, u, n.path, l)));
    return n.common.async ? Promise.all(s).then((u) => o(u)) : o(s);
  }
  min(t, r) {
    return new yi({
      ...this._def,
      minSize: { value: t, message: se.toString(r) }
    });
  }
  max(t, r) {
    return new yi({
      ...this._def,
      maxSize: { value: t, message: se.toString(r) }
    });
  }
  size(t, r) {
    return this.min(t, r).max(t, r);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
yi.create = (e, t) => new yi({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: fe.ZodSet,
  ...me(t)
});
class oa extends $e {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== J.function)
      return Y(r, {
        code: H.invalid_type,
        expected: J.function,
        received: r.parsedType
      }), he;
    function n(s, u) {
      return Pc({
        data: s,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          kc(),
          _a
        ].filter((l) => !!l),
        issueData: {
          code: H.invalid_arguments,
          argumentsError: u
        }
      });
    }
    function i(s, u) {
      return Pc({
        data: s,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          kc(),
          _a
        ].filter((l) => !!l),
        issueData: {
          code: H.invalid_return_type,
          returnTypeError: u
        }
      });
    }
    const a = { errorMap: r.common.contextualErrorMap }, o = r.data;
    if (this._def.returns instanceof Oa) {
      const s = this;
      return Dt(async function(...u) {
        const l = new Rt([]), c = await s._def.args.parseAsync(u, a).catch((h) => {
          throw l.addIssue(n(u, h)), l;
        }), d = await Reflect.apply(o, this, c);
        return await s._def.returns._def.type.parseAsync(d, a).catch((h) => {
          throw l.addIssue(i(d, h)), l;
        });
      });
    } else {
      const s = this;
      return Dt(function(...u) {
        const l = s._def.args.safeParse(u, a);
        if (!l.success)
          throw new Rt([n(u, l.error)]);
        const c = Reflect.apply(o, this, l.data), d = s._def.returns.safeParse(c, a);
        if (!d.success)
          throw new Rt([i(c, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new oa({
      ...this._def,
      args: Dr.create(t).rest(ai.create())
    });
  }
  returns(t) {
    return new oa({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, r, n) {
    return new oa({
      args: t || Dr.create([]).rest(ai.create()),
      returns: r || ai.create(),
      typeName: fe.ZodFunction,
      ...me(n)
    });
  }
}
class Es extends $e {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
Es.create = (e, t) => new Es({
  getter: e,
  typeName: fe.ZodLazy,
  ...me(t)
});
class ws extends $e {
  _parse(t) {
    if (t.data !== this._def.value) {
      const r = this._getOrReturnCtx(t);
      return Y(r, {
        received: r.data,
        code: H.invalid_literal,
        expected: this._def.value
      }), he;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
ws.create = (e, t) => new ws({
  value: e,
  typeName: fe.ZodLiteral,
  ...me(t)
});
function B$(e, t) {
  return new Dn({
    values: e,
    typeName: fe.ZodEnum,
    ...me(t)
  });
}
class Dn extends $e {
  constructor() {
    super(...arguments), Qi.set(this, void 0);
  }
  _parse(t) {
    if (typeof t.data != "string") {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return Y(r, {
        expected: Se.joinValues(n),
        received: r.parsedType,
        code: H.invalid_type
      }), he;
    }
    if (ys(this, Qi) || O$(this, Qi, new Set(this._def.values)), !ys(this, Qi).has(t.data)) {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return Y(r, {
        received: r.data,
        code: H.invalid_enum_value,
        options: n
      }), he;
    }
    return Dt(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Values() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  extract(t, r = this._def) {
    return Dn.create(t, {
      ...this._def,
      ...r
    });
  }
  exclude(t, r = this._def) {
    return Dn.create(this.options.filter((n) => !t.includes(n)), {
      ...this._def,
      ...r
    });
  }
}
Qi = /* @__PURE__ */ new WeakMap();
Dn.create = B$;
class Cs extends $e {
  constructor() {
    super(...arguments), Gi.set(this, void 0);
  }
  _parse(t) {
    const r = Se.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
    if (n.parsedType !== J.string && n.parsedType !== J.number) {
      const i = Se.objectValues(r);
      return Y(n, {
        expected: Se.joinValues(i),
        received: n.parsedType,
        code: H.invalid_type
      }), he;
    }
    if (ys(this, Gi) || O$(this, Gi, new Set(Se.getValidEnumValues(this._def.values))), !ys(this, Gi).has(t.data)) {
      const i = Se.objectValues(r);
      return Y(n, {
        received: n.data,
        code: H.invalid_enum_value,
        options: i
      }), he;
    }
    return Dt(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Gi = /* @__PURE__ */ new WeakMap();
Cs.create = (e, t) => new Cs({
  values: e,
  typeName: fe.ZodNativeEnum,
  ...me(t)
});
class Oa extends $e {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== J.promise && r.common.async === !1)
      return Y(r, {
        code: H.invalid_type,
        expected: J.promise,
        received: r.parsedType
      }), he;
    const n = r.parsedType === J.promise ? r.data : Promise.resolve(r.data);
    return Dt(n.then((i) => this._def.type.parseAsync(i, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
Oa.create = (e, t) => new Oa({
  type: e,
  typeName: fe.ZodPromise,
  ...me(t)
});
class Er extends $e {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === fe.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), i = this._def.effect || null, a = {
      addIssue: (o) => {
        Y(n, o), o.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), i.type === "preprocess") {
      const o = i.transform(n.data, a);
      if (n.common.async)
        return Promise.resolve(o).then(async (s) => {
          if (r.value === "aborted")
            return he;
          const u = await this._def.schema._parseAsync({
            data: s,
            path: n.path,
            parent: n
          });
          return u.status === "aborted" ? he : u.status === "dirty" || r.value === "dirty" ? Wi(u.value) : u;
        });
      {
        if (r.value === "aborted")
          return he;
        const s = this._def.schema._parseSync({
          data: o,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? he : s.status === "dirty" || r.value === "dirty" ? Wi(s.value) : s;
      }
    }
    if (i.type === "refinement") {
      const o = (s) => {
        const u = i.refinement(s, a);
        if (n.common.async)
          return Promise.resolve(u);
        if (u instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      };
      if (n.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? he : (s.status === "dirty" && r.dirty(), o(s.value), { status: r.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((s) => s.status === "aborted" ? he : (s.status === "dirty" && r.dirty(), o(s.value).then(() => ({ status: r.value, value: s.value }))));
    }
    if (i.type === "transform")
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!ms(o))
          return o;
        const s = i.transform(o.value, a);
        if (s instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => ms(o) ? Promise.resolve(i.transform(o.value, a)).then((s) => ({ status: r.value, value: s })) : o);
    Se.assertNever(i);
  }
}
Er.create = (e, t, r) => new Er({
  schema: e,
  typeName: fe.ZodEffects,
  effect: t,
  ...me(r)
});
Er.createWithPreprocess = (e, t, r) => new Er({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: fe.ZodEffects,
  ...me(r)
});
class vr extends $e {
  _parse(t) {
    return this._getType(t) === J.undefined ? Dt(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
vr.create = (e, t) => new vr({
  innerType: e,
  typeName: fe.ZodOptional,
  ...me(t)
});
class En extends $e {
  _parse(t) {
    return this._getType(t) === J.null ? Dt(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
En.create = (e, t) => new En({
  innerType: e,
  typeName: fe.ZodNullable,
  ...me(t)
});
class Ss extends $e {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    let n = r.data;
    return r.parsedType === J.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Ss.create = (e, t) => new Ss({
  innerType: e,
  typeName: fe.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...me(t)
});
class ks extends $e {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return vs(i) ? i.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new Rt(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Rt(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ks.create = (e, t) => new ks({
  innerType: e,
  typeName: fe.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...me(t)
});
class Rc extends $e {
  _parse(t) {
    if (this._getType(t) !== J.nan) {
      const n = this._getOrReturnCtx(t);
      return Y(n, {
        code: H.invalid_type,
        expected: J.nan,
        received: n.parsedType
      }), he;
    }
    return { status: "valid", value: t.data };
  }
}
Rc.create = (e) => new Rc({
  typeName: fe.ZodNaN,
  ...me(e)
});
class M$ extends $e {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class hu extends $e {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return a.status === "aborted" ? he : a.status === "dirty" ? (r.dirty(), Wi(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return i.status === "aborted" ? he : i.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(t, r) {
    return new hu({
      in: t,
      out: r,
      typeName: fe.ZodPipeline
    });
  }
}
class Ps extends $e {
  _parse(t) {
    const r = this._def.innerType._parse(t), n = (i) => (ms(i) && (i.value = Object.freeze(i.value)), i);
    return vs(r) ? r.then((i) => n(i)) : n(r);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ps.create = (e, t) => new Ps({
  innerType: e,
  typeName: fe.ZodReadonly,
  ...me(t)
});
Ue.lazycreate;
var fe;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(fe || (fe = {}));
const Ts = mr.create;
mi.create;
Rc.create;
vi.create;
Tc.create;
Fa.create;
Ac.create;
gs.create;
bs.create;
_c.create;
ai.create;
Wr.create;
Fc.create;
Jt.create;
const N$ = Ue.create;
Ue.strictCreate;
$s.create;
df.create;
xs.create;
Dr.create;
Ds.create;
Ic.create;
yi.create;
oa.create;
Es.create;
ws.create;
Dn.create;
Cs.create;
Oa.create;
Er.create;
vr.create;
En.create;
Er.createWithPreprocess;
hu.create;
const wP = er`
  mutation GenerateAIReply($senalysisBusinessId: String, $spilloverBusinessId: String, $message: String!, $type: String!, $n: Int) {
    generateAiReply(input: {
      senalysisBusinessId: $senalysisBusinessId,
      spilloverBusinessId: $spilloverBusinessId,
      message: $message,
      type: $type,
      n: $n
    }) {
      replies
      errors {
        message
      }
    }
  }
`;
function ff() {
  var a, o;
  const { senalysisBusinessId: e, spilloverBusinessId: t } = VE(), [r, n] = RE(wP);
  return n.generatedOptions = (o = (a = n.data) == null ? void 0 : a.generateAiReply) == null ? void 0 : o.replies, [async (s, u, l = { n: 1 }) => {
    try {
      const { data: c } = await r({
        variables: {
          type: s,
          message: u,
          senalysisBusinessId: e,
          spilloverBusinessId: t,
          n: l.n
        }
      }), d = (c == null ? void 0 : c.generateAiReply.errors) || [];
      for (const f of d)
        console.error(`AI Error: ${f.message}`), Ie.error(f.message, { position: "bottom-right" });
      return c.generateAiReply.replies;
    } catch {
      return null;
    }
  }, n];
}
const CP = Et({
  extend: Pn,
  base: "flex flex-row items-center justify-center gap-1.5 h-10 px-3 text-sm shadow-md pressed:shadow-none transition rounded-md cursor-pointer",
  variants: {
    variant: {
      primary: "bg-spillover-700 hover:bg-spillover-500 pressed:bg-spillover-400 text-white",
      secondary: "bg-gray-100 hover:bg-gray-200 pressed:bg-gray-300 text-gray-800 dark:bg-zinc-600 dark:hover:bg-zinc-500 dark:pressed:bg-zinc-400 dark:text-zinc-100 shadow-sm",
      destructive: "bg-orange-700 hover:bg-orange-800 pressed:bg-orange-900 text-white",
      icon: "text-gray-500 p-0 shadow-none"
    },
    isDisabled: {
      true: "bg-gray-100 dark:bg-zinc-800 text-gray-300 dark:text-zinc-600 forced-colors:text-[GrayText] border-black/5 dark:border-white/5 cursor-not-allowed"
    },
    isLoading: {
      true: "cursor-wait"
    },
    reverse: {
      true: "flex-row-reverse"
    },
    circle: {
      true: "rounded-full w-10 h-10"
    }
  },
  defaultVariants: {
    variant: "primary"
  }
});
function Bt({
  Icon: e,
  isLoading: t,
  reverse: r,
  circle: n,
  children: i,
  ...a
}) {
  return /* @__PURE__ */ pe(
    y3,
    {
      ...a,
      isDisabled: a.isDisabled || t,
      className: xi(
        a.className,
        (o, s) => CP({
          ...s,
          variant: a.variant,
          reverse: r,
          circle: n,
          isLoading: t,
          className: o
        })
      ),
      children: [
        e && (t ? /* @__PURE__ */ O(Hv, { size: 20, className: "animate-spin" }) : /* @__PURE__ */ O(e, { size: 20 })),
        i
      ]
    }
  );
}
function hf({ option: e, type: t, onClick: r }) {
  const n = () => {
    r && r(e, t);
  };
  return /* @__PURE__ */ O(
    "div",
    {
      className: `p-3 bg-gray-100 rounded-md text-gray-600 hover:bg-gray-200 transition duration-200 text-sm ${r && "cursor-pointer"} whitespace-pre-line`,
      ...cs(n),
      children: e
    }
  );
}
const SP = N$({
  context: Ts().min(5, "Please provide some more context")
});
function kP({ onOptionSelected: e }) {
  const [t, { generatedOptions: r, loading: n }] = ff(), {
    register: i,
    handleSubmit: a,
    formState: { errors: o }
  } = A$({ resolver: F$(SP) }), s = ({ context: l }) => t("text", l, { n: 3 }), u = r || [];
  return /* @__PURE__ */ pe(
    "form",
    {
      onSubmit: a(s),
      className: "flex flex-col gap-4 py-2 px-4 w-full box-border",
      children: [
        /* @__PURE__ */ pe("div", { className: "w-full flex flex-col gap-1", children: [
          /* @__PURE__ */ O("label", { className: "text-sm text-gray-700", children: "Give us some context..." }),
          /* @__PURE__ */ O("div", { className: "w-full flex flex-col gap-4", children: /* @__PURE__ */ O(
            "textarea",
            {
              className: "box-border w-full h-20 border border-gray-300 rounded-md p-2",
              ...i("context"),
              autoFocus: !0
            }
          ) }),
          o.context && /* @__PURE__ */ O("div", { className: "text-red-500 text-sm", children: o.context.message })
        ] }),
        /* @__PURE__ */ O(
          Bt,
          {
            isDisabled: n,
            isLoading: n,
            Icon: Ks,
            onPress: a(s),
            children: "Generate Text"
          }
        ),
        u.length > 0 && /* @__PURE__ */ pe("div", { className: "w-full flex flex-col gap-4 mt-4", children: [
          /* @__PURE__ */ O("div", { className: "text-gray-700", children: "Pick an option or try again for new options" }),
          u.map((l, c) => /* @__PURE__ */ O(
            hf,
            {
              option: l,
              type: "text",
              onClick: e
            },
            c
          ))
        ] })
      ]
    }
  );
}
const PP = N$({
  context: Ts().min(5, "Please provide some more context")
});
function TP({ onOptionSelected: e }) {
  const [t, { generatedOptions: r, loading: n }] = ff(), {
    register: i,
    handleSubmit: a,
    formState: { errors: o }
  } = A$({ resolver: F$(PP) }), s = ({ context: l }) => t("post_caption", l, { n: 3 }), u = r || [];
  return /* @__PURE__ */ pe(
    "form",
    {
      onSubmit: a(s),
      className: "flex flex-col gap-4 py-2 px-4 w-full box-border",
      children: [
        /* @__PURE__ */ pe("div", { className: "w-full flex flex-col gap-1", children: [
          /* @__PURE__ */ O("label", { className: "text-sm text-gray-700", children: "Give us some context..." }),
          /* @__PURE__ */ O("div", { className: "w-full flex flex-col gap-4", children: /* @__PURE__ */ O(
            "textarea",
            {
              className: "box-border w-full h-20 border border-gray-300 rounded-md p-2",
              ...i("context"),
              autoFocus: !0
            }
          ) }),
          o.context && /* @__PURE__ */ O("div", { className: "text-red-500 text-sm", children: o.context.message })
        ] }),
        /* @__PURE__ */ O(
          Bt,
          {
            isLoading: n,
            isDisabled: n,
            Icon: Ks,
            onPress: a(s),
            children: "Generate Caption"
          }
        ),
        u.length > 0 && /* @__PURE__ */ pe("div", { className: "w-full flex flex-col gap-4 mt-4", children: [
          /* @__PURE__ */ O("div", { className: "text-gray-700", children: "Pick an option or try again for new options" }),
          u.map((l, c) => /* @__PURE__ */ O(
            hf,
            {
              option: l,
              type: "post_caption",
              onClick: e
            },
            c
          ))
        ] })
      ]
    }
  );
}
function Pt({
  type: e,
  text: t,
  onOptionSelected: r,
  loadingMsg: n,
  children: i,
  autoRun: a = !0,
  retry: o = !0,
  n: s = 1
}) {
  const [u, { generatedOptions: l, loading: c }] = ff(), d = () => {
    t && t.trim().length > 0 && u(e, t, { n: s });
  };
  return oe(() => {
    a && d();
  }, []), /* @__PURE__ */ pe("div", { className: "w-full flex flex-col gap-4 py-2 px-4 box-border", children: [
    i,
    c ? /* @__PURE__ */ pe("div", { className: "text-gray-700 flex flex-row items-center gap-2", children: [
      /* @__PURE__ */ O(n6, { className: "animate-spin" }),
      n || "Loading..."
    ] }) : o && /* @__PURE__ */ O(Bt, { variant: "secondary", Icon: a6, onPress: d, children: "Retry" }),
    l == null ? void 0 : l.map((f, h) => /* @__PURE__ */ O(
      hf,
      {
        type: e,
        option: f,
        onClick: r
      },
      h
    ))
  ] });
}
function AP({ message: e }) {
  return /* @__PURE__ */ O(
    Pt,
    {
      type: "translate",
      text: e,
      loadingMsg: "Translating...",
      retry: !1
    }
  );
}
function _P({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ O(
    Pt,
    {
      type: "spellcheck",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Checking spelling..."
    }
  );
}
function FP({ message: e }) {
  return /* @__PURE__ */ O(
    Pt,
    {
      type: "summarize",
      text: e,
      loadingMsg: "Summarizing...",
      retry: !1
    }
  );
}
function OP({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ O(
    Pt,
    {
      type: "improve_writing",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Improving writing..."
    }
  );
}
function IP({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ O(
    Pt,
    {
      type: "make_longer",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Making text longer..."
    }
  );
}
function RP({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ O(
    Pt,
    {
      type: "make_shorter",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Making text shorter..."
    }
  );
}
function BP({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ O(
    Pt,
    {
      type: "make_more_formal",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Making more formal..."
    }
  );
}
function MP({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ O(
    Pt,
    {
      type: "make_more_casual",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Making more casual..."
    }
  );
}
function NP({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ O(
    Pt,
    {
      type: "make_friendlier",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Making text friendlier..."
    }
  );
}
function LP({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ O(
    Pt,
    {
      type: "make_funnier",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Making text funnier..."
    }
  );
}
function VP({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ O(
    Pt,
    {
      type: "continue_writing",
      text: e,
      onOptionSelected: (n, i) => {
        t(`${e} ${n}`, i);
      },
      loadingMsg: "Continuing your text..."
    }
  );
}
function zP({ message: e, onOptionSelected: t }) {
  return /* @__PURE__ */ O(
    Pt,
    {
      type: "review_reply",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Generating reply...",
      n: 3
    }
  );
}
function jP({ message: e, onOptionSelected: t }) {
  return /* @__PURE__ */ O(
    Pt,
    {
      type: "comment_reply",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Generating reply...",
      n: 3
    }
  );
}
const L$ = [
  {
    name: "GenerateText",
    title: "Generate Text",
    Icon: wh,
    component: kP
  },
  {
    name: "GenerateCaption",
    title: "Generate Caption",
    Icon: wh,
    component: TP
  },
  {
    name: "GenerateReviewReply",
    title: "Generate Reply",
    Icon: l6,
    component: zP
  },
  {
    name: "GenerateCommentReply",
    title: "Generate Reply",
    Icon: o6,
    component: jP
  },
  {
    name: "Translate",
    title: "Translate",
    Icon: e6,
    component: AP
  },
  {
    name: "SpellCheck",
    title: "Fix Spelling & Grammar",
    Icon: u6,
    component: _P
  },
  {
    name: "Summarize",
    title: "Summarize",
    Icon: r6,
    component: FP
  },
  {
    name: "ImproveWriting",
    title: "Improve Writing",
    Icon: YE,
    component: OP
  },
  {
    name: "MakeLonger",
    title: "Make Longer",
    Icon: GE,
    component: IP
  },
  {
    name: "MakeShorter",
    title: "Make Shorter",
    Icon: QE,
    component: RP
  },
  {
    name: "MakeMoreFormal",
    title: "Make More Formal",
    Icon: qE,
    component: BP
  },
  {
    name: "MakeMoreCasual",
    title: "Make More Casual",
    Icon: s6,
    component: MP
  },
  {
    name: "MakeFriendlier",
    title: "Make Friendlier",
    Icon: XE,
    component: NP
  },
  {
    name: "MakeFunnier",
    title: "Make Funnier",
    Icon: t6,
    component: LP
  },
  {
    name: "ContinueWriting",
    title: "Continue Writing",
    Icon: ZE,
    component: VP
  }
], KP = L$.map((e) => e.name);
function UP({
  message: e,
  text: t,
  onOptionSelected: r,
  onCloseButtonClick: n,
  tools: i
}) {
  i ?? (i = KP);
  const a = L$.filter((o) => i.includes(o.name)).map(
    (o) => /* @__PURE__ */ O($$, { title: o.title, Icon: o.Icon, children: /* @__PURE__ */ O(
      o.component,
      {
        message: e,
        text: t,
        onOptionSelected: r
      }
    ) }, o.name)
  );
  return /* @__PURE__ */ O(
    I8,
    {
      title: "AI Helpers",
      Icon: Ks,
      onCloseButtonClick: n,
      children: a
    }
  );
}
function pf(e) {
  return /* @__PURE__ */ O(
    bk,
    {
      ...e,
      className: Sr(
        "outline outline-0 p-4 [[data-placement]>&]:p-4 max-h-[inherit] overflow-auto relative",
        e.className
      )
    }
  );
}
function qP(e) {
  return /* @__PURE__ */ O(
    s$,
    {
      ...e,
      className: Sr("text-lg font-medium text-slate-900", e.className)
    }
  );
}
const HP = Et({
  base: "bg-white dark:bg-zinc-900/70 dark:backdrop-blur-2xl dark:backdrop-saturate-200 forced-colors:bg-[Canvas] shadow-md rounded-md bg-clip-padding border border-black/10 dark:border-white/[15%] text-slate-700 dark:text-zinc-300",
  variants: {
    isEntering: {
      true: "animate-in fade-in placement-bottom:slide-in-from-top-1 placement-top:slide-in-from-bottom-1 placement-left:slide-in-from-right-1 placement-right:slide-in-from-left-1 ease-out duration-200"
    },
    isExiting: {
      true: "animate-out fade-out placement-bottom:slide-out-to-top-1 placement-top:slide-out-to-bottom-1 placement-left:slide-out-to-right-1 placement-right:slide-out-to-left-1 ease-in duration-150"
    }
  }
});
function pu({ children: e, showArrow: t, className: r, ...n }) {
  const i = Zr(ki), a = (i == null ? void 0 : i.trigger) === "SubmenuTrigger";
  let o = t ? 12 : 8;
  return o = a ? o - 6 : o, /* @__PURE__ */ pe(
    vk,
    {
      UNSTABLE_portalContainer: document.getElementById("sfs-portal"),
      offset: o,
      ...n,
      className: xi(
        r,
        (s, u) => HP({ ...u, className: s })
      ),
      children: [
        t && /* @__PURE__ */ O(pk, { className: "group", children: /* @__PURE__ */ pe(
          "svg",
          {
            width: 12,
            height: 12,
            viewBox: "0 0 12 12",
            className: "block fill-white dark:fill-[#1f1f21] forced-colors:fill-[Canvas] stroke-1 stroke-black/10 dark:stroke-zinc-600 forced-colors:stroke-[ButtonBorder] group-placement-bottom:rotate-180 group-placement-left:-rotate-90 group-placement-right:rotate-90",
            children: [
              /* @__PURE__ */ O("title", { children: "Popover arrow" }),
              /* @__PURE__ */ O("path", { d: "M0 0 L6 6 L12 0" })
            ]
          }
        ) }),
        e
      ]
    }
  );
}
function AT({
  message: e,
  text: t,
  onOptionSelected: r,
  className: n,
  children: i,
  tools: a
}) {
  return /* @__PURE__ */ pe(i$, { children: [
    /* @__PURE__ */ O(
      Bt,
      {
        circle: !0,
        Icon: Ks,
        "aria-label": "AI Text Helpers",
        className: n,
        children: i
      }
    ),
    /* @__PURE__ */ O(
      pu,
      {
        showArrow: !0,
        shouldCloseOnInteractOutside: () => !1,
        className: "w-[340px]",
        children: /* @__PURE__ */ O(
          pf,
          {
            className: "p-0 [[data-placement]>&]:p-0",
            "aria-label": "AI Text Helpers",
            children: ({ close: o }) => /* @__PURE__ */ O(
              UP,
              {
                tools: a,
                message: e,
                text: t,
                onOptionSelected: r,
                onCloseButtonClick: o
              }
            )
          }
        )
      }
    )
  ] });
}
const Zp = [
  "Loading, please wait...",
  "Still loading...",
  "Almost there...",
  "This is taking longer than expected..."
];
function WP({ msgInterval: e = 5e3, ...t }) {
  const [r, n] = ee(0);
  oe(() => {
    const a = setInterval(() => {
      n((o) => o < Zp.length - 1 ? o + 1 : (clearInterval(a), o));
    }, e);
    return () => clearInterval(a);
  }, [e]);
  const i = Zp[r];
  return /* @__PURE__ */ pe("div", { className: "flex flex-col gap-4 items-center justify-center w-full h-full", children: [
    /* @__PURE__ */ O(
      Hv,
      {
        size: 46,
        ...t,
        className: Sr("animate-spin text-spillover-700", t.className)
      }
    ),
    /* @__PURE__ */ O("p", { className: "text-slate-400 animate-pulse", children: i })
  ] });
}
function Za(e) {
  return /* @__PURE__ */ O(
    GS,
    {
      ...e,
      className: Sr(
        "text-sm text-gray-500 dark:text-zinc-400 font-medium cursor-default w-fit",
        e.className
      )
    }
  );
}
function Ya(e) {
  return /* @__PURE__ */ O(
    lu,
    {
      ...e,
      slot: "description",
      className: Sr("text-sm text-gray-600", e.className)
    }
  );
}
function Ja(e) {
  return /* @__PURE__ */ O(
    US,
    {
      ...e,
      className: Yr(
        e.className,
        "text-sm text-red-600 forced-colors:text-[Mark]"
      )
    }
  );
}
const Bc = Et({
  variants: {
    isFocusWithin: {
      false: "border-gray-300 dark:border-zinc-500 forced-colors:border-[ButtonBorder]",
      true: "border-gray-600 dark:border-zinc-300 forced-colors:border-[Highlight]"
    },
    isInvalid: {
      true: "border-red-600 dark:border-red-600 forced-colors:border-[Mark]"
    },
    isDisabled: {
      true: "border-gray-200 dark:border-zinc-700 forced-colors:border-[GrayText]"
    }
  }
}), V$ = Et({
  extend: Pn,
  base: "group flex gap-1 pr-1.5 items-center h-10 shadow-sm bg-white dark:bg-zinc-900 forced-colors:bg-[Field] border rounded-lg overflow-hidden",
  variants: Bc.variants
});
function z$(e) {
  return /* @__PURE__ */ O(
    r$,
    {
      ...e,
      className: xi(
        e.className,
        (t, r) => V$({ ...r, className: t })
      )
    }
  );
}
function j$(e) {
  return /* @__PURE__ */ O(
    p1,
    {
      ...e,
      className: Yr(
        e.className,
        "px-2 py-1.5 flex-1 min-w-0 outline outline-0 bg-white dark:bg-zinc-900 text-sm text-gray-800 dark:text-zinc-200 disabled:text-gray-200 dark:disabled:text-zinc-600"
      )
    }
  );
}
function _T({ children: e, ...t }) {
  return /* @__PURE__ */ O(
    ef,
    {
      ...t,
      className: Yr(
        t.className,
        "outline-0 p-1 border border-gray-300 dark:border-zinc-600 rounded-md"
      ),
      children: e
    }
  );
}
const QP = Et({
  extend: Pn,
  base: "group relative flex items-center gap-8 cursor-default select-none py-1.5 px-2.5 rounded-md will-change-transform text-sm forced-color-adjust-none",
  variants: {
    isSelected: {
      false: "text-slate-700 dark:text-zinc-300 hover:bg-slate-200 dark:hover:bg-zinc-700 -outline-offset-2",
      true: "bg-spillover-600 text-white forced-colors:bg-[Highlight] forced-colors:text-[HighlightText] [&:has(+[data-selected])]:rounded-b-none [&+[data-selected]]:rounded-t-none -outline-offset-4 outline-white dark:outline-white forced-colors:outline-[HighlightText]"
    },
    isDisabled: {
      true: "text-slate-300 dark:text-zinc-600 forced-colors:text-[GrayText]"
    }
  }
});
function FT(e) {
  const t = e.textValue || (typeof e.children == "string" ? e.children : void 0);
  return /* @__PURE__ */ O(e$, { ...e, textValue: t, className: QP, children: xi(e.children, (r) => /* @__PURE__ */ pe(Nc, { children: [
    r,
    /* @__PURE__ */ O("div", { className: "absolute left-4 right-4 bottom-0 h-px bg-white/20 forced-colors:bg-[HighlightText] hidden [.group[data-selected]:has(+[data-selected])_&]:block" })
  ] })) });
}
const GP = Et({
  base: "group flex items-center gap-4 cursor-default select-none py-2 pl-3 pr-1 rounded-md outline outline-0 text-sm forced-color-adjust-none",
  variants: {
    isDisabled: {
      false: "text-gray-900 dark:text-zinc-100",
      true: "text-gray-300 dark:text-zinc-600 forced-colors:text-[GrayText]"
    },
    isFocused: {
      true: "bg-spillover-600 text-white forced-colors:bg-[Highlight] forced-colors:text-[HighlightText]"
    }
  },
  compoundVariants: [
    {
      isFocused: !1,
      isOpen: !0,
      className: "bg-gray-100 dark:bg-zinc-700/60"
    }
  ]
});
function K$(e) {
  const t = e.textValue || (typeof e.children == "string" ? e.children : void 0);
  return /* @__PURE__ */ O(
    e$,
    {
      ...e,
      textValue: t,
      className: GP,
      children: xi(e.children, (r, { isSelected: n }) => /* @__PURE__ */ pe(Nc, { children: [
        /* @__PURE__ */ O("span", { className: "flex items-center flex-1 gap-2 font-normal truncate group-selected:font-semibold", children: r }),
        /* @__PURE__ */ O("span", { className: "flex items-center w-5", children: n && /* @__PURE__ */ O(WE, { className: "w-4 h-4" }) })
      ] }))
    }
  );
}
function U$(e) {
  return /* @__PURE__ */ pe(sS, { className: "first:-mt-[5px] after:content-[''] after:block after:h-[5px]", children: [
    /* @__PURE__ */ O(Y1, { className: "text-sm font-semibold text-gray-500 dark:text-zinc-300 px-4 py-1 truncate sticky -top-[5px] -mt-px -mx-1 z-10 bg-gray-100/60 dark:bg-zinc-700/60 backdrop-blur-md supports-[-moz-appearance:none]:bg-gray-100 border-y dark:border-y-zinc-700 [&+*]:mt-1", children: e.title }),
    /* @__PURE__ */ O(cS, { items: e.items, children: e.children })
  ] });
}
function ZP() {
  const e = le(a$);
  return (e == null ? void 0 : e.selectedKey) && /* @__PURE__ */ O(
    Bt,
    {
      variant: "icon",
      Icon: (t) => /* @__PURE__ */ O(Wv, { ...t, size: 16 }),
      onPress: () => e == null ? void 0 : e.setSelectedKey(null)
    }
  );
}
function q$({
  label: e,
  description: t,
  isClearable: r,
  errorMessage: n,
  children: i,
  items: a,
  ...o
}) {
  return /* @__PURE__ */ pe(
    Ek,
    {
      ...o,
      className: Yr(
        o.className,
        "group flex flex-col gap-1"
      ),
      children: [
        e && /* @__PURE__ */ O(Za, { children: e }),
        /* @__PURE__ */ pe(z$, { children: [
          /* @__PURE__ */ O(j$, {}),
          r && /* @__PURE__ */ O(ZP, {}),
          /* @__PURE__ */ O(Bt, { variant: "icon", Icon: qv })
        ] }),
        t && /* @__PURE__ */ O(Ya, { children: t }),
        /* @__PURE__ */ O(Ja, { children: n }),
        /* @__PURE__ */ O(pu, { className: "w-[--trigger-width]", children: /* @__PURE__ */ O(
          ef,
          {
            items: a,
            className: "outline-0 p-1 max-h-[inherit] overflow-auto [clip-path:inset(0_0_0_0_round_.75rem)]",
            children: i
          }
        ) })
      ]
    }
  );
}
function H$(e) {
  return /* @__PURE__ */ O(K$, { ...e });
}
function OT(e) {
  return /* @__PURE__ */ O(U$, { ...e });
}
const YP = er`
  query ListBusinesses {
    allowedBusinesses {
      id
      name
      senalysisId
      locations {
        id
        name
      }
    }
  }
`;
function JP({ defaultBusinessId: e = null } = {}) {
  const [t, r] = ee(e), { data: n } = gd(YP), i = (n == null ? void 0 : n.allowedBusinesses) || [], a = i.find((o) => o.id === t);
  return oe(() => {
    !t && i.length && r(i[0].id);
  }, [i, t]), {
    business: a,
    businessSelectProps: {
      businesses: i,
      selectedId: t,
      onSelectionChange: r
    }
  };
}
function XP({
  businesses: e = [],
  selectedId: t = null,
  onSelectionChange: r
}) {
  return /* @__PURE__ */ O(
    q$,
    {
      placeholder: "Select a business",
      items: e,
      selectedKey: t,
      onSelectionChange: r,
      children: (n) => /* @__PURE__ */ O(H$, { children: n.name })
    }
  );
}
function eT({ locations: e = [] }) {
  const [t, r] = ee(null), n = e.find((i) => i.id === t);
  return oe(() => {
    n || r(null);
  }, [n]), {
    location: n,
    locationSelectProps: {
      locations: e,
      selectedId: t,
      onSelectionChange: r
    }
  };
}
function tT({
  locations: e = [],
  selectedId: t = null,
  onSelectionChange: r,
  ...n
}) {
  return /* @__PURE__ */ O(
    q$,
    {
      placeholder: "Select a location",
      items: e,
      selectedKey: t,
      onSelectionChange: r,
      ...n,
      children: (i) => /* @__PURE__ */ O(H$, { children: i.name })
    }
  );
}
function rT({ title: e, subtitle: t, children: r, ...n }) {
  return /* @__PURE__ */ pe(
    "section",
    {
      ...n,
      className: Sr(
        "border border-gray-300 rounded-2xl bg-white",
        n.className
      ),
      children: [
        /* @__PURE__ */ pe("header", { className: "flex items-center gap-2 px-5 py-2 pb-1 border-b border-gray-300 text-spillover-900", children: [
          /* @__PURE__ */ O("h2", { className: "text-lg font-semibold uppercase", children: e }),
          t && /* @__PURE__ */ O("p", { className: "text-xs lowercase", children: t })
        ] }),
        r
      ]
    }
  );
}
function IT({ label: e, description: t, errorMessage: r, ...n }) {
  return /* @__PURE__ */ pe(
    Ck,
    {
      ...n,
      className: Yr(
        n.className,
        "flex flex-col gap-1"
      ),
      children: [
        e && /* @__PURE__ */ O(Za, { children: e }),
        /* @__PURE__ */ O(Mc, {}),
        t && /* @__PURE__ */ O(Ya, { children: t }),
        /* @__PURE__ */ O(Ja, { children: r })
      ]
    }
  );
}
const nT = Et({
  base: "inline p-0.5 type-literal:px-0 rounded outline outline-0 forced-color-adjust-none caret-transparent text-gray-800 dark:text-zinc-200 forced-colors:text-[ButtonText]",
  variants: {
    isPlaceholder: {
      true: "text-gray-600 dark:text-zinc-400 italic"
    },
    isDisabled: {
      true: "text-gray-200 dark:text-zinc-600 forced-colors:text-[GrayText]"
    },
    isFocused: {
      true: "bg-spillover-600 text-white dark:text-white forced-colors:bg-[Highlight] forced-colors:text-[HighlightText]"
    }
  }
});
function Mc(e) {
  return /* @__PURE__ */ O(
    Pk,
    {
      className: (t) => V$({
        ...t,
        class: "block min-w-[150px] px-2 py-1.5 text-sm"
      }),
      ...e,
      children: (t) => /* @__PURE__ */ O(Ak, { segment: t, className: nT })
    }
  );
}
const iT = Et({
  extend: Pn,
  base: "w-9 h-9 text-sm cursor-default rounded-full flex items-center justify-center forced-color-adjust-none",
  variants: {
    isSelected: {
      false: "text-zinc-900 dark:text-zinc-200 hover:bg-gray-100 dark:hover:bg-zinc-700 pressed:bg-gray-200 dark:pressed:bg-zinc-600",
      true: "bg-spillover-600 invalid:bg-red-600 text-white forced-colors:bg-[Highlight] forced-colors:invalid:bg-[Mark] forced-colors:text-[HighlightText]"
    },
    isDisabled: {
      true: "text-gray-300 dark:text-zinc-600 forced-colors:text-[GrayText]"
    }
  }
});
function RT({ errorMessage: e, ...t }) {
  return /* @__PURE__ */ pe(RS, { ...t, children: [
    /* @__PURE__ */ O(W$, {}),
    /* @__PURE__ */ pe(c1, { children: [
      /* @__PURE__ */ O(Q$, {}),
      /* @__PURE__ */ O(Jd, { children: (r) => /* @__PURE__ */ O(h1, { date: r, className: iT }) })
    ] }),
    e && /* @__PURE__ */ O(lu, { slot: "errorMessage", className: "text-sm text-red-600", children: e })
  ] });
}
function W$() {
  const e = st();
  return /* @__PURE__ */ pe("header", { className: "flex items-center gap-1 pb-4 px-1 w-full", children: [
    /* @__PURE__ */ O(Bt, { variant: "icon", slot: "previous", children: e === "rtl" ? /* @__PURE__ */ O(Eh, { "aria-hidden": !0 }) : /* @__PURE__ */ O(Ul, { "aria-hidden": !0 }) }),
    /* @__PURE__ */ O(s$, { className: "flex-1 font-semibold text-xl text-center mx-2 text-zinc-900 dark:text-zinc-200" }),
    /* @__PURE__ */ O(Bt, { variant: "icon", slot: "next", children: e === "rtl" ? /* @__PURE__ */ O(Ul, { "aria-hidden": !0 }) : /* @__PURE__ */ O(Eh, { "aria-hidden": !0 }) })
  ] });
}
function Q$() {
  return /* @__PURE__ */ O(d1, { children: (e) => /* @__PURE__ */ O(f1, { className: "text-xs text-gray-500 font-semibold", children: e }) });
}
const aT = Et({
  extend: Pn,
  base: "w-full h-full flex items-center justify-center rounded-full forced-color-adjust-none text-zinc-900 dark:text-zinc-200",
  variants: {
    selectionState: {
      none: "group-hover:bg-gray-100 dark:group-hover:bg-zinc-700 group-pressed:bg-gray-200 dark:group-pressed:bg-zinc-600",
      middle: [
        "group-hover:bg-spillover-200 dark:group-hover:bg-spillover-900 forced-colors:group-hover:bg-[Highlight]",
        "group-invalid:group-hover:bg-red-200 dark:group-invalid:group-hover:bg-red-900 forced-colors:group-invalid:group-hover:bg-[Mark] text-white",
        "group-pressed:bg-spillover-300 dark:group-pressed:bg-spillover-800 forced-colors:group-pressed:bg-[Highlight] forced-colors:text-[HighlightText]",
        "group-invalid:group-pressed:bg-red-300 dark:group-invalid:group-pressed:bg-red-800 forced-colors:group-invalid:group-pressed:bg-[Mark]"
      ],
      cap: "bg-spillover-600 group-invalid:bg-red-600 forced-colors:bg-[Highlight] forced-colors:group-invalid:bg-[Mark] text-white forced-colors:text-[HighlightText]"
    },
    isDisabled: {
      true: "text-gray-300 dark:text-zinc-600 forced-colors:text-[GrayText]"
    }
  }
});
function oT({ errorMessage: e, children: t, ...r }) {
  return /* @__PURE__ */ pe(MS, { ...r, children: [
    /* @__PURE__ */ O(W$, {}),
    t,
    /* @__PURE__ */ pe(c1, { className: "[&_td]:px-0", children: [
      /* @__PURE__ */ O(Q$, {}),
      /* @__PURE__ */ O(Jd, { children: (n) => /* @__PURE__ */ O(
        h1,
        {
          date: n,
          className: "group w-9 h-9 text-sm outline outline-0 cursor-default outside-month:text-gray-300 selected:bg-spillover-100 dark:selected:bg-spillover-700/30 forced-colors:selected:bg-[Highlight] invalid:selected:bg-red-100 dark:invalid:selected:bg-red-700/30 forced-colors:invalid:selected:bg-[Mark] [td:first-child_&]:rounded-s-full selection-start:rounded-s-full [td:last-child_&]:rounded-e-full selection-end:rounded-e-full",
          children: ({
            formattedDate: i,
            isSelected: a,
            isSelectionStart: o,
            isSelectionEnd: s,
            isFocusVisible: u,
            isDisabled: l
          }) => /* @__PURE__ */ O(
            "span",
            {
              className: aT({
                selectionState: a && (o || s) ? "cap" : a ? "middle" : "none",
                isDisabled: l,
                isFocusVisible: u
              }),
              children: i
            }
          )
        }
      ) })
    ] }),
    e && /* @__PURE__ */ O(lu, { slot: "errorMessage", className: "text-sm text-red-600", children: e })
  ] });
}
function sT({
  label: e,
  description: t,
  errorMessage: r,
  children: n,
  ...i
}) {
  return /* @__PURE__ */ pe(
    Ik,
    {
      ...i,
      className: Yr(
        i.className,
        "group flex flex-col gap-1"
      ),
      children: [
        e && /* @__PURE__ */ O(Za, { children: e }),
        /* @__PURE__ */ pe(z$, { className: "min-w-[208px] w-auto", children: [
          /* @__PURE__ */ O(Mc, { slot: "start", className: "px-2 py-1.5 text-sm" }),
          /* @__PURE__ */ O(
            "span",
            {
              "aria-hidden": "true",
              className: "text-gray-800 dark:text-zinc-200 forced-colors:text-[ButtonText] group-disabled:text-gray-200 group-disabled:dark:text-zinc-600 group-disabled:forced-colors:text-[GrayText]",
              children: ""
            }
          ),
          /* @__PURE__ */ O(Mc, { slot: "end", className: "flex-1 px-2 py-1.5 text-sm" }),
          /* @__PURE__ */ O(Bt, { variant: "icon", Icon: HE })
        ] }),
        t && /* @__PURE__ */ O(Ya, { children: t }),
        /* @__PURE__ */ O(Ja, { children: r }),
        /* @__PURE__ */ O(pu, { children: /* @__PURE__ */ O(pf, { children: /* @__PURE__ */ O(oT, { children: n }) }) })
      ]
    }
  );
}
const uT = Et({
  base: "fixed top-0 left-0 w-full h-[--visual-viewport-height] isolate z-20 bg-black/[30%] flex items-center justify-center p-4 text-center",
  variants: {
    isEntering: {
      true: "animate-in fade-in duration-200 ease-out"
    },
    isExiting: {
      true: "animate-out fade-out duration-200 ease-in"
    }
  }
}), lT = Et({
  base: "w-full max-w-md max-h-full rounded-2xl bg-white dark:bg-zinc-800/70 dark:backdrop-saturate-200 forced-colors:bg-[Canvas] text-left align-middle text-slate-700 dark:text-zinc-300 shadow-2xl bg-clip-padding border border-black/10 dark:border-white/10",
  variants: {
    isEntering: {
      true: "animate-in zoom-in-105 ease-out duration-200"
    },
    isExiting: {
      true: "animate-out zoom-out-95 ease-in duration-200"
    }
  }
});
function cT(e) {
  return /* @__PURE__ */ O(u$, { ...e, className: uT, children: /* @__PURE__ */ O(Nk, { ...e, className: lT }) });
}
function dT(e) {
  return /* @__PURE__ */ O(
    WS,
    {
      ...e,
      className: Sr("flex flex-col gap-4", e.className)
    }
  );
}
const fT = Et({
  extend: Pn,
  base: "shadow-sm bg-white border rounded-lg",
  variants: {
    isFocused: Bc.variants.isFocusWithin,
    ...Bc.variants
  }
});
function hT({ label: e, description: t, errorMessage: r, ...n }) {
  return /* @__PURE__ */ pe(
    Gk,
    {
      ...n,
      className: Yr(
        n.className,
        "flex flex-col gap-1"
      ),
      children: [
        e && /* @__PURE__ */ O(Za, { children: e }),
        /* @__PURE__ */ O(j$, { className: fT }),
        t && /* @__PURE__ */ O(Ya, { children: t }),
        /* @__PURE__ */ O(Ja, { children: r })
      ]
    }
  );
}
const pT = er`
  query CurrentAccount {
    currentAccount {
      id
      email
    }
  }
`, mT = er`
  mutation SendReport(
    $businessId: GID!
    $locationId: GID
    $startDate: ISO8601Date!
    $endDate: ISO8601Date!
    $emailAddresses: [String!]!
  ) {
    sendCustomerReport(input: {
    businessId: $businessId,
    locationId: $locationId,
    startDate: $startDate,
    endDate: $endDate,
    emailAddresses: $emailAddresses,
  }) {
    id
  }
}`, vT = Ts().transform((e) => e.split(",").map((t) => t.trim())).pipe(Ts().email().array());
function yT({ business: e, location: t, dateRange: r, ...n }) {
  var c;
  const [i, a] = ee(!1), { data: o } = gd(pT), [s] = LE(mT), u = (c = o == null ? void 0 : o.currentAccount) == null ? void 0 : c.email, l = async (d) => {
    a(!0), d.preventDefault();
    const f = new FormData(d.target).get("emailAddresses").split(",").map((p) => p.trim()), h = s({
      variables: {
        businessId: e.id,
        locationId: t == null ? void 0 : t.id,
        startDate: r.start.toString(),
        endDate: r.end.toString(),
        emailAddresses: f
      }
    });
    await Ie.promise(
      h,
      {
        pending: "Requesting report...",
        success: "Report requested successfully, it should be in your inbox soon.",
        error: "Failed to request report. Please try again."
      },
      { position: "bottom-right" }
    ), a(!1);
  };
  return /* @__PURE__ */ pe(i$, { children: [
    /* @__PURE__ */ O(Bt, { Icon: JE, ...n, children: "Export" }),
    /* @__PURE__ */ O(cT, { UNSTABLE_portalContainer: document.getElementById("sfs-portal"), children: /* @__PURE__ */ O(pf, { children: ({ close: d }) => /* @__PURE__ */ pe("div", { className: "flex flex-col gap-4", children: [
      /* @__PURE__ */ O(qP, { slot: "title", children: "Export Report" }),
      /* @__PURE__ */ pe("div", { className: "flex flex-col gap-1 text-slate-600 text-sm font-medium", children: [
        /* @__PURE__ */ pe("p", { children: [
          e.name,
          " ",
          t && ` - ${t.name}`
        ] }),
        /* @__PURE__ */ O("p", { children: new Yt("en-US").formatRange(
          r.start.toDate(gn()),
          r.end.toDate(gn())
        ) })
      ] }),
      /* @__PURE__ */ pe(
        dT,
        {
          onSubmit: (f) => {
            l(f), d();
          },
          children: [
            /* @__PURE__ */ O("p", { className: "text-slate-600 text-sm", children: "Type in the email addresses you would like to send the report to." }),
            /* @__PURE__ */ O(
              hT,
              {
                label: "Email Addresses",
                description: "Separate multiple email addresses with a comma",
                name: "emailAddresses",
                isRequired: !0,
                defaultValue: u,
                validate: (f) => {
                  const { success: h } = vT.safeParse(f);
                  if (!h) return "Invalid email addresses";
                }
              }
            ),
            /* @__PURE__ */ pe("div", { className: "flex flex-row gap-4 justify-end items-center", children: [
              /* @__PURE__ */ O(Bt, { variant: "secondary", onClick: d, children: "Cancel" }),
              /* @__PURE__ */ O(
                Bt,
                {
                  Icon: i6,
                  isLoading: i,
                  type: "submit",
                  children: "Send"
                }
              )
            ] })
          ]
        }
      )
    ] }) }) })
  ] });
}
const gT = Et({
  extend: Pn,
  base: "flex items-center text-start gap-4 w-full cursor-default border border-black/10 dark:border-white/10 shadow-[inset_0_1px_0_0_rgba(255,255,255,0.1)] dark:shadow-none rounded-lg pl-3 pr-2 py-2 min-w-[150px] transition bg-gray-50 dark:bg-zinc-700",
  variants: {
    isDisabled: {
      false: "text-gray-800 dark:text-zinc-300 hover:bg-gray-100 pressed:bg-gray-200 dark:hover:bg-zinc-600 dark:pressed:bg-zinc-500 group-invalid:border-red-600 forced-colors:group-invalid:border-[Mark]",
      true: "text-gray-200 dark:text-zinc-600 forced-colors:text-[GrayText] dark:bg-zinc-800 dark:border-white/5 forced-colors:border-[GrayText]"
    }
  }
});
function bT({
  label: e,
  description: t,
  errorMessage: r,
  children: n,
  items: i,
  ...a
}) {
  return /* @__PURE__ */ pe(
    Kk,
    {
      ...a,
      className: Yr(
        a.className,
        "group flex flex-col gap-1"
      ),
      children: [
        e && /* @__PURE__ */ O(Za, { children: e }),
        /* @__PURE__ */ pe(y3, { className: gT, children: [
          /* @__PURE__ */ O(qk, { className: "flex-1 text-sm placeholder-shown:italic" }),
          /* @__PURE__ */ O(
            qv,
            {
              "aria-hidden": !0,
              className: "w-4 h-4 text-gray-600 dark:text-zinc-400 forced-colors:text-[ButtonText] group-disabled:text-gray-200 dark:group-disabled:text-zinc-600 forced-colors:group-disabled:text-[GrayText]"
            }
          )
        ] }),
        t && /* @__PURE__ */ O(Ya, { children: t }),
        /* @__PURE__ */ O(Ja, { children: r }),
        /* @__PURE__ */ O(pu, { className: "min-w-[--trigger-width]", children: /* @__PURE__ */ O(
          ef,
          {
            items: i,
            className: "outline-none p-1 max-h-[inherit] overflow-auto [clip-path:inset(0_0_0_0_round_.75rem)]",
            children: n
          }
        ) })
      ]
    }
  );
}
function $T(e) {
  return /* @__PURE__ */ O(K$, { ...e });
}
function BT(e) {
  return /* @__PURE__ */ O(U$, { ...e });
}
const G$ = [
  { id: "custom", name: "Custom" },
  { id: "today", name: "Today" },
  { id: "thisWeek", name: "This Week" },
  { id: "thisMonth", name: "This Month" },
  { id: "thisYear", name: "This Year" },
  { id: "yesterday", name: "Yesterday" },
  { id: "previousWeek", name: "Previous Week" },
  { id: "previousMonth", name: "Previous Month" },
  { id: "previousYear", name: "Previous Year" },
  { id: "last7Days", name: "Last 7 Days" },
  { id: "last30Days", name: "Last 30 Days" },
  { id: "last90Days", name: "Last 90 Days" },
  { id: "last6Months", name: "Last 6 Months" },
  { id: "last12Months", name: "Last 12 Months" }
];
function xT(e, t) {
  switch (e) {
    case "custom":
      return null;
    case "today":
      return { start: t, end: t };
    case "thisWeek":
      return {
        start: bn(t, "en-US"),
        end: t
      };
    case "thisMonth":
      return {
        start: $r(t),
        end: t
      };
    case "thisYear":
      return {
        start: ec(t),
        end: t
      };
    case "yesterday": {
      const r = t.subtract({ days: 1 });
      return {
        start: r,
        end: r
      };
    }
    case "previousWeek": {
      const r = bn(
        t.subtract({ weeks: 1 }),
        "en-US"
      );
      return {
        start: r,
        end: Dy(r, "en-US")
      };
    }
    case "previousMonth": {
      const r = $r(
        t.subtract({ months: 1 })
      );
      return {
        start: r,
        end: fi(r)
      };
    }
    case "previousYear": {
      const r = ec(t.subtract({ years: 1 }));
      return {
        start: r,
        end: Lw(r)
      };
    }
    case "last7Days":
      return {
        start: t.subtract({ days: 7 }),
        end: t
      };
    case "last30Days":
      return {
        start: t.subtract({ days: 30 }),
        end: t
      };
    case "last90Days":
      return {
        start: t.subtract({ days: 90 }),
        end: t
      };
    case "last6Months":
      return {
        start: t.subtract({ months: 6 }),
        end: t
      };
    case "last12Months":
      return {
        start: t.subtract({ months: 12 }),
        end: t
      };
    default:
      throw new Error(`Unknown preset: ${e}`);
  }
}
function DT({
  defaultPreset: e = "custom",
  onChange: t
}) {
  const [r, n] = ee(null), i = (a) => {
    n(a);
    const o = Js(gn()), s = xT(a, o);
    t && t(a, s);
  };
  return oe(() => {
    i(e);
  }, []), {
    setSelectedPresetDateRange: n,
    presetDateRangeProps: {
      presets: G$,
      selectedPreset: r,
      onSelectionChange: i
    }
  };
}
function ET({
  presets: e,
  selectedPreset: t,
  onSelectionChange: r,
  ...n
}) {
  return /* @__PURE__ */ O(
    bT,
    {
      items: G$,
      selectedKey: t,
      onSelectionChange: r,
      ...n,
      children: (i) => /* @__PURE__ */ O($T, { children: i.name })
    }
  );
}
const wT = er`
  query ReportsEmbedURL(
    $businessId: GID!
    $locationId: GID
    $startDate: ISO8601Date
    $endDate: ISO8601Date
  ) {
    reportsEmbedUrl(
      businessId: $businessId
      locationId: $locationId
      startDate: $startDate
      endDate: $endDate
    )
  }
`;
function MT({
  defaultBusinessId: e = null,
  showBusinessSelect: t = !1
}) {
  const { businessSelectProps: r, business: n } = JP({
    defaultBusinessId: e
  }), { locationSelectProps: i, location: a } = eT({
    locations: (n == null ? void 0 : n.locations) || []
  }), [o, s] = ee(null), { data: u } = gd(wT, {
    skip: !n || !o,
    variables: {
      businessId: n == null ? void 0 : n.id,
      locationId: a == null ? void 0 : a.id,
      startDate: o == null ? void 0 : o.start.toString(),
      endDate: o == null ? void 0 : o.end.toString()
    }
  }), l = u == null ? void 0 : u.reportsEmbedUrl, { presetDateRangeProps: c, setSelectedPresetDateRange: d } = DT({
    defaultPreset: "last30Days",
    onChange: (p, v) => {
      p !== "custom" && s(v);
    }
  }), f = (p) => {
    s(p), d("custom");
  }, h = o && new Yt("en-US").formatRange(
    o.start.toDate(gn()),
    o.end.toDate(gn())
  );
  return /* @__PURE__ */ pe("div", { className: "sfs-customer-reports w-full h-full flex flex-col gap-8", children: [
    /* @__PURE__ */ pe("div", { className: "sfs-customer-reports__header flex flex-row justify-between items-center", children: [
      /* @__PURE__ */ pe("div", { className: "sfs-customer-reports__left flex flex-row gap-4 items-center", children: [
        t && /* @__PURE__ */ O(XP, { ...r, ariaLabel: "Business" }),
        n && /* @__PURE__ */ O(
          tT,
          {
            ...i,
            isClearable: !0,
            ariaLabel: "Location"
          }
        ),
        /* @__PURE__ */ O("div", { className: "sfs-customer-reports__date-range flex flex-row items-center", children: /* @__PURE__ */ O(
          sT,
          {
            ariaLabel: "Date range",
            value: o,
            onChange: f,
            children: /* @__PURE__ */ O(
              ET,
              {
                ...c,
                ariaLabel: "Preset Date Range",
                className: "mb-4"
              }
            )
          }
        ) })
      ] }),
      /* @__PURE__ */ O("div", { className: "sfs-customer-reports__right flex flex-row gap-4 items-center", children: /* @__PURE__ */ O(
        yT,
        {
          isDisabled: !n || !o,
          business: n,
          location: a,
          dateRange: o
        }
      ) })
    ] }),
    /* @__PURE__ */ O(
      rT,
      {
        title: "Reports",
        subtitle: h,
        className: "sfs-customer-reports__content h-full w-full",
        children: l ? /* @__PURE__ */ O(
          "iframe",
          {
            title: "Reports",
            src: l,
            className: "sfs-customer-reports__iframe w-full h-[calc(100%_-_50px)] border-0"
          }
        ) : /* @__PURE__ */ O(WP, {})
      }
    )
  ] });
}
export {
  UP as AITextHelpers,
  AT as AITextHelpersButton,
  Bt as Button,
  RT as Calendar,
  Q$ as CalendarGridHeader,
  W$ as CalendarHeader,
  q$ as ComboBox,
  H$ as ComboBoxItem,
  OT as ComboBoxSection,
  MT as CustomerReports,
  IT as DateField,
  Mc as DateInput,
  sT as DateRangePicker,
  Ya as Description,
  pf as Dialog,
  K$ as DropdownItem,
  U$ as DropdownSection,
  Ja as FieldError,
  z$ as FieldGroup,
  dT as Form,
  qP as Heading,
  F8 as HomeScreen,
  j$ as Input,
  Za as Label,
  _T as ListBox,
  FT as ListBoxItem,
  WP as LoadingSpinner,
  I8 as MiniApp,
  _8 as MiniAppHeader,
  c6 as MiniAppProvider,
  O8 as MiniAppScreens,
  cT as Modal,
  pu as Popover,
  ET as PresetDateRangeSelector,
  oT as RangeCalendar,
  $$ as Screen,
  rT as Section,
  bT as Select,
  $T as SelectItem,
  BT as SelectSection,
  TT as SpilloverProvider,
  hT as TextField,
  GP as dropdownItemStyles,
  Bc as fieldBorderStyles,
  V$ as fieldGroupStyles,
  QP as itemStyles,
  bd as useMiniApp,
  DT as usePresetDateRangeSelector
};
