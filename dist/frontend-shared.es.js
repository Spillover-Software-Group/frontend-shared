import { jsx as N, jsxs as Se, Fragment as _p } from "react/jsx-runtime";
import F, { useState as re, useRef as q, useSyncExternalStore as $$, useLayoutEffect as Fp, useEffect as ue, isValidElement as Ln, cloneElement as Gi, useCallback as ye, createContext as de, useContext as ce, forwardRef as Ae, createElement as rl, useMemo as G } from "react";
import xc, { flushSync as x$, createPortal as D$ } from "react-dom";
function E$(e, t) {
  for (var r = 0; r < t.length; r++) {
    const n = t[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const i in n)
        if (i !== "default" && !(i in e)) {
          const a = Object.getOwnPropertyDescriptor(n, i);
          a && Object.defineProperty(e, i, a.get ? a : {
            enumerable: !0,
            get: () => n[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
function Op(e) {
  var t, r, n = "";
  if (typeof e == "string" || typeof e == "number") n += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (r = Op(e[t])) && (n && (n += " "), n += r);
  } else for (r in e) e[r] && (n && (n += " "), n += r);
  return n;
}
function ur() {
  for (var e, t, r = 0, n = "", i = arguments.length; r < i; r++) (e = arguments[r]) && (t = Op(e)) && (n && (n += " "), n += t);
  return n;
}
const Zi = (e) => typeof e == "number" && !isNaN(e), nn = (e) => typeof e == "string", wt = (e) => typeof e == "function", co = (e) => nn(e) || wt(e) ? e : null, nl = (e) => Ln(e) || nn(e) || wt(e) || Zi(e);
function w$(e, t, r) {
  r === void 0 && (r = 300);
  const { scrollHeight: n, style: i } = e;
  requestAnimationFrame(() => {
    i.minHeight = "initial", i.height = n + "px", i.transition = `all ${r}ms`, requestAnimationFrame(() => {
      i.height = "0", i.padding = "0", i.margin = "0", setTimeout(t, r);
    });
  });
}
function vs(e) {
  let { enter: t, exit: r, appendPosition: n = !1, collapse: i = !0, collapseDuration: a = 300 } = e;
  return function(o) {
    let { children: s, position: u, preventExitTransition: l, done: c, nodeRef: d, isIn: f, playToast: h } = o;
    const p = n ? `${t}--${u}` : t, v = n ? `${r}--${u}` : r, g = q(0);
    return Fp(() => {
      const $ = d.current, m = p.split(" "), b = (D) => {
        D.target === d.current && (h(), $.removeEventListener("animationend", b), $.removeEventListener("animationcancel", b), g.current === 0 && D.type !== "animationcancel" && $.classList.remove(...m));
      };
      $.classList.add(...m), $.addEventListener("animationend", b), $.addEventListener("animationcancel", b);
    }, []), ue(() => {
      const $ = d.current, m = () => {
        $.removeEventListener("animationend", m), i ? w$($, c, a) : c();
      };
      f || (l ? m() : (g.current = 1, $.className += ` ${v}`, $.addEventListener("animationend", m)));
    }, [f]), F.createElement(F.Fragment, null, s);
  };
}
function Jd(e, t) {
  return e != null ? { content: e.content, containerId: e.props.containerId, id: e.props.toastId, theme: e.props.theme, type: e.props.type, data: e.props.data || {}, isLoading: e.props.isLoading, icon: e.props.icon, status: t } : {};
}
const ft = /* @__PURE__ */ new Map();
let Yi = [];
const il = /* @__PURE__ */ new Set(), C$ = (e) => il.forEach((t) => t(e)), Ip = () => ft.size > 0;
function Rp(e, t) {
  var r;
  if (t) return !((r = ft.get(t)) == null || !r.isToastActive(e));
  let n = !1;
  return ft.forEach((i) => {
    i.isToastActive(e) && (n = !0);
  }), n;
}
function Bp(e, t) {
  nl(e) && (Ip() || Yi.push({ content: e, options: t }), ft.forEach((r) => {
    r.buildToast(e, t);
  }));
}
function Xd(e, t) {
  ft.forEach((r) => {
    t != null && t != null && t.containerId ? (t == null ? void 0 : t.containerId) === r.id && r.toggle(e, t == null ? void 0 : t.id) : r.toggle(e, t == null ? void 0 : t.id);
  });
}
function S$(e) {
  const { subscribe: t, getSnapshot: r, setProps: n } = q(function(a) {
    const o = a.containerId || 1;
    return { subscribe(s) {
      const u = /* @__PURE__ */ function(c, d, f) {
        let h = 1, p = 0, v = [], g = [], $ = [], m = d;
        const b = /* @__PURE__ */ new Map(), D = /* @__PURE__ */ new Set(), S = () => {
          $ = Array.from(b.values()), D.forEach((y) => y());
        }, T = (y) => {
          g = y == null ? [] : g.filter((A) => A !== y), S();
        }, R = (y) => {
          const { toastId: A, onOpen: w, updateId: E, children: k } = y.props, C = E == null;
          y.staleId && b.delete(y.staleId), b.set(A, y), g = [...g, y.props.toastId].filter((P) => P !== y.staleId), S(), f(Jd(y, C ? "added" : "updated")), C && wt(w) && w(Ln(k) && k.props);
        };
        return { id: c, props: m, observe: (y) => (D.add(y), () => D.delete(y)), toggle: (y, A) => {
          b.forEach((w) => {
            A != null && A !== w.props.toastId || wt(w.toggle) && w.toggle(y);
          });
        }, removeToast: T, toasts: b, clearQueue: () => {
          p -= v.length, v = [];
        }, buildToast: (y, A) => {
          if (((ne) => {
            let { containerId: me, toastId: $e, updateId: _e } = ne;
            const Fe = me ? me !== c : c !== 1, V = b.has($e) && _e == null;
            return Fe || V;
          })(A)) return;
          const { toastId: w, updateId: E, data: k, staleId: C, delay: P } = A, L = () => {
            T(w);
          }, O = E == null;
          O && p++;
          const x = { ...m, style: m.toastStyle, key: h++, ...Object.fromEntries(Object.entries(A).filter((ne) => {
            let [me, $e] = ne;
            return $e != null;
          })), toastId: w, updateId: E, data: k, closeToast: L, isIn: !1, className: co(A.className || m.toastClassName), bodyClassName: co(A.bodyClassName || m.bodyClassName), progressClassName: co(A.progressClassName || m.progressClassName), autoClose: !A.isLoading && (U = A.autoClose, K = m.autoClose, U === !1 || Zi(U) && U > 0 ? U : K), deleteToast() {
            const ne = b.get(w), { onClose: me, children: $e } = ne.props;
            wt(me) && me(Ln($e) && $e.props), f(Jd(ne, "removed")), b.delete(w), p--, p < 0 && (p = 0), v.length > 0 ? R(v.shift()) : S();
          } };
          var U, K;
          x.closeButton = m.closeButton, A.closeButton === !1 || nl(A.closeButton) ? x.closeButton = A.closeButton : A.closeButton === !0 && (x.closeButton = !nl(m.closeButton) || m.closeButton);
          let j = y;
          Ln(y) && !nn(y.type) ? j = Gi(y, { closeToast: L, toastProps: x, data: k }) : wt(y) && (j = y({ closeToast: L, toastProps: x, data: k }));
          const ae = { content: j, props: x, staleId: C };
          m.limit && m.limit > 0 && p > m.limit && O ? v.push(ae) : Zi(P) ? setTimeout(() => {
            R(ae);
          }, P) : R(ae);
        }, setProps(y) {
          m = y;
        }, setToggle: (y, A) => {
          b.get(y).toggle = A;
        }, isToastActive: (y) => g.some((A) => A === y), getSnapshot: () => m.newestOnTop ? $.reverse() : $ };
      }(o, a, C$);
      ft.set(o, u);
      const l = u.observe(s);
      return Yi.forEach((c) => Bp(c.content, c.options)), Yi = [], () => {
        l(), ft.delete(o);
      };
    }, setProps(s) {
      var u;
      (u = ft.get(o)) == null || u.setProps(s);
    }, getSnapshot() {
      var s;
      return (s = ft.get(o)) == null ? void 0 : s.getSnapshot();
    } };
  }(e)).current;
  n(e);
  const i = $$(t, r, r);
  return { getToastToRender: function(a) {
    if (!i) return [];
    const o = /* @__PURE__ */ new Map();
    return i.forEach((s) => {
      const { position: u } = s.props;
      o.has(u) || o.set(u, []), o.get(u).push(s);
    }), Array.from(o, (s) => a(s[0], s[1]));
  }, isToastActive: Rp, count: i == null ? void 0 : i.length };
}
function k$(e) {
  const [t, r] = re(!1), [n, i] = re(!1), a = q(null), o = q({ start: 0, delta: 0, removalDistance: 0, canCloseOnClick: !0, canDrag: !1, didMove: !1 }).current, { autoClose: s, pauseOnHover: u, closeToast: l, onClick: c, closeOnClick: d } = e;
  var f, h;
  function p() {
    r(!0);
  }
  function v() {
    r(!1);
  }
  function g(b) {
    const D = a.current;
    o.canDrag && D && (o.didMove = !0, t && v(), o.delta = e.draggableDirection === "x" ? b.clientX - o.start : b.clientY - o.start, o.start !== b.clientX && (o.canCloseOnClick = !1), D.style.transform = `translate3d(${e.draggableDirection === "x" ? `${o.delta}px, var(--y)` : `0, calc(${o.delta}px + var(--y))`},0)`, D.style.opacity = "" + (1 - Math.abs(o.delta / o.removalDistance)));
  }
  function $() {
    document.removeEventListener("pointermove", g), document.removeEventListener("pointerup", $);
    const b = a.current;
    if (o.canDrag && o.didMove && b) {
      if (o.canDrag = !1, Math.abs(o.delta) > o.removalDistance) return i(!0), e.closeToast(), void e.collapseAll();
      b.style.transition = "transform 0.2s, opacity 0.2s", b.style.removeProperty("transform"), b.style.removeProperty("opacity");
    }
  }
  (h = ft.get((f = { id: e.toastId, containerId: e.containerId, fn: r }).containerId || 1)) == null || h.setToggle(f.id, f.fn), ue(() => {
    if (e.pauseOnFocusLoss) return document.hasFocus() || v(), window.addEventListener("focus", p), window.addEventListener("blur", v), () => {
      window.removeEventListener("focus", p), window.removeEventListener("blur", v);
    };
  }, [e.pauseOnFocusLoss]);
  const m = { onPointerDown: function(b) {
    if (e.draggable === !0 || e.draggable === b.pointerType) {
      o.didMove = !1, document.addEventListener("pointermove", g), document.addEventListener("pointerup", $);
      const D = a.current;
      o.canCloseOnClick = !0, o.canDrag = !0, D.style.transition = "none", e.draggableDirection === "x" ? (o.start = b.clientX, o.removalDistance = D.offsetWidth * (e.draggablePercent / 100)) : (o.start = b.clientY, o.removalDistance = D.offsetHeight * (e.draggablePercent === 80 ? 1.5 * e.draggablePercent : e.draggablePercent) / 100);
    }
  }, onPointerUp: function(b) {
    const { top: D, bottom: S, left: T, right: R } = a.current.getBoundingClientRect();
    b.nativeEvent.type !== "touchend" && e.pauseOnHover && b.clientX >= T && b.clientX <= R && b.clientY >= D && b.clientY <= S ? v() : p();
  } };
  return s && u && (m.onMouseEnter = v, e.stacked || (m.onMouseLeave = p)), d && (m.onClick = (b) => {
    c && c(b), o.canCloseOnClick && l();
  }), { playToast: p, pauseToast: v, isRunning: t, preventExitTransition: n, toastRef: a, eventHandlers: m };
}
function T$(e) {
  let { delay: t, isRunning: r, closeToast: n, type: i = "default", hide: a, className: o, style: s, controlledProgress: u, progress: l, rtl: c, isIn: d, theme: f } = e;
  const h = a || u && l === 0, p = { ...s, animationDuration: `${t}ms`, animationPlayState: r ? "running" : "paused" };
  u && (p.transform = `scaleX(${l})`);
  const v = ur("Toastify__progress-bar", u ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${f}`, `Toastify__progress-bar--${i}`, { "Toastify__progress-bar--rtl": c }), g = wt(o) ? o({ rtl: c, type: i, defaultClassName: v }) : ur(v, o), $ = { [u && l >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: u && l < 1 ? null : () => {
    d && n();
  } };
  return F.createElement("div", { className: "Toastify__progress-bar--wrp", "data-hidden": h }, F.createElement("div", { className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${f} Toastify__progress-bar--${i}` }), F.createElement("div", { role: "progressbar", "aria-hidden": h ? "true" : "false", "aria-label": "notification timer", className: g, style: p, ...$ }));
}
let P$ = 1;
const Mp = () => "" + P$++;
function A$(e) {
  return e && (nn(e.toastId) || Zi(e.toastId)) ? e.toastId : Mp();
}
function Ni(e, t) {
  return Bp(e, t), t.toastId;
}
function To(e, t) {
  return { ...t, type: t && t.type || e, toastId: A$(t) };
}
function ja(e) {
  return (t, r) => Ni(t, To(e, r));
}
function Ie(e, t) {
  return Ni(e, To("default", t));
}
Ie.loading = (e, t) => Ni(e, To("default", { isLoading: !0, autoClose: !1, closeOnClick: !1, closeButton: !1, draggable: !1, ...t })), Ie.promise = function(e, t, r) {
  let n, { pending: i, error: a, success: o } = t;
  i && (n = nn(i) ? Ie.loading(i, r) : Ie.loading(i.render, { ...r, ...i }));
  const s = { isLoading: null, autoClose: null, closeOnClick: null, closeButton: null, draggable: null }, u = (c, d, f) => {
    if (d == null) return void Ie.dismiss(n);
    const h = { type: c, ...s, ...r, data: f }, p = nn(d) ? { render: d } : d;
    return n ? Ie.update(n, { ...h, ...p }) : Ie(p.render, { ...h, ...p }), f;
  }, l = wt(e) ? e() : e;
  return l.then((c) => u("success", o, c)).catch((c) => u("error", a, c)), l;
}, Ie.success = ja("success"), Ie.info = ja("info"), Ie.error = ja("error"), Ie.warning = ja("warning"), Ie.warn = Ie.warning, Ie.dark = (e, t) => Ni(e, To("default", { theme: "dark", ...t })), Ie.dismiss = function(e) {
  (function(t) {
    var r;
    if (Ip()) {
      if (t == null || nn(r = t) || Zi(r)) ft.forEach((n) => {
        n.removeToast(t);
      });
      else if (t && ("containerId" in t || "id" in t)) {
        const n = ft.get(t.containerId);
        n ? n.removeToast(t.id) : ft.forEach((i) => {
          i.removeToast(t.id);
        });
      }
    } else Yi = Yi.filter((n) => t != null && n.options.toastId !== t);
  })(e);
}, Ie.clearWaitingQueue = function(e) {
  e === void 0 && (e = {}), ft.forEach((t) => {
    !t.props.limit || e.containerId && t.id !== e.containerId || t.clearQueue();
  });
}, Ie.isActive = Rp, Ie.update = function(e, t) {
  t === void 0 && (t = {});
  const r = ((n, i) => {
    var a;
    let { containerId: o } = i;
    return (a = ft.get(o || 1)) == null ? void 0 : a.toasts.get(n);
  })(e, t);
  if (r) {
    const { props: n, content: i } = r, a = { delay: 100, ...n, ...t, toastId: t.toastId || e, updateId: Mp() };
    a.toastId !== e && (a.staleId = e);
    const o = a.render || i;
    delete a.render, Ni(o, a);
  }
}, Ie.done = (e) => {
  Ie.update(e, { progress: 1 });
}, Ie.onChange = function(e) {
  return il.add(e), () => {
    il.delete(e);
  };
}, Ie.play = (e) => Xd(!0, e), Ie.pause = (e) => Xd(!1, e);
const _$ = typeof window < "u" ? Fp : ue, za = (e) => {
  let { theme: t, type: r, isLoading: n, ...i } = e;
  return F.createElement("svg", { viewBox: "0 0 24 24", width: "100%", height: "100%", fill: t === "colored" ? "currentColor" : `var(--toastify-icon-color-${r})`, ...i });
}, iu = { info: function(e) {
  return F.createElement(za, { ...e }, F.createElement("path", { d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z" }));
}, warning: function(e) {
  return F.createElement(za, { ...e }, F.createElement("path", { d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z" }));
}, success: function(e) {
  return F.createElement(za, { ...e }, F.createElement("path", { d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z" }));
}, error: function(e) {
  return F.createElement(za, { ...e }, F.createElement("path", { d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z" }));
}, spinner: function() {
  return F.createElement("div", { className: "Toastify__spinner" });
} }, F$ = (e) => {
  const { isRunning: t, preventExitTransition: r, toastRef: n, eventHandlers: i, playToast: a } = k$(e), { closeButton: o, children: s, autoClose: u, onClick: l, type: c, hideProgressBar: d, closeToast: f, transition: h, position: p, className: v, style: g, bodyClassName: $, bodyStyle: m, progressClassName: b, progressStyle: D, updateId: S, role: T, progress: R, rtl: y, toastId: A, deleteToast: w, isIn: E, isLoading: k, closeOnClick: C, theme: P } = e, L = ur("Toastify__toast", `Toastify__toast-theme--${P}`, `Toastify__toast--${c}`, { "Toastify__toast--rtl": y }, { "Toastify__toast--close-on-click": C }), O = wt(v) ? v({ rtl: y, position: p, type: c, defaultClassName: L }) : ur(L, v), x = function(ae) {
    let { theme: ne, type: me, isLoading: $e, icon: _e } = ae, Fe = null;
    const V = { theme: ne, type: me };
    return _e === !1 || (wt(_e) ? Fe = _e({ ...V, isLoading: $e }) : Ln(_e) ? Fe = Gi(_e, V) : $e ? Fe = iu.spinner() : ((ie) => ie in iu)(me) && (Fe = iu[me](V))), Fe;
  }(e), U = !!R || !u, K = { closeToast: f, type: c, theme: P };
  let j = null;
  return o === !1 || (j = wt(o) ? o(K) : Ln(o) ? Gi(o, K) : function(ae) {
    let { closeToast: ne, theme: me, ariaLabel: $e = "close" } = ae;
    return F.createElement("button", { className: `Toastify__close-button Toastify__close-button--${me}`, type: "button", onClick: (_e) => {
      _e.stopPropagation(), ne(_e);
    }, "aria-label": $e }, F.createElement("svg", { "aria-hidden": "true", viewBox: "0 0 14 16" }, F.createElement("path", { fillRule: "evenodd", d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z" })));
  }(K)), F.createElement(h, { isIn: E, done: w, position: p, preventExitTransition: r, nodeRef: n, playToast: a }, F.createElement("div", { id: A, onClick: l, "data-in": E, className: O, ...i, style: g, ref: n }, F.createElement("div", { ...E && { role: T }, className: wt($) ? $({ type: c }) : ur("Toastify__toast-body", $), style: m }, x != null && F.createElement("div", { className: ur("Toastify__toast-icon", { "Toastify--animate-icon Toastify__zoom-enter": !k }) }, x), F.createElement("div", null, s)), j, F.createElement(T$, { ...S && !U ? { key: `pb-${S}` } : {}, rtl: y, theme: P, delay: u, isRunning: t, isIn: E, closeToast: f, hide: d, type: c, style: D, className: b, controlledProgress: U, progress: R || 0 })));
}, ys = function(e, t) {
  return t === void 0 && (t = !1), { enter: `Toastify--animate Toastify__${e}-enter`, exit: `Toastify--animate Toastify__${e}-exit`, appendPosition: t };
}, O$ = vs(ys("bounce", !0));
vs(ys("slide", !0));
vs(ys("zoom"));
vs(ys("flip"));
const I$ = { position: "top-right", transition: O$, autoClose: 5e3, closeButton: !0, pauseOnHover: !0, pauseOnFocusLoss: !0, draggable: "touch", draggablePercent: 80, draggableDirection: "x", role: "alert", theme: "light" };
function R$(e) {
  let t = { ...I$, ...e };
  const r = e.stacked, [n, i] = re(!0), a = q(null), { getToastToRender: o, isToastActive: s, count: u } = S$(t), { className: l, style: c, rtl: d, containerId: f } = t;
  function h(v) {
    const g = ur("Toastify__toast-container", `Toastify__toast-container--${v}`, { "Toastify__toast-container--rtl": d });
    return wt(l) ? l({ position: v, rtl: d, defaultClassName: g }) : ur(g, co(l));
  }
  function p() {
    r && (i(!0), Ie.play());
  }
  return _$(() => {
    if (r) {
      var v;
      const g = a.current.querySelectorAll('[data-in="true"]'), $ = 12, m = (v = t.position) == null ? void 0 : v.includes("top");
      let b = 0, D = 0;
      Array.from(g).reverse().forEach((S, T) => {
        const R = S;
        R.classList.add("Toastify__toast--stacked"), T > 0 && (R.dataset.collapsed = `${n}`), R.dataset.pos || (R.dataset.pos = m ? "top" : "bot");
        const y = b * (n ? 0.2 : 1) + (n ? 0 : $ * T);
        R.style.setProperty("--y", `${m ? y : -1 * y}px`), R.style.setProperty("--g", `${$}`), R.style.setProperty("--s", "" + (1 - (n ? D : 0))), b += R.offsetHeight, D += 0.025;
      });
    }
  }, [n, u, r]), F.createElement("div", { ref: a, className: "Toastify", id: f, onMouseEnter: () => {
    r && (i(!1), Ie.pause());
  }, onMouseLeave: p }, o((v, g) => {
    const $ = g.length ? { ...c } : { ...c, pointerEvents: "none" };
    return F.createElement("div", { className: h(v), style: $, key: `container-${v}` }, g.map((m) => {
      let { content: b, props: D } = m;
      return F.createElement(F$, { ...D, stacked: r, collapseAll: p, isIn: s(D.toastId, D.containerId), style: D.style, key: `toast-${D.key}` }, b);
    }));
  }));
}
function Np(e) {
  const t = Object.prototype.toString.call(e);
  return e instanceof Date || typeof e == "object" && t === "[object Date]" ? new e.constructor(+e) : typeof e == "number" || t === "[object Number]" || typeof e == "string" || t === "[object String]" ? new Date(e) : /* @__PURE__ */ new Date(NaN);
}
function B$(e, t) {
  return e instanceof Date ? new e.constructor(t) : new Date(t);
}
function M$(e, t) {
  const r = +Np(e);
  return B$(e, r + t);
}
const Lp = 6e4, Vp = 36e5;
function N$(e, t) {
  return M$(e, t * 1e3);
}
function Dr(e, t) {
  const r = e < 0 ? "-" : "", n = Math.abs(e).toString().padStart(t, "0");
  return r + n;
}
function L$(e, t) {
  const r = Np(e);
  if (isNaN(r.getTime()))
    throw new RangeError("Invalid time value");
  let n = "", i = "";
  const a = "-", o = ":";
  {
    const s = Dr(r.getDate(), 2), u = Dr(r.getMonth() + 1, 2);
    n = `${Dr(r.getFullYear(), 4)}${a}${u}${a}${s}`;
  }
  {
    const s = r.getTimezoneOffset();
    if (s !== 0) {
      const h = Math.abs(s), p = Dr(Math.trunc(h / 60), 2), v = Dr(h % 60, 2);
      i = `${s < 0 ? "+" : "-"}${p}:${v}`;
    } else
      i = "Z";
    const u = Dr(r.getHours(), 2), l = Dr(r.getMinutes(), 2), c = Dr(r.getSeconds(), 2), d = n === "" ? "" : "T", f = [u, l, c].join(o);
    n = `${n}${d}${f}${i}`;
  }
  return n;
}
function V$(e, t) {
  const n = U$(e);
  let i;
  if (n.date) {
    const u = q$(n.date, 2);
    i = H$(u.restDateString, u.year);
  }
  if (!i || isNaN(i.getTime()))
    return /* @__PURE__ */ new Date(NaN);
  const a = i.getTime();
  let o = 0, s;
  if (n.time && (o = W$(n.time), isNaN(o)))
    return /* @__PURE__ */ new Date(NaN);
  if (n.timezone) {
    if (s = Q$(n.timezone), isNaN(s))
      return /* @__PURE__ */ new Date(NaN);
  } else {
    const u = new Date(a + o), l = /* @__PURE__ */ new Date(0);
    return l.setFullYear(
      u.getUTCFullYear(),
      u.getUTCMonth(),
      u.getUTCDate()
    ), l.setHours(
      u.getUTCHours(),
      u.getUTCMinutes(),
      u.getUTCSeconds(),
      u.getUTCMilliseconds()
    ), l;
  }
  return new Date(a + o + s);
}
const Ka = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
}, j$ = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, z$ = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, K$ = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function U$(e) {
  const t = {}, r = e.split(Ka.dateTimeDelimiter);
  let n;
  if (r.length > 2)
    return t;
  if (/:/.test(r[0]) ? n = r[0] : (t.date = r[0], n = r[1], Ka.timeZoneDelimiter.test(t.date) && (t.date = e.split(Ka.timeZoneDelimiter)[0], n = e.substr(
    t.date.length,
    e.length
  ))), n) {
    const i = Ka.timezone.exec(n);
    i ? (t.time = n.replace(i[1], ""), t.timezone = i[1]) : t.time = n;
  }
  return t;
}
function q$(e, t) {
  const r = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + t) + "})|(\\d{2}|[+-]\\d{" + (2 + t) + "})$)"
  ), n = e.match(r);
  if (!n) return { year: NaN, restDateString: "" };
  const i = n[1] ? parseInt(n[1]) : null, a = n[2] ? parseInt(n[2]) : null;
  return {
    year: a === null ? i : a * 100,
    restDateString: e.slice((n[1] || n[2]).length)
  };
}
function H$(e, t) {
  if (t === null) return /* @__PURE__ */ new Date(NaN);
  const r = e.match(j$);
  if (!r) return /* @__PURE__ */ new Date(NaN);
  const n = !!r[4], i = yi(r[1]), a = yi(r[2]) - 1, o = yi(r[3]), s = yi(r[4]), u = yi(r[5]) - 1;
  if (n)
    return X$(t, s, u) ? G$(t, s, u) : /* @__PURE__ */ new Date(NaN);
  {
    const l = /* @__PURE__ */ new Date(0);
    return !Y$(t, a, o) || !J$(t, i) ? /* @__PURE__ */ new Date(NaN) : (l.setUTCFullYear(t, a, Math.max(i, o)), l);
  }
}
function yi(e) {
  return e ? parseInt(e) : 1;
}
function W$(e) {
  const t = e.match(z$);
  if (!t) return NaN;
  const r = au(t[1]), n = au(t[2]), i = au(t[3]);
  return ex(r, n, i) ? r * Vp + n * Lp + i * 1e3 : NaN;
}
function au(e) {
  return e && parseFloat(e.replace(",", ".")) || 0;
}
function Q$(e) {
  if (e === "Z") return 0;
  const t = e.match(K$);
  if (!t) return 0;
  const r = t[1] === "+" ? -1 : 1, n = parseInt(t[2]), i = t[3] && parseInt(t[3]) || 0;
  return tx(n, i) ? r * (n * Vp + i * Lp) : NaN;
}
function G$(e, t, r) {
  const n = /* @__PURE__ */ new Date(0);
  n.setUTCFullYear(e, 0, 4);
  const i = n.getUTCDay() || 7, a = (t - 1) * 7 + r + 1 - i;
  return n.setUTCDate(n.getUTCDate() + a), n;
}
const Z$ = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function jp(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function Y$(e, t, r) {
  return t >= 0 && t <= 11 && r >= 1 && r <= (Z$[t] || (jp(e) ? 29 : 28));
}
function J$(e, t) {
  return t >= 1 && t <= (jp(e) ? 366 : 365);
}
function X$(e, t, r) {
  return t >= 1 && t <= 53 && r >= 0 && r <= 6;
}
function ex(e, t, r) {
  return e === 24 ? t === 0 && r === 0 : r >= 0 && r < 60 && t >= 0 && t < 60 && e >= 0 && e < 25;
}
function tx(e, t) {
  return t >= 0 && t <= 59;
}
const Yn = {
  isProd: !0,
  isDev: !1,
  ssoUrl: "https://media-library-api.spillover.com/sso",
  ssoDevUrl: "http://localhost:3030/sso",
  engageGraphqlEndpoint: "https://rails-admin.spillover.com/graphql",
  engageGraphqlDevEndpoint: "http://localhost:8080/graphql",
  accountsGraphqlEndpoint: "https://accounts-api.spillover.com/graphql",
  accountsGraphqlDevEndpoint: "http://localhost:3000/graphql"
};
var ou = function(e, t, r) {
  if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)
    (a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]);
  return e.concat(a || Array.prototype.slice.call(t));
}, rx = function() {
  function e(t) {
    var r = t.debug, n = r === void 0 ? !1 : r;
    this.debug = n, this.lines = [];
  }
  return e.prototype.emit = function(t, r) {
    if (t in console) {
      var n = e.prefix;
      console[t].apply(console, ou([n], r, !1));
    }
  }, e.prototype.tailLogs = function() {
    var t = this;
    this.lines.forEach(function(r) {
      var n = r[0], i = r[1];
      return t.emit(n, i);
    });
  }, e.prototype.getLogs = function() {
    return this.lines;
  }, e.prototype.write = function(t, r) {
    var n = e.buffer;
    this.lines = ou(ou([], this.lines.slice(1 - n), !0), [[t, r]], !1), (this.debug || t !== "log") && this.emit(t, r);
  }, e.prototype.info = function() {
    for (var t = [], r = 0; r < arguments.length; r++)
      t[r] = arguments[r];
    this.write("log", t);
  }, e.prototype.warn = function() {
    for (var t = [], r = 0; r < arguments.length; r++)
      t[r] = arguments[r];
    this.write("warn", t);
  }, e.prototype.error = function() {
    for (var t = [], r = 0; r < arguments.length; r++)
      t[r] = arguments[r];
    this.write("error", t);
  }, e.buffer = 30, e.prefix = "[apollo-cache-persist]", e;
}(), nx = function() {
  function e(t) {
    var r = t.cache, n = t.serialize, i = n === void 0 ? !0 : n;
    this.cache = r, this.serialize = i;
  }
  return e.prototype.extract = function() {
    var t = this.cache.extract();
    return this.serialize && (t = JSON.stringify(t)), t;
  }, e.prototype.restore = function(t) {
    this.serialize && typeof t == "string" && (t = JSON.parse(t)), t != null && this.cache.restore(t);
  }, e;
}(), Ua = function(e, t, r, n) {
  function i(a) {
    return a instanceof r ? a : new r(function(o) {
      o(a);
    });
  }
  return new (r || (r = Promise))(function(a, o) {
    function s(c) {
      try {
        l(n.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(n.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? a(c.value) : i(c.value).then(s, u);
    }
    l((n = n.apply(e, t || [])).next());
  });
}, qa = function(e, t) {
  var r = { label: 0, sent: function() {
    if (a[0] & 1) throw a[1];
    return a[1];
  }, trys: [], ops: [] }, n, i, a, o;
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(l) {
    return function(c) {
      return u([l, c]);
    };
  }
  function u(l) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, l[0] && (r = 0)), r; ) try {
      if (n = 1, i && (a = l[0] & 2 ? i.return : l[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, l[1])).done) return a;
      switch (i = 0, a && (l = [l[0] & 2, a.value]), l[0]) {
        case 0:
        case 1:
          a = l;
          break;
        case 4:
          return r.label++, { value: l[1], done: !1 };
        case 5:
          r.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            r = 0;
            continue;
          }
          if (l[0] === 3 && (!a || l[1] > a[0] && l[1] < a[3])) {
            r.label = l[1];
            break;
          }
          if (l[0] === 6 && r.label < a[1]) {
            r.label = a[1], a = l;
            break;
          }
          if (a && r.label < a[2]) {
            r.label = a[2], r.ops.push(l);
            break;
          }
          a[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      l = t.call(e, r);
    } catch (c) {
      l = [6, c], i = 0;
    } finally {
      n = a = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}, zp = function() {
  function e(t) {
    var r = t.storage, n = t.key, i = n === void 0 ? "apollo-cache-persist" : n;
    this.storage = r, this.key = i;
  }
  return e.prototype.read = function() {
    return Ua(this, void 0, void 0, function() {
      return qa(this, function(t) {
        return [2, this.storage.getItem(this.key)];
      });
    });
  }, e.prototype.write = function(t) {
    return Ua(this, void 0, void 0, function() {
      return qa(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, this.storage.setItem(this.key, t)];
          case 1:
            return r.sent(), [2];
        }
      });
    });
  }, e.prototype.purge = function() {
    return Ua(this, void 0, void 0, function() {
      return qa(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.storage.removeItem(this.key)];
          case 1:
            return t.sent(), [2];
        }
      });
    });
  }, e.prototype.getSize = function() {
    return Ua(this, void 0, void 0, function() {
      var t;
      return qa(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, this.storage.getItem(this.key)];
          case 1:
            return t = r.sent(), t == null ? [2, 0] : [2, typeof t == "string" ? t.length : null];
        }
      });
    });
  }, e;
}(), su = function(e, t, r, n) {
  function i(a) {
    return a instanceof r ? a : new r(function(o) {
      o(a);
    });
  }
  return new (r || (r = Promise))(function(a, o) {
    function s(c) {
      try {
        l(n.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(n.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? a(c.value) : i(c.value).then(s, u);
    }
    l((n = n.apply(e, t || [])).next());
  });
}, uu = function(e, t) {
  var r = { label: 0, sent: function() {
    if (a[0] & 1) throw a[1];
    return a[1];
  }, trys: [], ops: [] }, n, i, a, o;
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(l) {
    return function(c) {
      return u([l, c]);
    };
  }
  function u(l) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, l[0] && (r = 0)), r; ) try {
      if (n = 1, i && (a = l[0] & 2 ? i.return : l[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, l[1])).done) return a;
      switch (i = 0, a && (l = [l[0] & 2, a.value]), l[0]) {
        case 0:
        case 1:
          a = l;
          break;
        case 4:
          return r.label++, { value: l[1], done: !1 };
        case 5:
          r.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            r = 0;
            continue;
          }
          if (l[0] === 3 && (!a || l[1] > a[0] && l[1] < a[3])) {
            r.label = l[1];
            break;
          }
          if (l[0] === 6 && r.label < a[1]) {
            r.label = a[1], a = l;
            break;
          }
          if (a && r.label < a[2]) {
            r.label = a[2], r.ops.push(l);
            break;
          }
          a[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      l = t.call(e, r);
    } catch (c) {
      l = [6, c], i = 0;
    } finally {
      n = a = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}, Kp = function() {
  function e(t, r) {
    var n = t.log, i = t.cache, a = t.storage, o = r.maxSize, s = o === void 0 ? 1024 * 1024 : o, u = r.persistenceMapper;
    this.log = n, this.cache = i, this.storage = a, this.paused = !1, u && (this.persistenceMapper = u), s && (this.maxSize = s);
  }
  return e.prototype.persist = function() {
    return su(this, void 0, void 0, function() {
      var t, r;
      return uu(this, function(n) {
        switch (n.label) {
          case 0:
            return n.trys.push([0, 6, , 7]), t = this.cache.extract(), !this.paused && this.persistenceMapper ? [4, this.persistenceMapper(t)] : [3, 2];
          case 1:
            t = n.sent(), n.label = 2;
          case 2:
            return this.maxSize != null && typeof t == "string" && t.length > this.maxSize && !this.paused ? [4, this.purge()] : [3, 4];
          case 3:
            return n.sent(), this.paused = !0, [2];
          case 4:
            return this.paused ? [2] : [4, this.storage.write(t)];
          case 5:
            return n.sent(), this.log.info(typeof t == "string" ? "Persisted cache of size ".concat(t.length, " characters") : "Persisted cache"), [3, 7];
          case 6:
            throw r = n.sent(), this.log.error("Error persisting cache", r), r;
          case 7:
            return [2];
        }
      });
    });
  }, e.prototype.restore = function() {
    return su(this, void 0, void 0, function() {
      var t, r;
      return uu(this, function(n) {
        switch (n.label) {
          case 0:
            return n.trys.push([0, 5, , 6]), [4, this.storage.read()];
          case 1:
            return t = n.sent(), t == null ? [3, 3] : [4, this.cache.restore(t)];
          case 2:
            return n.sent(), this.log.info(typeof t == "string" ? "Restored cache of size ".concat(t.length, " characters") : "Restored cache"), [3, 4];
          case 3:
            this.log.info("No stored cache to restore"), n.label = 4;
          case 4:
            return [3, 6];
          case 5:
            throw r = n.sent(), this.log.error("Error restoring cache", r), r;
          case 6:
            return [2];
        }
      });
    });
  }, e.prototype.purge = function() {
    return su(this, void 0, void 0, function() {
      var t;
      return uu(this, function(r) {
        switch (r.label) {
          case 0:
            return r.trys.push([0, 2, , 3]), [4, this.storage.purge()];
          case 1:
            return r.sent(), this.log.info("Purged cache storage"), [3, 3];
          case 2:
            throw t = r.sent(), this.log.error("Error purging cache storage", t), t;
          case 3:
            return [2];
        }
      });
    });
  }, e;
}();
const Up = function(e) {
  var t = e.cache;
  return function(r) {
    var n = t.write, i = t.evict, a = t.modify, o = t.gc;
    return t.write = function() {
      for (var s = [], u = 0; u < arguments.length; u++)
        s[u] = arguments[u];
      var l = n.apply(t, s);
      return r(), l;
    }, t.evict = function() {
      for (var s = [], u = 0; u < arguments.length; u++)
        s[u] = arguments[u];
      var l = i.apply(t, s);
      return r(), l;
    }, t.modify = function() {
      for (var s = [], u = 0; u < arguments.length; u++)
        s[u] = arguments[u];
      var l = a.apply(t, s);
      return r(), l;
    }, t.gc = function() {
      for (var s = [], u = 0; u < arguments.length; u++)
        s[u] = arguments[u];
      var l = o.apply(t, s);
      return r(), l;
    }, function() {
      t.write = n, t.evict = i, t.modify = a, t.gc = o;
    };
  };
}, ix = function(e) {
  var t = e.log, r = e.cache;
  return function(n) {
    return t.warn("Trigger option `background` not available on web; using `write` trigger"), Up({ cache: r })(n);
  };
};
var ax = function() {
  function e(t, r) {
    var n = t.log, i = t.persistor, a = this;
    this.fire = function() {
      if (!a.debounce) {
        a.persist();
        return;
      }
      a.timeout != null && clearTimeout(a.timeout), a.timeout = setTimeout(a.persist, a.debounce);
    }, this.persist = function() {
      a.paused || a.persistor.persist();
    };
    var o = e.defaultDebounce, s = r.cache, u = r.debounce, l = r.trigger, c = l === void 0 ? "write" : l;
    if (c)
      switch (this.debounce = u ?? o, this.persistor = i, this.paused = !1, c) {
        case "write":
          this.uninstall = Up({ cache: s })(this.fire);
          break;
        case "background":
          u && n.warn("Debounce is not recommended with `background` trigger"), this.debounce = u, this.uninstall = ix({ cache: s, log: n })(this.fire);
          break;
        default:
          if (typeof c == "function")
            this.uninstall = c(this.fire);
          else
            throw Error("Unrecognized trigger option: ".concat(c));
      }
  }
  return e.prototype.pause = function() {
    this.paused = !0;
  }, e.prototype.resume = function() {
    this.paused = !1;
  }, e.prototype.remove = function() {
    this.uninstall && (this.uninstall(), this.uninstall = null, this.paused = !0);
  }, e.defaultDebounce = 1e3, e;
}(), ox = function() {
  function e(t) {
    if (!t.cache)
      throw new Error("In order to persist your Apollo Cache, you need to pass in a cache. Please see https://www.apollographql.com/docs/react/basics/caching.html for our default InMemoryCache.");
    if (!t.storage)
      throw new Error("In order to persist your Apollo Cache, you need to pass in an underlying storage provider. Please see https://github.com/apollographql/apollo-cache-persist#storage-providers");
    var r = new rx(t), n = new nx(t), i = new zp(t), a = new Kp({ log: r, cache: n, storage: i }, t), o = new ax({ log: r, persistor: a }, t);
    this.log = r, this.cache = n, this.storage = i, this.persistor = a, this.trigger = o;
  }
  return e.prototype.persist = function() {
    return this.persistor.persist();
  }, e.prototype.restore = function() {
    return this.persistor.restore();
  }, e.prototype.purge = function() {
    return this.persistor.purge();
  }, e.prototype.pause = function() {
    this.trigger.pause();
  }, e.prototype.resume = function() {
    this.trigger.resume();
  }, e.prototype.remove = function() {
    this.trigger.remove();
  }, e.prototype.getLogs = function(t) {
    if (t === void 0 && (t = !1), t)
      this.log.tailLogs();
    else
      return this.log.getLogs();
  }, e.prototype.getSize = function() {
    return this.storage.getSize();
  }, e;
}(), Dc = /* @__PURE__ */ function() {
  var e = function(t, r) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]);
    }, e(t, r);
  };
  return function(t, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    e(t, r);
    function n() {
      this.constructor = t;
    }
    t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
(function(e) {
  Dc(t, e);
  function t(r) {
    var n = e.call(this, r) || this;
    return n.storage = new ux(r), n.persistor = new sx({ log: n.log, cache: n.cache, storage: n.storage }, r), n;
  }
  return t.prototype.restoreSync = function() {
    this.persistor.restoreSync();
  }, t;
})(ox);
var sx = function(e) {
  Dc(t, e);
  function t(r, n) {
    var i = r.log, a = r.cache, o = r.storage;
    return e.call(this, { log: i, cache: a, storage: o }, n) || this;
  }
  return t.prototype.restoreSync = function() {
    this.cache.restore(this.storage.readSync());
  }, t;
}(Kp), ux = function(e) {
  Dc(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.readSync = function() {
    return this.storage.getItem(this.key);
  }, t;
}(zp), lx = function() {
  function e(t) {
    this.storage = t;
  }
  return e.prototype.getItem = function(t) {
    return this.storage.getItem(t);
  }, e.prototype.removeItem = function(t) {
    return this.storage.removeItem(t);
  }, e.prototype.setItem = function(t, r) {
    return r !== null ? this.storage.setItem(t, r) : this.removeItem(t);
  }, e;
}();
function cx(e, t, r = window) {
  const n = q();
  ue(() => {
    n.current = t;
  }, [t]), ue(
    () => {
      if (!(r == null ? void 0 : r.addEventListener)) return;
      const a = (o) => n.current(o);
      return r.addEventListener(e, a), () => {
        r.removeEventListener(e, a);
      };
    },
    [e, r]
    // Re-run if eventName or element changes.
  );
}
const qp = new lx(window.localStorage);
function Ec(e) {
  try {
    const t = qp.getItem(e);
    return t ? JSON.parse(t) : null;
  } catch (t) {
    return console.error(t), null;
  }
}
function Hp(e, t) {
  try {
    const r = t instanceof Function ? t(Ec(e)) : t;
    qp.setItem(
      e,
      r !== null ? JSON.stringify(r) : null
    );
  } catch (r) {
    console.error(r);
  }
  return t;
}
function dx(e, t, r = { sync: !1 }) {
  const [n, i] = re(
    () => Ec(e) || t
  ), a = ye(
    (s) => {
      !s.isTrusted || !r.sync || s.key === e && i(JSON.parse(s.newValue));
    },
    [e, r.sync]
  );
  return cx("storage", a), [n, (s) => i(Hp(e, s))];
}
class Jn {
  constructor(t) {
    this.accessToken = t.accessToken, this.expiresAt = t.expiresAt, this.ownerId = t.ownerId;
  }
  static fromOAuthResponse(t, r) {
    return new Jn({
      accessToken: t.access_token,
      expiresAt: N$(/* @__PURE__ */ new Date(), t.expires_in),
      ownerId: r
    });
  }
  static fromStored(t) {
    return new Jn({
      ...t,
      expiresAt: V$(t.expiresAt)
    });
  }
  get dataForStorage() {
    return {
      accessToken: this.accessToken,
      expiresAt: L$(this.expiresAt),
      ownerId: this.ownerId
    };
  }
  get expiresIn() {
    return this.expiresAt - /* @__PURE__ */ new Date();
  }
  get isExpired() {
    return this.expiresIn <= 0;
  }
  get isValid() {
    return !this.isExpired;
  }
}
const wc = "sfsAuthTokenData";
function Wp(e) {
  if (e.error)
    throw new Error(`SSO callback error: ${e.error}`);
  return e;
}
function fx(e) {
  return new Promise((t, r) => {
    const n = document.createElement("iframe");
    n.src = e, n.classList.add("border-0", "w-0", "h-0", "absolute", "invisible"), n.width = 0, n.height = 0;
    const i = (a) => {
      if (a.source !== n.contentWindow) return;
      n.remove();
      const {
        data: { type: o, payload: s }
      } = a;
      switch (o) {
        case "UNAUTHENTICATED":
          window.removeEventListener("message", i), r(new Error("SSO_UNAUTHENTICATED"));
          break;
        case "SSO_CALLBACK":
          window.removeEventListener("message", i), t(Wp(s));
          break;
        default:
          console.error("Unknown message type", o, s);
      }
    };
    window.addEventListener("message", i), document.body.appendChild(n);
  });
}
function hx(e) {
  return new Promise((t, r) => {
    const n = window.open(e, "ssoLogin", "width=600,height=480");
    if (!n) return r(new Error("Failed to open login popup."));
    const i = setInterval(() => {
      n.closed && (clearInterval(i), r(new Error("Login popup closed.")));
    }, 1e3), a = (o) => {
      if (o.source !== n) return;
      const {
        data: { type: s, payload: u }
      } = o;
      s === "SSO_CALLBACK" && (clearInterval(i), n.close(), window.removeEventListener("message", a), t(Wp(u)));
    };
    window.addEventListener("message", a);
  });
}
async function Cc({ mode: e, ownerId: t }) {
  const r = e === "development" ? Yn.ssoDevUrl : Yn.ssoUrl;
  let n;
  try {
    n = await fx(r);
  } catch (a) {
    if (a.message === "SSO_UNAUTHENTICATED") {
      const o = hx(r);
      n = await Ie.promise(
        o,
        {
          pending: "Please login to use this feature",
          success: "Successfully logged in!",
          error: "Failed to login. You need to login to use this feature."
        },
        { position: "bottom-right" }
      );
    } else
      throw a;
  }
  const i = Jn.fromOAuthResponse(n, t);
  return Hp(wc, i.dataForStorage), i.accessToken;
}
function Qp({ ownerId: e }) {
  const t = Ec(wc);
  if (t && t.ownerId === e) {
    const { accessToken: r } = Jn.fromStored(t);
    return r;
  }
  return null;
}
const px = de({
  isAuthenticated: !1,
  tokenData: null,
  reauth: () => {
  }
});
function mx({ children: e, mode: t, ownerId: r }) {
  const n = vx({ mode: t, ownerId: r });
  return /* @__PURE__ */ N(px.Provider, { value: n, children: e });
}
function vx({ mode: e, ownerId: t }) {
  let r;
  const [n, i] = dx(
    wc,
    null,
    { sync: !0 }
  ), a = () => {
    i(null), Cc({ mode: e, ownerId: t });
  };
  n && (t !== n.ownerId ? a() : r = Jn.fromStored(n));
  const o = !!(r != null && r.accessToken);
  return {
    accessToken: r == null ? void 0 : r.accessToken,
    isAuthenticated: o,
    reauth: a
  };
}
var al = function(e, t) {
  return al = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (r[i] = n[i]);
  }, al(e, t);
};
function Vt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  al(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var B = function() {
  return B = Object.assign || function(t) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (t[a] = r[a]);
    }
    return t;
  }, B.apply(this, arguments);
};
function Nt(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
      t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
}
function kr(e, t, r, n) {
  function i(a) {
    return a instanceof r ? a : new r(function(o) {
      o(a);
    });
  }
  return new (r || (r = Promise))(function(a, o) {
    function s(c) {
      try {
        l(n.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(n.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? a(c.value) : i(c.value).then(s, u);
    }
    l((n = n.apply(e, t || [])).next());
  });
}
function Tr(e, t) {
  var r = { label: 0, sent: function() {
    if (a[0] & 1) throw a[1];
    return a[1];
  }, trys: [], ops: [] }, n, i, a, o;
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(l) {
    return function(c) {
      return u([l, c]);
    };
  }
  function u(l) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, l[0] && (r = 0)), r; ) try {
      if (n = 1, i && (a = l[0] & 2 ? i.return : l[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, l[1])).done) return a;
      switch (i = 0, a && (l = [l[0] & 2, a.value]), l[0]) {
        case 0:
        case 1:
          a = l;
          break;
        case 4:
          return r.label++, { value: l[1], done: !1 };
        case 5:
          r.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            r = 0;
            continue;
          }
          if (l[0] === 3 && (!a || l[1] > a[0] && l[1] < a[3])) {
            r.label = l[1];
            break;
          }
          if (l[0] === 6 && r.label < a[1]) {
            r.label = a[1], a = l;
            break;
          }
          if (a && r.label < a[2]) {
            r.label = a[2], r.ops.push(l);
            break;
          }
          a[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      l = t.call(e, r);
    } catch (c) {
      l = [6, c], i = 0;
    } finally {
      n = a = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function Mt(e, t, r) {
  if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)
    (a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]);
  return e.concat(a || Array.prototype.slice.call(t));
}
var lu = "Invariant Violation", ef = Object.setPrototypeOf, yx = ef === void 0 ? function(e, t) {
  return e.__proto__ = t, e;
} : ef, Gp = (
  /** @class */
  function(e) {
    Vt(t, e);
    function t(r) {
      r === void 0 && (r = lu);
      var n = e.call(this, typeof r == "number" ? lu + ": " + r + " (see https://github.com/apollographql/invariant-packages)" : r) || this;
      return n.framesToPop = 1, n.name = lu, yx(n, t.prototype), n;
    }
    return t;
  }(Error)
);
function Wr(e, t) {
  if (!e)
    throw new Gp(t);
}
var Zp = ["debug", "log", "warn", "error", "silent"], gx = Zp.indexOf("log");
function Ha(e) {
  return function() {
    if (Zp.indexOf(e) >= gx) {
      var t = console[e] || console.log;
      return t.apply(console, arguments);
    }
  };
}
(function(e) {
  e.debug = Ha("debug"), e.log = Ha("log"), e.warn = Ha("warn"), e.error = Ha("error");
})(Wr || (Wr = {}));
var Sc = "3.10.5";
function Rt(e) {
  try {
    return e();
  } catch {
  }
}
const ol = Rt(function() {
  return globalThis;
}) || Rt(function() {
  return window;
}) || Rt(function() {
  return self;
}) || Rt(function() {
  return global;
}) || // We don't expect the Function constructor ever to be invoked at runtime, as
// long as at least one of globalThis, window, self, or global is defined, so
// we are under no obligation to make it easy for static analysis tools to
// detect syntactic usage of the Function constructor. If you think you can
// improve your static analysis to detect this obfuscation, think again. This
// is an arms race you cannot win, at least not in JavaScript.
Rt(function() {
  return Rt.constructor("return this")();
});
var tf = /* @__PURE__ */ new Map();
function sl(e) {
  var t = tf.get(e) || 1;
  return tf.set(e, t + 1), "".concat(e, ":").concat(t, ":").concat(Math.random().toString(36).slice(2));
}
function Yp(e, t) {
  t === void 0 && (t = 0);
  var r = sl("stringifyForDisplay");
  return JSON.stringify(e, function(n, i) {
    return i === void 0 ? r : i;
  }, t).split(JSON.stringify(r)).join("<undefined>");
}
function Wa(e) {
  return function(t) {
    for (var r = [], n = 1; n < arguments.length; n++)
      r[n - 1] = arguments[n];
    if (typeof t == "number") {
      var i = t;
      t = kc(i), t || (t = Tc(i, r), r = []);
    }
    e.apply(void 0, [t].concat(r));
  };
}
var se = Object.assign(function(t, r) {
  for (var n = [], i = 2; i < arguments.length; i++)
    n[i - 2] = arguments[i];
  t || Wr(t, kc(r, n) || Tc(r, n));
}, {
  debug: Wa(Wr.debug),
  log: Wa(Wr.log),
  warn: Wa(Wr.warn),
  error: Wa(Wr.error)
});
function ht(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  return new Gp(kc(e, t) || Tc(e, t));
}
var rf = Symbol.for("ApolloErrorMessageHandler_" + Sc);
function Jp(e) {
  return typeof e == "string" ? e : Yp(e, 2).slice(0, 1e3);
}
function kc(e, t) {
  if (t === void 0 && (t = []), !!e)
    return ol[rf] && ol[rf](e, t.map(Jp));
}
function Tc(e, t) {
  if (t === void 0 && (t = []), !!e)
    return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
      version: Sc,
      message: e,
      args: t.map(Jp)
    })));
}
function fo(e, t) {
  if (!!!e)
    throw new Error(t);
}
function bx(e) {
  return typeof e == "object" && e !== null;
}
function $x(e, t) {
  if (!!!e)
    throw new Error(
      "Unexpected invariant triggered."
    );
}
const xx = /\r\n|[\n\r]/g;
function ul(e, t) {
  let r = 0, n = 1;
  for (const i of e.body.matchAll(xx)) {
    if (typeof i.index == "number" || $x(!1), i.index >= t)
      break;
    r = i.index + i[0].length, n += 1;
  }
  return {
    line: n,
    column: t + 1 - r
  };
}
function Dx(e) {
  return Xp(
    e.source,
    ul(e.source, e.start)
  );
}
function Xp(e, t) {
  const r = e.locationOffset.column - 1, n = "".padStart(r) + e.body, i = t.line - 1, a = e.locationOffset.line - 1, o = t.line + a, s = t.line === 1 ? r : 0, u = t.column + s, l = `${e.name}:${o}:${u}
`, c = n.split(/\r\n|[\n\r]/g), d = c[i];
  if (d.length > 120) {
    const f = Math.floor(u / 80), h = u % 80, p = [];
    for (let v = 0; v < d.length; v += 80)
      p.push(d.slice(v, v + 80));
    return l + nf([
      [`${o} |`, p[0]],
      ...p.slice(1, f + 1).map((v) => ["|", v]),
      ["|", "^".padStart(h)],
      ["|", p[f + 1]]
    ]);
  }
  return l + nf([
    // Lines specified like this: ["prefix", "string"],
    [`${o - 1} |`, c[i - 1]],
    [`${o} |`, d],
    ["|", "^".padStart(u)],
    [`${o + 1} |`, c[i + 1]]
  ]);
}
function nf(e) {
  const t = e.filter(([n, i]) => i !== void 0), r = Math.max(...t.map(([n]) => n.length));
  return t.map(([n, i]) => n.padStart(r) + (i ? " " + i : "")).join(`
`);
}
function Ex(e) {
  const t = e[0];
  return t == null || "kind" in t || "length" in t ? {
    nodes: t,
    source: e[1],
    positions: e[2],
    path: e[3],
    originalError: e[4],
    extensions: e[5]
  } : t;
}
class Pc extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(t, ...r) {
    var n, i, a;
    const { nodes: o, source: s, positions: u, path: l, originalError: c, extensions: d } = Ex(r);
    super(t), this.name = "GraphQLError", this.path = l ?? void 0, this.originalError = c ?? void 0, this.nodes = af(
      Array.isArray(o) ? o : o ? [o] : void 0
    );
    const f = af(
      (n = this.nodes) === null || n === void 0 ? void 0 : n.map((p) => p.loc).filter((p) => p != null)
    );
    this.source = s ?? (f == null || (i = f[0]) === null || i === void 0 ? void 0 : i.source), this.positions = u ?? (f == null ? void 0 : f.map((p) => p.start)), this.locations = u && s ? u.map((p) => ul(s, p)) : f == null ? void 0 : f.map((p) => ul(p.source, p.start));
    const h = bx(
      c == null ? void 0 : c.extensions
    ) ? c == null ? void 0 : c.extensions : void 0;
    this.extensions = (a = d ?? h) !== null && a !== void 0 ? a : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), c != null && c.stack ? Object.defineProperty(this, "stack", {
      value: c.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, Pc) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let t = this.message;
    if (this.nodes)
      for (const r of this.nodes)
        r.loc && (t += `

` + Dx(r.loc));
    else if (this.source && this.locations)
      for (const r of this.locations)
        t += `

` + Xp(this.source, r);
    return t;
  }
  toJSON() {
    const t = {
      message: this.message
    };
    return this.locations != null && (t.locations = this.locations), this.path != null && (t.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (t.extensions = this.extensions), t;
  }
}
function af(e) {
  return e === void 0 || e.length === 0 ? void 0 : e;
}
function it(e, t, r) {
  return new Pc(`Syntax Error: ${r}`, {
    source: e,
    positions: [t]
  });
}
class wx {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(t, r, n) {
    this.start = t.start, this.end = r.end, this.startToken = t, this.endToken = r, this.source = n;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class em {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(t, r, n, i, a, o) {
    this.kind = t, this.start = r, this.end = n, this.line = i, this.column = a, this.value = o, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const tm = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, Cx = new Set(Object.keys(tm));
function of(e) {
  const t = e == null ? void 0 : e.kind;
  return typeof t == "string" && Cx.has(t);
}
var _n;
(function(e) {
  e.QUERY = "query", e.MUTATION = "mutation", e.SUBSCRIPTION = "subscription";
})(_n || (_n = {}));
var ll;
(function(e) {
  e.QUERY = "QUERY", e.MUTATION = "MUTATION", e.SUBSCRIPTION = "SUBSCRIPTION", e.FIELD = "FIELD", e.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", e.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", e.INLINE_FRAGMENT = "INLINE_FRAGMENT", e.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", e.SCHEMA = "SCHEMA", e.SCALAR = "SCALAR", e.OBJECT = "OBJECT", e.FIELD_DEFINITION = "FIELD_DEFINITION", e.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", e.INTERFACE = "INTERFACE", e.UNION = "UNION", e.ENUM = "ENUM", e.ENUM_VALUE = "ENUM_VALUE", e.INPUT_OBJECT = "INPUT_OBJECT", e.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(ll || (ll = {}));
var ee;
(function(e) {
  e.NAME = "Name", e.DOCUMENT = "Document", e.OPERATION_DEFINITION = "OperationDefinition", e.VARIABLE_DEFINITION = "VariableDefinition", e.SELECTION_SET = "SelectionSet", e.FIELD = "Field", e.ARGUMENT = "Argument", e.FRAGMENT_SPREAD = "FragmentSpread", e.INLINE_FRAGMENT = "InlineFragment", e.FRAGMENT_DEFINITION = "FragmentDefinition", e.VARIABLE = "Variable", e.INT = "IntValue", e.FLOAT = "FloatValue", e.STRING = "StringValue", e.BOOLEAN = "BooleanValue", e.NULL = "NullValue", e.ENUM = "EnumValue", e.LIST = "ListValue", e.OBJECT = "ObjectValue", e.OBJECT_FIELD = "ObjectField", e.DIRECTIVE = "Directive", e.NAMED_TYPE = "NamedType", e.LIST_TYPE = "ListType", e.NON_NULL_TYPE = "NonNullType", e.SCHEMA_DEFINITION = "SchemaDefinition", e.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", e.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", e.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", e.FIELD_DEFINITION = "FieldDefinition", e.INPUT_VALUE_DEFINITION = "InputValueDefinition", e.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", e.UNION_TYPE_DEFINITION = "UnionTypeDefinition", e.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", e.ENUM_VALUE_DEFINITION = "EnumValueDefinition", e.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", e.DIRECTIVE_DEFINITION = "DirectiveDefinition", e.SCHEMA_EXTENSION = "SchemaExtension", e.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", e.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", e.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", e.UNION_TYPE_EXTENSION = "UnionTypeExtension", e.ENUM_TYPE_EXTENSION = "EnumTypeExtension", e.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(ee || (ee = {}));
function cl(e) {
  return e === 9 || e === 32;
}
function Ji(e) {
  return e >= 48 && e <= 57;
}
function rm(e) {
  return e >= 97 && e <= 122 || // A-Z
  e >= 65 && e <= 90;
}
function nm(e) {
  return rm(e) || e === 95;
}
function Sx(e) {
  return rm(e) || Ji(e) || e === 95;
}
function kx(e) {
  var t;
  let r = Number.MAX_SAFE_INTEGER, n = null, i = -1;
  for (let o = 0; o < e.length; ++o) {
    var a;
    const s = e[o], u = Tx(s);
    u !== s.length && (n = (a = n) !== null && a !== void 0 ? a : o, i = o, o !== 0 && u < r && (r = u));
  }
  return e.map((o, s) => s === 0 ? o : o.slice(r)).slice(
    (t = n) !== null && t !== void 0 ? t : 0,
    i + 1
  );
}
function Tx(e) {
  let t = 0;
  for (; t < e.length && cl(e.charCodeAt(t)); )
    ++t;
  return t;
}
function Px(e, t) {
  const r = e.replace(/"""/g, '\\"""'), n = r.split(/\r\n|[\n\r]/g), i = n.length === 1, a = n.length > 1 && n.slice(1).every((h) => h.length === 0 || cl(h.charCodeAt(0))), o = r.endsWith('\\"""'), s = e.endsWith('"') && !o, u = e.endsWith("\\"), l = s || u, c = (
    // add leading and trailing new lines only if it improves readability
    !i || e.length > 70 || l || a || o
  );
  let d = "";
  const f = i && cl(e.charCodeAt(0));
  return (c && !f || a) && (d += `
`), d += r, (c || l) && (d += `
`), '"""' + d + '"""';
}
var z;
(function(e) {
  e.SOF = "<SOF>", e.EOF = "<EOF>", e.BANG = "!", e.DOLLAR = "$", e.AMP = "&", e.PAREN_L = "(", e.PAREN_R = ")", e.SPREAD = "...", e.COLON = ":", e.EQUALS = "=", e.AT = "@", e.BRACKET_L = "[", e.BRACKET_R = "]", e.BRACE_L = "{", e.PIPE = "|", e.BRACE_R = "}", e.NAME = "Name", e.INT = "Int", e.FLOAT = "Float", e.STRING = "String", e.BLOCK_STRING = "BlockString", e.COMMENT = "Comment";
})(z || (z = {}));
class Ax {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(t) {
    const r = new em(z.SOF, 0, 0, 0, 0);
    this.source = t, this.lastToken = r, this.token = r, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let t = this.token;
    if (t.kind !== z.EOF)
      do
        if (t.next)
          t = t.next;
        else {
          const r = Fx(this, t.end);
          t.next = r, r.prev = t, t = r;
        }
      while (t.kind === z.COMMENT);
    return t;
  }
}
function _x(e) {
  return e === z.BANG || e === z.DOLLAR || e === z.AMP || e === z.PAREN_L || e === z.PAREN_R || e === z.SPREAD || e === z.COLON || e === z.EQUALS || e === z.AT || e === z.BRACKET_L || e === z.BRACKET_R || e === z.BRACE_L || e === z.PIPE || e === z.BRACE_R;
}
function ui(e) {
  return e >= 0 && e <= 55295 || e >= 57344 && e <= 1114111;
}
function gs(e, t) {
  return im(e.charCodeAt(t)) && am(e.charCodeAt(t + 1));
}
function im(e) {
  return e >= 55296 && e <= 56319;
}
function am(e) {
  return e >= 56320 && e <= 57343;
}
function an(e, t) {
  const r = e.source.body.codePointAt(t);
  if (r === void 0)
    return z.EOF;
  if (r >= 32 && r <= 126) {
    const n = String.fromCodePoint(r);
    return n === '"' ? `'"'` : `"${n}"`;
  }
  return "U+" + r.toString(16).toUpperCase().padStart(4, "0");
}
function Ze(e, t, r, n, i) {
  const a = e.line, o = 1 + r - e.lineStart;
  return new em(t, r, n, a, o, i);
}
function Fx(e, t) {
  const r = e.source.body, n = r.length;
  let i = t;
  for (; i < n; ) {
    const a = r.charCodeAt(i);
    switch (a) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++i;
        continue;
      case 10:
        ++i, ++e.line, e.lineStart = i;
        continue;
      case 13:
        r.charCodeAt(i + 1) === 10 ? i += 2 : ++i, ++e.line, e.lineStart = i;
        continue;
      case 35:
        return Ox(e, i);
      case 33:
        return Ze(e, z.BANG, i, i + 1);
      case 36:
        return Ze(e, z.DOLLAR, i, i + 1);
      case 38:
        return Ze(e, z.AMP, i, i + 1);
      case 40:
        return Ze(e, z.PAREN_L, i, i + 1);
      case 41:
        return Ze(e, z.PAREN_R, i, i + 1);
      case 46:
        if (r.charCodeAt(i + 1) === 46 && r.charCodeAt(i + 2) === 46)
          return Ze(e, z.SPREAD, i, i + 3);
        break;
      case 58:
        return Ze(e, z.COLON, i, i + 1);
      case 61:
        return Ze(e, z.EQUALS, i, i + 1);
      case 64:
        return Ze(e, z.AT, i, i + 1);
      case 91:
        return Ze(e, z.BRACKET_L, i, i + 1);
      case 93:
        return Ze(e, z.BRACKET_R, i, i + 1);
      case 123:
        return Ze(e, z.BRACE_L, i, i + 1);
      case 124:
        return Ze(e, z.PIPE, i, i + 1);
      case 125:
        return Ze(e, z.BRACE_R, i, i + 1);
      case 34:
        return r.charCodeAt(i + 1) === 34 && r.charCodeAt(i + 2) === 34 ? Lx(e, i) : Rx(e, i);
    }
    if (Ji(a) || a === 45)
      return Ix(e, i, a);
    if (nm(a))
      return Vx(e, i);
    throw it(
      e.source,
      i,
      a === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : ui(a) || gs(r, i) ? `Unexpected character: ${an(e, i)}.` : `Invalid character: ${an(e, i)}.`
    );
  }
  return Ze(e, z.EOF, n, n);
}
function Ox(e, t) {
  const r = e.source.body, n = r.length;
  let i = t + 1;
  for (; i < n; ) {
    const a = r.charCodeAt(i);
    if (a === 10 || a === 13)
      break;
    if (ui(a))
      ++i;
    else if (gs(r, i))
      i += 2;
    else
      break;
  }
  return Ze(
    e,
    z.COMMENT,
    t,
    i,
    r.slice(t + 1, i)
  );
}
function Ix(e, t, r) {
  const n = e.source.body;
  let i = t, a = r, o = !1;
  if (a === 45 && (a = n.charCodeAt(++i)), a === 48) {
    if (a = n.charCodeAt(++i), Ji(a))
      throw it(
        e.source,
        i,
        `Invalid number, unexpected digit after 0: ${an(
          e,
          i
        )}.`
      );
  } else
    i = cu(e, i, a), a = n.charCodeAt(i);
  if (a === 46 && (o = !0, a = n.charCodeAt(++i), i = cu(e, i, a), a = n.charCodeAt(i)), (a === 69 || a === 101) && (o = !0, a = n.charCodeAt(++i), (a === 43 || a === 45) && (a = n.charCodeAt(++i)), i = cu(e, i, a), a = n.charCodeAt(i)), a === 46 || nm(a))
    throw it(
      e.source,
      i,
      `Invalid number, expected digit but got: ${an(
        e,
        i
      )}.`
    );
  return Ze(
    e,
    o ? z.FLOAT : z.INT,
    t,
    i,
    n.slice(t, i)
  );
}
function cu(e, t, r) {
  if (!Ji(r))
    throw it(
      e.source,
      t,
      `Invalid number, expected digit but got: ${an(
        e,
        t
      )}.`
    );
  const n = e.source.body;
  let i = t + 1;
  for (; Ji(n.charCodeAt(i)); )
    ++i;
  return i;
}
function Rx(e, t) {
  const r = e.source.body, n = r.length;
  let i = t + 1, a = i, o = "";
  for (; i < n; ) {
    const s = r.charCodeAt(i);
    if (s === 34)
      return o += r.slice(a, i), Ze(e, z.STRING, t, i + 1, o);
    if (s === 92) {
      o += r.slice(a, i);
      const u = r.charCodeAt(i + 1) === 117 ? r.charCodeAt(i + 2) === 123 ? Bx(e, i) : Mx(e, i) : Nx(e, i);
      o += u.value, i += u.size, a = i;
      continue;
    }
    if (s === 10 || s === 13)
      break;
    if (ui(s))
      ++i;
    else if (gs(r, i))
      i += 2;
    else
      throw it(
        e.source,
        i,
        `Invalid character within String: ${an(
          e,
          i
        )}.`
      );
  }
  throw it(e.source, i, "Unterminated string.");
}
function Bx(e, t) {
  const r = e.source.body;
  let n = 0, i = 3;
  for (; i < 12; ) {
    const a = r.charCodeAt(t + i++);
    if (a === 125) {
      if (i < 5 || !ui(n))
        break;
      return {
        value: String.fromCodePoint(n),
        size: i
      };
    }
    if (n = n << 4 | _i(a), n < 0)
      break;
  }
  throw it(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${r.slice(
      t,
      t + i
    )}".`
  );
}
function Mx(e, t) {
  const r = e.source.body, n = sf(r, t + 2);
  if (ui(n))
    return {
      value: String.fromCodePoint(n),
      size: 6
    };
  if (im(n) && r.charCodeAt(t + 6) === 92 && r.charCodeAt(t + 7) === 117) {
    const i = sf(r, t + 8);
    if (am(i))
      return {
        value: String.fromCodePoint(n, i),
        size: 12
      };
  }
  throw it(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${r.slice(t, t + 6)}".`
  );
}
function sf(e, t) {
  return _i(e.charCodeAt(t)) << 12 | _i(e.charCodeAt(t + 1)) << 8 | _i(e.charCodeAt(t + 2)) << 4 | _i(e.charCodeAt(t + 3));
}
function _i(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function Nx(e, t) {
  const r = e.source.body;
  switch (r.charCodeAt(t + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw it(
    e.source,
    t,
    `Invalid character escape sequence: "${r.slice(
      t,
      t + 2
    )}".`
  );
}
function Lx(e, t) {
  const r = e.source.body, n = r.length;
  let i = e.lineStart, a = t + 3, o = a, s = "";
  const u = [];
  for (; a < n; ) {
    const l = r.charCodeAt(a);
    if (l === 34 && r.charCodeAt(a + 1) === 34 && r.charCodeAt(a + 2) === 34) {
      s += r.slice(o, a), u.push(s);
      const c = Ze(
        e,
        z.BLOCK_STRING,
        t,
        a + 3,
        // Return a string of the lines joined with U+000A.
        kx(u).join(`
`)
      );
      return e.line += u.length - 1, e.lineStart = i, c;
    }
    if (l === 92 && r.charCodeAt(a + 1) === 34 && r.charCodeAt(a + 2) === 34 && r.charCodeAt(a + 3) === 34) {
      s += r.slice(o, a), o = a + 1, a += 4;
      continue;
    }
    if (l === 10 || l === 13) {
      s += r.slice(o, a), u.push(s), l === 13 && r.charCodeAt(a + 1) === 10 ? a += 2 : ++a, s = "", o = a, i = a;
      continue;
    }
    if (ui(l))
      ++a;
    else if (gs(r, a))
      a += 2;
    else
      throw it(
        e.source,
        a,
        `Invalid character within String: ${an(
          e,
          a
        )}.`
      );
  }
  throw it(e.source, a, "Unterminated string.");
}
function Vx(e, t) {
  const r = e.source.body, n = r.length;
  let i = t + 1;
  for (; i < n; ) {
    const a = r.charCodeAt(i);
    if (Sx(a))
      ++i;
    else
      break;
  }
  return Ze(
    e,
    z.NAME,
    t,
    i,
    r.slice(t, i)
  );
}
const jx = 10, om = 2;
function Ac(e) {
  return bs(e, []);
}
function bs(e, t) {
  switch (typeof e) {
    case "string":
      return JSON.stringify(e);
    case "function":
      return e.name ? `[function ${e.name}]` : "[function]";
    case "object":
      return zx(e, t);
    default:
      return String(e);
  }
}
function zx(e, t) {
  if (e === null)
    return "null";
  if (t.includes(e))
    return "[Circular]";
  const r = [...t, e];
  if (Kx(e)) {
    const n = e.toJSON();
    if (n !== e)
      return typeof n == "string" ? n : bs(n, r);
  } else if (Array.isArray(e))
    return qx(e, r);
  return Ux(e, r);
}
function Kx(e) {
  return typeof e.toJSON == "function";
}
function Ux(e, t) {
  const r = Object.entries(e);
  return r.length === 0 ? "{}" : t.length > om ? "[" + Hx(e) + "]" : "{ " + r.map(
    ([i, a]) => i + ": " + bs(a, t)
  ).join(", ") + " }";
}
function qx(e, t) {
  if (e.length === 0)
    return "[]";
  if (t.length > om)
    return "[Array]";
  const r = Math.min(jx, e.length), n = e.length - r, i = [];
  for (let a = 0; a < r; ++a)
    i.push(bs(e[a], t));
  return n === 1 ? i.push("... 1 more item") : n > 1 && i.push(`... ${n} more items`), "[" + i.join(", ") + "]";
}
function Hx(e) {
  const t = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, "");
  if (t === "Object" && typeof e.constructor == "function") {
    const r = e.constructor.name;
    if (typeof r == "string" && r !== "")
      return r;
  }
  return t;
}
const Wx = globalThis.process && // eslint-disable-next-line no-undef
process.env.NODE_ENV === "production", Qx = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  Wx ? function(t, r) {
    return t instanceof r;
  } : function(t, r) {
    if (t instanceof r)
      return !0;
    if (typeof t == "object" && t !== null) {
      var n;
      const i = r.prototype[Symbol.toStringTag], a = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in t ? t[Symbol.toStringTag] : (n = t.constructor) === null || n === void 0 ? void 0 : n.name
      );
      if (i === a) {
        const o = Ac(t);
        throw new Error(`Cannot use ${i} "${o}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
class sm {
  constructor(t, r = "GraphQL request", n = {
    line: 1,
    column: 1
  }) {
    typeof t == "string" || fo(!1, `Body must be a string. Received: ${Ac(t)}.`), this.body = t, this.name = r, this.locationOffset = n, this.locationOffset.line > 0 || fo(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || fo(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function Gx(e) {
  return Qx(e, sm);
}
function Zx(e, t) {
  return new Yx(e, t).parseDocument();
}
class Yx {
  constructor(t, r = {}) {
    const n = Gx(t) ? t : new sm(t);
    this._lexer = new Ax(n), this._options = r, this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const t = this.expectToken(z.NAME);
    return this.node(t, {
      kind: ee.NAME,
      value: t.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: ee.DOCUMENT,
      definitions: this.many(
        z.SOF,
        this.parseDefinition,
        z.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(z.BRACE_L))
      return this.parseOperationDefinition();
    const t = this.peekDescription(), r = t ? this._lexer.lookahead() : this._lexer.token;
    if (r.kind === z.NAME) {
      switch (r.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (t)
        throw it(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (r.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(r);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const t = this._lexer.token;
    if (this.peek(z.BRACE_L))
      return this.node(t, {
        kind: ee.OPERATION_DEFINITION,
        operation: _n.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const r = this.parseOperationType();
    let n;
    return this.peek(z.NAME) && (n = this.parseName()), this.node(t, {
      kind: ee.OPERATION_DEFINITION,
      operation: r,
      name: n,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const t = this.expectToken(z.NAME);
    switch (t.value) {
      case "query":
        return _n.QUERY;
      case "mutation":
        return _n.MUTATION;
      case "subscription":
        return _n.SUBSCRIPTION;
    }
    throw this.unexpected(t);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      z.PAREN_L,
      this.parseVariableDefinition,
      z.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: ee.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(z.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(z.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const t = this._lexer.token;
    return this.expectToken(z.DOLLAR), this.node(t, {
      kind: ee.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: ee.SELECTION_SET,
      selections: this.many(
        z.BRACE_L,
        this.parseSelection,
        z.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(z.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const t = this._lexer.token, r = this.parseName();
    let n, i;
    return this.expectOptionalToken(z.COLON) ? (n = r, i = this.parseName()) : i = r, this.node(t, {
      kind: ee.FIELD,
      alias: n,
      name: i,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(z.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(t) {
    const r = t ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(z.PAREN_L, r, z.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(t = !1) {
    const r = this._lexer.token, n = this.parseName();
    return this.expectToken(z.COLON), this.node(r, {
      kind: ee.ARGUMENT,
      name: n,
      value: this.parseValueLiteral(t)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const t = this._lexer.token;
    this.expectToken(z.SPREAD);
    const r = this.expectOptionalKeyword("on");
    return !r && this.peek(z.NAME) ? this.node(t, {
      kind: ee.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(t, {
      kind: ee.INLINE_FRAGMENT,
      typeCondition: r ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const t = this._lexer.token;
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(t, {
      kind: ee.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(t, {
      kind: ee.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(t) {
    const r = this._lexer.token;
    switch (r.kind) {
      case z.BRACKET_L:
        return this.parseList(t);
      case z.BRACE_L:
        return this.parseObject(t);
      case z.INT:
        return this.advanceLexer(), this.node(r, {
          kind: ee.INT,
          value: r.value
        });
      case z.FLOAT:
        return this.advanceLexer(), this.node(r, {
          kind: ee.FLOAT,
          value: r.value
        });
      case z.STRING:
      case z.BLOCK_STRING:
        return this.parseStringLiteral();
      case z.NAME:
        switch (this.advanceLexer(), r.value) {
          case "true":
            return this.node(r, {
              kind: ee.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(r, {
              kind: ee.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(r, {
              kind: ee.NULL
            });
          default:
            return this.node(r, {
              kind: ee.ENUM,
              value: r.value
            });
        }
      case z.DOLLAR:
        if (t)
          if (this.expectToken(z.DOLLAR), this._lexer.token.kind === z.NAME) {
            const n = this._lexer.token.value;
            throw it(
              this._lexer.source,
              r.start,
              `Unexpected variable "$${n}" in constant value.`
            );
          } else
            throw this.unexpected(r);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const t = this._lexer.token;
    return this.advanceLexer(), this.node(t, {
      kind: ee.STRING,
      value: t.value,
      block: t.kind === z.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(t) {
    const r = () => this.parseValueLiteral(t);
    return this.node(this._lexer.token, {
      kind: ee.LIST,
      values: this.any(z.BRACKET_L, r, z.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(t) {
    const r = () => this.parseObjectField(t);
    return this.node(this._lexer.token, {
      kind: ee.OBJECT,
      fields: this.any(z.BRACE_L, r, z.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(t) {
    const r = this._lexer.token, n = this.parseName();
    return this.expectToken(z.COLON), this.node(r, {
      kind: ee.OBJECT_FIELD,
      name: n,
      value: this.parseValueLiteral(t)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(t) {
    const r = [];
    for (; this.peek(z.AT); )
      r.push(this.parseDirective(t));
    return r;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(t) {
    const r = this._lexer.token;
    return this.expectToken(z.AT), this.node(r, {
      kind: ee.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(t)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const t = this._lexer.token;
    let r;
    if (this.expectOptionalToken(z.BRACKET_L)) {
      const n = this.parseTypeReference();
      this.expectToken(z.BRACKET_R), r = this.node(t, {
        kind: ee.LIST_TYPE,
        type: n
      });
    } else
      r = this.parseNamedType();
    return this.expectOptionalToken(z.BANG) ? this.node(t, {
      kind: ee.NON_NULL_TYPE,
      type: r
    }) : r;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: ee.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(z.STRING) || this.peek(z.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("schema");
    const n = this.parseConstDirectives(), i = this.many(
      z.BRACE_L,
      this.parseOperationTypeDefinition,
      z.BRACE_R
    );
    return this.node(t, {
      kind: ee.SCHEMA_DEFINITION,
      description: r,
      directives: n,
      operationTypes: i
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const t = this._lexer.token, r = this.parseOperationType();
    this.expectToken(z.COLON);
    const n = this.parseNamedType();
    return this.node(t, {
      kind: ee.OPERATION_TYPE_DEFINITION,
      operation: r,
      type: n
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("scalar");
    const n = this.parseName(), i = this.parseConstDirectives();
    return this.node(t, {
      kind: ee.SCALAR_TYPE_DEFINITION,
      description: r,
      name: n,
      directives: i
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("type");
    const n = this.parseName(), i = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(t, {
      kind: ee.OBJECT_TYPE_DEFINITION,
      description: r,
      name: n,
      interfaces: i,
      directives: a,
      fields: o
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(z.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      z.BRACE_L,
      this.parseFieldDefinition,
      z.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const t = this._lexer.token, r = this.parseDescription(), n = this.parseName(), i = this.parseArgumentDefs();
    this.expectToken(z.COLON);
    const a = this.parseTypeReference(), o = this.parseConstDirectives();
    return this.node(t, {
      kind: ee.FIELD_DEFINITION,
      description: r,
      name: n,
      arguments: i,
      type: a,
      directives: o
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      z.PAREN_L,
      this.parseInputValueDef,
      z.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const t = this._lexer.token, r = this.parseDescription(), n = this.parseName();
    this.expectToken(z.COLON);
    const i = this.parseTypeReference();
    let a;
    this.expectOptionalToken(z.EQUALS) && (a = this.parseConstValueLiteral());
    const o = this.parseConstDirectives();
    return this.node(t, {
      kind: ee.INPUT_VALUE_DEFINITION,
      description: r,
      name: n,
      type: i,
      defaultValue: a,
      directives: o
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("interface");
    const n = this.parseName(), i = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(t, {
      kind: ee.INTERFACE_TYPE_DEFINITION,
      description: r,
      name: n,
      interfaces: i,
      directives: a,
      fields: o
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("union");
    const n = this.parseName(), i = this.parseConstDirectives(), a = this.parseUnionMemberTypes();
    return this.node(t, {
      kind: ee.UNION_TYPE_DEFINITION,
      description: r,
      name: n,
      directives: i,
      types: a
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(z.EQUALS) ? this.delimitedMany(z.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("enum");
    const n = this.parseName(), i = this.parseConstDirectives(), a = this.parseEnumValuesDefinition();
    return this.node(t, {
      kind: ee.ENUM_TYPE_DEFINITION,
      description: r,
      name: n,
      directives: i,
      values: a
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      z.BRACE_L,
      this.parseEnumValueDefinition,
      z.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const t = this._lexer.token, r = this.parseDescription(), n = this.parseEnumValueName(), i = this.parseConstDirectives();
    return this.node(t, {
      kind: ee.ENUM_VALUE_DEFINITION,
      description: r,
      name: n,
      directives: i
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw it(
        this._lexer.source,
        this._lexer.token.start,
        `${Qa(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("input");
    const n = this.parseName(), i = this.parseConstDirectives(), a = this.parseInputFieldsDefinition();
    return this.node(t, {
      kind: ee.INPUT_OBJECT_TYPE_DEFINITION,
      description: r,
      name: n,
      directives: i,
      fields: a
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      z.BRACE_L,
      this.parseInputValueDef,
      z.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const t = this._lexer.lookahead();
    if (t.kind === z.NAME)
      switch (t.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(t);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const r = this.parseConstDirectives(), n = this.optionalMany(
      z.BRACE_L,
      this.parseOperationTypeDefinition,
      z.BRACE_R
    );
    if (r.length === 0 && n.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ee.SCHEMA_EXTENSION,
      directives: r,
      operationTypes: n
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const r = this.parseName(), n = this.parseConstDirectives();
    if (n.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ee.SCALAR_TYPE_EXTENSION,
      name: r,
      directives: n
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const r = this.parseName(), n = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    if (n.length === 0 && i.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ee.OBJECT_TYPE_EXTENSION,
      name: r,
      interfaces: n,
      directives: i,
      fields: a
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const r = this.parseName(), n = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    if (n.length === 0 && i.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ee.INTERFACE_TYPE_EXTENSION,
      name: r,
      interfaces: n,
      directives: i,
      fields: a
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const r = this.parseName(), n = this.parseConstDirectives(), i = this.parseUnionMemberTypes();
    if (n.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ee.UNION_TYPE_EXTENSION,
      name: r,
      directives: n,
      types: i
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const r = this.parseName(), n = this.parseConstDirectives(), i = this.parseEnumValuesDefinition();
    if (n.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ee.ENUM_TYPE_EXTENSION,
      name: r,
      directives: n,
      values: i
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const r = this.parseName(), n = this.parseConstDirectives(), i = this.parseInputFieldsDefinition();
    if (n.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: ee.INPUT_OBJECT_TYPE_EXTENSION,
      name: r,
      directives: n,
      fields: i
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(z.AT);
    const n = this.parseName(), i = this.parseArgumentDefs(), a = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const o = this.parseDirectiveLocations();
    return this.node(t, {
      kind: ee.DIRECTIVE_DEFINITION,
      description: r,
      name: n,
      arguments: i,
      repeatable: a,
      locations: o
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(z.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const t = this._lexer.token, r = this.parseName();
    if (Object.prototype.hasOwnProperty.call(ll, r.value))
      return r;
    throw this.unexpected(t);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(t, r) {
    return this._options.noLocation !== !0 && (r.loc = new wx(
      t,
      this._lexer.lastToken,
      this._lexer.source
    )), r;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(t) {
    return this._lexer.token.kind === t;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(t) {
    const r = this._lexer.token;
    if (r.kind === t)
      return this.advanceLexer(), r;
    throw it(
      this._lexer.source,
      r.start,
      `Expected ${um(t)}, found ${Qa(r)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(t) {
    return this._lexer.token.kind === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(t) {
    const r = this._lexer.token;
    if (r.kind === z.NAME && r.value === t)
      this.advanceLexer();
    else
      throw it(
        this._lexer.source,
        r.start,
        `Expected "${t}", found ${Qa(r)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(t) {
    const r = this._lexer.token;
    return r.kind === z.NAME && r.value === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(t) {
    const r = t ?? this._lexer.token;
    return it(
      this._lexer.source,
      r.start,
      `Unexpected ${Qa(r)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(t, r, n) {
    this.expectToken(t);
    const i = [];
    for (; !this.expectOptionalToken(n); )
      i.push(r.call(this));
    return i;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(t, r, n) {
    if (this.expectOptionalToken(t)) {
      const i = [];
      do
        i.push(r.call(this));
      while (!this.expectOptionalToken(n));
      return i;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(t, r, n) {
    this.expectToken(t);
    const i = [];
    do
      i.push(r.call(this));
    while (!this.expectOptionalToken(n));
    return i;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(t, r) {
    this.expectOptionalToken(t);
    const n = [];
    do
      n.push(r.call(this));
    while (this.expectOptionalToken(t));
    return n;
  }
  advanceLexer() {
    const { maxTokens: t } = this._options, r = this._lexer.advance();
    if (t !== void 0 && r.kind !== z.EOF && (++this._tokenCounter, this._tokenCounter > t))
      throw it(
        this._lexer.source,
        r.start,
        `Document contains more that ${t} tokens. Parsing aborted.`
      );
  }
}
function Qa(e) {
  const t = e.value;
  return um(e.kind) + (t != null ? ` "${t}"` : "");
}
function um(e) {
  return _x(e) ? `"${e}"` : e;
}
function Jx(e) {
  return `"${e.replace(Xx, eD)}"`;
}
const Xx = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function eD(e) {
  return tD[e.charCodeAt(0)];
}
const tD = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], _c = Object.freeze({});
function pr(e, t, r = tm) {
  const n = /* @__PURE__ */ new Map();
  for (const $ of Object.values(ee))
    n.set($, rD(t, $));
  let i, a = Array.isArray(e), o = [e], s = -1, u = [], l = e, c, d;
  const f = [], h = [];
  do {
    s++;
    const $ = s === o.length, m = $ && u.length !== 0;
    if ($) {
      if (c = h.length === 0 ? void 0 : f[f.length - 1], l = d, d = h.pop(), m)
        if (a) {
          l = l.slice();
          let D = 0;
          for (const [S, T] of u) {
            const R = S - D;
            T === null ? (l.splice(R, 1), D++) : l[R] = T;
          }
        } else {
          l = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(l)
          );
          for (const [D, S] of u)
            l[D] = S;
        }
      s = i.index, o = i.keys, u = i.edits, a = i.inArray, i = i.prev;
    } else if (d) {
      if (c = a ? s : o[s], l = d[c], l == null)
        continue;
      f.push(c);
    }
    let b;
    if (!Array.isArray(l)) {
      var p, v;
      of(l) || fo(!1, `Invalid AST Node: ${Ac(l)}.`);
      const D = $ ? (p = n.get(l.kind)) === null || p === void 0 ? void 0 : p.leave : (v = n.get(l.kind)) === null || v === void 0 ? void 0 : v.enter;
      if (b = D == null ? void 0 : D.call(t, l, c, d, f, h), b === _c)
        break;
      if (b === !1) {
        if (!$) {
          f.pop();
          continue;
        }
      } else if (b !== void 0 && (u.push([c, b]), !$))
        if (of(b))
          l = b;
        else {
          f.pop();
          continue;
        }
    }
    if (b === void 0 && m && u.push([c, l]), $)
      f.pop();
    else {
      var g;
      i = {
        inArray: a,
        index: s,
        keys: o,
        edits: u,
        prev: i
      }, a = Array.isArray(l), o = a ? l : (g = r[l.kind]) !== null && g !== void 0 ? g : [], s = -1, u = [], d && h.push(d), d = l;
    }
  } while (i !== void 0);
  return u.length !== 0 ? u[u.length - 1][1] : e;
}
function rD(e, t) {
  const r = e[t];
  return typeof r == "object" ? r : typeof r == "function" ? {
    enter: r,
    leave: void 0
  } : {
    enter: e.enter,
    leave: e.leave
  };
}
function nD(e) {
  return pr(e, aD);
}
const iD = 80, aD = {
  Name: {
    leave: (e) => e.value
  },
  Variable: {
    leave: (e) => "$" + e.name
  },
  // Document
  Document: {
    leave: (e) => te(e.definitions, `

`)
  },
  OperationDefinition: {
    leave(e) {
      const t = xe("(", te(e.variableDefinitions, ", "), ")"), r = te(
        [
          e.operation,
          te([e.name, t]),
          te(e.directives, " ")
        ],
        " "
      );
      return (r === "query" ? "" : r + " ") + e.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: e, type: t, defaultValue: r, directives: n }) => e + ": " + t + xe(" = ", r) + xe(" ", te(n, " "))
  },
  SelectionSet: {
    leave: ({ selections: e }) => Ot(e)
  },
  Field: {
    leave({ alias: e, name: t, arguments: r, directives: n, selectionSet: i }) {
      const a = xe("", e, ": ") + t;
      let o = a + xe("(", te(r, ", "), ")");
      return o.length > iD && (o = a + xe(`(
`, ho(te(r, `
`)), `
)`)), te([o, te(n, " "), i], " ");
    }
  },
  Argument: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: e, directives: t }) => "..." + e + xe(" ", te(t, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: e, directives: t, selectionSet: r }) => te(
      [
        "...",
        xe("on ", e),
        te(t, " "),
        r
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: e, typeCondition: t, variableDefinitions: r, directives: n, selectionSet: i }) => (
      // or removed in the future.
      `fragment ${e}${xe("(", te(r, ", "), ")")} on ${t} ${xe("", te(n, " "), " ")}` + i
    )
  },
  // Value
  IntValue: {
    leave: ({ value: e }) => e
  },
  FloatValue: {
    leave: ({ value: e }) => e
  },
  StringValue: {
    leave: ({ value: e, block: t }) => t ? Px(e) : Jx(e)
  },
  BooleanValue: {
    leave: ({ value: e }) => e ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: e }) => e
  },
  ListValue: {
    leave: ({ values: e }) => "[" + te(e, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: e }) => "{" + te(e, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Directive
  Directive: {
    leave: ({ name: e, arguments: t }) => "@" + e + xe("(", te(t, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: e }) => e
  },
  ListType: {
    leave: ({ type: e }) => "[" + e + "]"
  },
  NonNullType: {
    leave: ({ type: e }) => e + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: e, directives: t, operationTypes: r }) => xe("", e, `
`) + te(["schema", te(t, " "), Ot(r)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: e, type: t }) => e + ": " + t
  },
  ScalarTypeDefinition: {
    leave: ({ description: e, name: t, directives: r }) => xe("", e, `
`) + te(["scalar", t, te(r, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: r, directives: n, fields: i }) => xe("", e, `
`) + te(
      [
        "type",
        t,
        xe("implements ", te(r, " & ")),
        te(n, " "),
        Ot(i)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: e, name: t, arguments: r, type: n, directives: i }) => xe("", e, `
`) + t + (uf(r) ? xe(`(
`, ho(te(r, `
`)), `
)`) : xe("(", te(r, ", "), ")")) + ": " + n + xe(" ", te(i, " "))
  },
  InputValueDefinition: {
    leave: ({ description: e, name: t, type: r, defaultValue: n, directives: i }) => xe("", e, `
`) + te(
      [t + ": " + r, xe("= ", n), te(i, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: r, directives: n, fields: i }) => xe("", e, `
`) + te(
      [
        "interface",
        t,
        xe("implements ", te(r, " & ")),
        te(n, " "),
        Ot(i)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: e, name: t, directives: r, types: n }) => xe("", e, `
`) + te(
      ["union", t, te(r, " "), xe("= ", te(n, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: e, name: t, directives: r, values: n }) => xe("", e, `
`) + te(["enum", t, te(r, " "), Ot(n)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: e, name: t, directives: r }) => xe("", e, `
`) + te([t, te(r, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: e, name: t, directives: r, fields: n }) => xe("", e, `
`) + te(["input", t, te(r, " "), Ot(n)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: e, name: t, arguments: r, repeatable: n, locations: i }) => xe("", e, `
`) + "directive @" + t + (uf(r) ? xe(`(
`, ho(te(r, `
`)), `
)`) : xe("(", te(r, ", "), ")")) + (n ? " repeatable" : "") + " on " + te(i, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: e, operationTypes: t }) => te(
      ["extend schema", te(e, " "), Ot(t)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: e, directives: t }) => te(["extend scalar", e, te(t, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: r, fields: n }) => te(
      [
        "extend type",
        e,
        xe("implements ", te(t, " & ")),
        te(r, " "),
        Ot(n)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: r, fields: n }) => te(
      [
        "extend interface",
        e,
        xe("implements ", te(t, " & ")),
        te(r, " "),
        Ot(n)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: e, directives: t, types: r }) => te(
      [
        "extend union",
        e,
        te(t, " "),
        xe("= ", te(r, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: e, directives: t, values: r }) => te(["extend enum", e, te(t, " "), Ot(r)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: e, directives: t, fields: r }) => te(["extend input", e, te(t, " "), Ot(r)], " ")
  }
};
function te(e, t = "") {
  var r;
  return (r = e == null ? void 0 : e.filter((n) => n).join(t)) !== null && r !== void 0 ? r : "";
}
function Ot(e) {
  return xe(`{
`, ho(te(e, `
`)), `
}`);
}
function xe(e, t, r = "") {
  return t != null && t !== "" ? e + t + r : "";
}
function ho(e) {
  return xe("  ", e.replace(/\n/g, `
  `));
}
function uf(e) {
  var t;
  return (t = e == null ? void 0 : e.some((r) => r.includes(`
`))) !== null && t !== void 0 ? t : !1;
}
function lf(e) {
  return e.kind === ee.FIELD || e.kind === ee.FRAGMENT_SPREAD || e.kind === ee.INLINE_FRAGMENT;
}
function Da(e, t) {
  var r = e.directives;
  return !r || !r.length ? !0 : uD(r).every(function(n) {
    var i = n.directive, a = n.ifArgument, o = !1;
    return a.value.kind === "Variable" ? (o = t && t[a.value.name.value], se(o !== void 0, 68, i.name.value)) : o = a.value.value, i.name.value === "skip" ? !o : o;
  });
}
function Xi(e, t, r) {
  var n = new Set(e), i = n.size;
  return pr(t, {
    Directive: function(a) {
      if (n.delete(a.name.value) && (!r || !n.size))
        return _c;
    }
  }), r ? !n.size : n.size < i;
}
function oD(e) {
  return e && Xi(["client", "export"], e, !0);
}
function sD(e) {
  var t = e.name.value;
  return t === "skip" || t === "include";
}
function uD(e) {
  var t = [];
  return e && e.length && e.forEach(function(r) {
    if (sD(r)) {
      var n = r.arguments, i = r.name.value;
      se(n && n.length === 1, 69, i);
      var a = n[0];
      se(a.name && a.name.value === "if", 70, i);
      var o = a.value;
      se(o && (o.kind === "Variable" || o.kind === "BooleanValue"), 71, i), t.push({ directive: r, ifArgument: a });
    }
  }), t;
}
const lD = () => /* @__PURE__ */ Object.create(null), { forEach: cD, slice: cf } = Array.prototype, { hasOwnProperty: dD } = Object.prototype;
let li = class lm {
  constructor(t = !0, r = lD) {
    this.weakness = t, this.makeData = r;
  }
  lookup() {
    return this.lookupArray(arguments);
  }
  lookupArray(t) {
    let r = this;
    return cD.call(t, (n) => r = r.getChildTrie(n)), dD.call(r, "data") ? r.data : r.data = this.makeData(cf.call(t));
  }
  peek() {
    return this.peekArray(arguments);
  }
  peekArray(t) {
    let r = this;
    for (let n = 0, i = t.length; r && n < i; ++n) {
      const a = r.mapFor(t[n], !1);
      r = a && a.get(t[n]);
    }
    return r && r.data;
  }
  remove() {
    return this.removeArray(arguments);
  }
  removeArray(t) {
    let r;
    if (t.length) {
      const n = t[0], i = this.mapFor(n, !1), a = i && i.get(n);
      a && (r = a.removeArray(cf.call(t, 1)), !a.data && !a.weak && !(a.strong && a.strong.size) && i.delete(n));
    } else
      r = this.data, delete this.data;
    return r;
  }
  getChildTrie(t) {
    const r = this.mapFor(t, !0);
    let n = r.get(t);
    return n || r.set(t, n = new lm(this.weakness, this.makeData)), n;
  }
  mapFor(t, r) {
    return this.weakness && fD(t) ? this.weak || (r ? this.weak = /* @__PURE__ */ new WeakMap() : void 0) : this.strong || (r ? this.strong = /* @__PURE__ */ new Map() : void 0);
  }
};
function fD(e) {
  switch (typeof e) {
    case "object":
      if (e === null)
        break;
    case "function":
      return !0;
  }
  return !1;
}
var mn = typeof WeakMap == "function" && !Rt(function() {
  return navigator.product == "ReactNative" && !global.HermesInternal;
}), cm = typeof WeakSet == "function", Fc = typeof Symbol == "function" && typeof Symbol.for == "function", $s = Fc && Symbol.asyncIterator, hD = typeof Rt(function() {
  return window.document.createElement;
}) == "function", pD = (
  // Following advice found in this comment from @domenic (maintainer of jsdom):
  // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327
  //
  // Since we control the version of Jest and jsdom used when running Apollo
  // Client tests, and that version is recent enought to include " jsdom/x.y.z"
  // at the end of the user agent string, I believe this case is all we need to
  // check. Testing for "Node.js" was recommended for backwards compatibility
  // with older version of jsdom, but we don't have that problem.
  Rt(function() {
    return navigator.userAgent.indexOf("jsdom") >= 0;
  }) || !1
), mD = hD && !pD;
function Ue(e) {
  return e !== null && typeof e == "object";
}
function vD(e, t) {
  var r = t, n = [];
  e.definitions.forEach(function(a) {
    if (a.kind === "OperationDefinition")
      throw ht(
        72,
        a.operation,
        a.name ? " named '".concat(a.name.value, "'") : ""
      );
    a.kind === "FragmentDefinition" && n.push(a);
  }), typeof r > "u" && (se(n.length === 1, 73, n.length), r = n[0].name.value);
  var i = B(B({}, e), { definitions: Mt([
    {
      kind: "OperationDefinition",
      // OperationTypeNode is an enum
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: r
            }
          }
        ]
      }
    }
  ], e.definitions, !0) });
  return i;
}
function xs(e) {
  e === void 0 && (e = []);
  var t = {};
  return e.forEach(function(r) {
    t[r.name.value] = r;
  }), t;
}
function Ds(e, t) {
  switch (e.kind) {
    case "InlineFragment":
      return e;
    case "FragmentSpread": {
      var r = e.name.value;
      if (typeof t == "function")
        return t(r);
      var n = t && t[r];
      return se(n, 74, r), n || null;
    }
    default:
      return null;
  }
}
function yD() {
}
class dl {
  constructor(t = 1 / 0, r = yD) {
    this.max = t, this.dispose = r, this.map = /* @__PURE__ */ new Map(), this.newest = null, this.oldest = null;
  }
  has(t) {
    return this.map.has(t);
  }
  get(t) {
    const r = this.getNode(t);
    return r && r.value;
  }
  get size() {
    return this.map.size;
  }
  getNode(t) {
    const r = this.map.get(t);
    if (r && r !== this.newest) {
      const { older: n, newer: i } = r;
      i && (i.older = n), n && (n.newer = i), r.older = this.newest, r.older.newer = r, r.newer = null, this.newest = r, r === this.oldest && (this.oldest = i);
    }
    return r;
  }
  set(t, r) {
    let n = this.getNode(t);
    return n ? n.value = r : (n = {
      key: t,
      value: r,
      newer: null,
      older: this.newest
    }, this.newest && (this.newest.newer = n), this.newest = n, this.oldest = this.oldest || n, this.map.set(t, n), n.value);
  }
  clean() {
    for (; this.oldest && this.map.size > this.max; )
      this.delete(this.oldest.key);
  }
  delete(t) {
    const r = this.map.get(t);
    return r ? (r === this.newest && (this.newest = r.older), r === this.oldest && (this.oldest = r.newer), r.newer && (r.newer.older = r.older), r.older && (r.older.newer = r.newer), this.map.delete(t), this.dispose(r.value, t), !0) : !1;
  }
}
function fl() {
}
const gD = fl, bD = typeof WeakRef < "u" ? WeakRef : function(e) {
  return { deref: () => e };
}, $D = typeof WeakMap < "u" ? WeakMap : Map, xD = typeof FinalizationRegistry < "u" ? FinalizationRegistry : function() {
  return {
    register: fl,
    unregister: fl
  };
}, DD = 10024;
class Po {
  constructor(t = 1 / 0, r = gD) {
    this.max = t, this.dispose = r, this.map = new $D(), this.newest = null, this.oldest = null, this.unfinalizedNodes = /* @__PURE__ */ new Set(), this.finalizationScheduled = !1, this.size = 0, this.finalize = () => {
      const n = this.unfinalizedNodes.values();
      for (let i = 0; i < DD; i++) {
        const a = n.next().value;
        if (!a)
          break;
        this.unfinalizedNodes.delete(a);
        const o = a.key;
        delete a.key, a.keyRef = new bD(o), this.registry.register(o, a, a);
      }
      this.unfinalizedNodes.size > 0 ? queueMicrotask(this.finalize) : this.finalizationScheduled = !1;
    }, this.registry = new xD(this.deleteNode.bind(this));
  }
  has(t) {
    return this.map.has(t);
  }
  get(t) {
    const r = this.getNode(t);
    return r && r.value;
  }
  getNode(t) {
    const r = this.map.get(t);
    if (r && r !== this.newest) {
      const { older: n, newer: i } = r;
      i && (i.older = n), n && (n.newer = i), r.older = this.newest, r.older.newer = r, r.newer = null, this.newest = r, r === this.oldest && (this.oldest = i);
    }
    return r;
  }
  set(t, r) {
    let n = this.getNode(t);
    return n ? n.value = r : (n = {
      key: t,
      value: r,
      newer: null,
      older: this.newest
    }, this.newest && (this.newest.newer = n), this.newest = n, this.oldest = this.oldest || n, this.scheduleFinalization(n), this.map.set(t, n), this.size++, n.value);
  }
  clean() {
    for (; this.oldest && this.size > this.max; )
      this.deleteNode(this.oldest);
  }
  deleteNode(t) {
    t === this.newest && (this.newest = t.older), t === this.oldest && (this.oldest = t.newer), t.newer && (t.newer.older = t.older), t.older && (t.older.newer = t.newer), this.size--;
    const r = t.key || t.keyRef && t.keyRef.deref();
    this.dispose(t.value, r), t.keyRef ? this.registry.unregister(t) : this.unfinalizedNodes.delete(t), r && this.map.delete(r);
  }
  delete(t) {
    const r = this.map.get(t);
    return r ? (this.deleteNode(r), !0) : !1;
  }
  scheduleFinalization(t) {
    this.unfinalizedNodes.add(t), this.finalizationScheduled || (this.finalizationScheduled = !0, queueMicrotask(this.finalize));
  }
}
var du = /* @__PURE__ */ new WeakSet();
function dm(e) {
  e.size <= (e.max || -1) || du.has(e) || (du.add(e), setTimeout(function() {
    e.clean(), du.delete(e);
  }, 100));
}
var Oc = function(e, t) {
  var r = new Po(e, t);
  return r.set = function(n, i) {
    var a = Po.prototype.set.call(this, n, i);
    return dm(this), a;
  }, r;
}, ED = function(e, t) {
  var r = new dl(e, t);
  return r.set = function(n, i) {
    var a = dl.prototype.set.call(this, n, i);
    return dm(this), a;
  }, r;
}, wD = Symbol.for("apollo.cacheSize"), Zt = B({}, ol[wD]), Hr = {};
function Ic(e, t) {
  Hr[e] = t;
}
var CD = globalThis.__DEV__ !== !1 ? PD : void 0, SD = globalThis.__DEV__ !== !1 ? AD : void 0, kD = globalThis.__DEV__ !== !1 ? fm : void 0;
function TD() {
  var e = {
    parser: 1e3,
    canonicalStringify: 1e3,
    print: 2e3,
    "documentTransform.cache": 2e3,
    "queryManager.getDocumentInfo": 2e3,
    "PersistedQueryLink.persistedQueryHashes": 2e3,
    "fragmentRegistry.transform": 2e3,
    "fragmentRegistry.lookup": 1e3,
    "fragmentRegistry.findFragmentSpreads": 4e3,
    "cache.fragmentQueryDocuments": 1e3,
    "removeTypenameFromVariables.getVariableDefinitions": 2e3,
    "inMemoryCache.maybeBroadcastWatch": 5e3,
    "inMemoryCache.executeSelectionSet": 5e4,
    "inMemoryCache.executeSubSelectedArray": 1e4
  };
  return Object.fromEntries(Object.entries(e).map(function(t) {
    var r = t[0], n = t[1];
    return [
      r,
      Zt[r] || n
    ];
  }));
}
function PD() {
  var e, t, r, n, i;
  if (globalThis.__DEV__ === !1)
    throw new Error("only supported in development mode");
  return {
    limits: TD(),
    sizes: B({ print: (e = Hr.print) === null || e === void 0 ? void 0 : e.call(Hr), parser: (t = Hr.parser) === null || t === void 0 ? void 0 : t.call(Hr), canonicalStringify: (r = Hr.canonicalStringify) === null || r === void 0 ? void 0 : r.call(Hr), links: pl(this.link), queryManager: {
      getDocumentInfo: this.queryManager.transformCache.size,
      documentTransforms: pm(this.queryManager.documentTransform)
    } }, (i = (n = this.cache).getMemoryInternals) === null || i === void 0 ? void 0 : i.call(n))
  };
}
function fm() {
  return {
    cache: {
      fragmentQueryDocuments: Pr(this.getFragmentDoc)
    }
  };
}
function AD() {
  var e = this.config.fragments;
  return B(B({}, fm.apply(this)), { addTypenameDocumentTransform: pm(this.addTypenameTransform), inMemoryCache: {
    executeSelectionSet: Pr(this.storeReader.executeSelectionSet),
    executeSubSelectedArray: Pr(this.storeReader.executeSubSelectedArray),
    maybeBroadcastWatch: Pr(this.maybeBroadcastWatch)
  }, fragmentRegistry: {
    findFragmentSpreads: Pr(e == null ? void 0 : e.findFragmentSpreads),
    lookup: Pr(e == null ? void 0 : e.lookup),
    transform: Pr(e == null ? void 0 : e.transform)
  } });
}
function _D(e) {
  return !!e && "dirtyKey" in e;
}
function Pr(e) {
  return _D(e) ? e.size : void 0;
}
function hm(e) {
  return e != null;
}
function pm(e) {
  return hl(e).map(function(t) {
    return { cache: t };
  });
}
function hl(e) {
  return e ? Mt(Mt([
    Pr(e == null ? void 0 : e.performWork)
  ], hl(e == null ? void 0 : e.left), !0), hl(e == null ? void 0 : e.right), !0).filter(hm) : [];
}
function pl(e) {
  var t;
  return e ? Mt(Mt([
    (t = e == null ? void 0 : e.getMemoryInternals) === null || t === void 0 ? void 0 : t.call(e)
  ], pl(e == null ? void 0 : e.left), !0), pl(e == null ? void 0 : e.right), !0).filter(hm) : [];
}
var Ir = Object.assign(function(t) {
  return JSON.stringify(t, FD);
}, {
  reset: function() {
    Fn = new ED(
      Zt.canonicalStringify || 1e3
      /* defaultCacheSizes.canonicalStringify */
    );
  }
});
globalThis.__DEV__ !== !1 && Ic("canonicalStringify", function() {
  return Fn.size;
});
var Fn;
Ir.reset();
function FD(e, t) {
  if (t && typeof t == "object") {
    var r = Object.getPrototypeOf(t);
    if (r === Object.prototype || r === null) {
      var n = Object.keys(t);
      if (n.every(OD))
        return t;
      var i = JSON.stringify(n), a = Fn.get(i);
      if (!a) {
        n.sort();
        var o = JSON.stringify(n);
        a = Fn.get(o) || n, Fn.set(i, a), Fn.set(o, a);
      }
      var s = Object.create(r);
      return a.forEach(function(u) {
        s[u] = t[u];
      }), s;
    }
  }
  return t;
}
function OD(e, t, r) {
  return t === 0 || r[t - 1] <= e;
}
function Vn(e) {
  return { __ref: String(e) };
}
function Pe(e) {
  return !!(e && typeof e == "object" && typeof e.__ref == "string");
}
function ID(e) {
  return Ue(e) && e.kind === "Document" && Array.isArray(e.definitions);
}
function RD(e) {
  return e.kind === "StringValue";
}
function BD(e) {
  return e.kind === "BooleanValue";
}
function MD(e) {
  return e.kind === "IntValue";
}
function ND(e) {
  return e.kind === "FloatValue";
}
function LD(e) {
  return e.kind === "Variable";
}
function VD(e) {
  return e.kind === "ObjectValue";
}
function jD(e) {
  return e.kind === "ListValue";
}
function zD(e) {
  return e.kind === "EnumValue";
}
function KD(e) {
  return e.kind === "NullValue";
}
function Xn(e, t, r, n) {
  if (MD(r) || ND(r))
    e[t.value] = Number(r.value);
  else if (BD(r) || RD(r))
    e[t.value] = r.value;
  else if (VD(r)) {
    var i = {};
    r.fields.map(function(o) {
      return Xn(i, o.name, o.value, n);
    }), e[t.value] = i;
  } else if (LD(r)) {
    var a = (n || {})[r.name.value];
    e[t.value] = a;
  } else if (jD(r))
    e[t.value] = r.values.map(function(o) {
      var s = {};
      return Xn(s, t, o, n), s[t.value];
    });
  else if (zD(r))
    e[t.value] = r.value;
  else if (KD(r))
    e[t.value] = null;
  else
    throw ht(83, t.value, r.kind);
}
function UD(e, t) {
  var r = null;
  e.directives && (r = {}, e.directives.forEach(function(i) {
    r[i.name.value] = {}, i.arguments && i.arguments.forEach(function(a) {
      var o = a.name, s = a.value;
      return Xn(r[i.name.value], o, s, t);
    });
  }));
  var n = null;
  return e.arguments && e.arguments.length && (n = {}, e.arguments.forEach(function(i) {
    var a = i.name, o = i.value;
    return Xn(n, a, o, t);
  })), mm(e.name.value, n, r);
}
var qD = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export",
  "nonreactive"
], gi = Ir, mm = Object.assign(function(e, t, r) {
  if (t && r && r.connection && r.connection.key)
    if (r.connection.filter && r.connection.filter.length > 0) {
      var n = r.connection.filter ? r.connection.filter : [];
      n.sort();
      var i = {};
      return n.forEach(function(s) {
        i[s] = t[s];
      }), "".concat(r.connection.key, "(").concat(gi(i), ")");
    } else
      return r.connection.key;
  var a = e;
  if (t) {
    var o = gi(t);
    a += "(".concat(o, ")");
  }
  return r && Object.keys(r).forEach(function(s) {
    qD.indexOf(s) === -1 && (r[s] && Object.keys(r[s]).length ? a += "@".concat(s, "(").concat(gi(r[s]), ")") : a += "@".concat(s));
  }), a;
}, {
  setStringify: function(e) {
    var t = gi;
    return gi = e, t;
  }
});
function Es(e, t) {
  if (e.arguments && e.arguments.length) {
    var r = {};
    return e.arguments.forEach(function(n) {
      var i = n.name, a = n.value;
      return Xn(r, i, a, t);
    }), r;
  }
  return null;
}
function Rr(e) {
  return e.alias ? e.alias.value : e.name.value;
}
function ml(e, t, r) {
  for (var n, i = 0, a = t.selections; i < a.length; i++) {
    var o = a[i];
    if (Br(o)) {
      if (o.name.value === "__typename")
        return e[Rr(o)];
    } else n ? n.push(o) : n = [o];
  }
  if (typeof e.__typename == "string")
    return e.__typename;
  if (n)
    for (var s = 0, u = n; s < u.length; s++) {
      var o = u[s], l = ml(e, Ds(o, r).selectionSet, r);
      if (typeof l == "string")
        return l;
    }
}
function Br(e) {
  return e.kind === "Field";
}
function HD(e) {
  return e.kind === "InlineFragment";
}
function Ea(e) {
  se(e && e.kind === "Document", 75);
  var t = e.definitions.filter(function(r) {
    return r.kind !== "FragmentDefinition";
  }).map(function(r) {
    if (r.kind !== "OperationDefinition")
      throw ht(76, r.kind);
    return r;
  });
  return se(t.length <= 1, 77, t.length), e;
}
function wa(e) {
  return Ea(e), e.definitions.filter(function(t) {
    return t.kind === "OperationDefinition";
  })[0];
}
function vl(e) {
  return e.definitions.filter(function(t) {
    return t.kind === "OperationDefinition" && !!t.name;
  }).map(function(t) {
    return t.name.value;
  })[0] || null;
}
function ws(e) {
  return e.definitions.filter(function(t) {
    return t.kind === "FragmentDefinition";
  });
}
function vm(e) {
  var t = wa(e);
  return se(t && t.operation === "query", 78), t;
}
function WD(e) {
  se(e.kind === "Document", 79), se(e.definitions.length <= 1, 80);
  var t = e.definitions[0];
  return se(t.kind === "FragmentDefinition", 81), t;
}
function Ca(e) {
  Ea(e);
  for (var t, r = 0, n = e.definitions; r < n.length; r++) {
    var i = n[r];
    if (i.kind === "OperationDefinition") {
      var a = i.operation;
      if (a === "query" || a === "mutation" || a === "subscription")
        return i;
    }
    i.kind === "FragmentDefinition" && !t && (t = i);
  }
  if (t)
    return t;
  throw ht(82);
}
function Rc(e) {
  var t = /* @__PURE__ */ Object.create(null), r = e && e.variableDefinitions;
  return r && r.length && r.forEach(function(n) {
    n.defaultValue && Xn(t, n.variable.name, n.defaultValue);
  }), t;
}
const QD = () => /* @__PURE__ */ Object.create(null), { forEach: GD, slice: ZD } = Array.prototype, { hasOwnProperty: YD } = Object.prototype;
class Bc {
  constructor(t = !0, r = QD) {
    this.weakness = t, this.makeData = r;
  }
  lookup(...t) {
    return this.lookupArray(t);
  }
  lookupArray(t) {
    let r = this;
    return GD.call(t, (n) => r = r.getChildTrie(n)), YD.call(r, "data") ? r.data : r.data = this.makeData(ZD.call(t));
  }
  peek(...t) {
    return this.peekArray(t);
  }
  peekArray(t) {
    let r = this;
    for (let n = 0, i = t.length; r && n < i; ++n) {
      const a = this.weakness && df(t[n]) ? r.weak : r.strong;
      r = a && a.get(t[n]);
    }
    return r && r.data;
  }
  getChildTrie(t) {
    const r = this.weakness && df(t) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
    let n = r.get(t);
    return n || r.set(t, n = new Bc(this.weakness, this.makeData)), n;
  }
}
function df(e) {
  switch (typeof e) {
    case "object":
      if (e === null)
        break;
    case "function":
      return !0;
  }
  return !1;
}
let ot = null;
const ff = {};
let JD = 1;
const XD = () => class {
  constructor() {
    this.id = [
      "slot",
      JD++,
      Date.now(),
      Math.random().toString(36).slice(2)
    ].join(":");
  }
  hasValue() {
    for (let t = ot; t; t = t.parent)
      if (this.id in t.slots) {
        const r = t.slots[this.id];
        if (r === ff)
          break;
        return t !== ot && (ot.slots[this.id] = r), !0;
      }
    return ot && (ot.slots[this.id] = ff), !1;
  }
  getValue() {
    if (this.hasValue())
      return ot.slots[this.id];
  }
  withValue(t, r, n, i) {
    const a = {
      __proto__: null,
      [this.id]: t
    }, o = ot;
    ot = { parent: o, slots: a };
    try {
      return r.apply(i, n);
    } finally {
      ot = o;
    }
  }
  // Capture the current context and wrap a callback function so that it
  // reestablishes the captured context when called.
  static bind(t) {
    const r = ot;
    return function() {
      const n = ot;
      try {
        return ot = r, t.apply(this, arguments);
      } finally {
        ot = n;
      }
    };
  }
  // Immediately run a callback function without any captured context.
  static noContext(t, r, n) {
    if (ot) {
      const i = ot;
      try {
        return ot = null, t.apply(n, r);
      } finally {
        ot = i;
      }
    } else
      return t.apply(n, r);
  }
};
function hf(e) {
  try {
    return e();
  } catch {
  }
}
const fu = "@wry/context:Slot", e5 = (
  // Prefer globalThis when available.
  // https://github.com/benjamn/wryware/issues/347
  hf(() => globalThis) || // Fall back to global, which works in Node.js and may be converted by some
  // bundlers to the appropriate identifier (window, self, ...) depending on the
  // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
  hf(() => global) || // Otherwise, use a dummy host that's local to this module. We used to fall
  // back to using the Array constructor as a namespace, but that was flagged in
  // https://github.com/benjamn/wryware/issues/347, and can be avoided.
  /* @__PURE__ */ Object.create(null)
), pf = e5, ym = pf[fu] || // Earlier versions of this package stored the globalKey property on the Array
// constructor, so we check there as well, to prevent Slot class duplication.
Array[fu] || function(e) {
  try {
    Object.defineProperty(pf, fu, {
      value: e,
      enumerable: !1,
      writable: !1,
      // When it was possible for globalHost to be the Array constructor (a
      // legacy Slot dedup strategy), it was important for the property to be
      // configurable:true so it could be deleted. That does not seem to be as
      // important when globalHost is the global object, but I don't want to
      // cause similar problems again, and configurable:true seems safest.
      // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
      configurable: !0
    });
  } finally {
    return e;
  }
}(XD()), Cs = new ym(), { hasOwnProperty: t5 } = Object.prototype, Mc = Array.from || function(e) {
  const t = [];
  return e.forEach((r) => t.push(r)), t;
};
function Nc(e) {
  const { unsubscribe: t } = e;
  typeof t == "function" && (e.unsubscribe = void 0, t());
}
const ea = [], r5 = 100;
function ei(e, t) {
  if (!e)
    throw new Error(t || "assertion failure");
}
function gm(e, t) {
  const r = e.length;
  return (
    // Unknown values are not equal to each other.
    r > 0 && // Both values must be ordinary (or both exceptional) to be equal.
    r === t.length && // The underlying value or exception must be the same.
    e[r - 1] === t[r - 1]
  );
}
function bm(e) {
  switch (e.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return e[0];
    case 2:
      throw e[1];
  }
}
function $m(e) {
  return e.slice(0);
}
class Ss {
  constructor(t) {
    this.fn = t, this.parents = /* @__PURE__ */ new Set(), this.childValues = /* @__PURE__ */ new Map(), this.dirtyChildren = null, this.dirty = !0, this.recomputing = !1, this.value = [], this.deps = null, ++Ss.count;
  }
  peek() {
    if (this.value.length === 1 && !Mr(this))
      return mf(this), this.value[0];
  }
  // This is the most important method of the Entry API, because it
  // determines whether the cached this.value can be returned immediately,
  // or must be recomputed. The overall performance of the caching system
  // depends on the truth of the following observations: (1) this.dirty is
  // usually false, (2) this.dirtyChildren is usually null/empty, and thus
  // (3) valueGet(this.value) is usually returned without recomputation.
  recompute(t) {
    return ei(!this.recomputing, "already recomputing"), mf(this), Mr(this) ? n5(this, t) : bm(this.value);
  }
  setDirty() {
    this.dirty || (this.dirty = !0, xm(this), Nc(this));
  }
  dispose() {
    this.setDirty(), Sm(this), Lc(this, (t, r) => {
      t.setDirty(), km(t, this);
    });
  }
  forget() {
    this.dispose();
  }
  dependOn(t) {
    t.add(this), this.deps || (this.deps = ea.pop() || /* @__PURE__ */ new Set()), this.deps.add(t);
  }
  forgetDeps() {
    this.deps && (Mc(this.deps).forEach((t) => t.delete(this)), this.deps.clear(), ea.push(this.deps), this.deps = null);
  }
}
Ss.count = 0;
function mf(e) {
  const t = Cs.getValue();
  if (t)
    return e.parents.add(t), t.childValues.has(e) || t.childValues.set(e, []), Mr(e) ? Em(t, e) : wm(t, e), t;
}
function n5(e, t) {
  return Sm(e), Cs.withValue(e, i5, [e, t]), o5(e, t) && a5(e), bm(e.value);
}
function i5(e, t) {
  e.recomputing = !0;
  const { normalizeResult: r } = e;
  let n;
  r && e.value.length === 1 && (n = $m(e.value)), e.value.length = 0;
  try {
    if (e.value[0] = e.fn.apply(null, t), r && n && !gm(n, e.value))
      try {
        e.value[0] = r(e.value[0], n[0]);
      } catch {
      }
  } catch (i) {
    e.value[1] = i;
  }
  e.recomputing = !1;
}
function Mr(e) {
  return e.dirty || !!(e.dirtyChildren && e.dirtyChildren.size);
}
function a5(e) {
  e.dirty = !1, !Mr(e) && Dm(e);
}
function xm(e) {
  Lc(e, Em);
}
function Dm(e) {
  Lc(e, wm);
}
function Lc(e, t) {
  const r = e.parents.size;
  if (r) {
    const n = Mc(e.parents);
    for (let i = 0; i < r; ++i)
      t(n[i], e);
  }
}
function Em(e, t) {
  ei(e.childValues.has(t)), ei(Mr(t));
  const r = !Mr(e);
  if (!e.dirtyChildren)
    e.dirtyChildren = ea.pop() || /* @__PURE__ */ new Set();
  else if (e.dirtyChildren.has(t))
    return;
  e.dirtyChildren.add(t), r && xm(e);
}
function wm(e, t) {
  ei(e.childValues.has(t)), ei(!Mr(t));
  const r = e.childValues.get(t);
  r.length === 0 ? e.childValues.set(t, $m(t.value)) : gm(r, t.value) || e.setDirty(), Cm(e, t), !Mr(e) && Dm(e);
}
function Cm(e, t) {
  const r = e.dirtyChildren;
  r && (r.delete(t), r.size === 0 && (ea.length < r5 && ea.push(r), e.dirtyChildren = null));
}
function Sm(e) {
  e.childValues.size > 0 && e.childValues.forEach((t, r) => {
    km(e, r);
  }), e.forgetDeps(), ei(e.dirtyChildren === null);
}
function km(e, t) {
  t.parents.delete(e), e.childValues.delete(t), Cm(e, t);
}
function o5(e, t) {
  if (typeof e.subscribe == "function")
    try {
      Nc(e), e.unsubscribe = e.subscribe.apply(null, t);
    } catch {
      return e.setDirty(), !1;
    }
  return !0;
}
const s5 = {
  setDirty: !0,
  dispose: !0,
  forget: !0
  // Fully remove parent Entry from LRU cache and computation graph
};
function Tm(e) {
  const t = /* @__PURE__ */ new Map();
  function r(n) {
    const i = Cs.getValue();
    if (i) {
      let a = t.get(n);
      a || t.set(n, a = /* @__PURE__ */ new Set()), i.dependOn(a);
    }
  }
  return r.dirty = function(i, a) {
    const o = t.get(i);
    if (o) {
      const s = a && t5.call(s5, a) ? a : "setDirty";
      Mc(o).forEach((u) => u[s]()), t.delete(i), Nc(o);
    }
  }, r;
}
let vf;
function u5(...e) {
  return (vf || (vf = new Bc(typeof WeakMap == "function"))).lookupArray(e);
}
const hu = /* @__PURE__ */ new Set();
function ta(e, { max: t = Math.pow(2, 16), keyArgs: r, makeCacheKey: n = u5, normalizeResult: i, subscribe: a, cache: o = dl } = /* @__PURE__ */ Object.create(null)) {
  const s = typeof o == "function" ? new o(t, (f) => f.dispose()) : o, u = function() {
    const f = n.apply(null, r ? r.apply(null, arguments) : arguments);
    if (f === void 0)
      return e.apply(null, arguments);
    let h = s.get(f);
    h || (s.set(f, h = new Ss(e)), h.normalizeResult = i, h.subscribe = a, h.forget = () => s.delete(f));
    const p = h.recompute(Array.prototype.slice.call(arguments));
    return s.set(f, h), hu.add(s), Cs.hasValue() || (hu.forEach((v) => v.clean()), hu.clear()), p;
  };
  Object.defineProperty(u, "size", {
    get: () => s.size,
    configurable: !1,
    enumerable: !1
  }), Object.freeze(u.options = {
    max: t,
    keyArgs: r,
    makeCacheKey: n,
    normalizeResult: i,
    subscribe: a,
    cache: s
  });
  function l(f) {
    const h = f && s.get(f);
    h && h.setDirty();
  }
  u.dirtyKey = l, u.dirty = function() {
    l(n.apply(null, arguments));
  };
  function c(f) {
    const h = f && s.get(f);
    if (h)
      return h.peek();
  }
  u.peekKey = c, u.peek = function() {
    return c(n.apply(null, arguments));
  };
  function d(f) {
    return f ? s.delete(f) : !1;
  }
  return u.forgetKey = d, u.forget = function() {
    return d(n.apply(null, arguments));
  }, u.makeCacheKey = n, u.getKey = r ? function() {
    return n.apply(null, r.apply(null, arguments));
  } : n, Object.freeze(u);
}
function l5(e) {
  return e;
}
var Pm = (
  /** @class */
  function() {
    function e(t, r) {
      r === void 0 && (r = /* @__PURE__ */ Object.create(null)), this.resultCache = cm ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set(), this.transform = t, r.getCacheKey && (this.getCacheKey = r.getCacheKey), this.cached = r.cache !== !1, this.resetCache();
    }
    return e.prototype.getCacheKey = function(t) {
      return [t];
    }, e.identity = function() {
      return new e(l5, { cache: !1 });
    }, e.split = function(t, r, n) {
      return n === void 0 && (n = e.identity()), Object.assign(new e(
        function(i) {
          var a = t(i) ? r : n;
          return a.transformDocument(i);
        },
        // Reasonably assume both `left` and `right` transforms handle their own caching
        { cache: !1 }
      ), { left: r, right: n });
    }, e.prototype.resetCache = function() {
      var t = this;
      if (this.cached) {
        var r = new li(mn);
        this.performWork = ta(e.prototype.performWork.bind(this), {
          makeCacheKey: function(n) {
            var i = t.getCacheKey(n);
            if (i)
              return se(Array.isArray(i), 67), r.lookupArray(i);
          },
          max: Zt["documentTransform.cache"],
          cache: Po
        });
      }
    }, e.prototype.performWork = function(t) {
      return Ea(t), this.transform(t);
    }, e.prototype.transformDocument = function(t) {
      if (this.resultCache.has(t))
        return t;
      var r = this.performWork(t);
      return this.resultCache.add(r), r;
    }, e.prototype.concat = function(t) {
      var r = this;
      return Object.assign(new e(
        function(n) {
          return t.transformDocument(r.transformDocument(n));
        },
        // Reasonably assume both transforms handle their own caching
        { cache: !1 }
      ), {
        left: this,
        right: t
      });
    }, e;
  }()
), Li, ks = Object.assign(function(e) {
  var t = Li.get(e);
  return t || (t = nD(e), Li.set(e, t)), t;
}, {
  reset: function() {
    Li = new Oc(
      Zt.print || 2e3
      /* defaultCacheSizes.print */
    );
  }
});
ks.reset();
globalThis.__DEV__ !== !1 && Ic("print", function() {
  return Li ? Li.size : 0;
});
var qe = Array.isArray;
function Ft(e) {
  return Array.isArray(e) && e.length > 0;
}
var yf = {
  kind: ee.FIELD,
  name: {
    kind: ee.NAME,
    value: "__typename"
  }
};
function Am(e, t) {
  return !e || e.selectionSet.selections.every(function(r) {
    return r.kind === ee.FRAGMENT_SPREAD && Am(t[r.name.value], t);
  });
}
function c5(e) {
  return Am(wa(e) || WD(e), xs(ws(e))) ? null : e;
}
function d5(e) {
  var t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  return e.forEach(function(n) {
    n && (n.name ? t.set(n.name, n) : n.test && r.set(n.test, n));
  }), function(n) {
    var i = t.get(n.name.value);
    return !i && r.size && r.forEach(function(a, o) {
      o(n) && (i = a);
    }), i;
  };
}
function gf(e) {
  var t = /* @__PURE__ */ new Map();
  return function(n) {
    n === void 0 && (n = e);
    var i = t.get(n);
    return i || t.set(n, i = {
      // Variable and fragment spread names used directly within this
      // operation or fragment definition, as identified by key. These sets
      // will be populated during the first traversal of the document in
      // removeDirectivesFromDocument below.
      variables: /* @__PURE__ */ new Set(),
      fragmentSpreads: /* @__PURE__ */ new Set()
    }), i;
  };
}
function _m(e, t) {
  Ea(t);
  for (var r = gf(""), n = gf(""), i = function($) {
    for (var m = 0, b = void 0; m < $.length && (b = $[m]); ++m)
      if (!qe(b)) {
        if (b.kind === ee.OPERATION_DEFINITION)
          return r(b.name && b.name.value);
        if (b.kind === ee.FRAGMENT_DEFINITION)
          return n(b.name.value);
      }
    return globalThis.__DEV__ !== !1 && se.error(84), null;
  }, a = 0, o = t.definitions.length - 1; o >= 0; --o)
    t.definitions[o].kind === ee.OPERATION_DEFINITION && ++a;
  var s = d5(e), u = function($) {
    return Ft($) && $.map(s).some(function(m) {
      return m && m.remove;
    });
  }, l = /* @__PURE__ */ new Map(), c = !1, d = {
    enter: function($) {
      if (u($.directives))
        return c = !0, null;
    }
  }, f = pr(t, {
    // These two AST node types share the same implementation, defined above.
    Field: d,
    InlineFragment: d,
    VariableDefinition: {
      enter: function() {
        return !1;
      }
    },
    Variable: {
      enter: function($, m, b, D, S) {
        var T = i(S);
        T && T.variables.add($.name.value);
      }
    },
    FragmentSpread: {
      enter: function($, m, b, D, S) {
        if (u($.directives))
          return c = !0, null;
        var T = i(S);
        T && T.fragmentSpreads.add($.name.value);
      }
    },
    FragmentDefinition: {
      enter: function($, m, b, D) {
        l.set(JSON.stringify(D), $);
      },
      leave: function($, m, b, D) {
        var S = l.get(JSON.stringify(D));
        if ($ === S)
          return $;
        if (
          // This logic applies only if the document contains one or more
          // operations, since removing all fragments from a document containing
          // only fragments makes the document useless.
          a > 0 && $.selectionSet.selections.every(function(T) {
            return T.kind === ee.FIELD && T.name.value === "__typename";
          })
        )
          return n($.name.value).removed = !0, c = !0, null;
      }
    },
    Directive: {
      leave: function($) {
        if (s($))
          return c = !0, null;
      }
    }
  });
  if (!c)
    return t;
  var h = function($) {
    return $.transitiveVars || ($.transitiveVars = new Set($.variables), $.removed || $.fragmentSpreads.forEach(function(m) {
      h(n(m)).transitiveVars.forEach(function(b) {
        $.transitiveVars.add(b);
      });
    })), $;
  }, p = /* @__PURE__ */ new Set();
  f.definitions.forEach(function($) {
    $.kind === ee.OPERATION_DEFINITION ? h(r($.name && $.name.value)).fragmentSpreads.forEach(function(m) {
      p.add(m);
    }) : $.kind === ee.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment
    // definitions count as usages of their own fragment names. This heuristic
    // prevents accidentally removing all fragment definitions from the
    // document just because it contains no operations that use the fragments.
    a === 0 && !n($.name.value).removed && p.add($.name.value);
  }), p.forEach(function($) {
    h(n($)).fragmentSpreads.forEach(function(m) {
      p.add(m);
    });
  });
  var v = function($) {
    return !!// A fragment definition will be removed if there are no spreads that refer
    // to it, or the fragment was explicitly removed because it had no fields
    // other than __typename.
    (!p.has($) || n($).removed);
  }, g = {
    enter: function($) {
      if (v($.name.value))
        return null;
    }
  };
  return c5(pr(f, {
    // If the fragment is going to be removed, then leaving any dangling
    // FragmentSpread nodes with the same name would be a mistake.
    FragmentSpread: g,
    // This is where the fragment definition is actually removed.
    FragmentDefinition: g,
    OperationDefinition: {
      leave: function($) {
        if ($.variableDefinitions) {
          var m = h(
            // If an operation is anonymous, we use the empty string as its key.
            r($.name && $.name.value)
          ).transitiveVars;
          if (m.size < $.variableDefinitions.length)
            return B(B({}, $), { variableDefinitions: $.variableDefinitions.filter(function(b) {
              return m.has(b.variable.name.value);
            }) });
        }
      }
    }
  }));
}
var Vc = Object.assign(function(e) {
  return pr(e, {
    SelectionSet: {
      enter: function(t, r, n) {
        if (!(n && n.kind === ee.OPERATION_DEFINITION)) {
          var i = t.selections;
          if (i) {
            var a = i.some(function(s) {
              return Br(s) && (s.name.value === "__typename" || s.name.value.lastIndexOf("__", 0) === 0);
            });
            if (!a) {
              var o = n;
              if (!(Br(o) && o.directives && o.directives.some(function(s) {
                return s.name.value === "export";
              })))
                return B(B({}, t), { selections: Mt(Mt([], i, !0), [yf], !1) });
            }
          }
        }
      }
    }
  });
}, {
  added: function(e) {
    return e === yf;
  }
});
function f5(e) {
  var t = Ca(e), r = t.operation;
  if (r === "query")
    return e;
  var n = pr(e, {
    OperationDefinition: {
      enter: function(i) {
        return B(B({}, i), { operation: "query" });
      }
    }
  });
  return n;
}
function Fm(e) {
  Ea(e);
  var t = _m([
    {
      test: function(r) {
        return r.name.value === "client";
      },
      remove: !0
    }
  ], e);
  return t;
}
var h5 = Object.prototype.hasOwnProperty;
function bf() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  return Ts(e);
}
function Ts(e) {
  var t = e[0] || {}, r = e.length;
  if (r > 1)
    for (var n = new Nr(), i = 1; i < r; ++i)
      t = n.merge(t, e[i]);
  return t;
}
var p5 = function(e, t, r) {
  return this.merge(e[r], t[r]);
}, Nr = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = p5), this.reconciler = t, this.isObject = Ue, this.pastCopies = /* @__PURE__ */ new Set();
    }
    return e.prototype.merge = function(t, r) {
      for (var n = this, i = [], a = 2; a < arguments.length; a++)
        i[a - 2] = arguments[a];
      return Ue(r) && Ue(t) ? (Object.keys(r).forEach(function(o) {
        if (h5.call(t, o)) {
          var s = t[o];
          if (r[o] !== s) {
            var u = n.reconciler.apply(n, Mt([
              t,
              r,
              o
            ], i, !1));
            u !== s && (t = n.shallowCopyForMerge(t), t[o] = u);
          }
        } else
          t = n.shallowCopyForMerge(t), t[o] = r[o];
      }), t) : r;
    }, e.prototype.shallowCopyForMerge = function(t) {
      return Ue(t) && (this.pastCopies.has(t) || (Array.isArray(t) ? t = t.slice(0) : t = B({ __proto__: Object.getPrototypeOf(t) }, t), this.pastCopies.add(t))), t;
    }, e;
  }()
);
function m5(e, t) {
  var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r) return (r = r.call(e)).next.bind(r);
  if (Array.isArray(e) || (r = v5(e)) || t) {
    r && (e = r);
    var n = 0;
    return function() {
      return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function v5(e, t) {
  if (e) {
    if (typeof e == "string") return $f(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return $f(e, t);
  }
}
function $f(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++)
    n[r] = e[r];
  return n;
}
function xf(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function jc(e, t, r) {
  return t && xf(e.prototype, t), r && xf(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
var zc = function() {
  return typeof Symbol == "function";
}, Kc = function(e) {
  return zc() && !!Symbol[e];
}, Uc = function(e) {
  return Kc(e) ? Symbol[e] : "@@" + e;
};
zc() && !Kc("observable") && (Symbol.observable = Symbol("observable"));
var y5 = Uc("iterator"), yl = Uc("observable"), Om = Uc("species");
function Ao(e, t) {
  var r = e[t];
  if (r != null) {
    if (typeof r != "function") throw new TypeError(r + " is not a function");
    return r;
  }
}
function bi(e) {
  var t = e.constructor;
  return t !== void 0 && (t = t[Om], t === null && (t = void 0)), t !== void 0 ? t : Ce;
}
function g5(e) {
  return e instanceof Ce;
}
function ti(e) {
  ti.log ? ti.log(e) : setTimeout(function() {
    throw e;
  });
}
function po(e) {
  Promise.resolve().then(function() {
    try {
      e();
    } catch (t) {
      ti(t);
    }
  });
}
function Im(e) {
  var t = e._cleanup;
  if (t !== void 0 && (e._cleanup = void 0, !!t))
    try {
      if (typeof t == "function")
        t();
      else {
        var r = Ao(t, "unsubscribe");
        r && r.call(t);
      }
    } catch (n) {
      ti(n);
    }
}
function gl(e) {
  e._observer = void 0, e._queue = void 0, e._state = "closed";
}
function b5(e) {
  var t = e._queue;
  if (t) {
    e._queue = void 0, e._state = "ready";
    for (var r = 0; r < t.length && (Rm(e, t[r].type, t[r].value), e._state !== "closed"); ++r)
      ;
  }
}
function Rm(e, t, r) {
  e._state = "running";
  var n = e._observer;
  try {
    var i = Ao(n, t);
    switch (t) {
      case "next":
        i && i.call(n, r);
        break;
      case "error":
        if (gl(e), i) i.call(n, r);
        else throw r;
        break;
      case "complete":
        gl(e), i && i.call(n);
        break;
    }
  } catch (a) {
    ti(a);
  }
  e._state === "closed" ? Im(e) : e._state === "running" && (e._state = "ready");
}
function pu(e, t, r) {
  if (e._state !== "closed") {
    if (e._state === "buffering") {
      e._queue.push({
        type: t,
        value: r
      });
      return;
    }
    if (e._state !== "ready") {
      e._state = "buffering", e._queue = [{
        type: t,
        value: r
      }], po(function() {
        return b5(e);
      });
      return;
    }
    Rm(e, t, r);
  }
}
var $5 = /* @__PURE__ */ function() {
  function e(r, n) {
    this._cleanup = void 0, this._observer = r, this._queue = void 0, this._state = "initializing";
    var i = new x5(this);
    try {
      this._cleanup = n.call(void 0, i);
    } catch (a) {
      i.error(a);
    }
    this._state === "initializing" && (this._state = "ready");
  }
  var t = e.prototype;
  return t.unsubscribe = function() {
    this._state !== "closed" && (gl(this), Im(this));
  }, jc(e, [{
    key: "closed",
    get: function() {
      return this._state === "closed";
    }
  }]), e;
}(), x5 = /* @__PURE__ */ function() {
  function e(r) {
    this._subscription = r;
  }
  var t = e.prototype;
  return t.next = function(n) {
    pu(this._subscription, "next", n);
  }, t.error = function(n) {
    pu(this._subscription, "error", n);
  }, t.complete = function() {
    pu(this._subscription, "complete");
  }, jc(e, [{
    key: "closed",
    get: function() {
      return this._subscription._state === "closed";
    }
  }]), e;
}(), Ce = /* @__PURE__ */ function() {
  function e(r) {
    if (!(this instanceof e)) throw new TypeError("Observable cannot be called as a function");
    if (typeof r != "function") throw new TypeError("Observable initializer must be a function");
    this._subscriber = r;
  }
  var t = e.prototype;
  return t.subscribe = function(n) {
    return (typeof n != "object" || n === null) && (n = {
      next: n,
      error: arguments[1],
      complete: arguments[2]
    }), new $5(n, this._subscriber);
  }, t.forEach = function(n) {
    var i = this;
    return new Promise(function(a, o) {
      if (typeof n != "function") {
        o(new TypeError(n + " is not a function"));
        return;
      }
      function s() {
        u.unsubscribe(), a();
      }
      var u = i.subscribe({
        next: function(l) {
          try {
            n(l, s);
          } catch (c) {
            o(c), u.unsubscribe();
          }
        },
        error: o,
        complete: a
      });
    });
  }, t.map = function(n) {
    var i = this;
    if (typeof n != "function") throw new TypeError(n + " is not a function");
    var a = bi(this);
    return new a(function(o) {
      return i.subscribe({
        next: function(s) {
          try {
            s = n(s);
          } catch (u) {
            return o.error(u);
          }
          o.next(s);
        },
        error: function(s) {
          o.error(s);
        },
        complete: function() {
          o.complete();
        }
      });
    });
  }, t.filter = function(n) {
    var i = this;
    if (typeof n != "function") throw new TypeError(n + " is not a function");
    var a = bi(this);
    return new a(function(o) {
      return i.subscribe({
        next: function(s) {
          try {
            if (!n(s)) return;
          } catch (u) {
            return o.error(u);
          }
          o.next(s);
        },
        error: function(s) {
          o.error(s);
        },
        complete: function() {
          o.complete();
        }
      });
    });
  }, t.reduce = function(n) {
    var i = this;
    if (typeof n != "function") throw new TypeError(n + " is not a function");
    var a = bi(this), o = arguments.length > 1, s = !1, u = arguments[1], l = u;
    return new a(function(c) {
      return i.subscribe({
        next: function(d) {
          var f = !s;
          if (s = !0, !f || o)
            try {
              l = n(l, d);
            } catch (h) {
              return c.error(h);
            }
          else
            l = d;
        },
        error: function(d) {
          c.error(d);
        },
        complete: function() {
          if (!s && !o) return c.error(new TypeError("Cannot reduce an empty sequence"));
          c.next(l), c.complete();
        }
      });
    });
  }, t.concat = function() {
    for (var n = this, i = arguments.length, a = new Array(i), o = 0; o < i; o++)
      a[o] = arguments[o];
    var s = bi(this);
    return new s(function(u) {
      var l, c = 0;
      function d(f) {
        l = f.subscribe({
          next: function(h) {
            u.next(h);
          },
          error: function(h) {
            u.error(h);
          },
          complete: function() {
            c === a.length ? (l = void 0, u.complete()) : d(s.from(a[c++]));
          }
        });
      }
      return d(n), function() {
        l && (l.unsubscribe(), l = void 0);
      };
    });
  }, t.flatMap = function(n) {
    var i = this;
    if (typeof n != "function") throw new TypeError(n + " is not a function");
    var a = bi(this);
    return new a(function(o) {
      var s = [], u = i.subscribe({
        next: function(c) {
          if (n)
            try {
              c = n(c);
            } catch (f) {
              return o.error(f);
            }
          var d = a.from(c).subscribe({
            next: function(f) {
              o.next(f);
            },
            error: function(f) {
              o.error(f);
            },
            complete: function() {
              var f = s.indexOf(d);
              f >= 0 && s.splice(f, 1), l();
            }
          });
          s.push(d);
        },
        error: function(c) {
          o.error(c);
        },
        complete: function() {
          l();
        }
      });
      function l() {
        u.closed && s.length === 0 && o.complete();
      }
      return function() {
        s.forEach(function(c) {
          return c.unsubscribe();
        }), u.unsubscribe();
      };
    });
  }, t[yl] = function() {
    return this;
  }, e.from = function(n) {
    var i = typeof this == "function" ? this : e;
    if (n == null) throw new TypeError(n + " is not an object");
    var a = Ao(n, yl);
    if (a) {
      var o = a.call(n);
      if (Object(o) !== o) throw new TypeError(o + " is not an object");
      return g5(o) && o.constructor === i ? o : new i(function(s) {
        return o.subscribe(s);
      });
    }
    if (Kc("iterator") && (a = Ao(n, y5), a))
      return new i(function(s) {
        po(function() {
          if (!s.closed) {
            for (var u = m5(a.call(n)), l; !(l = u()).done; ) {
              var c = l.value;
              if (s.next(c), s.closed) return;
            }
            s.complete();
          }
        });
      });
    if (Array.isArray(n))
      return new i(function(s) {
        po(function() {
          if (!s.closed) {
            for (var u = 0; u < n.length; ++u)
              if (s.next(n[u]), s.closed) return;
            s.complete();
          }
        });
      });
    throw new TypeError(n + " is not observable");
  }, e.of = function() {
    for (var n = arguments.length, i = new Array(n), a = 0; a < n; a++)
      i[a] = arguments[a];
    var o = typeof this == "function" ? this : e;
    return new o(function(s) {
      po(function() {
        if (!s.closed) {
          for (var u = 0; u < i.length; ++u)
            if (s.next(i[u]), s.closed) return;
          s.complete();
        }
      });
    });
  }, jc(e, null, [{
    key: Om,
    get: function() {
      return this;
    }
  }]), e;
}();
zc() && Object.defineProperty(Ce, Symbol("extensions"), {
  value: {
    symbol: yl,
    hostReportError: ti
  },
  configurable: !0
});
function D5(e) {
  var t, r = e.Symbol;
  if (typeof r == "function")
    if (r.observable)
      t = r.observable;
    else {
      typeof r.for == "function" ? t = r.for("https://github.com/benlesh/symbol-observable") : t = r("https://github.com/benlesh/symbol-observable");
      try {
        r.observable = t;
      } catch {
      }
    }
  else
    t = "@@observable";
  return t;
}
var Sn;
typeof self < "u" ? Sn = self : typeof window < "u" ? Sn = window : typeof global < "u" ? Sn = global : typeof module < "u" ? Sn = module : Sn = Function("return this")();
D5(Sn);
var Df = Ce.prototype, Ef = "@@observable";
Df[Ef] || (Df[Ef] = function() {
  return this;
});
var E5 = Object.prototype.toString;
function Bm(e) {
  return bl(e);
}
function bl(e, t) {
  switch (E5.call(e)) {
    case "[object Array]": {
      if (t = t || /* @__PURE__ */ new Map(), t.has(e))
        return t.get(e);
      var r = e.slice(0);
      return t.set(e, r), r.forEach(function(i, a) {
        r[a] = bl(i, t);
      }), r;
    }
    case "[object Object]": {
      if (t = t || /* @__PURE__ */ new Map(), t.has(e))
        return t.get(e);
      var n = Object.create(Object.getPrototypeOf(e));
      return t.set(e, n), Object.keys(e).forEach(function(i) {
        n[i] = bl(e[i], t);
      }), n;
    }
    default:
      return e;
  }
}
function w5(e) {
  var t = /* @__PURE__ */ new Set([e]);
  return t.forEach(function(r) {
    Ue(r) && C5(r) === r && Object.getOwnPropertyNames(r).forEach(function(n) {
      Ue(r[n]) && t.add(r[n]);
    });
  }), e;
}
function C5(e) {
  if (globalThis.__DEV__ !== !1 && !Object.isFrozen(e))
    try {
      Object.freeze(e);
    } catch (t) {
      if (t instanceof TypeError)
        return null;
      throw t;
    }
  return e;
}
function ra(e) {
  return globalThis.__DEV__ !== !1 && w5(e), e;
}
function Vi(e, t, r) {
  var n = [];
  e.forEach(function(i) {
    return i[t] && n.push(i);
  }), n.forEach(function(i) {
    return i[t](r);
  });
}
function mu(e, t, r) {
  return new Ce(function(n) {
    var i = {
      // Normally we would initialize promiseQueue to Promise.resolve(), but
      // in this case, for backwards compatibility, we need to be careful to
      // invoke the first callback synchronously.
      then: function(u) {
        return new Promise(function(l) {
          return l(u());
        });
      }
    };
    function a(u, l) {
      return function(c) {
        if (u) {
          var d = function() {
            return n.closed ? (
              /* will be swallowed */
              0
            ) : u(c);
          };
          i = i.then(d, d).then(function(f) {
            return n.next(f);
          }, function(f) {
            return n.error(f);
          });
        } else
          n[l](c);
      };
    }
    var o = {
      next: a(t, "next"),
      error: a(r, "error"),
      complete: function() {
        i.then(function() {
          return n.complete();
        });
      }
    }, s = e.subscribe(o);
    return function() {
      return s.unsubscribe();
    };
  });
}
function Mm(e) {
  function t(r) {
    Object.defineProperty(e, r, { value: Ce });
  }
  return Fc && Symbol.species && t(Symbol.species), t("@@species"), e;
}
function wf(e) {
  return e && typeof e.then == "function";
}
var kn = (
  /** @class */
  function(e) {
    Vt(t, e);
    function t(r) {
      var n = e.call(this, function(i) {
        return n.addObserver(i), function() {
          return n.removeObserver(i);
        };
      }) || this;
      return n.observers = /* @__PURE__ */ new Set(), n.promise = new Promise(function(i, a) {
        n.resolve = i, n.reject = a;
      }), n.handlers = {
        next: function(i) {
          n.sub !== null && (n.latest = ["next", i], n.notify("next", i), Vi(n.observers, "next", i));
        },
        error: function(i) {
          var a = n.sub;
          a !== null && (a && setTimeout(function() {
            return a.unsubscribe();
          }), n.sub = null, n.latest = ["error", i], n.reject(i), n.notify("error", i), Vi(n.observers, "error", i));
        },
        complete: function() {
          var i = n, a = i.sub, o = i.sources, s = o === void 0 ? [] : o;
          if (a !== null) {
            var u = s.shift();
            u ? wf(u) ? u.then(function(l) {
              return n.sub = l.subscribe(n.handlers);
            }, n.handlers.error) : n.sub = u.subscribe(n.handlers) : (a && setTimeout(function() {
              return a.unsubscribe();
            }), n.sub = null, n.latest && n.latest[0] === "next" ? n.resolve(n.latest[1]) : n.resolve(), n.notify("complete"), Vi(n.observers, "complete"));
          }
        }
      }, n.nextResultListeners = /* @__PURE__ */ new Set(), n.cancel = function(i) {
        n.reject(i), n.sources = [], n.handlers.complete();
      }, n.promise.catch(function(i) {
      }), typeof r == "function" && (r = [new Ce(r)]), wf(r) ? r.then(function(i) {
        return n.start(i);
      }, n.handlers.error) : n.start(r), n;
    }
    return t.prototype.start = function(r) {
      this.sub === void 0 && (this.sources = Array.from(r), this.handlers.complete());
    }, t.prototype.deliverLastMessage = function(r) {
      if (this.latest) {
        var n = this.latest[0], i = r[n];
        i && i.call(r, this.latest[1]), this.sub === null && n === "next" && r.complete && r.complete();
      }
    }, t.prototype.addObserver = function(r) {
      this.observers.has(r) || (this.deliverLastMessage(r), this.observers.add(r));
    }, t.prototype.removeObserver = function(r) {
      this.observers.delete(r) && this.observers.size < 1 && this.handlers.complete();
    }, t.prototype.notify = function(r, n) {
      var i = this.nextResultListeners;
      i.size && (this.nextResultListeners = /* @__PURE__ */ new Set(), i.forEach(function(a) {
        return a(r, n);
      }));
    }, t.prototype.beforeNext = function(r) {
      var n = !1;
      this.nextResultListeners.add(function(i, a) {
        n || (n = !0, r(i, a));
      });
    }, t;
  }(Ce)
);
Mm(kn);
function jn(e) {
  return "incremental" in e;
}
function S5(e) {
  return "hasNext" in e && "data" in e;
}
function k5(e) {
  return jn(e) || S5(e);
}
function T5(e) {
  return Ue(e) && "payload" in e;
}
function Nm(e, t) {
  var r = e, n = new Nr();
  return jn(t) && Ft(t.incremental) && t.incremental.forEach(function(i) {
    for (var a = i.data, o = i.path, s = o.length - 1; s >= 0; --s) {
      var u = o[s], l = !isNaN(+u), c = l ? [] : {};
      c[u] = a, a = c;
    }
    r = n.merge(r, a);
  }), r;
}
function mo(e) {
  var t = $l(e);
  return Ft(t);
}
function $l(e) {
  var t = Ft(e.errors) ? e.errors.slice(0) : [];
  return jn(e) && Ft(e.incremental) && e.incremental.forEach(function(r) {
    r.errors && t.push.apply(t, r.errors);
  }), t;
}
function on() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var r = /* @__PURE__ */ Object.create(null);
  return e.forEach(function(n) {
    n && Object.keys(n).forEach(function(i) {
      var a = n[i];
      a !== void 0 && (r[i] = a);
    });
  }), r;
}
function ji(e, t) {
  return on(e, t, t.variables && {
    variables: on(B(B({}, e && e.variables), t.variables))
  });
}
function vu(e) {
  return new Ce(function(t) {
    t.error(e);
  });
}
var Lm = function(e, t, r) {
  var n = new Error(r);
  throw n.name = "ServerError", n.response = e, n.statusCode = e.status, n.result = t, n;
};
function P5(e) {
  for (var t = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ], r = 0, n = Object.keys(e); r < n.length; r++) {
    var i = n[r];
    if (t.indexOf(i) < 0)
      throw ht(43, i);
  }
  return e;
}
function A5(e, t) {
  var r = B({}, e), n = function(a) {
    typeof a == "function" ? r = B(B({}, r), a(r)) : r = B(B({}, r), a);
  }, i = function() {
    return B({}, r);
  };
  return Object.defineProperty(t, "setContext", {
    enumerable: !1,
    value: n
  }), Object.defineProperty(t, "getContext", {
    enumerable: !1,
    value: i
  }), t;
}
function _5(e) {
  var t = {
    variables: e.variables || {},
    extensions: e.extensions || {},
    operationName: e.operationName,
    query: e.query
  };
  return t.operationName || (t.operationName = typeof t.query != "string" ? vl(t.query) || void 0 : ""), t;
}
function F5(e, t) {
  var r = B({}, e), n = new Set(Object.keys(e));
  return pr(t, {
    Variable: function(i, a, o) {
      o && o.kind !== "VariableDefinition" && n.delete(i.name.value);
    }
  }), n.forEach(function(i) {
    delete r[i];
  }), r;
}
function Cf(e, t) {
  return t ? t(e) : Ce.of();
}
function $i(e) {
  return typeof e == "function" ? new jt(e) : e;
}
function Ga(e) {
  return e.request.length <= 1;
}
var jt = (
  /** @class */
  function() {
    function e(t) {
      t && (this.request = t);
    }
    return e.empty = function() {
      return new e(function() {
        return Ce.of();
      });
    }, e.from = function(t) {
      return t.length === 0 ? e.empty() : t.map($i).reduce(function(r, n) {
        return r.concat(n);
      });
    }, e.split = function(t, r, n) {
      var i = $i(r), a = $i(n || new e(Cf)), o;
      return Ga(i) && Ga(a) ? o = new e(function(s) {
        return t(s) ? i.request(s) || Ce.of() : a.request(s) || Ce.of();
      }) : o = new e(function(s, u) {
        return t(s) ? i.request(s, u) || Ce.of() : a.request(s, u) || Ce.of();
      }), Object.assign(o, { left: i, right: a });
    }, e.execute = function(t, r) {
      return t.request(A5(r.context, _5(P5(r)))) || Ce.of();
    }, e.concat = function(t, r) {
      var n = $i(t);
      if (Ga(n))
        return globalThis.__DEV__ !== !1 && se.warn(35, n), n;
      var i = $i(r), a;
      return Ga(i) ? a = new e(function(o) {
        return n.request(o, function(s) {
          return i.request(s) || Ce.of();
        }) || Ce.of();
      }) : a = new e(function(o, s) {
        return n.request(o, function(u) {
          return i.request(u, s) || Ce.of();
        }) || Ce.of();
      }), Object.assign(a, { left: n, right: i });
    }, e.prototype.split = function(t, r, n) {
      return this.concat(e.split(t, r, n || new e(Cf)));
    }, e.prototype.concat = function(t) {
      return e.concat(this, t);
    }, e.prototype.request = function(t, r) {
      throw ht(36);
    }, e.prototype.onError = function(t, r) {
      if (r && r.error)
        return r.error(t), !1;
      throw t;
    }, e.prototype.setOnError = function(t) {
      return this.onError = t, this;
    }, e;
  }()
), O5 = function() {
  if (typeof AbortController > "u")
    return { controller: !1, signal: !1 };
  var e = new AbortController(), t = e.signal;
  return { controller: e, signal: t };
};
function I5(e) {
  var t, r = e[Symbol.asyncIterator]();
  return t = {
    next: function() {
      return r.next();
    }
  }, t[Symbol.asyncIterator] = function() {
    return this;
  }, t;
}
function R5(e) {
  var t = null, r = null, n = !1, i = [], a = [];
  function o(d) {
    if (!r) {
      if (a.length) {
        var f = a.shift();
        if (Array.isArray(f) && f[0])
          return f[0]({ value: d, done: !1 });
      }
      i.push(d);
    }
  }
  function s(d) {
    r = d;
    var f = a.slice();
    f.forEach(function(h) {
      h[1](d);
    }), !t || t();
  }
  function u() {
    n = !0;
    var d = a.slice();
    d.forEach(function(f) {
      f[0]({ value: void 0, done: !0 });
    }), !t || t();
  }
  t = function() {
    t = null, e.removeListener("data", o), e.removeListener("error", s), e.removeListener("end", u), e.removeListener("finish", u), e.removeListener("close", u);
  }, e.on("data", o), e.on("error", s), e.on("end", u), e.on("finish", u), e.on("close", u);
  function l() {
    return new Promise(function(d, f) {
      if (r)
        return f(r);
      if (i.length)
        return d({ value: i.shift(), done: !1 });
      if (n)
        return d({ value: void 0, done: !0 });
      a.push([d, f]);
    });
  }
  var c = {
    next: function() {
      return l();
    }
  };
  return $s && (c[Symbol.asyncIterator] = function() {
    return this;
  }), c;
}
function B5(e) {
  var t = !1, r = {
    next: function() {
      return t ? Promise.resolve({
        value: void 0,
        done: !0
      }) : (t = !0, new Promise(function(n, i) {
        e.then(function(a) {
          n({ value: a, done: !1 });
        }).catch(i);
      }));
    }
  };
  return $s && (r[Symbol.asyncIterator] = function() {
    return this;
  }), r;
}
function Sf(e) {
  var t = {
    next: function() {
      return e.read();
    }
  };
  return $s && (t[Symbol.asyncIterator] = function() {
    return this;
  }), t;
}
function M5(e) {
  return !!e.body;
}
function N5(e) {
  return !!e.getReader;
}
function L5(e) {
  return !!($s && e[Symbol.asyncIterator]);
}
function V5(e) {
  return !!e.stream;
}
function j5(e) {
  return !!e.arrayBuffer;
}
function z5(e) {
  return !!e.pipe;
}
function K5(e) {
  var t = e;
  if (M5(e) && (t = e.body), L5(t))
    return I5(t);
  if (N5(t))
    return Sf(t.getReader());
  if (V5(t))
    return Sf(t.stream().getReader());
  if (j5(t))
    return B5(t.arrayBuffer());
  if (z5(t))
    return R5(t);
  throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
}
var qc = Symbol();
function U5(e) {
  return e.extensions ? Array.isArray(e.extensions[qc]) : !1;
}
function q5(e) {
  return e.hasOwnProperty("graphQLErrors");
}
var H5 = function(e) {
  var t = Mt(Mt(Mt([], e.graphQLErrors, !0), e.clientErrors, !0), e.protocolErrors, !0);
  return e.networkError && t.push(e.networkError), t.map(function(r) {
    return Ue(r) && r.message || "Error message not found.";
  }).join(`
`);
}, or = (
  /** @class */
  function(e) {
    Vt(t, e);
    function t(r) {
      var n = r.graphQLErrors, i = r.protocolErrors, a = r.clientErrors, o = r.networkError, s = r.errorMessage, u = r.extraInfo, l = e.call(this, s) || this;
      return l.name = "ApolloError", l.graphQLErrors = n || [], l.protocolErrors = i || [], l.clientErrors = a || [], l.networkError = o || null, l.message = s || H5(l), l.extraInfo = u, l.__proto__ = t.prototype, l;
    }
    return t;
  }(Error)
), kf = Object.prototype.hasOwnProperty;
function W5(e, t) {
  return kr(this, void 0, void 0, function() {
    var r, n, i, a, o, s, u, l, c, d, f, h, p, v, g, $, m, b, D, S, T, R, y, A;
    return Tr(this, function(w) {
      switch (w.label) {
        case 0:
          if (TextDecoder === void 0)
            throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
          r = new TextDecoder("utf-8"), n = (A = e.headers) === null || A === void 0 ? void 0 : A.get("content-type"), i = "boundary=", a = n != null && n.includes(i) ? n == null ? void 0 : n.substring((n == null ? void 0 : n.indexOf(i)) + i.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-", o = `\r
--`.concat(a), s = "", u = K5(e), l = !0, w.label = 1;
        case 1:
          return l ? [4, u.next()] : [3, 3];
        case 2:
          for (c = w.sent(), d = c.value, f = c.done, h = typeof d == "string" ? d : r.decode(d), p = s.length - o.length + 1, l = !f, s += h, v = s.indexOf(o, p); v > -1; ) {
            if (g = void 0, R = [
              s.slice(0, v),
              s.slice(v + o.length)
            ], g = R[0], s = R[1], $ = g.indexOf(`\r
\r
`), m = Q5(g.slice(0, $)), b = m["content-type"], b && b.toLowerCase().indexOf("application/json") === -1)
              throw new Error("Unsupported patch content type: application/json is required.");
            if (D = g.slice($), D) {
              if (S = Vm(e, D), Object.keys(S).length > 1 || "data" in S || "incremental" in S || "errors" in S || "payload" in S)
                if (T5(S)) {
                  if (T = {}, "payload" in S) {
                    if (Object.keys(S).length === 1 && S.payload === null)
                      return [
                        2
                        /*return*/
                      ];
                    T = B({}, S.payload);
                  }
                  "errors" in S && (T = B(B({}, T), { extensions: B(B({}, "extensions" in T ? T.extensions : null), (y = {}, y[qc] = S.errors, y)) })), t(T);
                } else
                  t(S);
              else if (
                // If the chunk contains only a "hasNext: false", we can call
                // observer.complete() immediately.
                Object.keys(S).length === 1 && "hasNext" in S && !S.hasNext
              )
                return [
                  2
                  /*return*/
                ];
            }
            v = s.indexOf(o);
          }
          return [3, 1];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Q5(e) {
  var t = {};
  return e.split(`
`).forEach(function(r) {
    var n = r.indexOf(":");
    if (n > -1) {
      var i = r.slice(0, n).trim().toLowerCase(), a = r.slice(n + 1).trim();
      t[i] = a;
    }
  }), t;
}
function Vm(e, t) {
  if (e.status >= 300) {
    var r = function() {
      try {
        return JSON.parse(t);
      } catch {
        return t;
      }
    };
    Lm(e, r(), "Response not successful: Received status code ".concat(e.status));
  }
  try {
    return JSON.parse(t);
  } catch (i) {
    var n = i;
    throw n.name = "ServerParseError", n.response = e, n.statusCode = e.status, n.bodyText = t, n;
  }
}
function G5(e, t) {
  e.result && e.result.errors && e.result.data && t.next(e.result), t.error(e);
}
function jm(e) {
  return function(t) {
    return t.text().then(function(r) {
      return Vm(t, r);
    }).then(function(r) {
      return !Array.isArray(r) && !kf.call(r, "data") && !kf.call(r, "errors") && Lm(t, r, "Server response was missing for query '".concat(Array.isArray(e) ? e.map(function(n) {
        return n.operationName;
      }) : e.operationName, "'.")), r;
    });
  };
}
var na = function(e, t) {
  var r;
  try {
    r = JSON.stringify(e);
  } catch (i) {
    var n = ht(39, t, i.message);
    throw n.parseError = i, n;
  }
  return r;
};
function zm(e, t) {
  var r = [], n = function(d, f) {
    r.push("".concat(d, "=").concat(encodeURIComponent(f)));
  };
  if ("query" in t && n("query", t.query), t.operationName && n("operationName", t.operationName), t.variables) {
    var i = void 0;
    try {
      i = na(t.variables, "Variables map");
    } catch (d) {
      return { parseError: d };
    }
    n("variables", i);
  }
  if (t.extensions) {
    var a = void 0;
    try {
      a = na(t.extensions, "Extensions map");
    } catch (d) {
      return { parseError: d };
    }
    n("extensions", a);
  }
  var o = "", s = e, u = e.indexOf("#");
  u !== -1 && (o = e.substr(u), s = e.substr(0, u));
  var l = s.indexOf("?") === -1 ? "?" : "&", c = s + l + r.join("&") + o;
  return { newURI: c };
}
var Z5 = {
  includeQuery: !0,
  includeExtensions: !1,
  preserveHeaderCase: !1
}, Y5 = {
  // headers are case insensitive (https://stackoverflow.com/a/5259004)
  accept: "*/*",
  // The content-type header describes the type of the body of the request, and
  // so it typically only is sent with requests that actually have bodies. One
  // could imagine that Apollo Client would remove this header when constructing
  // a GET request (which has no body), but we historically have not done that.
  // This means that browsers will preflight all Apollo Client requests (even
  // GET requests). Apollo Server's CSRF prevention feature (introduced in
  // AS3.7) takes advantage of this fact and does not block requests with this
  // header. If you want to drop this header from GET requests, then you should
  // probably replace it with a `apollo-require-preflight` header, or servers
  // with CSRF prevention enabled might block your GET request. See
  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf
  // for more details.
  "content-type": "application/json"
}, J5 = {
  method: "POST"
}, Km = {
  http: Z5,
  headers: Y5,
  options: J5
}, Um = function(e, t) {
  return t(e);
};
function qm(e, t) {
  for (var r = [], n = 2; n < arguments.length; n++)
    r[n - 2] = arguments[n];
  var i = {}, a = {};
  r.forEach(function(d) {
    i = B(B(B({}, i), d.options), { headers: B(B({}, i.headers), d.headers) }), d.credentials && (i.credentials = d.credentials), a = B(B({}, a), d.http);
  }), i.headers && (i.headers = X5(i.headers, a.preserveHeaderCase));
  var o = e.operationName, s = e.extensions, u = e.variables, l = e.query, c = { operationName: o, variables: u };
  return a.includeExtensions && (c.extensions = s), a.includeQuery && (c.query = t(l, ks)), {
    options: i,
    body: c
  };
}
function X5(e, t) {
  if (!t) {
    var r = /* @__PURE__ */ Object.create(null);
    return Object.keys(Object(e)).forEach(function(a) {
      r[a.toLowerCase()] = e[a];
    }), r;
  }
  var n = /* @__PURE__ */ Object.create(null);
  Object.keys(Object(e)).forEach(function(a) {
    n[a.toLowerCase()] = {
      originalName: a,
      value: e[a]
    };
  });
  var i = /* @__PURE__ */ Object.create(null);
  return Object.keys(n).forEach(function(a) {
    i[n[a].originalName] = n[a].value;
  }), i;
}
var Hm = function(e, t) {
  var r = e.getContext(), n = r.uri;
  return n || (typeof t == "function" ? t(e) : t || "/graphql");
};
function e2(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function t2(e, t, r = "") {
  if (!arguments.length) throw new TypeError("Argument 1 `value` is required.");
  if (typeof t != "function")
    throw new TypeError("Argument 2 `isExtractable` must be a function.");
  if (typeof r != "string")
    throw new TypeError("Argument 3 `path` must be a string.");
  const n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  function a(o, s, u) {
    if (t(o)) {
      const d = i.get(o);
      return d ? d.push(s) : i.set(o, [s]), null;
    }
    const l = Array.isArray(o) || typeof FileList < "u" && o instanceof FileList, c = e2(o);
    if (l || c) {
      let d = n.get(o);
      const f = !d;
      if (f && (d = l ? [] : (
        // Replicate if the plain object is an `Object` instance.
        o instanceof /** @type {any} */
        Object ? {} : /* @__PURE__ */ Object.create(null)
      ), n.set(
        o,
        /** @type {Clone} */
        d
      )), !u.has(o)) {
        const h = s ? `${s}.` : "", p = new Set(u).add(o);
        if (l) {
          let v = 0;
          for (const g of o) {
            const $ = a(
              g,
              h + v++,
              p
            );
            f && d.push($);
          }
        } else
          for (const v in o) {
            const g = a(
              o[v],
              h + v,
              p
            );
            f && (d[v] = g);
          }
      }
      return d;
    }
    return o;
  }
  return {
    clone: a(e, r, /* @__PURE__ */ new Set()),
    files: i
  };
}
function r2(e, t, r) {
  "name" in r ? e.append(t, r, r.name) : e.append(t, r);
}
function n2(e) {
  return typeof File < "u" && e instanceof File || typeof Blob < "u" && e instanceof Blob;
}
function Wm({
  uri: e = "/graphql",
  useGETForQueries: t,
  isExtractableFile: r = n2,
  FormData: n,
  formDataAppendFile: i = r2,
  print: a = Um,
  fetch: o,
  fetchOptions: s,
  credentials: u,
  headers: l,
  includeExtensions: c
} = {}) {
  const d = {
    http: { includeExtensions: c },
    options: s,
    credentials: u,
    headers: l
  };
  return new jt((f) => {
    const h = (
      /**
       * @type {import("@apollo/client/core/types.js").DefaultContext & {
       *   clientAwareness?: {
       *     name?: string,
       *     version?: string,
       *   },
       * }}
       */
      f.getContext()
    ), {
      // Apollo Studio client awareness `name` and `version` can be configured
      // via `ApolloClient` constructor options:
      // https://www.apollographql.com/docs/graphos/metrics/client-awareness/#setup
      clientAwareness: { name: p, version: v } = {},
      headers: g
    } = h, $ = {
      http: h.http,
      options: h.fetchOptions,
      credentials: h.credentials,
      headers: {
        // Client awareness headers can be overridden by context `headers`.
        ...p && { "apollographql-client-name": p },
        ...v && { "apollographql-client-version": v },
        ...g
      }
    }, { options: m, body: b } = qm(
      f,
      a,
      Km,
      d,
      $
    ), { clone: D, files: S } = t2(b, r, "");
    let T = Hm(f, e);
    if (S.size) {
      m.headers && delete m.headers["content-type"];
      const A = n || FormData, w = new A();
      w.append("operations", na(D, "Payload"));
      const E = {};
      let k = 0;
      S.forEach((C) => {
        E[++k] = C;
      }), w.append("map", JSON.stringify(E)), k = 0, S.forEach((C, P) => {
        i(w, String(++k), P);
      }), m.body = w;
    } else if (t && // If the operation contains some mutations GET shouldn’t be used.
    !f.query.definitions.some(
      (A) => A.kind === "OperationDefinition" && A.operation === "mutation"
    ) && (m.method = "GET"), m.method === "GET") {
      const { newURI: A, parseError: w } = zm(T, b);
      if (w)
        return new Ce((E) => {
          E.error(w);
        });
      T = A;
    } else m.body = na(D, "Payload");
    const { controller: R } = O5();
    typeof R != "boolean" && (m.signal && (m.signal.aborted ? (
      // Signal already aborted, so immediately abort.
      R.abort()
    ) : (
      // Signal not already aborted, so setup a listener to abort when it
      // does.
      m.signal.addEventListener(
        "abort",
        () => {
          R.abort();
        },
        {
          // Prevent a memory leak if the user configured abort controller
          // is long lasting, or controls multiple things.
          once: !0
        }
      )
    )), m.signal = R.signal);
    const y = o || fetch;
    return new Ce((A) => {
      let w;
      return y(T, m).then((E) => (f.setContext({ response: E }), E)).then(jm(f)).then((E) => {
        A.next(E), A.complete();
      }).catch((E) => {
        w || (E.result && E.result.errors && E.result.data && A.next(E.result), A.error(E));
      }), () => {
        w = !0, typeof R != "boolean" && R.abort();
      };
    });
  });
}
var xl = jt.execute, i2 = function(e) {
  if (!e && typeof fetch > "u")
    throw ht(37);
}, Tf = Rt(function() {
  return fetch;
}), a2 = function(e) {
  e === void 0 && (e = {});
  var t = e.uri, r = t === void 0 ? "/graphql" : t, n = e.fetch, i = e.print, a = i === void 0 ? Um : i, o = e.includeExtensions, s = e.preserveHeaderCase, u = e.useGETForQueries, l = e.includeUnusedVariables, c = l === void 0 ? !1 : l, d = Nt(e, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
  globalThis.__DEV__ !== !1 && i2(n || Tf);
  var f = {
    http: { includeExtensions: o, preserveHeaderCase: s },
    options: d.fetchOptions,
    credentials: d.credentials,
    headers: d.headers
  };
  return new jt(function(h) {
    var p = Hm(h, r), v = h.getContext(), g = {};
    if (v.clientAwareness) {
      var $ = v.clientAwareness, m = $.name, b = $.version;
      m && (g["apollographql-client-name"] = m), b && (g["apollographql-client-version"] = b);
    }
    var D = B(B({}, g), v.headers), S = {
      http: v.http,
      options: v.fetchOptions,
      credentials: v.credentials,
      headers: D
    };
    if (Xi(["client"], h.query)) {
      var T = Fm(h.query);
      if (!T)
        return vu(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
      h.query = T;
    }
    var R = qm(h, a, Km, f, S), y = R.options, A = R.body;
    A.variables && !c && (A.variables = F5(A.variables, h.query));
    var w;
    !y.signal && typeof AbortController < "u" && (w = new AbortController(), y.signal = w.signal);
    var E = function(K) {
      return K.kind === "OperationDefinition" && K.operation === "mutation";
    }, k = function(K) {
      return K.kind === "OperationDefinition" && K.operation === "subscription";
    }, C = k(Ca(h.query)), P = Xi(["defer"], h.query);
    if (u && !h.query.definitions.some(E) && (y.method = "GET"), P || C) {
      y.headers = y.headers || {};
      var L = "multipart/mixed;";
      C && P && globalThis.__DEV__ !== !1 && se.warn(38), C ? L += "boundary=graphql;subscriptionSpec=1.0,application/json" : P && (L += "deferSpec=20220824,application/json"), y.headers.accept = L;
    }
    if (y.method === "GET") {
      var O = zm(p, A), x = O.newURI, U = O.parseError;
      if (U)
        return vu(U);
      p = x;
    } else
      try {
        y.body = na(A, "Payload");
      } catch (K) {
        return vu(K);
      }
    return new Ce(function(K) {
      var j = n || Rt(function() {
        return fetch;
      }) || Tf, ae = K.next.bind(K);
      return j(p, y).then(function(ne) {
        var me;
        h.setContext({ response: ne });
        var $e = (me = ne.headers) === null || me === void 0 ? void 0 : me.get("content-type");
        return $e !== null && /^multipart\/mixed/i.test($e) ? W5(ne, ae) : jm(h)(ne).then(ae);
      }).then(function() {
        w = void 0, K.complete();
      }).catch(function(ne) {
        w = void 0, G5(ne, K);
      }), function() {
        w && w.abort();
      };
    });
  });
}, o2 = (
  /** @class */
  function(e) {
    Vt(t, e);
    function t(r) {
      r === void 0 && (r = {});
      var n = e.call(this, a2(r).request) || this;
      return n.options = r, n;
    }
    return t;
  }(jt)
);
const { toString: Pf, hasOwnProperty: s2 } = Object.prototype, Af = Function.prototype.toString, Dl = /* @__PURE__ */ new Map();
function Te(e, t) {
  try {
    return El(e, t);
  } finally {
    Dl.clear();
  }
}
function El(e, t) {
  if (e === t)
    return !0;
  const r = Pf.call(e), n = Pf.call(t);
  if (r !== n)
    return !1;
  switch (r) {
    case "[object Array]":
      if (e.length !== t.length)
        return !1;
    case "[object Object]": {
      if (Ff(e, t))
        return !0;
      const i = _f(e), a = _f(t), o = i.length;
      if (o !== a.length)
        return !1;
      for (let s = 0; s < o; ++s)
        if (!s2.call(t, i[s]))
          return !1;
      for (let s = 0; s < o; ++s) {
        const u = i[s];
        if (!El(e[u], t[u]))
          return !1;
      }
      return !0;
    }
    case "[object Error]":
      return e.name === t.name && e.message === t.message;
    case "[object Number]":
      if (e !== e)
        return t !== t;
    case "[object Boolean]":
    case "[object Date]":
      return +e == +t;
    case "[object RegExp]":
    case "[object String]":
      return e == `${t}`;
    case "[object Map]":
    case "[object Set]": {
      if (e.size !== t.size)
        return !1;
      if (Ff(e, t))
        return !0;
      const i = e.entries(), a = r === "[object Map]";
      for (; ; ) {
        const o = i.next();
        if (o.done)
          break;
        const [s, u] = o.value;
        if (!t.has(s) || a && !El(u, t.get(s)))
          return !1;
      }
      return !0;
    }
    case "[object Uint16Array]":
    case "[object Uint8Array]":
    case "[object Uint32Array]":
    case "[object Int32Array]":
    case "[object Int8Array]":
    case "[object Int16Array]":
    case "[object ArrayBuffer]":
      e = new Uint8Array(e), t = new Uint8Array(t);
    case "[object DataView]": {
      let i = e.byteLength;
      if (i === t.byteLength)
        for (; i-- && e[i] === t[i]; )
          ;
      return i === -1;
    }
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
    case "[object Function]": {
      const i = Af.call(e);
      return i !== Af.call(t) ? !1 : !c2(i, l2);
    }
  }
  return !1;
}
function _f(e) {
  return Object.keys(e).filter(u2, e);
}
function u2(e) {
  return this[e] !== void 0;
}
const l2 = "{ [native code] }";
function c2(e, t) {
  const r = e.length - t.length;
  return r >= 0 && e.indexOf(t, r) === r;
}
function Ff(e, t) {
  let r = Dl.get(e);
  if (r) {
    if (r.has(t))
      return !0;
  } else
    Dl.set(e, r = /* @__PURE__ */ new Set());
  return r.add(t), !1;
}
function Qm(e, t, r, n) {
  var i = t.data, a = Nt(t, ["data"]), o = r.data, s = Nt(r, ["data"]);
  return Te(a, s) && vo(Ca(e).selectionSet, i, o, {
    fragmentMap: xs(ws(e)),
    variables: n
  });
}
function vo(e, t, r, n) {
  if (t === r)
    return !0;
  var i = /* @__PURE__ */ new Set();
  return e.selections.every(function(a) {
    if (i.has(a) || (i.add(a), !Da(a, n.variables)) || Of(a))
      return !0;
    if (Br(a)) {
      var o = Rr(a), s = t && t[o], u = r && r[o], l = a.selectionSet;
      if (!l)
        return Te(s, u);
      var c = Array.isArray(s), d = Array.isArray(u);
      if (c !== d)
        return !1;
      if (c && d) {
        var f = s.length;
        if (u.length !== f)
          return !1;
        for (var h = 0; h < f; ++h)
          if (!vo(l, s[h], u[h], n))
            return !1;
        return !0;
      }
      return vo(l, s, u, n);
    } else {
      var p = Ds(a, n.fragmentMap);
      if (p)
        return Of(p) ? !0 : vo(
          p.selectionSet,
          // Notice that we reuse the same aResult and bResult values here,
          // since the fragment ...spread does not specify a field name, but
          // consists of multiple fields (within the fragment's selection set)
          // that should be applied to the current result value(s).
          t,
          r,
          n
        );
    }
  });
}
function Of(e) {
  return !!e.directives && e.directives.some(d2);
}
function d2(e) {
  return e.name.value === "nonreactive";
}
var Gm = (
  /** @class */
  function() {
    function e() {
      this.assumeImmutableResults = !1, this.getFragmentDoc = ta(vD, {
        max: Zt["cache.fragmentQueryDocuments"] || 1e3,
        cache: Po
      });
    }
    return e.prototype.batch = function(t) {
      var r = this, n = typeof t.optimistic == "string" ? t.optimistic : t.optimistic === !1 ? null : void 0, i;
      return this.performTransaction(function() {
        return i = t.update(r);
      }, n), i;
    }, e.prototype.recordOptimisticTransaction = function(t, r) {
      this.performTransaction(t, r);
    }, e.prototype.transformDocument = function(t) {
      return t;
    }, e.prototype.transformForLink = function(t) {
      return t;
    }, e.prototype.identify = function(t) {
    }, e.prototype.gc = function() {
      return [];
    }, e.prototype.modify = function(t) {
      return !1;
    }, e.prototype.readQuery = function(t, r) {
      return r === void 0 && (r = !!t.optimistic), this.read(B(B({}, t), { rootId: t.id || "ROOT_QUERY", optimistic: r }));
    }, e.prototype.watchFragment = function(t) {
      var r = this, n = t.fragment, i = t.fragmentName, a = t.from, o = t.optimistic, s = o === void 0 ? !0 : o, u = this.getFragmentDoc(n, i), l = {
        returnPartialData: !0,
        id: typeof a == "string" ? a : this.identify(a),
        query: u,
        optimistic: s
      }, c;
      return new Ce(function(d) {
        return r.watch(B(B({}, l), { immediate: !0, callback: function(f) {
          if (
            // Always ensure we deliver the first result
            !(c && Qm(u, { data: c == null ? void 0 : c.result }, { data: f.result }))
          ) {
            var h = {
              data: f.result,
              complete: !!f.complete
            };
            f.missing && (h.missing = Ts(f.missing.map(function(p) {
              return p.missing;
            }))), c = f, d.next(h);
          }
        } }));
      });
    }, e.prototype.readFragment = function(t, r) {
      return r === void 0 && (r = !!t.optimistic), this.read(B(B({}, t), { query: this.getFragmentDoc(t.fragment, t.fragmentName), rootId: t.id, optimistic: r }));
    }, e.prototype.writeQuery = function(t) {
      var r = t.id, n = t.data, i = Nt(t, ["id", "data"]);
      return this.write(Object.assign(i, {
        dataId: r || "ROOT_QUERY",
        result: n
      }));
    }, e.prototype.writeFragment = function(t) {
      var r = t.id, n = t.data, i = t.fragment, a = t.fragmentName, o = Nt(t, ["id", "data", "fragment", "fragmentName"]);
      return this.write(Object.assign(o, {
        query: this.getFragmentDoc(i, a),
        dataId: r,
        result: n
      }));
    }, e.prototype.updateQuery = function(t, r) {
      return this.batch({
        update: function(n) {
          var i = n.readQuery(t), a = r(i);
          return a == null ? i : (n.writeQuery(B(B({}, t), { data: a })), a);
        }
      });
    }, e.prototype.updateFragment = function(t, r) {
      return this.batch({
        update: function(n) {
          var i = n.readFragment(t), a = r(i);
          return a == null ? i : (n.writeFragment(B(B({}, t), { data: a })), a);
        }
      });
    }, e;
  }()
);
globalThis.__DEV__ !== !1 && (Gm.prototype.getMemoryInternals = kD);
var Zm = (
  /** @class */
  function(e) {
    Vt(t, e);
    function t(r, n, i, a) {
      var o, s = e.call(this, r) || this;
      if (s.message = r, s.path = n, s.query = i, s.variables = a, Array.isArray(s.path)) {
        s.missing = s.message;
        for (var u = s.path.length - 1; u >= 0; --u)
          s.missing = (o = {}, o[s.path[u]] = s.missing, o);
      } else
        s.missing = s.path;
      return s.__proto__ = t.prototype, s;
    }
    return t;
  }(Error)
), nt = Object.prototype.hasOwnProperty;
function xi(e) {
  return e == null;
}
function Ym(e, t) {
  var r = e.__typename, n = e.id, i = e._id;
  if (typeof r == "string" && (t && (t.keyObject = xi(n) ? xi(i) ? void 0 : { _id: i } : { id: n }), xi(n) && !xi(i) && (n = i), !xi(n)))
    return "".concat(r, ":").concat(typeof n == "number" || typeof n == "string" ? n : JSON.stringify(n));
}
var Jm = {
  dataIdFromObject: Ym,
  addTypename: !0,
  resultCaching: !0,
  // Thanks to the shouldCanonizeResults helper, this should be the only line
  // you have to change to reenable canonization by default in the future.
  canonizeResults: !1
};
function f2(e) {
  return on(Jm, e);
}
function Xm(e) {
  var t = e.canonizeResults;
  return t === void 0 ? Jm.canonizeResults : t;
}
function h2(e, t) {
  return Pe(t) ? e.get(t.__ref, "__typename") : t && t.__typename;
}
var ev = /^[_a-z][_0-9a-z]*/i;
function Lr(e) {
  var t = e.match(ev);
  return t ? t[0] : e;
}
function wl(e, t, r) {
  return Ue(t) ? qe(t) ? t.every(function(n) {
    return wl(e, n, r);
  }) : e.selections.every(function(n) {
    if (Br(n) && Da(n, r)) {
      var i = Rr(n);
      return nt.call(t, i) && (!n.selectionSet || wl(n.selectionSet, t[i], r));
    }
    return !0;
  }) : !1;
}
function On(e) {
  return Ue(e) && !Pe(e) && !qe(e);
}
function p2() {
  return new Nr();
}
function tv(e, t) {
  var r = xs(ws(e));
  return {
    fragmentMap: r,
    lookupFragment: function(n) {
      var i = r[n];
      return !i && t && (i = t.lookup(n)), i || null;
    }
  };
}
var yo = /* @__PURE__ */ Object.create(null), yu = function() {
  return yo;
}, If = /* @__PURE__ */ Object.create(null), ia = (
  /** @class */
  function() {
    function e(t, r) {
      var n = this;
      this.policies = t, this.group = r, this.data = /* @__PURE__ */ Object.create(null), this.rootIds = /* @__PURE__ */ Object.create(null), this.refs = /* @__PURE__ */ Object.create(null), this.getFieldValue = function(i, a) {
        return ra(Pe(i) ? n.get(i.__ref, a) : i && i[a]);
      }, this.canRead = function(i) {
        return Pe(i) ? n.has(i.__ref) : typeof i == "object";
      }, this.toReference = function(i, a) {
        if (typeof i == "string")
          return Vn(i);
        if (Pe(i))
          return i;
        var o = n.policies.identify(i)[0];
        if (o) {
          var s = Vn(o);
          return a && n.merge(o, i), s;
        }
      };
    }
    return e.prototype.toObject = function() {
      return B({}, this.data);
    }, e.prototype.has = function(t) {
      return this.lookup(t, !0) !== void 0;
    }, e.prototype.get = function(t, r) {
      if (this.group.depend(t, r), nt.call(this.data, t)) {
        var n = this.data[t];
        if (n && nt.call(n, r))
          return n[r];
      }
      if (r === "__typename" && nt.call(this.policies.rootTypenamesById, t))
        return this.policies.rootTypenamesById[t];
      if (this instanceof Cr)
        return this.parent.get(t, r);
    }, e.prototype.lookup = function(t, r) {
      if (r && this.group.depend(t, "__exists"), nt.call(this.data, t))
        return this.data[t];
      if (this instanceof Cr)
        return this.parent.lookup(t, r);
      if (this.policies.rootTypenamesById[t])
        return /* @__PURE__ */ Object.create(null);
    }, e.prototype.merge = function(t, r) {
      var n = this, i;
      Pe(t) && (t = t.__ref), Pe(r) && (r = r.__ref);
      var a = typeof t == "string" ? this.lookup(i = t) : t, o = typeof r == "string" ? this.lookup(i = r) : r;
      if (o) {
        se(typeof i == "string", 1);
        var s = new Nr(v2).merge(a, o);
        if (this.data[i] = s, s !== a && (delete this.refs[i], this.group.caching)) {
          var u = /* @__PURE__ */ Object.create(null);
          a || (u.__exists = 1), Object.keys(o).forEach(function(l) {
            if (!a || a[l] !== s[l]) {
              u[l] = 1;
              var c = Lr(l);
              c !== l && !n.policies.hasKeyArgs(s.__typename, c) && (u[c] = 1), s[l] === void 0 && !(n instanceof Cr) && delete s[l];
            }
          }), u.__typename && !(a && a.__typename) && // Since we return default root __typename strings
          // automatically from store.get, we don't need to dirty the
          // ROOT_QUERY.__typename field if merged.__typename is equal
          // to the default string (usually "Query").
          this.policies.rootTypenamesById[i] === s.__typename && delete u.__typename, Object.keys(u).forEach(function(l) {
            return n.group.dirty(i, l);
          });
        }
      }
    }, e.prototype.modify = function(t, r) {
      var n = this, i = this.lookup(t);
      if (i) {
        var a = /* @__PURE__ */ Object.create(null), o = !1, s = !0, u = {
          DELETE: yo,
          INVALIDATE: If,
          isReference: Pe,
          toReference: this.toReference,
          canRead: this.canRead,
          readField: function(l, c) {
            return n.policies.readField(typeof l == "string" ? {
              fieldName: l,
              from: c || Vn(t)
            } : l, { store: n });
          }
        };
        if (Object.keys(i).forEach(function(l) {
          var c = Lr(l), d = i[l];
          if (d !== void 0) {
            var f = typeof r == "function" ? r : r[l] || r[c];
            if (f) {
              var h = f === yu ? yo : f(ra(d), B(B({}, u), { fieldName: c, storeFieldName: l, storage: n.getStorage(t, l) }));
              if (h === If)
                n.group.dirty(t, l);
              else if (h === yo && (h = void 0), h !== d && (a[l] = h, o = !0, d = h, globalThis.__DEV__ !== !1)) {
                var p = function(S) {
                  if (n.lookup(S.__ref) === void 0)
                    return globalThis.__DEV__ !== !1 && se.warn(2, S), !0;
                };
                if (Pe(h))
                  p(h);
                else if (Array.isArray(h))
                  for (var v = !1, g = void 0, $ = 0, m = h; $ < m.length; $++) {
                    var b = m[$];
                    if (Pe(b)) {
                      if (v = !0, p(b))
                        break;
                    } else if (typeof b == "object" && b) {
                      var D = n.policies.identify(b)[0];
                      D && (g = b);
                    }
                    if (v && g !== void 0) {
                      globalThis.__DEV__ !== !1 && se.warn(3, g);
                      break;
                    }
                  }
              }
            }
            d !== void 0 && (s = !1);
          }
        }), o)
          return this.merge(t, a), s && (this instanceof Cr ? this.data[t] = void 0 : delete this.data[t], this.group.dirty(t, "__exists")), !0;
      }
      return !1;
    }, e.prototype.delete = function(t, r, n) {
      var i, a = this.lookup(t);
      if (a) {
        var o = this.getFieldValue(a, "__typename"), s = r && n ? this.policies.getStoreFieldName({ typename: o, fieldName: r, args: n }) : r;
        return this.modify(t, s ? (i = {}, i[s] = yu, i) : yu);
      }
      return !1;
    }, e.prototype.evict = function(t, r) {
      var n = !1;
      return t.id && (nt.call(this.data, t.id) && (n = this.delete(t.id, t.fieldName, t.args)), this instanceof Cr && this !== r && (n = this.parent.evict(t, r) || n), (t.fieldName || n) && this.group.dirty(t.id, t.fieldName || "__exists")), n;
    }, e.prototype.clear = function() {
      this.replace(null);
    }, e.prototype.extract = function() {
      var t = this, r = this.toObject(), n = [];
      return this.getRootIdSet().forEach(function(i) {
        nt.call(t.policies.rootTypenamesById, i) || n.push(i);
      }), n.length && (r.__META = { extraRootIds: n.sort() }), r;
    }, e.prototype.replace = function(t) {
      var r = this;
      if (Object.keys(this.data).forEach(function(a) {
        t && nt.call(t, a) || r.delete(a);
      }), t) {
        var n = t.__META, i = Nt(t, ["__META"]);
        Object.keys(i).forEach(function(a) {
          r.merge(a, i[a]);
        }), n && n.extraRootIds.forEach(this.retain, this);
      }
    }, e.prototype.retain = function(t) {
      return this.rootIds[t] = (this.rootIds[t] || 0) + 1;
    }, e.prototype.release = function(t) {
      if (this.rootIds[t] > 0) {
        var r = --this.rootIds[t];
        return r || delete this.rootIds[t], r;
      }
      return 0;
    }, e.prototype.getRootIdSet = function(t) {
      return t === void 0 && (t = /* @__PURE__ */ new Set()), Object.keys(this.rootIds).forEach(t.add, t), this instanceof Cr ? this.parent.getRootIdSet(t) : Object.keys(this.policies.rootTypenamesById).forEach(t.add, t), t;
    }, e.prototype.gc = function() {
      var t = this, r = this.getRootIdSet(), n = this.toObject();
      r.forEach(function(o) {
        nt.call(n, o) && (Object.keys(t.findChildRefIds(o)).forEach(r.add, r), delete n[o]);
      });
      var i = Object.keys(n);
      if (i.length) {
        for (var a = this; a instanceof Cr; )
          a = a.parent;
        i.forEach(function(o) {
          return a.delete(o);
        });
      }
      return i;
    }, e.prototype.findChildRefIds = function(t) {
      if (!nt.call(this.refs, t)) {
        var r = this.refs[t] = /* @__PURE__ */ Object.create(null), n = this.data[t];
        if (!n)
          return r;
        var i = /* @__PURE__ */ new Set([n]);
        i.forEach(function(a) {
          Pe(a) && (r[a.__ref] = !0), Ue(a) && Object.keys(a).forEach(function(o) {
            var s = a[o];
            Ue(s) && i.add(s);
          });
        });
      }
      return this.refs[t];
    }, e.prototype.makeCacheKey = function() {
      return this.group.keyMaker.lookupArray(arguments);
    }, e;
  }()
), rv = (
  /** @class */
  function() {
    function e(t, r) {
      r === void 0 && (r = null), this.caching = t, this.parent = r, this.d = null, this.resetCaching();
    }
    return e.prototype.resetCaching = function() {
      this.d = this.caching ? Tm() : null, this.keyMaker = new li(mn);
    }, e.prototype.depend = function(t, r) {
      if (this.d) {
        this.d(gu(t, r));
        var n = Lr(r);
        n !== r && this.d(gu(t, n)), this.parent && this.parent.depend(t, r);
      }
    }, e.prototype.dirty = function(t, r) {
      this.d && this.d.dirty(
        gu(t, r),
        // When storeFieldName === "__exists", that means the entity identified
        // by dataId has either disappeared from the cache or was newly added,
        // so the result caching system would do well to "forget everything it
        // knows" about that object. To achieve that kind of invalidation, we
        // not only dirty the associated result cache entry, but also remove it
        // completely from the dependency graph. For the optimism implementation
        // details, see https://github.com/benjamn/optimism/pull/195.
        r === "__exists" ? "forget" : "setDirty"
      );
    }, e;
  }()
);
function gu(e, t) {
  return t + "#" + e;
}
function Rf(e, t) {
  zi(e) && e.group.depend(t, "__exists");
}
(function(e) {
  var t = (
    /** @class */
    function(r) {
      Vt(n, r);
      function n(i) {
        var a = i.policies, o = i.resultCaching, s = o === void 0 ? !0 : o, u = i.seed, l = r.call(this, a, new rv(s)) || this;
        return l.stump = new m2(l), l.storageTrie = new li(mn), u && l.replace(u), l;
      }
      return n.prototype.addLayer = function(i, a) {
        return this.stump.addLayer(i, a);
      }, n.prototype.removeLayer = function() {
        return this;
      }, n.prototype.getStorage = function() {
        return this.storageTrie.lookupArray(arguments);
      }, n;
    }(e)
  );
  e.Root = t;
})(ia || (ia = {}));
var Cr = (
  /** @class */
  function(e) {
    Vt(t, e);
    function t(r, n, i, a) {
      var o = e.call(this, n.policies, a) || this;
      return o.id = r, o.parent = n, o.replay = i, o.group = a, i(o), o;
    }
    return t.prototype.addLayer = function(r, n) {
      return new t(r, this, n, this.group);
    }, t.prototype.removeLayer = function(r) {
      var n = this, i = this.parent.removeLayer(r);
      return r === this.id ? (this.group.caching && Object.keys(this.data).forEach(function(a) {
        var o = n.data[a], s = i.lookup(a);
        s ? o ? o !== s && Object.keys(o).forEach(function(u) {
          Te(o[u], s[u]) || n.group.dirty(a, u);
        }) : (n.group.dirty(a, "__exists"), Object.keys(s).forEach(function(u) {
          n.group.dirty(a, u);
        })) : n.delete(a);
      }), i) : i === this.parent ? this : i.addLayer(this.id, this.replay);
    }, t.prototype.toObject = function() {
      return B(B({}, this.parent.toObject()), this.data);
    }, t.prototype.findChildRefIds = function(r) {
      var n = this.parent.findChildRefIds(r);
      return nt.call(this.data, r) ? B(B({}, n), e.prototype.findChildRefIds.call(this, r)) : n;
    }, t.prototype.getStorage = function() {
      for (var r = this.parent; r.parent; )
        r = r.parent;
      return r.getStorage.apply(
        r,
        // @ts-expect-error
        arguments
      );
    }, t;
  }(ia)
), m2 = (
  /** @class */
  function(e) {
    Vt(t, e);
    function t(r) {
      return e.call(this, "EntityStore.Stump", r, function() {
      }, new rv(r.group.caching, r.group)) || this;
    }
    return t.prototype.removeLayer = function() {
      return this;
    }, t.prototype.merge = function(r, n) {
      return this.parent.merge(r, n);
    }, t;
  }(Cr)
);
function v2(e, t, r) {
  var n = e[r], i = t[r];
  return Te(n, i) ? n : i;
}
function zi(e) {
  return !!(e instanceof ia && e.group.caching);
}
function y2(e) {
  return Ue(e) ? qe(e) ? e.slice(0) : B({ __proto__: Object.getPrototypeOf(e) }, e) : e;
}
var Bf = (
  /** @class */
  function() {
    function e() {
      this.known = new (cm ? WeakSet : Set)(), this.pool = new li(mn), this.passes = /* @__PURE__ */ new WeakMap(), this.keysByJSON = /* @__PURE__ */ new Map(), this.empty = this.admit({});
    }
    return e.prototype.isKnown = function(t) {
      return Ue(t) && this.known.has(t);
    }, e.prototype.pass = function(t) {
      if (Ue(t)) {
        var r = y2(t);
        return this.passes.set(r, t), r;
      }
      return t;
    }, e.prototype.admit = function(t) {
      var r = this;
      if (Ue(t)) {
        var n = this.passes.get(t);
        if (n)
          return n;
        var i = Object.getPrototypeOf(t);
        switch (i) {
          case Array.prototype: {
            if (this.known.has(t))
              return t;
            var a = t.map(this.admit, this), o = this.pool.lookupArray(a);
            return o.array || (this.known.add(o.array = a), globalThis.__DEV__ !== !1 && Object.freeze(a)), o.array;
          }
          case null:
          case Object.prototype: {
            if (this.known.has(t))
              return t;
            var s = Object.getPrototypeOf(t), u = [s], l = this.sortedKeys(t);
            u.push(l.json);
            var c = u.length;
            l.sorted.forEach(function(h) {
              u.push(r.admit(t[h]));
            });
            var o = this.pool.lookupArray(u);
            if (!o.object) {
              var d = o.object = Object.create(s);
              this.known.add(d), l.sorted.forEach(function(h, p) {
                d[h] = u[c + p];
              }), globalThis.__DEV__ !== !1 && Object.freeze(d);
            }
            return o.object;
          }
        }
      }
      return t;
    }, e.prototype.sortedKeys = function(t) {
      var r = Object.keys(t), n = this.pool.lookupArray(r);
      if (!n.keys) {
        r.sort();
        var i = JSON.stringify(r);
        (n.keys = this.keysByJSON.get(i)) || this.keysByJSON.set(i, n.keys = { sorted: r, json: i });
      }
      return n.keys;
    }, e;
  }()
);
function Mf(e) {
  return [
    e.selectionSet,
    e.objectOrReference,
    e.context,
    // We split out this property so we can pass different values
    // independently without modifying options.context itself.
    e.context.canonizeResults
  ];
}
var g2 = (
  /** @class */
  function() {
    function e(t) {
      var r = this;
      this.knownResults = new (mn ? WeakMap : Map)(), this.config = on(t, {
        addTypename: t.addTypename !== !1,
        canonizeResults: Xm(t)
      }), this.canon = t.canon || new Bf(), this.executeSelectionSet = ta(function(n) {
        var i, a = n.context.canonizeResults, o = Mf(n);
        o[3] = !a;
        var s = (i = r.executeSelectionSet).peek.apply(i, o);
        return s ? a ? B(B({}, s), {
          // If we previously read this result without canonizing it, we can
          // reuse that result simply by canonizing it now.
          result: r.canon.admit(s.result)
        }) : s : (Rf(n.context.store, n.enclosingRef.__ref), r.execSelectionSetImpl(n));
      }, {
        max: this.config.resultCacheMaxSize || Zt["inMemoryCache.executeSelectionSet"] || 5e4,
        keyArgs: Mf,
        // Note that the parameters of makeCacheKey are determined by the
        // array returned by keyArgs.
        makeCacheKey: function(n, i, a, o) {
          if (zi(a.store))
            return a.store.makeCacheKey(n, Pe(i) ? i.__ref : i, a.varString, o);
        }
      }), this.executeSubSelectedArray = ta(function(n) {
        return Rf(n.context.store, n.enclosingRef.__ref), r.execSubSelectedArrayImpl(n);
      }, {
        max: this.config.resultCacheMaxSize || Zt["inMemoryCache.executeSubSelectedArray"] || 1e4,
        makeCacheKey: function(n) {
          var i = n.field, a = n.array, o = n.context;
          if (zi(o.store))
            return o.store.makeCacheKey(i, a, o.varString);
        }
      });
    }
    return e.prototype.resetCanon = function() {
      this.canon = new Bf();
    }, e.prototype.diffQueryAgainstStore = function(t) {
      var r = t.store, n = t.query, i = t.rootId, a = i === void 0 ? "ROOT_QUERY" : i, o = t.variables, s = t.returnPartialData, u = s === void 0 ? !0 : s, l = t.canonizeResults, c = l === void 0 ? this.config.canonizeResults : l, d = this.config.cache.policies;
      o = B(B({}, Rc(vm(n))), o);
      var f = Vn(a), h = this.executeSelectionSet({
        selectionSet: Ca(n).selectionSet,
        objectOrReference: f,
        enclosingRef: f,
        context: B({ store: r, query: n, policies: d, variables: o, varString: Ir(o), canonizeResults: c }, tv(n, this.config.fragments))
      }), p;
      if (h.missing && (p = [
        new Zm(b2(h.missing), h.missing, n, o)
      ], !u))
        throw p[0];
      return {
        result: h.result,
        complete: !p,
        missing: p
      };
    }, e.prototype.isFresh = function(t, r, n, i) {
      if (zi(i.store) && this.knownResults.get(t) === n) {
        var a = this.executeSelectionSet.peek(
          n,
          r,
          i,
          // If result is canonical, then it could only have been previously
          // cached by the canonizing version of executeSelectionSet, so we can
          // avoid checking both possibilities here.
          this.canon.isKnown(t)
        );
        if (a && t === a.result)
          return !0;
      }
      return !1;
    }, e.prototype.execSelectionSetImpl = function(t) {
      var r = this, n = t.selectionSet, i = t.objectOrReference, a = t.enclosingRef, o = t.context;
      if (Pe(i) && !o.policies.rootTypenamesById[i.__ref] && !o.store.has(i.__ref))
        return {
          result: this.canon.empty,
          missing: "Dangling reference to missing ".concat(i.__ref, " object")
        };
      var s = o.variables, u = o.policies, l = o.store, c = l.getFieldValue(i, "__typename"), d = [], f, h = new Nr();
      this.config.addTypename && typeof c == "string" && !u.rootIdsByTypename[c] && d.push({ __typename: c });
      function p(b, D) {
        var S;
        return b.missing && (f = h.merge(f, (S = {}, S[D] = b.missing, S))), b.result;
      }
      var v = new Set(n.selections);
      v.forEach(function(b) {
        var D, S;
        if (Da(b, s))
          if (Br(b)) {
            var T = u.readField({
              fieldName: b.name.value,
              field: b,
              variables: o.variables,
              from: i
            }, o), R = Rr(b);
            T === void 0 ? Vc.added(b) || (f = h.merge(f, (D = {}, D[R] = "Can't find field '".concat(b.name.value, "' on ").concat(Pe(i) ? i.__ref + " object" : "object " + JSON.stringify(i, null, 2)), D))) : qe(T) ? T.length > 0 && (T = p(r.executeSubSelectedArray({
              field: b,
              array: T,
              enclosingRef: a,
              context: o
            }), R)) : b.selectionSet ? T != null && (T = p(r.executeSelectionSet({
              selectionSet: b.selectionSet,
              objectOrReference: T,
              enclosingRef: Pe(T) ? T : a,
              context: o
            }), R)) : o.canonizeResults && (T = r.canon.pass(T)), T !== void 0 && d.push((S = {}, S[R] = T, S));
          } else {
            var y = Ds(b, o.lookupFragment);
            if (!y && b.kind === ee.FRAGMENT_SPREAD)
              throw ht(9, b.name.value);
            y && u.fragmentMatches(y, c) && y.selectionSet.selections.forEach(v.add, v);
          }
      });
      var g = Ts(d), $ = { result: g, missing: f }, m = o.canonizeResults ? this.canon.admit($) : ra($);
      return m.result && this.knownResults.set(m.result, n), m;
    }, e.prototype.execSubSelectedArrayImpl = function(t) {
      var r = this, n = t.field, i = t.array, a = t.enclosingRef, o = t.context, s, u = new Nr();
      function l(c, d) {
        var f;
        return c.missing && (s = u.merge(s, (f = {}, f[d] = c.missing, f))), c.result;
      }
      return n.selectionSet && (i = i.filter(o.store.canRead)), i = i.map(function(c, d) {
        return c === null ? null : qe(c) ? l(r.executeSubSelectedArray({
          field: n,
          array: c,
          enclosingRef: a,
          context: o
        }), d) : n.selectionSet ? l(r.executeSelectionSet({
          selectionSet: n.selectionSet,
          objectOrReference: c,
          enclosingRef: Pe(c) ? c : a,
          context: o
        }), d) : (globalThis.__DEV__ !== !1 && $2(o.store, n, c), c);
      }), {
        result: o.canonizeResults ? this.canon.admit(i) : i,
        missing: s
      };
    }, e;
  }()
);
function b2(e) {
  try {
    JSON.stringify(e, function(t, r) {
      if (typeof r == "string")
        throw r;
      return r;
    });
  } catch (t) {
    return t;
  }
}
function $2(e, t, r) {
  if (!t.selectionSet) {
    var n = /* @__PURE__ */ new Set([r]);
    n.forEach(function(i) {
      Ue(i) && (se(
        !Pe(i),
        10,
        h2(e, i),
        t.name.value
      ), Object.values(i).forEach(n.add, n));
    });
  }
}
var Hc = new ym(), Nf = /* @__PURE__ */ new WeakMap();
function Ki(e) {
  var t = Nf.get(e);
  return t || Nf.set(e, t = {
    vars: /* @__PURE__ */ new Set(),
    dep: Tm()
  }), t;
}
function Lf(e) {
  Ki(e).vars.forEach(function(t) {
    return t.forgetCache(e);
  });
}
function x2(e) {
  Ki(e).vars.forEach(function(t) {
    return t.attachCache(e);
  });
}
function D2(e) {
  var t = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), n = function(a) {
    if (arguments.length > 0) {
      if (e !== a) {
        e = a, t.forEach(function(u) {
          Ki(u).dep.dirty(n), E2(u);
        });
        var o = Array.from(r);
        r.clear(), o.forEach(function(u) {
          return u(e);
        });
      }
    } else {
      var s = Hc.getValue();
      s && (i(s), Ki(s).dep(n));
    }
    return e;
  };
  n.onNextChange = function(a) {
    return r.add(a), function() {
      r.delete(a);
    };
  };
  var i = n.attachCache = function(a) {
    return t.add(a), Ki(a).vars.add(n), n;
  };
  return n.forgetCache = function(a) {
    return t.delete(a);
  }, n;
}
function E2(e) {
  e.broadcastWatches && e.broadcastWatches();
}
var Vf = /* @__PURE__ */ Object.create(null);
function Wc(e) {
  var t = JSON.stringify(e);
  return Vf[t] || (Vf[t] = /* @__PURE__ */ Object.create(null));
}
function jf(e) {
  var t = Wc(e);
  return t.keyFieldsFn || (t.keyFieldsFn = function(r, n) {
    var i = function(o, s) {
      return n.readField(s, o);
    }, a = n.keyObject = Qc(e, function(o) {
      var s = zn(
        n.storeObject,
        o,
        // Using context.readField to extract paths from context.storeObject
        // allows the extraction to see through Reference objects and respect
        // custom read functions.
        i
      );
      return s === void 0 && r !== n.storeObject && nt.call(r, o[0]) && (s = zn(r, o, iv)), se(s !== void 0, 4, o.join("."), r), s;
    });
    return "".concat(n.typename, ":").concat(JSON.stringify(a));
  });
}
function zf(e) {
  var t = Wc(e);
  return t.keyArgsFn || (t.keyArgsFn = function(r, n) {
    var i = n.field, a = n.variables, o = n.fieldName, s = Qc(e, function(l) {
      var c = l[0], d = c.charAt(0);
      if (d === "@") {
        if (i && Ft(i.directives)) {
          var f = c.slice(1), h = i.directives.find(function($) {
            return $.name.value === f;
          }), p = h && Es(h, a);
          return p && zn(
            p,
            // If keyPath.length === 1, this code calls extractKeyPath with an
            // empty path, which works because it uses directiveArgs as the
            // extracted value.
            l.slice(1)
          );
        }
        return;
      }
      if (d === "$") {
        var v = c.slice(1);
        if (a && nt.call(a, v)) {
          var g = l.slice(0);
          return g[0] = v, zn(a, g);
        }
        return;
      }
      if (r)
        return zn(r, l);
    }), u = JSON.stringify(s);
    return (r || u !== "{}") && (o += ":" + u), o;
  });
}
function Qc(e, t) {
  var r = new Nr();
  return nv(e).reduce(function(n, i) {
    var a, o = t(i);
    if (o !== void 0) {
      for (var s = i.length - 1; s >= 0; --s)
        o = (a = {}, a[i[s]] = o, a);
      n = r.merge(n, o);
    }
    return n;
  }, /* @__PURE__ */ Object.create(null));
}
function nv(e) {
  var t = Wc(e);
  if (!t.paths) {
    var r = t.paths = [], n = [];
    e.forEach(function(i, a) {
      qe(i) ? (nv(i).forEach(function(o) {
        return r.push(n.concat(o));
      }), n.length = 0) : (n.push(i), qe(e[a + 1]) || (r.push(n.slice(0)), n.length = 0));
    });
  }
  return t.paths;
}
function iv(e, t) {
  return e[t];
}
function zn(e, t, r) {
  return r = r || iv, av(t.reduce(function n(i, a) {
    return qe(i) ? i.map(function(o) {
      return n(o, a);
    }) : i && r(i, a);
  }, e));
}
function av(e) {
  return Ue(e) ? qe(e) ? e.map(av) : Qc(Object.keys(e).sort(), function(t) {
    return zn(e, t);
  }) : e;
}
function Cl(e) {
  return e.args !== void 0 ? e.args : e.field ? Es(e.field, e.variables) : null;
}
var w2 = function() {
}, Kf = function(e, t) {
  return t.fieldName;
}, Uf = function(e, t, r) {
  var n = r.mergeObjects;
  return n(e, t);
}, qf = function(e, t) {
  return t;
}, C2 = (
  /** @class */
  function() {
    function e(t) {
      this.config = t, this.typePolicies = /* @__PURE__ */ Object.create(null), this.toBeAdded = /* @__PURE__ */ Object.create(null), this.supertypeMap = /* @__PURE__ */ new Map(), this.fuzzySubtypes = /* @__PURE__ */ new Map(), this.rootIdsByTypename = /* @__PURE__ */ Object.create(null), this.rootTypenamesById = /* @__PURE__ */ Object.create(null), this.usingPossibleTypes = !1, this.config = B({ dataIdFromObject: Ym }, t), this.cache = this.config.cache, this.setRootTypename("Query"), this.setRootTypename("Mutation"), this.setRootTypename("Subscription"), t.possibleTypes && this.addPossibleTypes(t.possibleTypes), t.typePolicies && this.addTypePolicies(t.typePolicies);
    }
    return e.prototype.identify = function(t, r) {
      var n, i = this, a = r && (r.typename || ((n = r.storeObject) === null || n === void 0 ? void 0 : n.__typename)) || t.__typename;
      if (a === this.rootTypenamesById.ROOT_QUERY)
        return ["ROOT_QUERY"];
      for (var o = r && r.storeObject || t, s = B(B({}, r), { typename: a, storeObject: o, readField: r && r.readField || function() {
        var f = Gc(arguments, o);
        return i.readField(f, {
          store: i.cache.data,
          variables: f.variables
        });
      } }), u, l = a && this.getTypePolicy(a), c = l && l.keyFn || this.config.dataIdFromObject; c; ) {
        var d = c(B(B({}, t), o), s);
        if (qe(d))
          c = jf(d);
        else {
          u = d;
          break;
        }
      }
      return u = u ? String(u) : void 0, s.keyObject ? [u, s.keyObject] : [u];
    }, e.prototype.addTypePolicies = function(t) {
      var r = this;
      Object.keys(t).forEach(function(n) {
        var i = t[n], a = i.queryType, o = i.mutationType, s = i.subscriptionType, u = Nt(i, ["queryType", "mutationType", "subscriptionType"]);
        a && r.setRootTypename("Query", n), o && r.setRootTypename("Mutation", n), s && r.setRootTypename("Subscription", n), nt.call(r.toBeAdded, n) ? r.toBeAdded[n].push(u) : r.toBeAdded[n] = [u];
      });
    }, e.prototype.updateTypePolicy = function(t, r) {
      var n = this, i = this.getTypePolicy(t), a = r.keyFields, o = r.fields;
      function s(u, l) {
        u.merge = typeof l == "function" ? l : l === !0 ? Uf : l === !1 ? qf : u.merge;
      }
      s(i, r.merge), i.keyFn = // Pass false to disable normalization for this typename.
      a === !1 ? w2 : qe(a) ? jf(a) : typeof a == "function" ? a : i.keyFn, o && Object.keys(o).forEach(function(u) {
        var l = n.getFieldPolicy(t, u, !0), c = o[u];
        if (typeof c == "function")
          l.read = c;
        else {
          var d = c.keyArgs, f = c.read, h = c.merge;
          l.keyFn = // Pass false to disable argument-based differentiation of
          // field identities.
          d === !1 ? Kf : qe(d) ? zf(d) : typeof d == "function" ? d : l.keyFn, typeof f == "function" && (l.read = f), s(l, h);
        }
        l.read && l.merge && (l.keyFn = l.keyFn || Kf);
      });
    }, e.prototype.setRootTypename = function(t, r) {
      r === void 0 && (r = t);
      var n = "ROOT_" + t.toUpperCase(), i = this.rootTypenamesById[n];
      r !== i && (se(!i || i === t, 5, t), i && delete this.rootIdsByTypename[i], this.rootIdsByTypename[r] = n, this.rootTypenamesById[n] = r);
    }, e.prototype.addPossibleTypes = function(t) {
      var r = this;
      this.usingPossibleTypes = !0, Object.keys(t).forEach(function(n) {
        r.getSupertypeSet(n, !0), t[n].forEach(function(i) {
          r.getSupertypeSet(i, !0).add(n);
          var a = i.match(ev);
          (!a || a[0] !== i) && r.fuzzySubtypes.set(i, new RegExp(i));
        });
      });
    }, e.prototype.getTypePolicy = function(t) {
      var r = this;
      if (!nt.call(this.typePolicies, t)) {
        var n = this.typePolicies[t] = /* @__PURE__ */ Object.create(null);
        n.fields = /* @__PURE__ */ Object.create(null);
        var i = this.supertypeMap.get(t);
        !i && this.fuzzySubtypes.size && (i = this.getSupertypeSet(t, !0), this.fuzzySubtypes.forEach(function(o, s) {
          if (o.test(t)) {
            var u = r.supertypeMap.get(s);
            u && u.forEach(function(l) {
              return i.add(l);
            });
          }
        })), i && i.size && i.forEach(function(o) {
          var s = r.getTypePolicy(o), u = s.fields, l = Nt(s, ["fields"]);
          Object.assign(n, l), Object.assign(n.fields, u);
        });
      }
      var a = this.toBeAdded[t];
      return a && a.length && a.splice(0).forEach(function(o) {
        r.updateTypePolicy(t, o);
      }), this.typePolicies[t];
    }, e.prototype.getFieldPolicy = function(t, r, n) {
      if (t) {
        var i = this.getTypePolicy(t).fields;
        return i[r] || n && (i[r] = /* @__PURE__ */ Object.create(null));
      }
    }, e.prototype.getSupertypeSet = function(t, r) {
      var n = this.supertypeMap.get(t);
      return !n && r && this.supertypeMap.set(t, n = /* @__PURE__ */ new Set()), n;
    }, e.prototype.fragmentMatches = function(t, r, n, i) {
      var a = this;
      if (!t.typeCondition)
        return !0;
      if (!r)
        return !1;
      var o = t.typeCondition.name.value;
      if (r === o)
        return !0;
      if (this.usingPossibleTypes && this.supertypeMap.has(o))
        for (var s = this.getSupertypeSet(r, !0), u = [s], l = function(p) {
          var v = a.getSupertypeSet(p, !1);
          v && v.size && u.indexOf(v) < 0 && u.push(v);
        }, c = !!(n && this.fuzzySubtypes.size), d = !1, f = 0; f < u.length; ++f) {
          var h = u[f];
          if (h.has(o))
            return s.has(o) || (d && globalThis.__DEV__ !== !1 && se.warn(6, r, o), s.add(o)), !0;
          h.forEach(l), c && // Start checking fuzzy subtypes only after exhausting all
          // non-fuzzy subtypes (after the final iteration of the loop).
          f === u.length - 1 && // We could wait to compare fragment.selectionSet to result
          // after we verify the supertype, but this check is often less
          // expensive than that search, and we will have to do the
          // comparison anyway whenever we find a potential match.
          wl(t.selectionSet, n, i) && (c = !1, d = !0, this.fuzzySubtypes.forEach(function(p, v) {
            var g = r.match(p);
            g && g[0] === r && l(v);
          }));
        }
      return !1;
    }, e.prototype.hasKeyArgs = function(t, r) {
      var n = this.getFieldPolicy(t, r, !1);
      return !!(n && n.keyFn);
    }, e.prototype.getStoreFieldName = function(t) {
      var r = t.typename, n = t.fieldName, i = this.getFieldPolicy(r, n, !1), a, o = i && i.keyFn;
      if (o && r)
        for (var s = {
          typename: r,
          fieldName: n,
          field: t.field || null,
          variables: t.variables
        }, u = Cl(t); o; ) {
          var l = o(u, s);
          if (qe(l))
            o = zf(l);
          else {
            a = l || n;
            break;
          }
        }
      return a === void 0 && (a = t.field ? UD(t.field, t.variables) : mm(n, Cl(t))), a === !1 ? n : n === Lr(a) ? a : n + ":" + a;
    }, e.prototype.readField = function(t, r) {
      var n = t.from;
      if (n) {
        var i = t.field || t.fieldName;
        if (i) {
          if (t.typename === void 0) {
            var a = r.store.getFieldValue(n, "__typename");
            a && (t.typename = a);
          }
          var o = this.getStoreFieldName(t), s = Lr(o), u = r.store.getFieldValue(n, o), l = this.getFieldPolicy(t.typename, s, !1), c = l && l.read;
          if (c) {
            var d = Hf(this, n, t, r, r.store.getStorage(Pe(n) ? n.__ref : n, o));
            return Hc.withValue(this.cache, c, [
              u,
              d
            ]);
          }
          return u;
        }
      }
    }, e.prototype.getReadFunction = function(t, r) {
      var n = this.getFieldPolicy(t, r, !1);
      return n && n.read;
    }, e.prototype.getMergeFunction = function(t, r, n) {
      var i = this.getFieldPolicy(t, r, !1), a = i && i.merge;
      return !a && n && (i = this.getTypePolicy(n), a = i && i.merge), a;
    }, e.prototype.runMergeFunction = function(t, r, n, i, a) {
      var o = n.field, s = n.typename, u = n.merge;
      return u === Uf ? ov(i.store)(t, r) : u === qf ? r : (i.overwrite && (t = void 0), u(t, r, Hf(
        this,
        // Unlike options.readField for read functions, we do not fall
        // back to the current object if no foreignObjOrRef is provided,
        // because it's not clear what the current object should be for
        // merge functions: the (possibly undefined) existing object, or
        // the incoming object? If you think your merge function needs
        // to read sibling fields in order to produce a new value for
        // the current field, you might want to rethink your strategy,
        // because that's a recipe for making merge behavior sensitive
        // to the order in which fields are written into the cache.
        // However, readField(name, ref) is useful for merge functions
        // that need to deduplicate child objects and references.
        void 0,
        {
          typename: s,
          fieldName: o.name.value,
          field: o,
          variables: i.variables
        },
        i,
        a || /* @__PURE__ */ Object.create(null)
      )));
    }, e;
  }()
);
function Hf(e, t, r, n, i) {
  var a = e.getStoreFieldName(r), o = Lr(a), s = r.variables || n.variables, u = n.store, l = u.toReference, c = u.canRead;
  return {
    args: Cl(r),
    field: r.field || null,
    fieldName: o,
    storeFieldName: a,
    variables: s,
    isReference: Pe,
    toReference: l,
    storage: i,
    cache: e.cache,
    canRead: c,
    readField: function() {
      return e.readField(Gc(arguments, t, s), n);
    },
    mergeObjects: ov(n.store)
  };
}
function Gc(e, t, r) {
  var n = e[0], i = e[1], a = e.length, o;
  return typeof n == "string" ? o = {
    fieldName: n,
    // Default to objectOrReference only when no second argument was
    // passed for the from parameter, not when undefined is explicitly
    // passed as the second argument.
    from: a > 1 ? i : t
  } : (o = B({}, n), nt.call(o, "from") || (o.from = t)), globalThis.__DEV__ !== !1 && o.from === void 0 && globalThis.__DEV__ !== !1 && se.warn(7, Yp(Array.from(e))), o.variables === void 0 && (o.variables = r), o;
}
function ov(e) {
  return function(r, n) {
    if (qe(r) || qe(n))
      throw ht(8);
    if (Ue(r) && Ue(n)) {
      var i = e.getFieldValue(r, "__typename"), a = e.getFieldValue(n, "__typename"), o = i && a && i !== a;
      if (o)
        return n;
      if (Pe(r) && On(n))
        return e.merge(r.__ref, n), r;
      if (On(r) && Pe(n))
        return e.merge(r, n.__ref), n;
      if (On(r) && On(n))
        return B(B({}, r), n);
    }
    return n;
  };
}
function bu(e, t, r) {
  var n = "".concat(t).concat(r), i = e.flavors.get(n);
  return i || e.flavors.set(n, i = e.clientOnly === t && e.deferred === r ? e : B(B({}, e), { clientOnly: t, deferred: r })), i;
}
var S2 = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.cache = t, this.reader = r, this.fragments = n;
    }
    return e.prototype.writeToStore = function(t, r) {
      var n = this, i = r.query, a = r.result, o = r.dataId, s = r.variables, u = r.overwrite, l = wa(i), c = p2();
      s = B(B({}, Rc(l)), s);
      var d = B(B({ store: t, written: /* @__PURE__ */ Object.create(null), merge: function(h, p) {
        return c.merge(h, p);
      }, variables: s, varString: Ir(s) }, tv(i, this.fragments)), { overwrite: !!u, incomingById: /* @__PURE__ */ new Map(), clientOnly: !1, deferred: !1, flavors: /* @__PURE__ */ new Map() }), f = this.processSelectionSet({
        result: a || /* @__PURE__ */ Object.create(null),
        dataId: o,
        selectionSet: l.selectionSet,
        mergeTree: { map: /* @__PURE__ */ new Map() },
        context: d
      });
      if (!Pe(f))
        throw ht(11, a);
      return d.incomingById.forEach(function(h, p) {
        var v = h.storeObject, g = h.mergeTree, $ = h.fieldNodeSet, m = Vn(p);
        if (g && g.map.size) {
          var b = n.applyMerges(g, m, v, d);
          if (Pe(b))
            return;
          v = b;
        }
        if (globalThis.__DEV__ !== !1 && !d.overwrite) {
          var D = /* @__PURE__ */ Object.create(null);
          $.forEach(function(R) {
            R.selectionSet && (D[R.name.value] = !0);
          });
          var S = function(R) {
            return D[Lr(R)] === !0;
          }, T = function(R) {
            var y = g && g.map.get(R);
            return !!(y && y.info && y.info.merge);
          };
          Object.keys(v).forEach(function(R) {
            S(R) && !T(R) && k2(m, v, R, d.store);
          });
        }
        t.merge(p, v);
      }), t.retain(f.__ref), f;
    }, e.prototype.processSelectionSet = function(t) {
      var r = this, n = t.dataId, i = t.result, a = t.selectionSet, o = t.context, s = t.mergeTree, u = this.cache.policies, l = /* @__PURE__ */ Object.create(null), c = n && u.rootTypenamesById[n] || ml(i, a, o.fragmentMap) || n && o.store.get(n, "__typename");
      typeof c == "string" && (l.__typename = c);
      var d = function() {
        var b = Gc(arguments, l, o.variables);
        if (Pe(b.from)) {
          var D = o.incomingById.get(b.from.__ref);
          if (D) {
            var S = u.readField(B(B({}, b), { from: D.storeObject }), o);
            if (S !== void 0)
              return S;
          }
        }
        return u.readField(b, o);
      }, f = /* @__PURE__ */ new Set();
      this.flattenFields(
        a,
        i,
        // This WriteContext will be the default context value for fields returned
        // by the flattenFields method, but some fields may be assigned a modified
        // context, depending on the presence of @client and other directives.
        o,
        c
      ).forEach(function(b, D) {
        var S, T = Rr(D), R = i[T];
        if (f.add(D), R !== void 0) {
          var y = u.getStoreFieldName({
            typename: c,
            fieldName: D.name.value,
            field: D,
            variables: b.variables
          }), A = Wf(s, y), w = r.processFieldValue(
            R,
            D,
            // Reset context.clientOnly and context.deferred to their default
            // values before processing nested selection sets.
            D.selectionSet ? bu(b, !1, !1) : b,
            A
          ), E = void 0;
          D.selectionSet && (Pe(w) || On(w)) && (E = d("__typename", w));
          var k = u.getMergeFunction(c, D.name.value, E);
          k ? A.info = {
            // TODO Check compatibility against any existing childTree.field?
            field: D,
            typename: c,
            merge: k
          } : Qf(s, y), l = b.merge(l, (S = {}, S[y] = w, S));
        } else globalThis.__DEV__ !== !1 && !b.clientOnly && !b.deferred && !Vc.added(D) && // If the field has a read function, it may be a synthetic field or
        // provide a default value, so its absence from the written data should
        // not be cause for alarm.
        !u.getReadFunction(c, D.name.value) && globalThis.__DEV__ !== !1 && se.error(12, Rr(D), i);
      });
      try {
        var h = u.identify(i, {
          typename: c,
          selectionSet: a,
          fragmentMap: o.fragmentMap,
          storeObject: l,
          readField: d
        }), p = h[0], v = h[1];
        n = n || p, v && (l = o.merge(l, v));
      } catch (b) {
        if (!n)
          throw b;
      }
      if (typeof n == "string") {
        var g = Vn(n), $ = o.written[n] || (o.written[n] = []);
        if ($.indexOf(a) >= 0 || ($.push(a), this.reader && this.reader.isFresh(i, g, a, o)))
          return g;
        var m = o.incomingById.get(n);
        return m ? (m.storeObject = o.merge(m.storeObject, l), m.mergeTree = Sl(m.mergeTree, s), f.forEach(function(b) {
          return m.fieldNodeSet.add(b);
        })) : o.incomingById.set(n, {
          storeObject: l,
          // Save a reference to mergeTree only if it is not empty, because
          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and
          // reused for entirely different parts of the result tree.
          mergeTree: _o(s) ? void 0 : s,
          fieldNodeSet: f
        }), g;
      }
      return l;
    }, e.prototype.processFieldValue = function(t, r, n, i) {
      var a = this;
      return !r.selectionSet || t === null ? globalThis.__DEV__ !== !1 ? Bm(t) : t : qe(t) ? t.map(function(o, s) {
        var u = a.processFieldValue(o, r, n, Wf(i, s));
        return Qf(i, s), u;
      }) : this.processSelectionSet({
        result: t,
        selectionSet: r.selectionSet,
        context: n,
        mergeTree: i
      });
    }, e.prototype.flattenFields = function(t, r, n, i) {
      i === void 0 && (i = ml(r, t, n.fragmentMap));
      var a = /* @__PURE__ */ new Map(), o = this.cache.policies, s = new li(!1);
      return function u(l, c) {
        var d = s.lookup(
          l,
          // Because we take inheritedClientOnly and inheritedDeferred into
          // consideration here (in addition to selectionSet), it's possible for
          // the same selection set to be flattened more than once, if it appears
          // in the query with different @client and/or @directive configurations.
          c.clientOnly,
          c.deferred
        );
        d.visited || (d.visited = !0, l.selections.forEach(function(f) {
          if (Da(f, n.variables)) {
            var h = c.clientOnly, p = c.deferred;
            if (
              // Since the presence of @client or @defer on this field can only
              // cause clientOnly or deferred to become true, we can skip the
              // forEach loop if both clientOnly and deferred are already true.
              !(h && p) && Ft(f.directives) && f.directives.forEach(function($) {
                var m = $.name.value;
                if (m === "client" && (h = !0), m === "defer") {
                  var b = Es($, n.variables);
                  (!b || b.if !== !1) && (p = !0);
                }
              }), Br(f)
            ) {
              var v = a.get(f);
              v && (h = h && v.clientOnly, p = p && v.deferred), a.set(f, bu(n, h, p));
            } else {
              var g = Ds(f, n.lookupFragment);
              if (!g && f.kind === ee.FRAGMENT_SPREAD)
                throw ht(13, f.name.value);
              g && o.fragmentMatches(g, i, r, n.variables) && u(g.selectionSet, bu(n, h, p));
            }
          }
        }));
      }(t, n), a;
    }, e.prototype.applyMerges = function(t, r, n, i, a) {
      var o, s = this;
      if (t.map.size && !Pe(n)) {
        var u = (
          // Items in the same position in different arrays are not
          // necessarily related to each other, so when incoming is an array
          // we process its elements as if there was no existing data.
          !qe(n) && // Likewise, existing must be either a Reference or a StoreObject
          // in order for its fields to be safe to merge with the fields of
          // the incoming object.
          (Pe(r) || On(r)) ? r : void 0
        ), l = n;
        u && !a && (a = [Pe(u) ? u.__ref : u]);
        var c, d = function(f, h) {
          return qe(f) ? typeof h == "number" ? f[h] : void 0 : i.store.getFieldValue(f, String(h));
        };
        t.map.forEach(function(f, h) {
          var p = d(u, h), v = d(l, h);
          if (v !== void 0) {
            a && a.push(h);
            var g = s.applyMerges(f, p, v, i, a);
            g !== v && (c = c || /* @__PURE__ */ new Map(), c.set(h, g)), a && se(a.pop() === h);
          }
        }), c && (n = qe(l) ? l.slice(0) : B({}, l), c.forEach(function(f, h) {
          n[h] = f;
        }));
      }
      return t.info ? this.cache.policies.runMergeFunction(r, n, t.info, i, a && (o = i.store).getStorage.apply(o, a)) : n;
    }, e;
  }()
), sv = [];
function Wf(e, t) {
  var r = e.map;
  return r.has(t) || r.set(t, sv.pop() || { map: /* @__PURE__ */ new Map() }), r.get(t);
}
function Sl(e, t) {
  if (e === t || !t || _o(t))
    return e;
  if (!e || _o(e))
    return t;
  var r = e.info && t.info ? B(B({}, e.info), t.info) : e.info || t.info, n = e.map.size && t.map.size, i = n ? /* @__PURE__ */ new Map() : e.map.size ? e.map : t.map, a = { info: r, map: i };
  if (n) {
    var o = new Set(t.map.keys());
    e.map.forEach(function(s, u) {
      a.map.set(u, Sl(s, t.map.get(u))), o.delete(u);
    }), o.forEach(function(s) {
      a.map.set(s, Sl(t.map.get(s), e.map.get(s)));
    });
  }
  return a;
}
function _o(e) {
  return !e || !(e.info || e.map.size);
}
function Qf(e, t) {
  var r = e.map, n = r.get(t);
  n && _o(n) && (sv.push(n), r.delete(t));
}
var Gf = /* @__PURE__ */ new Set();
function k2(e, t, r, n) {
  var i = function(d) {
    var f = n.getFieldValue(d, r);
    return typeof f == "object" && f;
  }, a = i(e);
  if (a) {
    var o = i(t);
    if (o && !Pe(a) && !Te(a, o) && !Object.keys(a).every(function(d) {
      return n.getFieldValue(o, d) !== void 0;
    })) {
      var s = n.getFieldValue(e, "__typename") || n.getFieldValue(t, "__typename"), u = Lr(r), l = "".concat(s, ".").concat(u);
      if (!Gf.has(l)) {
        Gf.add(l);
        var c = [];
        !qe(a) && !qe(o) && [a, o].forEach(function(d) {
          var f = n.getFieldValue(d, "__typename");
          typeof f == "string" && !c.includes(f) && c.push(f);
        }), globalThis.__DEV__ !== !1 && se.warn(14, u, s, c.length ? "either ensure all objects of type " + c.join(" and ") + " have an ID or a custom merge function, or " : "", l, B({}, a), B({}, o));
      }
    }
  }
}
var Zc = (
  /** @class */
  function(e) {
    Vt(t, e);
    function t(r) {
      r === void 0 && (r = {});
      var n = e.call(this) || this;
      return n.watches = /* @__PURE__ */ new Set(), n.addTypenameTransform = new Pm(Vc), n.assumeImmutableResults = !0, n.makeVar = D2, n.txCount = 0, n.config = f2(r), n.addTypename = !!n.config.addTypename, n.policies = new C2({
        cache: n,
        dataIdFromObject: n.config.dataIdFromObject,
        possibleTypes: n.config.possibleTypes,
        typePolicies: n.config.typePolicies
      }), n.init(), n;
    }
    return t.prototype.init = function() {
      var r = this.data = new ia.Root({
        policies: this.policies,
        resultCaching: this.config.resultCaching
      });
      this.optimisticData = r.stump, this.resetResultCache();
    }, t.prototype.resetResultCache = function(r) {
      var n = this, i = this.storeReader, a = this.config.fragments;
      this.storeWriter = new S2(this, this.storeReader = new g2({
        cache: this,
        addTypename: this.addTypename,
        resultCacheMaxSize: this.config.resultCacheMaxSize,
        canonizeResults: Xm(this.config),
        canon: r ? void 0 : i && i.canon,
        fragments: a
      }), a), this.maybeBroadcastWatch = ta(function(o, s) {
        return n.broadcastWatch(o, s);
      }, {
        max: this.config.resultCacheMaxSize || Zt["inMemoryCache.maybeBroadcastWatch"] || 5e3,
        makeCacheKey: function(o) {
          var s = o.optimistic ? n.optimisticData : n.data;
          if (zi(s)) {
            var u = o.optimistic, l = o.id, c = o.variables;
            return s.makeCacheKey(
              o.query,
              // Different watches can have the same query, optimistic
              // status, rootId, and variables, but if their callbacks are
              // different, the (identical) result needs to be delivered to
              // each distinct callback. The easiest way to achieve that
              // separation is to include c.callback in the cache key for
              // maybeBroadcastWatch calls. See issue #5733.
              o.callback,
              Ir({ optimistic: u, id: l, variables: c })
            );
          }
        }
      }), (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(o) {
        return o.resetCaching();
      });
    }, t.prototype.restore = function(r) {
      return this.init(), r && this.data.replace(r), this;
    }, t.prototype.extract = function(r) {
      return r === void 0 && (r = !1), (r ? this.optimisticData : this.data).extract();
    }, t.prototype.read = function(r) {
      var n = r.returnPartialData, i = n === void 0 ? !1 : n;
      try {
        return this.storeReader.diffQueryAgainstStore(B(B({}, r), { store: r.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData: i })).result || null;
      } catch (a) {
        if (a instanceof Zm)
          return null;
        throw a;
      }
    }, t.prototype.write = function(r) {
      try {
        return ++this.txCount, this.storeWriter.writeToStore(this.data, r);
      } finally {
        !--this.txCount && r.broadcast !== !1 && this.broadcastWatches();
      }
    }, t.prototype.modify = function(r) {
      if (nt.call(r, "id") && !r.id)
        return !1;
      var n = r.optimistic ? this.optimisticData : this.data;
      try {
        return ++this.txCount, n.modify(r.id || "ROOT_QUERY", r.fields);
      } finally {
        !--this.txCount && r.broadcast !== !1 && this.broadcastWatches();
      }
    }, t.prototype.diff = function(r) {
      return this.storeReader.diffQueryAgainstStore(B(B({}, r), { store: r.optimistic ? this.optimisticData : this.data, rootId: r.id || "ROOT_QUERY", config: this.config }));
    }, t.prototype.watch = function(r) {
      var n = this;
      return this.watches.size || x2(this), this.watches.add(r), r.immediate && this.maybeBroadcastWatch(r), function() {
        n.watches.delete(r) && !n.watches.size && Lf(n), n.maybeBroadcastWatch.forget(r);
      };
    }, t.prototype.gc = function(r) {
      var n;
      Ir.reset(), ks.reset(), this.addTypenameTransform.resetCache(), (n = this.config.fragments) === null || n === void 0 || n.resetCaches();
      var i = this.optimisticData.gc();
      return r && !this.txCount && (r.resetResultCache ? this.resetResultCache(r.resetResultIdentities) : r.resetResultIdentities && this.storeReader.resetCanon()), i;
    }, t.prototype.retain = function(r, n) {
      return (n ? this.optimisticData : this.data).retain(r);
    }, t.prototype.release = function(r, n) {
      return (n ? this.optimisticData : this.data).release(r);
    }, t.prototype.identify = function(r) {
      if (Pe(r))
        return r.__ref;
      try {
        return this.policies.identify(r)[0];
      } catch (n) {
        globalThis.__DEV__ !== !1 && se.warn(n);
      }
    }, t.prototype.evict = function(r) {
      if (!r.id) {
        if (nt.call(r, "id"))
          return !1;
        r = B(B({}, r), { id: "ROOT_QUERY" });
      }
      try {
        return ++this.txCount, this.optimisticData.evict(r, this.data);
      } finally {
        !--this.txCount && r.broadcast !== !1 && this.broadcastWatches();
      }
    }, t.prototype.reset = function(r) {
      var n = this;
      return this.init(), Ir.reset(), r && r.discardWatches ? (this.watches.forEach(function(i) {
        return n.maybeBroadcastWatch.forget(i);
      }), this.watches.clear(), Lf(this)) : this.broadcastWatches(), Promise.resolve();
    }, t.prototype.removeOptimistic = function(r) {
      var n = this.optimisticData.removeLayer(r);
      n !== this.optimisticData && (this.optimisticData = n, this.broadcastWatches());
    }, t.prototype.batch = function(r) {
      var n = this, i = r.update, a = r.optimistic, o = a === void 0 ? !0 : a, s = r.removeOptimistic, u = r.onWatchUpdated, l, c = function(f) {
        var h = n, p = h.data, v = h.optimisticData;
        ++n.txCount, f && (n.data = n.optimisticData = f);
        try {
          return l = i(n);
        } finally {
          --n.txCount, n.data = p, n.optimisticData = v;
        }
      }, d = /* @__PURE__ */ new Set();
      return u && !this.txCount && this.broadcastWatches(B(B({}, r), { onWatchUpdated: function(f) {
        return d.add(f), !1;
      } })), typeof o == "string" ? this.optimisticData = this.optimisticData.addLayer(o, c) : o === !1 ? c(this.data) : c(), typeof s == "string" && (this.optimisticData = this.optimisticData.removeLayer(s)), u && d.size ? (this.broadcastWatches(B(B({}, r), { onWatchUpdated: function(f, h) {
        var p = u.call(this, f, h);
        return p !== !1 && d.delete(f), p;
      } })), d.size && d.forEach(function(f) {
        return n.maybeBroadcastWatch.dirty(f);
      })) : this.broadcastWatches(r), l;
    }, t.prototype.performTransaction = function(r, n) {
      return this.batch({
        update: r,
        optimistic: n || n !== null
      });
    }, t.prototype.transformDocument = function(r) {
      return this.addTypenameToDocument(this.addFragmentsToDocument(r));
    }, t.prototype.broadcastWatches = function(r) {
      var n = this;
      this.txCount || this.watches.forEach(function(i) {
        return n.maybeBroadcastWatch(i, r);
      });
    }, t.prototype.addFragmentsToDocument = function(r) {
      var n = this.config.fragments;
      return n ? n.transform(r) : r;
    }, t.prototype.addTypenameToDocument = function(r) {
      return this.addTypename ? this.addTypenameTransform.transformDocument(r) : r;
    }, t.prototype.broadcastWatch = function(r, n) {
      var i = r.lastDiff, a = this.diff(r);
      n && (r.optimistic && typeof n.optimistic == "string" && (a.fromOptimisticTransaction = !0), n.onWatchUpdated && n.onWatchUpdated.call(this, r, a, i) === !1) || (!i || !Te(i.result, a.result)) && r.callback(r.lastDiff = a, i);
    }, t;
  }(Gm)
);
globalThis.__DEV__ !== !1 && (Zc.prototype.getMemoryInternals = SD);
var Ee;
(function(e) {
  e[e.loading = 1] = "loading", e[e.setVariables = 2] = "setVariables", e[e.fetchMore = 3] = "fetchMore", e[e.refetch = 4] = "refetch", e[e.poll = 6] = "poll", e[e.ready = 7] = "ready", e[e.error = 8] = "error";
})(Ee || (Ee = {}));
function aa(e) {
  return e ? e < 7 : !1;
}
var Zf = Object.assign, T2 = Object.hasOwnProperty, kl = (
  /** @class */
  function(e) {
    Vt(t, e);
    function t(r) {
      var n = r.queryManager, i = r.queryInfo, a = r.options, o = e.call(this, function(g) {
        try {
          var $ = g._subscription._observer;
          $ && !$.error && ($.error = P2);
        } catch {
        }
        var m = !o.observers.size;
        o.observers.add(g);
        var b = o.last;
        return b && b.error ? g.error && g.error(b.error) : b && b.result && g.next && g.next(b.result), m && o.reobserve().catch(function() {
        }), function() {
          o.observers.delete(g) && !o.observers.size && o.tearDownQuery();
        };
      }) || this;
      o.observers = /* @__PURE__ */ new Set(), o.subscriptions = /* @__PURE__ */ new Set(), o.queryInfo = i, o.queryManager = n, o.waitForOwnResult = $u(a.fetchPolicy), o.isTornDown = !1;
      var s = n.defaultOptions.watchQuery, u = s === void 0 ? {} : s, l = u.fetchPolicy, c = l === void 0 ? "cache-first" : l, d = a.fetchPolicy, f = d === void 0 ? c : d, h = a.initialFetchPolicy, p = h === void 0 ? f === "standby" ? c : f : h;
      o.options = B(B({}, a), {
        // Remember the initial options.fetchPolicy so we can revert back to this
        // policy when variables change. This information can also be specified
        // (or overridden) by providing options.initialFetchPolicy explicitly.
        initialFetchPolicy: p,
        // This ensures this.options.fetchPolicy always has a string value, in
        // case options.fetchPolicy was not provided.
        fetchPolicy: f
      }), o.queryId = i.queryId || n.generateQueryId();
      var v = wa(o.query);
      return o.queryName = v && v.name && v.name.value, o;
    }
    return Object.defineProperty(t.prototype, "query", {
      // The `query` computed property will always reflect the document transformed
      // by the last run query. `this.options.query` will always reflect the raw
      // untransformed query to ensure document transforms with runtime conditionals
      // are run on the original document.
      get: function() {
        return this.lastQuery || this.options.query;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "variables", {
      // Computed shorthand for this.options.variables, preserved for
      // backwards compatibility.
      /**
       * An object containing the variables that were provided for the query.
       */
      get: function() {
        return this.options.variables;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.result = function() {
      var r = this;
      return new Promise(function(n, i) {
        var a = {
          next: function(s) {
            n(s), r.observers.delete(a), r.observers.size || r.queryManager.removeQuery(r.queryId), setTimeout(function() {
              o.unsubscribe();
            }, 0);
          },
          error: i
        }, o = r.subscribe(a);
      });
    }, t.prototype.resetDiff = function() {
      this.queryInfo.resetDiff();
    }, t.prototype.getCurrentResult = function(r) {
      r === void 0 && (r = !0);
      var n = this.getLastResult(!0), i = this.queryInfo.networkStatus || n && n.networkStatus || Ee.ready, a = B(B({}, n), { loading: aa(i), networkStatus: i }), o = this.options.fetchPolicy, s = o === void 0 ? "cache-first" : o;
      if (
        // These fetch policies should never deliver data from the cache, unless
        // redelivering a previously delivered result.
        !($u(s) || // If this.options.query has @client(always: true) fields, we cannot
        // trust diff.result, since it was read from the cache without running
        // local resolvers (and it's too late to run resolvers now, since we must
        // return a result synchronously).
        this.queryManager.getDocumentInfo(this.query).hasForcedResolvers)
      ) if (this.waitForOwnResult)
        this.queryInfo.updateWatch();
      else {
        var u = this.queryInfo.getDiff();
        (u.complete || this.options.returnPartialData) && (a.data = u.result), Te(a.data, {}) && (a.data = void 0), u.complete ? (delete a.partial, u.complete && a.networkStatus === Ee.loading && (s === "cache-first" || s === "cache-only") && (a.networkStatus = Ee.ready, a.loading = !1)) : a.partial = !0, globalThis.__DEV__ !== !1 && !u.complete && !this.options.partialRefetch && !a.loading && !a.data && !a.error && lv(u.missing);
      }
      return r && this.updateLastResult(a), a;
    }, t.prototype.isDifferentFromLastResult = function(r, n) {
      if (!this.last)
        return !0;
      var i = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ? !Qm(this.query, this.last.result, r, this.variables) : !Te(this.last.result, r);
      return i || n && !Te(this.last.variables, n);
    }, t.prototype.getLast = function(r, n) {
      var i = this.last;
      if (i && i[r] && (!n || Te(i.variables, this.variables)))
        return i[r];
    }, t.prototype.getLastResult = function(r) {
      return this.getLast("result", r);
    }, t.prototype.getLastError = function(r) {
      return this.getLast("error", r);
    }, t.prototype.resetLastResults = function() {
      delete this.last, this.isTornDown = !1;
    }, t.prototype.resetQueryStoreErrors = function() {
      this.queryManager.resetErrors(this.queryId);
    }, t.prototype.refetch = function(r) {
      var n, i = {
        // Always disable polling for refetches.
        pollInterval: 0
      }, a = this.options.fetchPolicy;
      if (a === "cache-and-network" ? i.fetchPolicy = a : a === "no-cache" ? i.fetchPolicy = "no-cache" : i.fetchPolicy = "network-only", globalThis.__DEV__ !== !1 && r && T2.call(r, "variables")) {
        var o = vm(this.query), s = o.variableDefinitions;
        (!s || !s.some(function(u) {
          return u.variable.name.value === "variables";
        })) && globalThis.__DEV__ !== !1 && se.warn(
          20,
          r,
          ((n = o.name) === null || n === void 0 ? void 0 : n.value) || o
        );
      }
      return r && !Te(this.options.variables, r) && (i.variables = this.options.variables = B(B({}, this.options.variables), r)), this.queryInfo.resetLastWrite(), this.reobserve(i, Ee.refetch);
    }, t.prototype.fetchMore = function(r) {
      var n = this, i = B(B({}, r.query ? r : B(B(B(B({}, this.options), { query: this.options.query }), r), { variables: B(B({}, this.options.variables), r.variables) })), {
        // The fetchMore request goes immediately to the network and does
        // not automatically write its result to the cache (hence no-cache
        // instead of network-only), because we allow the caller of
        // fetchMore to provide an updateQuery callback that determines how
        // the data gets written to the cache.
        fetchPolicy: "no-cache"
      });
      i.query = this.transformDocument(i.query);
      var a = this.queryManager.generateQueryId();
      this.lastQuery = r.query ? this.transformDocument(this.options.query) : i.query;
      var o = this.queryInfo, s = o.networkStatus;
      o.networkStatus = Ee.fetchMore, i.notifyOnNetworkStatusChange && this.observe();
      var u = /* @__PURE__ */ new Set();
      return this.queryManager.fetchQuery(a, i, Ee.fetchMore).then(function(l) {
        return n.queryManager.removeQuery(a), o.networkStatus === Ee.fetchMore && (o.networkStatus = s), n.queryManager.cache.batch({
          update: function(c) {
            var d = r.updateQuery;
            d ? c.updateQuery({
              query: n.query,
              variables: n.variables,
              returnPartialData: !0,
              optimistic: !1
            }, function(f) {
              return d(f, {
                fetchMoreResult: l.data,
                variables: i.variables
              });
            }) : c.writeQuery({
              query: i.query,
              variables: i.variables,
              data: l.data
            });
          },
          onWatchUpdated: function(c) {
            u.add(c.query);
          }
        }), l;
      }).finally(function() {
        u.has(n.query) || uv(n);
      });
    }, t.prototype.subscribeToMore = function(r) {
      var n = this, i = this.queryManager.startGraphQLSubscription({
        query: r.document,
        variables: r.variables,
        context: r.context
      }).subscribe({
        next: function(a) {
          var o = r.updateQuery;
          o && n.updateQuery(function(s, u) {
            var l = u.variables;
            return o(s, {
              subscriptionData: a,
              variables: l
            });
          });
        },
        error: function(a) {
          if (r.onError) {
            r.onError(a);
            return;
          }
          globalThis.__DEV__ !== !1 && se.error(21, a);
        }
      });
      return this.subscriptions.add(i), function() {
        n.subscriptions.delete(i) && i.unsubscribe();
      };
    }, t.prototype.setOptions = function(r) {
      return this.reobserve(r);
    }, t.prototype.silentSetOptions = function(r) {
      var n = on(this.options, r || {});
      Zf(this.options, n);
    }, t.prototype.setVariables = function(r) {
      return Te(this.variables, r) ? this.observers.size ? this.result() : Promise.resolve() : (this.options.variables = r, this.observers.size ? this.reobserve({
        // Reset options.fetchPolicy to its original value.
        fetchPolicy: this.options.initialFetchPolicy,
        variables: r
      }, Ee.setVariables) : Promise.resolve());
    }, t.prototype.updateQuery = function(r) {
      var n = this.queryManager, i = n.cache.diff({
        query: this.options.query,
        variables: this.variables,
        returnPartialData: !0,
        optimistic: !1
      }).result, a = r(i, {
        variables: this.variables
      });
      a && (n.cache.writeQuery({
        query: this.options.query,
        data: a,
        variables: this.variables
      }), n.broadcastQueries());
    }, t.prototype.startPolling = function(r) {
      this.options.pollInterval = r, this.updatePolling();
    }, t.prototype.stopPolling = function() {
      this.options.pollInterval = 0, this.updatePolling();
    }, t.prototype.applyNextFetchPolicy = function(r, n) {
      if (n.nextFetchPolicy) {
        var i = n.fetchPolicy, a = i === void 0 ? "cache-first" : i, o = n.initialFetchPolicy, s = o === void 0 ? a : o;
        a === "standby" || (typeof n.nextFetchPolicy == "function" ? n.fetchPolicy = n.nextFetchPolicy(a, {
          reason: r,
          options: n,
          observable: this,
          initialFetchPolicy: s
        }) : r === "variables-changed" ? n.fetchPolicy = s : n.fetchPolicy = n.nextFetchPolicy);
      }
      return n.fetchPolicy;
    }, t.prototype.fetch = function(r, n, i) {
      return this.queryManager.setObservableQuery(this), this.queryManager.fetchConcastWithInfo(this.queryId, r, n, i);
    }, t.prototype.updatePolling = function() {
      var r = this;
      if (!this.queryManager.ssrMode) {
        var n = this, i = n.pollingInfo, a = n.options.pollInterval;
        if (!a || !this.hasObservers()) {
          i && (clearTimeout(i.timeout), delete this.pollingInfo);
          return;
        }
        if (!(i && i.interval === a)) {
          se(a, 22);
          var o = i || (this.pollingInfo = {});
          o.interval = a;
          var s = function() {
            var l, c;
            r.pollingInfo && (!aa(r.queryInfo.networkStatus) && !(!((c = (l = r.options).skipPollAttempt) === null || c === void 0) && c.call(l)) ? r.reobserve({
              // Most fetchPolicy options don't make sense to use in a polling context, as
              // users wouldn't want to be polling the cache directly. However, network-only and
              // no-cache are both useful for when the user wants to control whether or not the
              // polled results are written to the cache.
              fetchPolicy: r.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
            }, Ee.poll).then(u, u) : u());
          }, u = function() {
            var l = r.pollingInfo;
            l && (clearTimeout(l.timeout), l.timeout = setTimeout(s, l.interval));
          };
          u();
        }
      }
    }, t.prototype.updateLastResult = function(r, n) {
      n === void 0 && (n = this.variables);
      var i = this.getLastError();
      return i && this.last && !Te(n, this.last.variables) && (i = void 0), this.last = B({ result: this.queryManager.assumeImmutableResults ? r : Bm(r), variables: n }, i ? { error: i } : null);
    }, t.prototype.reobserveAsConcast = function(r, n) {
      var i = this;
      this.isTornDown = !1;
      var a = (
        // Refetching uses a disposable Concast to allow refetches using different
        // options/variables, without permanently altering the options of the
        // original ObservableQuery.
        n === Ee.refetch || // The fetchMore method does not actually call the reobserve method, but,
        // if it did, it would definitely use a disposable Concast.
        n === Ee.fetchMore || // Polling uses a disposable Concast so the polling options (which force
        // fetchPolicy to be "network-only" or "no-cache") won't override the original options.
        n === Ee.poll
      ), o = this.options.variables, s = this.options.fetchPolicy, u = on(this.options, r || {}), l = a ? (
        // Disposable Concast fetches receive a shallow copy of this.options
        // (merged with newOptions), leaving this.options unmodified.
        u
      ) : Zf(this.options, u), c = this.transformDocument(l.query);
      this.lastQuery = c, a || (this.updatePolling(), r && r.variables && !Te(r.variables, o) && // Don't mess with the fetchPolicy if it's currently "standby".
      l.fetchPolicy !== "standby" && // If we're changing the fetchPolicy anyway, don't try to change it here
      // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.
      l.fetchPolicy === s && (this.applyNextFetchPolicy("variables-changed", l), n === void 0 && (n = Ee.setVariables))), this.waitForOwnResult && (this.waitForOwnResult = $u(l.fetchPolicy));
      var d = function() {
        i.concast === p && (i.waitForOwnResult = !1);
      }, f = l.variables && B({}, l.variables), h = this.fetch(l, n, c), p = h.concast, v = h.fromLink, g = {
        next: function($) {
          Te(i.variables, f) && (d(), i.reportResult($, f));
        },
        error: function($) {
          Te(i.variables, f) && (d(), i.reportError($, f));
        }
      };
      return !a && (v || !this.concast) && (this.concast && this.observer && this.concast.removeObserver(this.observer), this.concast = p, this.observer = g), p.addObserver(g), p;
    }, t.prototype.reobserve = function(r, n) {
      return this.reobserveAsConcast(r, n).promise;
    }, t.prototype.resubscribeAfterError = function() {
      for (var r = [], n = 0; n < arguments.length; n++)
        r[n] = arguments[n];
      var i = this.last;
      this.resetLastResults();
      var a = this.subscribe.apply(this, r);
      return this.last = i, a;
    }, t.prototype.observe = function() {
      this.reportResult(
        // Passing false is important so that this.getCurrentResult doesn't
        // save the fetchMore result as this.lastResult, causing it to be
        // ignored due to the this.isDifferentFromLastResult check in
        // this.reportResult.
        this.getCurrentResult(!1),
        this.variables
      );
    }, t.prototype.reportResult = function(r, n) {
      var i = this.getLastError(), a = this.isDifferentFromLastResult(r, n);
      (i || !r.partial || this.options.returnPartialData) && this.updateLastResult(r, n), (i || a) && Vi(this.observers, "next", r);
    }, t.prototype.reportError = function(r, n) {
      var i = B(B({}, this.getLastResult()), { error: r, errors: r.graphQLErrors, networkStatus: Ee.error, loading: !1 });
      this.updateLastResult(i, n), Vi(this.observers, "error", this.last.error = r);
    }, t.prototype.hasObservers = function() {
      return this.observers.size > 0;
    }, t.prototype.tearDownQuery = function() {
      this.isTornDown || (this.concast && this.observer && (this.concast.removeObserver(this.observer), delete this.concast, delete this.observer), this.stopPolling(), this.subscriptions.forEach(function(r) {
        return r.unsubscribe();
      }), this.subscriptions.clear(), this.queryManager.stopQuery(this.queryId), this.observers.clear(), this.isTornDown = !0);
    }, t.prototype.transformDocument = function(r) {
      return this.queryManager.transform(r);
    }, t;
  }(Ce)
);
Mm(kl);
function uv(e) {
  var t = e.options, r = t.fetchPolicy, n = t.nextFetchPolicy;
  return r === "cache-and-network" || r === "network-only" ? e.reobserve({
    fetchPolicy: "cache-first",
    // Use a temporary nextFetchPolicy function that replaces itself with the
    // previous nextFetchPolicy value and returns the original fetchPolicy.
    nextFetchPolicy: function(i, a) {
      return this.nextFetchPolicy = n, typeof this.nextFetchPolicy == "function" ? this.nextFetchPolicy(i, a) : r;
    }
  }) : e.reobserve();
}
function P2(e) {
  globalThis.__DEV__ !== !1 && se.error(23, e.message, e.stack);
}
function lv(e) {
  globalThis.__DEV__ !== !1 && e && globalThis.__DEV__ !== !1 && se.debug(24, e);
}
function $u(e) {
  return e === "network-only" || e === "no-cache" || e === "standby";
}
var cv = (
  /** @class */
  function() {
    function e(t) {
      var r = t.cache, n = t.client, i = t.resolvers, a = t.fragmentMatcher;
      this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap(), this.cache = r, n && (this.client = n), i && this.addResolvers(i), a && this.setFragmentMatcher(a);
    }
    return e.prototype.addResolvers = function(t) {
      var r = this;
      this.resolvers = this.resolvers || {}, Array.isArray(t) ? t.forEach(function(n) {
        r.resolvers = bf(r.resolvers, n);
      }) : this.resolvers = bf(this.resolvers, t);
    }, e.prototype.setResolvers = function(t) {
      this.resolvers = {}, this.addResolvers(t);
    }, e.prototype.getResolvers = function() {
      return this.resolvers || {};
    }, e.prototype.runResolvers = function(t) {
      return kr(this, arguments, void 0, function(r) {
        var n = r.document, i = r.remoteResult, a = r.context, o = r.variables, s = r.onlyRunForcedResolvers, u = s === void 0 ? !1 : s;
        return Tr(this, function(l) {
          return n ? [2, this.resolveDocument(n, i.data, a, o, this.fragmentMatcher, u).then(function(c) {
            return B(B({}, i), { data: c.result });
          })] : [2, i];
        });
      });
    }, e.prototype.setFragmentMatcher = function(t) {
      this.fragmentMatcher = t;
    }, e.prototype.getFragmentMatcher = function() {
      return this.fragmentMatcher;
    }, e.prototype.clientQuery = function(t) {
      return Xi(["client"], t) && this.resolvers ? t : null;
    }, e.prototype.serverQuery = function(t) {
      return Fm(t);
    }, e.prototype.prepareContext = function(t) {
      var r = this.cache;
      return B(B({}, t), {
        cache: r,
        // Getting an entry's cache key is useful for local state resolvers.
        getCacheKey: function(n) {
          return r.identify(n);
        }
      });
    }, e.prototype.addExportedVariables = function(t) {
      return kr(this, arguments, void 0, function(r, n, i) {
        return n === void 0 && (n = {}), i === void 0 && (i = {}), Tr(this, function(a) {
          return r ? [2, this.resolveDocument(r, this.buildRootValueFromCache(r, n) || {}, this.prepareContext(i), n).then(function(o) {
            return B(B({}, n), o.exportedVariables);
          })] : [2, B({}, n)];
        });
      });
    }, e.prototype.shouldForceResolvers = function(t) {
      var r = !1;
      return pr(t, {
        Directive: {
          enter: function(n) {
            if (n.name.value === "client" && n.arguments && (r = n.arguments.some(function(i) {
              return i.name.value === "always" && i.value.kind === "BooleanValue" && i.value.value === !0;
            }), r))
              return _c;
          }
        }
      }), r;
    }, e.prototype.buildRootValueFromCache = function(t, r) {
      return this.cache.diff({
        query: f5(t),
        variables: r,
        returnPartialData: !0,
        optimistic: !1
      }).result;
    }, e.prototype.resolveDocument = function(t, r) {
      return kr(this, arguments, void 0, function(n, i, a, o, s, u) {
        var l, c, d, f, h, p, v, g, $, m, b;
        return a === void 0 && (a = {}), o === void 0 && (o = {}), s === void 0 && (s = function() {
          return !0;
        }), u === void 0 && (u = !1), Tr(this, function(D) {
          return l = Ca(n), c = ws(n), d = xs(c), f = this.collectSelectionsToResolve(l, d), h = l.operation, p = h ? h.charAt(0).toUpperCase() + h.slice(1) : "Query", v = this, g = v.cache, $ = v.client, m = {
            fragmentMap: d,
            context: B(B({}, a), { cache: g, client: $ }),
            variables: o,
            fragmentMatcher: s,
            defaultOperationType: p,
            exportedVariables: {},
            selectionsToResolve: f,
            onlyRunForcedResolvers: u
          }, b = !1, [2, this.resolveSelectionSet(l.selectionSet, b, i, m).then(function(S) {
            return {
              result: S,
              exportedVariables: m.exportedVariables
            };
          })];
        });
      });
    }, e.prototype.resolveSelectionSet = function(t, r, n, i) {
      return kr(this, void 0, void 0, function() {
        var a, o, s, u, l, c = this;
        return Tr(this, function(d) {
          return a = i.fragmentMap, o = i.context, s = i.variables, u = [n], l = function(f) {
            return kr(c, void 0, void 0, function() {
              var h, p;
              return Tr(this, function(v) {
                return !r && !i.selectionsToResolve.has(f) ? [
                  2
                  /*return*/
                ] : Da(f, s) ? Br(f) ? [2, this.resolveField(f, r, n, i).then(function(g) {
                  var $;
                  typeof g < "u" && u.push(($ = {}, $[Rr(f)] = g, $));
                })] : (HD(f) ? h = f : (h = a[f.name.value], se(h, 18, f.name.value)), h && h.typeCondition && (p = h.typeCondition.name.value, i.fragmentMatcher(n, p, o)) ? [2, this.resolveSelectionSet(h.selectionSet, r, n, i).then(function(g) {
                  u.push(g);
                })] : [
                  2
                  /*return*/
                ]) : [
                  2
                  /*return*/
                ];
              });
            });
          }, [2, Promise.all(t.selections.map(l)).then(function() {
            return Ts(u);
          })];
        });
      });
    }, e.prototype.resolveField = function(t, r, n, i) {
      return kr(this, void 0, void 0, function() {
        var a, o, s, u, l, c, d, f, h, p = this;
        return Tr(this, function(v) {
          return n ? (a = i.variables, o = t.name.value, s = Rr(t), u = o !== s, l = n[s] || n[o], c = Promise.resolve(l), (!i.onlyRunForcedResolvers || this.shouldForceResolvers(t)) && (d = n.__typename || i.defaultOperationType, f = this.resolvers && this.resolvers[d], f && (h = f[u ? o : s], h && (c = Promise.resolve(
            // In case the resolve function accesses reactive variables,
            // set cacheSlot to the current cache instance.
            Hc.withValue(this.cache, h, [
              n,
              Es(t, a),
              i.context,
              { field: t, fragmentMap: i.fragmentMap }
            ])
          )))), [2, c.then(function(g) {
            var $, m;
            if (g === void 0 && (g = l), t.directives && t.directives.forEach(function(D) {
              D.name.value === "export" && D.arguments && D.arguments.forEach(function(S) {
                S.name.value === "as" && S.value.kind === "StringValue" && (i.exportedVariables[S.value.value] = g);
              });
            }), !t.selectionSet || g == null)
              return g;
            var b = (m = ($ = t.directives) === null || $ === void 0 ? void 0 : $.some(function(D) {
              return D.name.value === "client";
            })) !== null && m !== void 0 ? m : !1;
            if (Array.isArray(g))
              return p.resolveSubSelectedArray(t, r || b, g, i);
            if (t.selectionSet)
              return p.resolveSelectionSet(t.selectionSet, r || b, g, i);
          })]) : [2, null];
        });
      });
    }, e.prototype.resolveSubSelectedArray = function(t, r, n, i) {
      var a = this;
      return Promise.all(n.map(function(o) {
        if (o === null)
          return null;
        if (Array.isArray(o))
          return a.resolveSubSelectedArray(t, r, o, i);
        if (t.selectionSet)
          return a.resolveSelectionSet(t.selectionSet, r, o, i);
      }));
    }, e.prototype.collectSelectionsToResolve = function(t, r) {
      var n = function(o) {
        return !Array.isArray(o);
      }, i = this.selectionsToResolveCache;
      function a(o) {
        if (!i.has(o)) {
          var s = /* @__PURE__ */ new Set();
          i.set(o, s), pr(o, {
            Directive: function(u, l, c, d, f) {
              u.name.value === "client" && f.forEach(function(h) {
                n(h) && lf(h) && s.add(h);
              });
            },
            FragmentSpread: function(u, l, c, d, f) {
              var h = r[u.name.value];
              se(h, 19, u.name.value);
              var p = a(h);
              p.size > 0 && (f.forEach(function(v) {
                n(v) && lf(v) && s.add(v);
              }), s.add(u), p.forEach(function(v) {
                s.add(v);
              }));
            }
          });
        }
        return i.get(o);
      }
      return a(t);
    }, e;
  }()
), In = new (mn ? WeakMap : Map)();
function xu(e, t) {
  var r = e[t];
  typeof r == "function" && (e[t] = function() {
    return In.set(
      e,
      // The %1e15 allows the count to wrap around to 0 safely every
      // quadrillion evictions, so there's no risk of overflow. To be
      // clear, this is more of a pedantic principle than something
      // that matters in any conceivable practical scenario.
      (In.get(e) + 1) % 1e15
    ), r.apply(this, arguments);
  });
}
function Yf(e) {
  e.notifyTimeout && (clearTimeout(e.notifyTimeout), e.notifyTimeout = void 0);
}
var Du = (
  /** @class */
  function() {
    function e(t, r) {
      r === void 0 && (r = t.generateQueryId()), this.queryId = r, this.listeners = /* @__PURE__ */ new Set(), this.document = null, this.lastRequestId = 1, this.stopped = !1, this.dirty = !1, this.observableQuery = null;
      var n = this.cache = t.cache;
      In.has(n) || (In.set(n, 0), xu(n, "evict"), xu(n, "modify"), xu(n, "reset"));
    }
    return e.prototype.init = function(t) {
      var r = t.networkStatus || Ee.loading;
      return this.variables && this.networkStatus !== Ee.loading && !Te(this.variables, t.variables) && (r = Ee.setVariables), Te(t.variables, this.variables) || (this.lastDiff = void 0), Object.assign(this, {
        document: t.document,
        variables: t.variables,
        networkError: null,
        graphQLErrors: this.graphQLErrors || [],
        networkStatus: r
      }), t.observableQuery && this.setObservableQuery(t.observableQuery), t.lastRequestId && (this.lastRequestId = t.lastRequestId), this;
    }, e.prototype.reset = function() {
      Yf(this), this.dirty = !1;
    }, e.prototype.resetDiff = function() {
      this.lastDiff = void 0;
    }, e.prototype.getDiff = function() {
      var t = this.getDiffOptions();
      if (this.lastDiff && Te(t, this.lastDiff.options))
        return this.lastDiff.diff;
      this.updateWatch(this.variables);
      var r = this.observableQuery;
      if (r && r.options.fetchPolicy === "no-cache")
        return { complete: !1 };
      var n = this.cache.diff(t);
      return this.updateLastDiff(n, t), n;
    }, e.prototype.updateLastDiff = function(t, r) {
      this.lastDiff = t ? {
        diff: t,
        options: r || this.getDiffOptions()
      } : void 0;
    }, e.prototype.getDiffOptions = function(t) {
      var r;
      return t === void 0 && (t = this.variables), {
        query: this.document,
        variables: t,
        returnPartialData: !0,
        optimistic: !0,
        canonizeResults: (r = this.observableQuery) === null || r === void 0 ? void 0 : r.options.canonizeResults
      };
    }, e.prototype.setDiff = function(t) {
      var r = this, n, i = this.lastDiff && this.lastDiff.diff;
      t && !t.complete && (!((n = this.observableQuery) === null || n === void 0) && n.getLastError()) || (this.updateLastDiff(t), !this.dirty && !Te(i && i.result, t && t.result) && (this.dirty = !0, this.notifyTimeout || (this.notifyTimeout = setTimeout(function() {
        return r.notify();
      }, 0))));
    }, e.prototype.setObservableQuery = function(t) {
      var r = this;
      t !== this.observableQuery && (this.oqListener && this.listeners.delete(this.oqListener), this.observableQuery = t, t ? (t.queryInfo = this, this.listeners.add(this.oqListener = function() {
        var n = r.getDiff();
        n.fromOptimisticTransaction ? t.observe() : uv(t);
      })) : delete this.oqListener);
    }, e.prototype.notify = function() {
      var t = this;
      Yf(this), this.shouldNotify() && this.listeners.forEach(function(r) {
        return r(t);
      }), this.dirty = !1;
    }, e.prototype.shouldNotify = function() {
      if (!this.dirty || !this.listeners.size)
        return !1;
      if (aa(this.networkStatus) && this.observableQuery) {
        var t = this.observableQuery.options.fetchPolicy;
        if (t !== "cache-only" && t !== "cache-and-network")
          return !1;
      }
      return !0;
    }, e.prototype.stop = function() {
      if (!this.stopped) {
        this.stopped = !0, this.reset(), this.cancel(), this.cancel = e.prototype.cancel;
        var t = this.observableQuery;
        t && t.stopPolling();
      }
    }, e.prototype.cancel = function() {
    }, e.prototype.updateWatch = function(t) {
      var r = this;
      t === void 0 && (t = this.variables);
      var n = this.observableQuery;
      if (!(n && n.options.fetchPolicy === "no-cache")) {
        var i = B(B({}, this.getDiffOptions(t)), { watcher: this, callback: function(a) {
          return r.setDiff(a);
        } });
        (!this.lastWatch || !Te(i, this.lastWatch)) && (this.cancel(), this.cancel = this.cache.watch(this.lastWatch = i));
      }
    }, e.prototype.resetLastWrite = function() {
      this.lastWrite = void 0;
    }, e.prototype.shouldWrite = function(t, r) {
      var n = this.lastWrite;
      return !(n && // If cache.evict has been called since the last time we wrote this
      // data into the cache, there's a chance writing this result into
      // the cache will repair what was evicted.
      n.dmCount === In.get(this.cache) && Te(r, n.variables) && Te(t.data, n.result.data));
    }, e.prototype.markResult = function(t, r, n, i) {
      var a = this, o = new Nr(), s = Ft(t.errors) ? t.errors.slice(0) : [];
      if (this.reset(), "incremental" in t && Ft(t.incremental)) {
        var u = Nm(this.getDiff().result, t);
        t.data = u;
      } else if ("hasNext" in t && t.hasNext) {
        var l = this.getDiff();
        t.data = o.merge(l.result, t.data);
      }
      this.graphQLErrors = s, n.fetchPolicy === "no-cache" ? this.updateLastDiff({ result: t.data, complete: !0 }, this.getDiffOptions(n.variables)) : i !== 0 && (Tl(t, n.errorPolicy) ? this.cache.performTransaction(function(c) {
        if (a.shouldWrite(t, n.variables))
          c.writeQuery({
            query: r,
            data: t.data,
            variables: n.variables,
            overwrite: i === 1
          }), a.lastWrite = {
            result: t,
            variables: n.variables,
            dmCount: In.get(a.cache)
          };
        else if (a.lastDiff && a.lastDiff.diff.complete) {
          t.data = a.lastDiff.diff.result;
          return;
        }
        var d = a.getDiffOptions(n.variables), f = c.diff(d);
        !a.stopped && Te(a.variables, n.variables) && a.updateWatch(n.variables), a.updateLastDiff(f, d), f.complete && (t.data = f.result);
      }) : this.lastWrite = void 0);
    }, e.prototype.markReady = function() {
      return this.networkError = null, this.networkStatus = Ee.ready;
    }, e.prototype.markError = function(t) {
      return this.networkStatus = Ee.error, this.lastWrite = void 0, this.reset(), t.graphQLErrors && (this.graphQLErrors = t.graphQLErrors), t.networkError && (this.networkError = t.networkError), t;
    }, e;
  }()
);
function Tl(e, t) {
  t === void 0 && (t = "none");
  var r = t === "ignore" || t === "all", n = !mo(e);
  return !n && r && e.data && (n = !0), n;
}
var A2 = Object.prototype.hasOwnProperty, Jf = /* @__PURE__ */ Object.create(null), _2 = (
  /** @class */
  function() {
    function e(t) {
      var r = t.cache, n = t.link, i = t.defaultOptions, a = t.documentTransform, o = t.queryDeduplication, s = o === void 0 ? !1 : o, u = t.onBroadcast, l = t.ssrMode, c = l === void 0 ? !1 : l, d = t.clientAwareness, f = d === void 0 ? {} : d, h = t.localState, p = t.assumeImmutableResults, v = p === void 0 ? !!r.assumeImmutableResults : p, g = t.defaultContext, $ = this;
      this.clientAwareness = {}, this.queries = /* @__PURE__ */ new Map(), this.fetchCancelFns = /* @__PURE__ */ new Map(), this.transformCache = new Oc(
        Zt["queryManager.getDocumentInfo"] || 2e3
        /* defaultCacheSizes["queryManager.getDocumentInfo"] */
      ), this.queryIdCounter = 1, this.requestIdCounter = 1, this.mutationIdCounter = 1, this.inFlightLinkObservables = new li(!1);
      var m = new Pm(
        function(b) {
          return $.cache.transformDocument(b);
        },
        // Allow the apollo cache to manage its own transform caches
        { cache: !1 }
      );
      this.cache = r, this.link = n, this.defaultOptions = i || /* @__PURE__ */ Object.create(null), this.queryDeduplication = s, this.clientAwareness = f, this.localState = h || new cv({ cache: r }), this.ssrMode = c, this.assumeImmutableResults = v, this.documentTransform = a ? m.concat(a).concat(m) : m, this.defaultContext = g || /* @__PURE__ */ Object.create(null), (this.onBroadcast = u) && (this.mutationStore = /* @__PURE__ */ Object.create(null));
    }
    return e.prototype.stop = function() {
      var t = this;
      this.queries.forEach(function(r, n) {
        t.stopQueryNoBroadcast(n);
      }), this.cancelPendingFetches(ht(25));
    }, e.prototype.cancelPendingFetches = function(t) {
      this.fetchCancelFns.forEach(function(r) {
        return r(t);
      }), this.fetchCancelFns.clear();
    }, e.prototype.mutate = function(t) {
      return kr(this, arguments, void 0, function(r) {
        var n, i, a, o, s, u, l, c = r.mutation, d = r.variables, f = r.optimisticResponse, h = r.updateQueries, p = r.refetchQueries, v = p === void 0 ? [] : p, g = r.awaitRefetchQueries, $ = g === void 0 ? !1 : g, m = r.update, b = r.onQueryUpdated, D = r.fetchPolicy, S = D === void 0 ? ((u = this.defaultOptions.mutate) === null || u === void 0 ? void 0 : u.fetchPolicy) || "network-only" : D, T = r.errorPolicy, R = T === void 0 ? ((l = this.defaultOptions.mutate) === null || l === void 0 ? void 0 : l.errorPolicy) || "none" : T, y = r.keepRootFields, A = r.context;
        return Tr(this, function(w) {
          switch (w.label) {
            case 0:
              return se(c, 26), se(S === "network-only" || S === "no-cache", 27), n = this.generateMutationId(), c = this.cache.transformForLink(this.transform(c)), i = this.getDocumentInfo(c).hasClientExports, d = this.getVariables(c, d), i ? [4, this.localState.addExportedVariables(c, d, A)] : [3, 2];
            case 1:
              d = w.sent(), w.label = 2;
            case 2:
              return a = this.mutationStore && (this.mutationStore[n] = {
                mutation: c,
                variables: d,
                loading: !0,
                error: null
              }), o = f && this.markMutationOptimistic(f, {
                mutationId: n,
                document: c,
                variables: d,
                fetchPolicy: S,
                errorPolicy: R,
                context: A,
                updateQueries: h,
                update: m,
                keepRootFields: y
              }), this.broadcastQueries(), s = this, [2, new Promise(function(E, k) {
                return mu(s.getObservableFromLink(c, B(B({}, A), { optimisticResponse: o ? f : void 0 }), d, !1), function(C) {
                  if (mo(C) && R === "none")
                    throw new or({
                      graphQLErrors: $l(C)
                    });
                  a && (a.loading = !1, a.error = null);
                  var P = B({}, C);
                  return typeof v == "function" && (v = v(P)), R === "ignore" && mo(P) && delete P.errors, s.markMutationResult({
                    mutationId: n,
                    result: P,
                    document: c,
                    variables: d,
                    fetchPolicy: S,
                    errorPolicy: R,
                    context: A,
                    update: m,
                    updateQueries: h,
                    awaitRefetchQueries: $,
                    refetchQueries: v,
                    removeOptimistic: o ? n : void 0,
                    onQueryUpdated: b,
                    keepRootFields: y
                  });
                }).subscribe({
                  next: function(C) {
                    s.broadcastQueries(), (!("hasNext" in C) || C.hasNext === !1) && E(C);
                  },
                  error: function(C) {
                    a && (a.loading = !1, a.error = C), o && s.cache.removeOptimistic(n), s.broadcastQueries(), k(C instanceof or ? C : new or({
                      networkError: C
                    }));
                  }
                });
              })];
          }
        });
      });
    }, e.prototype.markMutationResult = function(t, r) {
      var n = this;
      r === void 0 && (r = this.cache);
      var i = t.result, a = [], o = t.fetchPolicy === "no-cache";
      if (!o && Tl(i, t.errorPolicy)) {
        if (jn(i) || a.push({
          result: i.data,
          dataId: "ROOT_MUTATION",
          query: t.document,
          variables: t.variables
        }), jn(i) && Ft(i.incremental)) {
          var s = r.diff({
            id: "ROOT_MUTATION",
            // The cache complains if passed a mutation where it expects a
            // query, so we transform mutations and subscriptions to queries
            // (only once, thanks to this.transformCache).
            query: this.getDocumentInfo(t.document).asQuery,
            variables: t.variables,
            optimistic: !1,
            returnPartialData: !0
          }), u = void 0;
          s.result && (u = Nm(s.result, i)), typeof u < "u" && (i.data = u, a.push({
            result: u,
            dataId: "ROOT_MUTATION",
            query: t.document,
            variables: t.variables
          }));
        }
        var l = t.updateQueries;
        l && this.queries.forEach(function(d, f) {
          var h = d.observableQuery, p = h && h.queryName;
          if (!(!p || !A2.call(l, p))) {
            var v = l[p], g = n.queries.get(f), $ = g.document, m = g.variables, b = r.diff({
              query: $,
              variables: m,
              returnPartialData: !0,
              optimistic: !1
            }), D = b.result, S = b.complete;
            if (S && D) {
              var T = v(D, {
                mutationResult: i,
                queryName: $ && vl($) || void 0,
                queryVariables: m
              });
              T && a.push({
                result: T,
                dataId: "ROOT_QUERY",
                query: $,
                variables: m
              });
            }
          }
        });
      }
      if (a.length > 0 || (t.refetchQueries || "").length > 0 || t.update || t.onQueryUpdated || t.removeOptimistic) {
        var c = [];
        if (this.refetchQueries({
          updateCache: function(d) {
            o || a.forEach(function(v) {
              return d.write(v);
            });
            var f = t.update, h = !k5(i) || jn(i) && !i.hasNext;
            if (f) {
              if (!o) {
                var p = d.diff({
                  id: "ROOT_MUTATION",
                  // The cache complains if passed a mutation where it expects a
                  // query, so we transform mutations and subscriptions to queries
                  // (only once, thanks to this.transformCache).
                  query: n.getDocumentInfo(t.document).asQuery,
                  variables: t.variables,
                  optimistic: !1,
                  returnPartialData: !0
                });
                p.complete && (i = B(B({}, i), { data: p.result }), "incremental" in i && delete i.incremental, "hasNext" in i && delete i.hasNext);
              }
              h && f(d, i, {
                context: t.context,
                variables: t.variables
              });
            }
            !o && !t.keepRootFields && h && d.modify({
              id: "ROOT_MUTATION",
              fields: function(v, g) {
                var $ = g.fieldName, m = g.DELETE;
                return $ === "__typename" ? v : m;
              }
            });
          },
          include: t.refetchQueries,
          // Write the final mutation.result to the root layer of the cache.
          optimistic: !1,
          // Remove the corresponding optimistic layer at the same time as we
          // write the final non-optimistic result.
          removeOptimistic: t.removeOptimistic,
          // Let the caller of client.mutate optionally determine the refetching
          // behavior for watched queries after the mutation.update function runs.
          // If no onQueryUpdated function was provided for this mutation, pass
          // null instead of undefined to disable the default refetching behavior.
          onQueryUpdated: t.onQueryUpdated || null
        }).forEach(function(d) {
          return c.push(d);
        }), t.awaitRefetchQueries || t.onQueryUpdated)
          return Promise.all(c).then(function() {
            return i;
          });
      }
      return Promise.resolve(i);
    }, e.prototype.markMutationOptimistic = function(t, r) {
      var n = this, i = typeof t == "function" ? t(r.variables, { IGNORE: Jf }) : t;
      return i === Jf ? !1 : (this.cache.recordOptimisticTransaction(function(a) {
        try {
          n.markMutationResult(B(B({}, r), { result: { data: i } }), a);
        } catch (o) {
          globalThis.__DEV__ !== !1 && se.error(o);
        }
      }, r.mutationId), !0);
    }, e.prototype.fetchQuery = function(t, r, n) {
      return this.fetchConcastWithInfo(t, r, n).concast.promise;
    }, e.prototype.getQueryStore = function() {
      var t = /* @__PURE__ */ Object.create(null);
      return this.queries.forEach(function(r, n) {
        t[n] = {
          variables: r.variables,
          networkStatus: r.networkStatus,
          networkError: r.networkError,
          graphQLErrors: r.graphQLErrors
        };
      }), t;
    }, e.prototype.resetErrors = function(t) {
      var r = this.queries.get(t);
      r && (r.networkError = void 0, r.graphQLErrors = []);
    }, e.prototype.transform = function(t) {
      return this.documentTransform.transformDocument(t);
    }, e.prototype.getDocumentInfo = function(t) {
      var r = this.transformCache;
      if (!r.has(t)) {
        var n = {
          // TODO These three calls (hasClientExports, shouldForceResolvers, and
          // usesNonreactiveDirective) are performing independent full traversals
          // of the transformed document. We should consider merging these
          // traversals into a single pass in the future, though the work is
          // cached after the first time.
          hasClientExports: oD(t),
          hasForcedResolvers: this.localState.shouldForceResolvers(t),
          hasNonreactiveDirective: Xi(["nonreactive"], t),
          clientQuery: this.localState.clientQuery(t),
          serverQuery: _m([
            { name: "client", remove: !0 },
            { name: "connection" },
            { name: "nonreactive" }
          ], t),
          defaultVars: Rc(wa(t)),
          // Transform any mutation or subscription operations to query operations
          // so we can read/write them from/to the cache.
          asQuery: B(B({}, t), { definitions: t.definitions.map(function(i) {
            return i.kind === "OperationDefinition" && i.operation !== "query" ? B(B({}, i), { operation: "query" }) : i;
          }) })
        };
        r.set(t, n);
      }
      return r.get(t);
    }, e.prototype.getVariables = function(t, r) {
      return B(B({}, this.getDocumentInfo(t).defaultVars), r);
    }, e.prototype.watchQuery = function(t) {
      var r = this.transform(t.query);
      t = B(B({}, t), { variables: this.getVariables(r, t.variables) }), typeof t.notifyOnNetworkStatusChange > "u" && (t.notifyOnNetworkStatusChange = !1);
      var n = new Du(this), i = new kl({
        queryManager: this,
        queryInfo: n,
        options: t
      });
      return i.lastQuery = r, this.queries.set(i.queryId, n), n.init({
        document: r,
        observableQuery: i,
        variables: i.variables
      }), i;
    }, e.prototype.query = function(t, r) {
      var n = this;
      return r === void 0 && (r = this.generateQueryId()), se(t.query, 28), se(t.query.kind === "Document", 29), se(!t.returnPartialData, 30), se(!t.pollInterval, 31), this.fetchQuery(r, B(B({}, t), { query: this.transform(t.query) })).finally(function() {
        return n.stopQuery(r);
      });
    }, e.prototype.generateQueryId = function() {
      return String(this.queryIdCounter++);
    }, e.prototype.generateRequestId = function() {
      return this.requestIdCounter++;
    }, e.prototype.generateMutationId = function() {
      return String(this.mutationIdCounter++);
    }, e.prototype.stopQueryInStore = function(t) {
      this.stopQueryInStoreNoBroadcast(t), this.broadcastQueries();
    }, e.prototype.stopQueryInStoreNoBroadcast = function(t) {
      var r = this.queries.get(t);
      r && r.stop();
    }, e.prototype.clearStore = function(t) {
      return t === void 0 && (t = {
        discardWatches: !0
      }), this.cancelPendingFetches(ht(32)), this.queries.forEach(function(r) {
        r.observableQuery ? r.networkStatus = Ee.loading : r.stop();
      }), this.mutationStore && (this.mutationStore = /* @__PURE__ */ Object.create(null)), this.cache.reset(t);
    }, e.prototype.getObservableQueries = function(t) {
      var r = this;
      t === void 0 && (t = "active");
      var n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set();
      return Array.isArray(t) && t.forEach(function(o) {
        typeof o == "string" ? i.set(o, !1) : ID(o) ? i.set(r.transform(o), !1) : Ue(o) && o.query && a.add(o);
      }), this.queries.forEach(function(o, s) {
        var u = o.observableQuery, l = o.document;
        if (u) {
          if (t === "all") {
            n.set(s, u);
            return;
          }
          var c = u.queryName, d = u.options.fetchPolicy;
          if (d === "standby" || t === "active" && !u.hasObservers())
            return;
          (t === "active" || c && i.has(c) || l && i.has(l)) && (n.set(s, u), c && i.set(c, !0), l && i.set(l, !0));
        }
      }), a.size && a.forEach(function(o) {
        var s = sl("legacyOneTimeQuery"), u = r.getQuery(s).init({
          document: o.query,
          variables: o.variables
        }), l = new kl({
          queryManager: r,
          queryInfo: u,
          options: B(B({}, o), { fetchPolicy: "network-only" })
        });
        se(l.queryId === s), u.setObservableQuery(l), n.set(s, l);
      }), globalThis.__DEV__ !== !1 && i.size && i.forEach(function(o, s) {
        o || globalThis.__DEV__ !== !1 && se.warn(typeof s == "string" ? 33 : 34, s);
      }), n;
    }, e.prototype.reFetchObservableQueries = function(t) {
      var r = this;
      t === void 0 && (t = !1);
      var n = [];
      return this.getObservableQueries(t ? "all" : "active").forEach(function(i, a) {
        var o = i.options.fetchPolicy;
        i.resetLastResults(), (t || o !== "standby" && o !== "cache-only") && n.push(i.refetch()), r.getQuery(a).setDiff(null);
      }), this.broadcastQueries(), Promise.all(n);
    }, e.prototype.setObservableQuery = function(t) {
      this.getQuery(t.queryId).setObservableQuery(t);
    }, e.prototype.startGraphQLSubscription = function(t) {
      var r = this, n = t.query, i = t.fetchPolicy, a = t.errorPolicy, o = a === void 0 ? "none" : a, s = t.variables, u = t.context, l = u === void 0 ? {} : u;
      n = this.transform(n), s = this.getVariables(n, s);
      var c = function(f) {
        return r.getObservableFromLink(n, l, f).map(function(h) {
          i !== "no-cache" && (Tl(h, o) && r.cache.write({
            query: n,
            result: h.data,
            dataId: "ROOT_SUBSCRIPTION",
            variables: f
          }), r.broadcastQueries());
          var p = mo(h), v = U5(h);
          if (p || v) {
            var g = {};
            if (p && (g.graphQLErrors = h.errors), v && (g.protocolErrors = h.extensions[qc]), o === "none" || v)
              throw new or(g);
          }
          return o === "ignore" && delete h.errors, h;
        });
      };
      if (this.getDocumentInfo(n).hasClientExports) {
        var d = this.localState.addExportedVariables(n, s, l).then(c);
        return new Ce(function(f) {
          var h = null;
          return d.then(function(p) {
            return h = p.subscribe(f);
          }, f.error), function() {
            return h && h.unsubscribe();
          };
        });
      }
      return c(s);
    }, e.prototype.stopQuery = function(t) {
      this.stopQueryNoBroadcast(t), this.broadcastQueries();
    }, e.prototype.stopQueryNoBroadcast = function(t) {
      this.stopQueryInStoreNoBroadcast(t), this.removeQuery(t);
    }, e.prototype.removeQuery = function(t) {
      this.fetchCancelFns.delete(t), this.queries.has(t) && (this.getQuery(t).stop(), this.queries.delete(t));
    }, e.prototype.broadcastQueries = function() {
      this.onBroadcast && this.onBroadcast(), this.queries.forEach(function(t) {
        return t.notify();
      });
    }, e.prototype.getLocalState = function() {
      return this.localState;
    }, e.prototype.getObservableFromLink = function(t, r, n, i) {
      var a = this, o;
      i === void 0 && (i = (o = r == null ? void 0 : r.queryDeduplication) !== null && o !== void 0 ? o : this.queryDeduplication);
      var s, u = this.getDocumentInfo(t), l = u.serverQuery, c = u.clientQuery;
      if (l) {
        var d = this, f = d.inFlightLinkObservables, h = d.link, p = {
          query: l,
          variables: n,
          operationName: vl(l) || void 0,
          context: this.prepareContext(B(B({}, r), { forceFetch: !i }))
        };
        if (r = p.context, i) {
          var v = ks(l), g = Ir(n), $ = f.lookup(v, g);
          if (s = $.observable, !s) {
            var m = new kn([
              xl(h, p)
            ]);
            s = $.observable = m, m.beforeNext(function() {
              f.remove(v, g);
            });
          }
        } else
          s = new kn([
            xl(h, p)
          ]);
      } else
        s = new kn([Ce.of({ data: {} })]), r = this.prepareContext(r);
      return c && (s = mu(s, function(b) {
        return a.localState.runResolvers({
          document: c,
          remoteResult: b,
          context: r,
          variables: n
        });
      })), s;
    }, e.prototype.getResultsFromLink = function(t, r, n) {
      var i = t.lastRequestId = this.generateRequestId(), a = this.cache.transformForLink(n.query);
      return mu(this.getObservableFromLink(a, n.context, n.variables), function(o) {
        var s = $l(o), u = s.length > 0;
        if (i >= t.lastRequestId) {
          if (u && n.errorPolicy === "none")
            throw t.markError(new or({
              graphQLErrors: s
            }));
          t.markResult(o, a, n, r), t.markReady();
        }
        var l = {
          data: o.data,
          loading: !1,
          networkStatus: Ee.ready
        };
        return u && n.errorPolicy !== "ignore" && (l.errors = s, l.networkStatus = Ee.error), l;
      }, function(o) {
        var s = q5(o) ? o : new or({ networkError: o });
        throw i >= t.lastRequestId && t.markError(s), s;
      });
    }, e.prototype.fetchConcastWithInfo = function(t, r, n, i) {
      var a = this;
      n === void 0 && (n = Ee.loading), i === void 0 && (i = r.query);
      var o = this.getVariables(i, r.variables), s = this.getQuery(t), u = this.defaultOptions.watchQuery, l = r.fetchPolicy, c = l === void 0 ? u && u.fetchPolicy || "cache-first" : l, d = r.errorPolicy, f = d === void 0 ? u && u.errorPolicy || "none" : d, h = r.returnPartialData, p = h === void 0 ? !1 : h, v = r.notifyOnNetworkStatusChange, g = v === void 0 ? !1 : v, $ = r.context, m = $ === void 0 ? {} : $, b = Object.assign({}, r, {
        query: i,
        variables: o,
        fetchPolicy: c,
        errorPolicy: f,
        returnPartialData: p,
        notifyOnNetworkStatusChange: g,
        context: m
      }), D = function(A) {
        b.variables = A;
        var w = a.fetchQueryByPolicy(s, b, n);
        return (
          // If we're in standby, postpone advancing options.fetchPolicy using
          // applyNextFetchPolicy.
          b.fetchPolicy !== "standby" && // The "standby" policy currently returns [] from fetchQueryByPolicy, so
          // this is another way to detect when nothing was done/fetched.
          w.sources.length > 0 && s.observableQuery && s.observableQuery.applyNextFetchPolicy("after-fetch", r), w
        );
      }, S = function() {
        return a.fetchCancelFns.delete(t);
      };
      this.fetchCancelFns.set(t, function(A) {
        S(), setTimeout(function() {
          return T.cancel(A);
        });
      });
      var T, R;
      if (this.getDocumentInfo(b.query).hasClientExports)
        T = new kn(this.localState.addExportedVariables(b.query, b.variables, b.context).then(D).then(function(A) {
          return A.sources;
        })), R = !0;
      else {
        var y = D(b.variables);
        R = y.fromLink, T = new kn(y.sources);
      }
      return T.promise.then(S, S), {
        concast: T,
        fromLink: R
      };
    }, e.prototype.refetchQueries = function(t) {
      var r = this, n = t.updateCache, i = t.include, a = t.optimistic, o = a === void 0 ? !1 : a, s = t.removeOptimistic, u = s === void 0 ? o ? sl("refetchQueries") : void 0 : s, l = t.onQueryUpdated, c = /* @__PURE__ */ new Map();
      i && this.getObservableQueries(i).forEach(function(f, h) {
        c.set(h, {
          oq: f,
          lastDiff: r.getQuery(h).getDiff()
        });
      });
      var d = /* @__PURE__ */ new Map();
      return n && this.cache.batch({
        update: n,
        // Since you can perform any combination of cache reads and/or writes in
        // the cache.batch update function, its optimistic option can be either
        // a boolean or a string, representing three distinct modes of
        // operation:
        //
        // * false: read/write only the root layer
        // * true: read/write the topmost layer
        // * string: read/write a fresh optimistic layer with that ID string
        //
        // When typeof optimistic === "string", a new optimistic layer will be
        // temporarily created within cache.batch with that string as its ID. If
        // we then pass that same string as the removeOptimistic option, we can
        // make cache.batch immediately remove the optimistic layer after
        // running the updateCache function, triggering only one broadcast.
        //
        // However, the refetchQueries method accepts only true or false for its
        // optimistic option (not string). We interpret true to mean a temporary
        // optimistic layer should be created, to allow efficiently rolling back
        // the effect of the updateCache function, which involves passing a
        // string instead of true as the optimistic option to cache.batch, when
        // refetchQueries receives optimistic: true.
        //
        // In other words, we are deliberately not supporting the use case of
        // writing to an *existing* optimistic layer (using the refetchQueries
        // updateCache function), since that would potentially interfere with
        // other optimistic updates in progress. Instead, you can read/write
        // only the root layer by passing optimistic: false to refetchQueries,
        // or you can read/write a brand new optimistic layer that will be
        // automatically removed by passing optimistic: true.
        optimistic: o && u || !1,
        // The removeOptimistic option can also be provided by itself, even if
        // optimistic === false, to remove some previously-added optimistic
        // layer safely and efficiently, like we do in markMutationResult.
        //
        // If an explicit removeOptimistic string is provided with optimistic:
        // true, the removeOptimistic string will determine the ID of the
        // temporary optimistic layer, in case that ever matters.
        removeOptimistic: u,
        onWatchUpdated: function(f, h, p) {
          var v = f.watcher instanceof Du && f.watcher.observableQuery;
          if (v) {
            if (l) {
              c.delete(v.queryId);
              var g = l(v, h, p);
              return g === !0 && (g = v.refetch()), g !== !1 && d.set(v, g), g;
            }
            l !== null && c.set(v.queryId, { oq: v, lastDiff: p, diff: h });
          }
        }
      }), c.size && c.forEach(function(f, h) {
        var p = f.oq, v = f.lastDiff, g = f.diff, $;
        if (l) {
          if (!g) {
            var m = p.queryInfo;
            m.reset(), g = m.getDiff();
          }
          $ = l(p, g, v);
        }
        (!l || $ === !0) && ($ = p.refetch()), $ !== !1 && d.set(p, $), h.indexOf("legacyOneTimeQuery") >= 0 && r.stopQueryNoBroadcast(h);
      }), u && this.cache.removeOptimistic(u), d;
    }, e.prototype.fetchQueryByPolicy = function(t, r, n) {
      var i = this, a = r.query, o = r.variables, s = r.fetchPolicy, u = r.refetchWritePolicy, l = r.errorPolicy, c = r.returnPartialData, d = r.context, f = r.notifyOnNetworkStatusChange, h = t.networkStatus;
      t.init({
        document: a,
        variables: o,
        networkStatus: n
      });
      var p = function() {
        return t.getDiff();
      }, v = function(D, S) {
        S === void 0 && (S = t.networkStatus || Ee.loading);
        var T = D.result;
        globalThis.__DEV__ !== !1 && !c && !Te(T, {}) && lv(D.missing);
        var R = function(y) {
          return Ce.of(B({ data: y, loading: aa(S), networkStatus: S }, D.complete ? null : { partial: !0 }));
        };
        return T && i.getDocumentInfo(a).hasForcedResolvers ? i.localState.runResolvers({
          document: a,
          remoteResult: { data: T },
          context: d,
          variables: o,
          onlyRunForcedResolvers: !0
        }).then(function(y) {
          return R(y.data || void 0);
        }) : l === "none" && S === Ee.refetch && Array.isArray(D.missing) ? R(void 0) : R(T);
      }, g = s === "no-cache" ? 0 : n === Ee.refetch && u !== "merge" ? 1 : 2, $ = function() {
        return i.getResultsFromLink(t, g, {
          query: a,
          variables: o,
          context: d,
          fetchPolicy: s,
          errorPolicy: l
        });
      }, m = f && typeof h == "number" && h !== n && aa(n);
      switch (s) {
        default:
        case "cache-first": {
          var b = p();
          return b.complete ? {
            fromLink: !1,
            sources: [v(b, t.markReady())]
          } : c || m ? {
            fromLink: !0,
            sources: [v(b), $()]
          } : { fromLink: !0, sources: [$()] };
        }
        case "cache-and-network": {
          var b = p();
          return b.complete || c || m ? {
            fromLink: !0,
            sources: [v(b), $()]
          } : { fromLink: !0, sources: [$()] };
        }
        case "cache-only":
          return {
            fromLink: !1,
            sources: [v(p(), t.markReady())]
          };
        case "network-only":
          return m ? {
            fromLink: !0,
            sources: [v(p()), $()]
          } : { fromLink: !0, sources: [$()] };
        case "no-cache":
          return m ? {
            fromLink: !0,
            // Note that queryInfo.getDiff() for no-cache queries does not call
            // cache.diff, but instead returns a { complete: false } stub result
            // when there is no queryInfo.diff already defined.
            sources: [v(t.getDiff()), $()]
          } : { fromLink: !0, sources: [$()] };
        case "standby":
          return { fromLink: !1, sources: [] };
      }
    }, e.prototype.getQuery = function(t) {
      return t && !this.queries.has(t) && this.queries.set(t, new Du(this, t)), this.queries.get(t);
    }, e.prototype.prepareContext = function(t) {
      t === void 0 && (t = {});
      var r = this.localState.prepareContext(t);
      return B(B(B({}, this.defaultContext), r), { clientAwareness: this.clientAwareness });
    }, e;
  }()
), Xf = !1, Yc = (
  /** @class */
  function() {
    function e(t) {
      var r = this;
      if (this.resetStoreCallbacks = [], this.clearStoreCallbacks = [], !t.cache)
        throw ht(15);
      var n = t.uri, i = t.credentials, a = t.headers, o = t.cache, s = t.documentTransform, u = t.ssrMode, l = u === void 0 ? !1 : u, c = t.ssrForceFetchDelay, d = c === void 0 ? 0 : c, f = t.connectToDevTools, h = f === void 0 ? typeof window == "object" && !window.__APOLLO_CLIENT__ && globalThis.__DEV__ !== !1 : f, p = t.queryDeduplication, v = p === void 0 ? !0 : p, g = t.defaultOptions, $ = t.defaultContext, m = t.assumeImmutableResults, b = m === void 0 ? o.assumeImmutableResults : m, D = t.resolvers, S = t.typeDefs, T = t.fragmentMatcher, R = t.name, y = t.version, A = t.link;
      A || (A = n ? new o2({ uri: n, credentials: i, headers: a }) : jt.empty()), this.link = A, this.cache = o, this.disableNetworkFetches = l || d > 0, this.queryDeduplication = v, this.defaultOptions = g || /* @__PURE__ */ Object.create(null), this.typeDefs = S, d && setTimeout(function() {
        return r.disableNetworkFetches = !1;
      }, d), this.watchQuery = this.watchQuery.bind(this), this.query = this.query.bind(this), this.mutate = this.mutate.bind(this), this.watchFragment = this.watchFragment.bind(this), this.resetStore = this.resetStore.bind(this), this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this), this.version = Sc, this.localState = new cv({
        cache: o,
        client: this,
        resolvers: D,
        fragmentMatcher: T
      }), this.queryManager = new _2({
        cache: this.cache,
        link: this.link,
        defaultOptions: this.defaultOptions,
        defaultContext: $,
        documentTransform: s,
        queryDeduplication: v,
        ssrMode: l,
        clientAwareness: {
          name: R,
          version: y
        },
        localState: this.localState,
        assumeImmutableResults: b,
        onBroadcast: h ? function() {
          r.devToolsHookCb && r.devToolsHookCb({
            action: {},
            state: {
              queries: r.queryManager.getQueryStore(),
              mutations: r.queryManager.mutationStore || {}
            },
            dataWithOptimisticResults: r.cache.extract(!0)
          });
        } : void 0
      }), h && this.connectToDevTools();
    }
    return e.prototype.connectToDevTools = function() {
      if (typeof window == "object") {
        var t = window, r = Symbol.for("apollo.devtools");
        (t[r] = t[r] || []).push(this), t.__APOLLO_CLIENT__ = this;
      }
      !Xf && globalThis.__DEV__ !== !1 && (Xf = !0, setTimeout(function() {
        if (typeof window < "u" && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__ && /^(https?|file):$/.test(window.location.protocol)) {
          var n = window.navigator, i = n && n.userAgent, a = void 0;
          typeof i == "string" && (i.indexOf("Chrome/") > -1 ? a = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm" : i.indexOf("Firefox/") > -1 && (a = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/")), a && globalThis.__DEV__ !== !1 && se.log("Download the Apollo DevTools for a better development experience: %s", a);
        }
      }, 1e4));
    }, Object.defineProperty(e.prototype, "documentTransform", {
      /**
       * The `DocumentTransform` used to modify GraphQL documents before a request
       * is made. If a custom `DocumentTransform` is not provided, this will be the
       * default document transform.
       */
      get: function() {
        return this.queryManager.documentTransform;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.stop = function() {
      this.queryManager.stop();
    }, e.prototype.watchQuery = function(t) {
      return this.defaultOptions.watchQuery && (t = ji(this.defaultOptions.watchQuery, t)), this.disableNetworkFetches && (t.fetchPolicy === "network-only" || t.fetchPolicy === "cache-and-network") && (t = B(B({}, t), { fetchPolicy: "cache-first" })), this.queryManager.watchQuery(t);
    }, e.prototype.query = function(t) {
      return this.defaultOptions.query && (t = ji(this.defaultOptions.query, t)), se(t.fetchPolicy !== "cache-and-network", 16), this.disableNetworkFetches && t.fetchPolicy === "network-only" && (t = B(B({}, t), { fetchPolicy: "cache-first" })), this.queryManager.query(t);
    }, e.prototype.mutate = function(t) {
      return this.defaultOptions.mutate && (t = ji(this.defaultOptions.mutate, t)), this.queryManager.mutate(t);
    }, e.prototype.subscribe = function(t) {
      return this.queryManager.startGraphQLSubscription(t);
    }, e.prototype.readQuery = function(t, r) {
      return r === void 0 && (r = !1), this.cache.readQuery(t, r);
    }, e.prototype.watchFragment = function(t) {
      return this.cache.watchFragment(t);
    }, e.prototype.readFragment = function(t, r) {
      return r === void 0 && (r = !1), this.cache.readFragment(t, r);
    }, e.prototype.writeQuery = function(t) {
      var r = this.cache.writeQuery(t);
      return t.broadcast !== !1 && this.queryManager.broadcastQueries(), r;
    }, e.prototype.writeFragment = function(t) {
      var r = this.cache.writeFragment(t);
      return t.broadcast !== !1 && this.queryManager.broadcastQueries(), r;
    }, e.prototype.__actionHookForDevTools = function(t) {
      this.devToolsHookCb = t;
    }, e.prototype.__requestRaw = function(t) {
      return xl(this.link, t);
    }, e.prototype.resetStore = function() {
      var t = this;
      return Promise.resolve().then(function() {
        return t.queryManager.clearStore({
          discardWatches: !1
        });
      }).then(function() {
        return Promise.all(t.resetStoreCallbacks.map(function(r) {
          return r();
        }));
      }).then(function() {
        return t.reFetchObservableQueries();
      });
    }, e.prototype.clearStore = function() {
      var t = this;
      return Promise.resolve().then(function() {
        return t.queryManager.clearStore({
          discardWatches: !0
        });
      }).then(function() {
        return Promise.all(t.clearStoreCallbacks.map(function(r) {
          return r();
        }));
      });
    }, e.prototype.onResetStore = function(t) {
      var r = this;
      return this.resetStoreCallbacks.push(t), function() {
        r.resetStoreCallbacks = r.resetStoreCallbacks.filter(function(n) {
          return n !== t;
        });
      };
    }, e.prototype.onClearStore = function(t) {
      var r = this;
      return this.clearStoreCallbacks.push(t), function() {
        r.clearStoreCallbacks = r.clearStoreCallbacks.filter(function(n) {
          return n !== t;
        });
      };
    }, e.prototype.reFetchObservableQueries = function(t) {
      return this.queryManager.reFetchObservableQueries(t);
    }, e.prototype.refetchQueries = function(t) {
      var r = this.queryManager.refetchQueries(t), n = [], i = [];
      r.forEach(function(o, s) {
        n.push(s), i.push(o);
      });
      var a = Promise.all(i);
      return a.queries = n, a.results = i, a.catch(function(o) {
        globalThis.__DEV__ !== !1 && se.debug(17, o);
      }), a;
    }, e.prototype.getObservableQueries = function(t) {
      return t === void 0 && (t = "active"), this.queryManager.getObservableQueries(t);
    }, e.prototype.extract = function(t) {
      return this.cache.extract(t);
    }, e.prototype.restore = function(t) {
      return this.cache.restore(t);
    }, e.prototype.addResolvers = function(t) {
      this.localState.addResolvers(t);
    }, e.prototype.setResolvers = function(t) {
      this.localState.setResolvers(t);
    }, e.prototype.getResolvers = function() {
      return this.localState.getResolvers();
    }, e.prototype.setLocalStateFragmentMatcher = function(t) {
      this.localState.setFragmentMatcher(t);
    }, e.prototype.setLink = function(t) {
      this.link = this.queryManager.link = t;
    }, Object.defineProperty(e.prototype, "defaultContext", {
      get: function() {
        return this.queryManager.defaultContext;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }()
);
globalThis.__DEV__ !== !1 && (Yc.prototype.getMemoryInternals = CD);
var go = /* @__PURE__ */ new Map(), Pl = /* @__PURE__ */ new Map(), dv = !0, Fo = !1;
function fv(e) {
  return e.replace(/[\s,]+/g, " ").trim();
}
function F2(e) {
  return fv(e.source.body.substring(e.start, e.end));
}
function O2(e) {
  var t = /* @__PURE__ */ new Set(), r = [];
  return e.definitions.forEach(function(n) {
    if (n.kind === "FragmentDefinition") {
      var i = n.name.value, a = F2(n.loc), o = Pl.get(i);
      o && !o.has(a) ? dv && console.warn("Warning: fragment with name " + i + ` already exists.
graphql-tag enforces all fragment names across your application to be unique; read more about
this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names`) : o || Pl.set(i, o = /* @__PURE__ */ new Set()), o.add(a), t.has(a) || (t.add(a), r.push(n));
    } else
      r.push(n);
  }), B(B({}, e), { definitions: r });
}
function I2(e) {
  var t = new Set(e.definitions);
  t.forEach(function(n) {
    n.loc && delete n.loc, Object.keys(n).forEach(function(i) {
      var a = n[i];
      a && typeof a == "object" && t.add(a);
    });
  });
  var r = e.loc;
  return r && (delete r.startToken, delete r.endToken), e;
}
function R2(e) {
  var t = fv(e);
  if (!go.has(t)) {
    var r = Zx(e, {
      experimentalFragmentVariables: Fo,
      allowLegacyFragmentVariables: Fo
    });
    if (!r || r.kind !== "Document")
      throw new Error("Not a valid GraphQL document.");
    go.set(t, I2(O2(r)));
  }
  return go.get(t);
}
function Vr(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  typeof e == "string" && (e = [e]);
  var n = e[0];
  return t.forEach(function(i, a) {
    i && i.kind === "Document" ? n += i.loc.source.body : n += i, n += e[a + 1];
  }), R2(n);
}
function B2() {
  go.clear(), Pl.clear();
}
function M2() {
  dv = !1;
}
function N2() {
  Fo = !0;
}
function L2() {
  Fo = !1;
}
var Di = {
  gql: Vr,
  resetCaches: B2,
  disableFragmentWarnings: M2,
  enableExperimentalFragmentVariables: N2,
  disableExperimentalFragmentVariables: L2
};
(function(e) {
  e.gql = Di.gql, e.resetCaches = Di.resetCaches, e.disableFragmentWarnings = Di.disableFragmentWarnings, e.enableExperimentalFragmentVariables = Di.enableExperimentalFragmentVariables, e.disableExperimentalFragmentVariables = Di.disableExperimentalFragmentVariables;
})(Vr || (Vr = {}));
Vr.default = Vr;
function hv(e) {
  return new jt(function(t, r) {
    var n = Nt(t, []);
    return new Ce(function(i) {
      var a, o = !1;
      return Promise.resolve(n).then(function(s) {
        return e(s, t.getContext());
      }).then(t.setContext).then(function() {
        o || (a = r(t).subscribe({
          next: i.next.bind(i),
          error: i.error.bind(i),
          complete: i.complete.bind(i)
        }));
      }).catch(i.error.bind(i)), function() {
        o = !0, a && a.unsubscribe();
      };
    });
  });
}
function Jc(e) {
  return new jt(function(t, r) {
    return new Ce(function(n) {
      var i, a, o;
      try {
        i = r(t).subscribe({
          next: function(s) {
            if (s.errors && (o = e({
              graphQLErrors: s.errors,
              response: s,
              operation: t,
              forward: r
            }), o)) {
              a = o.subscribe({
                next: n.next.bind(n),
                error: n.error.bind(n),
                complete: n.complete.bind(n)
              });
              return;
            }
            n.next(s);
          },
          error: function(s) {
            if (o = e({
              operation: t,
              networkError: s,
              //Network errors can return GraphQL errors on for example a 403
              graphQLErrors: s && s.result && s.result.errors || void 0,
              forward: r
            }), o) {
              a = o.subscribe({
                next: n.next.bind(n),
                error: n.error.bind(n),
                complete: n.complete.bind(n)
              });
              return;
            }
            n.error(s);
          },
          complete: function() {
            o || n.complete.bind(n)();
          }
        });
      } catch (s) {
        e({ networkError: s, operation: t, forward: r }), n.error(s);
      }
      return function() {
        i && i.unsubscribe(), a && i.unsubscribe();
      };
    });
  });
}
(function(e) {
  Vt(t, e);
  function t(r) {
    var n = e.call(this) || this;
    return n.link = Jc(r), n;
  }
  return t.prototype.request = function(r, n) {
    return this.link.request(r, n);
  }, t;
})(jt);
function V2(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var pv = { exports: {} };
(function(e) {
  e.exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = void 0, e.exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0, e.exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0, Object.assign(e.exports, F);
})(pv);
var Xe = pv.exports;
const j2 = /* @__PURE__ */ V2(Xe), mv = /* @__PURE__ */ E$({
  __proto__: null,
  default: j2
}, [Xe]);
var eh = Fc ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
function vv() {
  se("createContext" in mv, 45);
  var e = Xe.createContext[eh];
  return e || (Object.defineProperty(Xe.createContext, eh, {
    value: e = Xe.createContext({}),
    enumerable: !1,
    writable: !1,
    configurable: !0
  }), e.displayName = "ApolloContext"), e;
}
function Xc(e) {
  var t = Xe.useContext(vv()), r = e || t.client;
  return se(!!r, 49), r;
}
var th = !1, z2 = "useSyncExternalStore", K2 = mv[z2], U2 = K2 || function(e, t, r) {
  var n = t();
  // DEVIATION: Using __DEV__
  globalThis.__DEV__ !== !1 && !th && // DEVIATION: Not using Object.is because we know our snapshots will never
  // be exotic primitive values like NaN, which is !== itself.
  n !== t() && (th = !0, globalThis.__DEV__ !== !1 && se.error(58));
  var i = Xe.useState({
    inst: { value: n, getSnapshot: t }
  }), a = i[0].inst, o = i[1];
  return mD ? Xe.useLayoutEffect(function() {
    Object.assign(a, { value: n, getSnapshot: t }), Eu(a) && o({ inst: a });
  }, [e, n, t]) : Object.assign(a, { value: n, getSnapshot: t }), Xe.useEffect(function() {
    return Eu(a) && o({ inst: a }), e(function() {
      Eu(a) && o({ inst: a });
    });
  }, [e]), n;
};
function Eu(e) {
  var t = e.value, r = e.getSnapshot;
  try {
    return t !== r();
  } catch {
    return !0;
  }
}
var Qt;
(function(e) {
  e[e.Query = 0] = "Query", e[e.Mutation = 1] = "Mutation", e[e.Subscription = 2] = "Subscription";
})(Qt || (Qt = {}));
var Yr;
function rh(e) {
  var t;
  switch (e) {
    case Qt.Query:
      t = "Query";
      break;
    case Qt.Mutation:
      t = "Mutation";
      break;
    case Qt.Subscription:
      t = "Subscription";
      break;
  }
  return t;
}
function yv(e) {
  Yr || (Yr = new Oc(
    Zt.parser || 1e3
    /* defaultCacheSizes.parser */
  ));
  var t = Yr.get(e);
  if (t)
    return t;
  var r, n, i;
  se(!!e && !!e.kind, 60, e);
  for (var a = [], o = [], s = [], u = [], l = 0, c = e.definitions; l < c.length; l++) {
    var d = c[l];
    if (d.kind === "FragmentDefinition") {
      a.push(d);
      continue;
    }
    if (d.kind === "OperationDefinition")
      switch (d.operation) {
        case "query":
          o.push(d);
          break;
        case "mutation":
          s.push(d);
          break;
        case "subscription":
          u.push(d);
          break;
      }
  }
  se(!a.length || o.length || s.length || u.length, 61), se(
    o.length + s.length + u.length <= 1,
    62,
    e,
    o.length,
    u.length,
    s.length
  ), n = o.length ? Qt.Query : Qt.Mutation, !o.length && !s.length && (n = Qt.Subscription);
  var f = o.length ? o : s.length ? s : u;
  se(f.length === 1, 63, e, f.length);
  var h = f[0];
  r = h.variableDefinitions || [], h.name && h.name.kind === "Name" ? i = h.name.value : i = "data";
  var p = { name: i, type: n, variables: r };
  return Yr.set(e, p), p;
}
yv.resetCache = function() {
  Yr = void 0;
};
globalThis.__DEV__ !== !1 && Ic("parser", function() {
  return Yr ? Yr.size : 0;
});
function gv(e, t) {
  var r = yv(e), n = rh(t), i = rh(r.type);
  se(
    r.type === t,
    64,
    n,
    n,
    i
  );
}
var q2 = Symbol.for("apollo.hook.wrappers");
function H2(e, t, r) {
  var n = r.queryManager, i = n && n[q2], a = i && i[e];
  return a ? a(t) : t;
}
var W2 = Object.prototype.hasOwnProperty;
function Q2(e, t) {
  return t === void 0 && (t = /* @__PURE__ */ Object.create(null)), H2("useQuery", G2, Xc(t && t.client))(e, t);
}
function G2(e, t) {
  return Z2(Xc(t.client), e).useQuery(t);
}
function Z2(e, t) {
  var r = Xe.useReducer(function(s) {
    return s + 1;
  }, 0)[1];
  function n(s) {
    return Object.assign(new Y2(e, t, s), {
      forceUpdateState: r
    });
  }
  var i = Xe.useState(n), a = i[0], o = i[1];
  return (e !== a.client || t !== a.query) && o(a = n(a)), a;
}
var Y2 = (
  /** @class */
  function() {
    function e(t, r, n) {
      var i = this;
      this.client = t, this.query = r, this.forceUpdate = function() {
        return i.forceUpdateState();
      }, this.ssrDisabledResult = ra({
        loading: !0,
        data: void 0,
        error: void 0,
        networkStatus: Ee.loading
      }), this.skipStandbyResult = ra({
        loading: !1,
        data: void 0,
        error: void 0,
        networkStatus: Ee.ready
      }), this.toQueryResultCache = new (mn ? WeakMap : Map)(), gv(r, Qt.Query);
      var a = n && n.result, o = a && a.data;
      o && (this.previousData = o);
    }
    return e.prototype.forceUpdateState = function() {
      globalThis.__DEV__ !== !1 && se.warn(51);
    }, e.prototype.executeQuery = function(t) {
      var r = this, n;
      t.query && Object.assign(this, { query: t.query }), this.watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = t);
      var i = this.observable.reobserveAsConcast(this.getObsQueryOptions());
      return this.previousData = ((n = this.result) === null || n === void 0 ? void 0 : n.data) || this.previousData, this.result = void 0, this.forceUpdate(), new Promise(function(a) {
        var o;
        i.subscribe({
          next: function(s) {
            o = s;
          },
          error: function() {
            a(r.toQueryResult(r.observable.getCurrentResult()));
          },
          complete: function() {
            a(r.toQueryResult(o));
          }
        });
      });
    }, e.prototype.useQuery = function(t) {
      var r = this;
      this.renderPromises = Xe.useContext(vv()).renderPromises, this.useOptions(t);
      var n = this.useObservableQuery(), i = U2(
        // eslint-disable-next-line react-hooks/rules-of-hooks
        Xe.useCallback(function(a) {
          if (r.renderPromises)
            return function() {
            };
          r.forceUpdate = a;
          var o = function() {
            var l = r.result, c = n.getCurrentResult();
            l && l.loading === c.loading && l.networkStatus === c.networkStatus && Te(l.data, c.data) || r.setResult(c);
          }, s = function(l) {
            if (u.unsubscribe(), u = n.resubscribeAfterError(o, s), !W2.call(l, "graphQLErrors"))
              throw l;
            var c = r.result;
            (!c || c && c.loading || !Te(l, c.error)) && r.setResult({
              data: c && c.data,
              error: l,
              loading: !1,
              networkStatus: Ee.error
            });
          }, u = n.subscribe(o, s);
          return function() {
            setTimeout(function() {
              return u.unsubscribe();
            }), r.forceUpdate = function() {
              return r.forceUpdateState();
            };
          };
        }, [
          // We memoize the subscribe function using useCallback and the following
          // dependency keys, because the subscribe function reference is all that
          // useSyncExternalStore uses internally as a dependency key for the
          // useEffect ultimately responsible for the subscription, so we are
          // effectively passing this dependency array to that useEffect buried
          // inside useSyncExternalStore, as desired.
          n,
          // eslint-disable-next-line react-hooks/exhaustive-deps
          this.renderPromises,
          // eslint-disable-next-line react-hooks/exhaustive-deps
          this.client.disableNetworkFetches
        ]),
        function() {
          return r.getCurrentResult();
        },
        function() {
          return r.getCurrentResult();
        }
      );
      return this.unsafeHandlePartialRefetch(i), this.toQueryResult(i);
    }, e.prototype.useOptions = function(t) {
      var r, n = this.createWatchQueryOptions(this.queryHookOptions = t), i = this.watchQueryOptions;
      Te(n, i) || (this.watchQueryOptions = n, i && this.observable && (this.observable.reobserve(this.getObsQueryOptions()), this.previousData = ((r = this.result) === null || r === void 0 ? void 0 : r.data) || this.previousData, this.result = void 0)), this.onCompleted = t.onCompleted || e.prototype.onCompleted, this.onError = t.onError || e.prototype.onError, (this.renderPromises || this.client.disableNetworkFetches) && this.queryHookOptions.ssr === !1 && !this.queryHookOptions.skip ? this.result = this.ssrDisabledResult : this.queryHookOptions.skip || this.watchQueryOptions.fetchPolicy === "standby" ? this.result = this.skipStandbyResult : (this.result === this.ssrDisabledResult || this.result === this.skipStandbyResult) && (this.result = void 0);
    }, e.prototype.getObsQueryOptions = function() {
      var t = [], r = this.client.defaultOptions.watchQuery;
      return r && t.push(r), this.queryHookOptions.defaultOptions && t.push(this.queryHookOptions.defaultOptions), t.push(on(this.observable && this.observable.options, this.watchQueryOptions)), t.reduce(ji);
    }, e.prototype.createWatchQueryOptions = function(t) {
      var r;
      t === void 0 && (t = {});
      var n = t.skip;
      t.ssr, t.onCompleted, t.onError, t.defaultOptions;
      var i = Nt(t, ["skip", "ssr", "onCompleted", "onError", "defaultOptions"]), a = Object.assign(i, { query: this.query });
      if (this.renderPromises && (a.fetchPolicy === "network-only" || a.fetchPolicy === "cache-and-network") && (a.fetchPolicy = "cache-first"), a.variables || (a.variables = {}), n) {
        var o = a.fetchPolicy, s = o === void 0 ? this.getDefaultFetchPolicy() : o, u = a.initialFetchPolicy, l = u === void 0 ? s : u;
        Object.assign(a, {
          initialFetchPolicy: l,
          fetchPolicy: "standby"
        });
      } else a.fetchPolicy || (a.fetchPolicy = ((r = this.observable) === null || r === void 0 ? void 0 : r.options.initialFetchPolicy) || this.getDefaultFetchPolicy());
      return a;
    }, e.prototype.getDefaultFetchPolicy = function() {
      var t, r;
      return ((t = this.queryHookOptions.defaultOptions) === null || t === void 0 ? void 0 : t.fetchPolicy) || ((r = this.client.defaultOptions.watchQuery) === null || r === void 0 ? void 0 : r.fetchPolicy) || "cache-first";
    }, e.prototype.onCompleted = function(t) {
    }, e.prototype.onError = function(t) {
    }, e.prototype.useObservableQuery = function() {
      var t = this.observable = this.renderPromises && this.renderPromises.getSSRObservable(this.watchQueryOptions) || this.observable || // Reuse this.observable if possible (and not SSR)
      this.client.watchQuery(this.getObsQueryOptions());
      this.obsQueryFields = Xe.useMemo(function() {
        return {
          refetch: t.refetch.bind(t),
          reobserve: t.reobserve.bind(t),
          fetchMore: t.fetchMore.bind(t),
          updateQuery: t.updateQuery.bind(t),
          startPolling: t.startPolling.bind(t),
          stopPolling: t.stopPolling.bind(t),
          subscribeToMore: t.subscribeToMore.bind(t)
        };
      }, [t]);
      var r = !(this.queryHookOptions.ssr === !1 || this.queryHookOptions.skip);
      return this.renderPromises && r && (this.renderPromises.registerSSRObservable(t), t.getCurrentResult().loading && this.renderPromises.addObservableQueryPromise(t)), t;
    }, e.prototype.setResult = function(t) {
      var r = this.result;
      r && r.data && (this.previousData = r.data), this.result = t, this.forceUpdate(), this.handleErrorOrCompleted(t, r);
    }, e.prototype.handleErrorOrCompleted = function(t, r) {
      var n = this;
      if (!t.loading) {
        var i = this.toApolloError(t);
        Promise.resolve().then(function() {
          i ? n.onError(i) : t.data && (r == null ? void 0 : r.networkStatus) !== t.networkStatus && t.networkStatus === Ee.ready && n.onCompleted(t.data);
        }).catch(function(a) {
          globalThis.__DEV__ !== !1 && se.warn(a);
        });
      }
    }, e.prototype.toApolloError = function(t) {
      return Ft(t.errors) ? new or({ graphQLErrors: t.errors }) : t.error;
    }, e.prototype.getCurrentResult = function() {
      return this.result || this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult()), this.result;
    }, e.prototype.toQueryResult = function(t) {
      var r = this.toQueryResultCache.get(t);
      if (r)
        return r;
      var n = t.data;
      t.partial;
      var i = Nt(t, ["data", "partial"]);
      return this.toQueryResultCache.set(t, r = B(B(B({ data: n }, i), this.obsQueryFields), { client: this.client, observable: this.observable, variables: this.observable.variables, called: !this.queryHookOptions.skip, previousData: this.previousData })), !r.error && Ft(t.errors) && (r.error = new or({ graphQLErrors: t.errors })), r;
    }, e.prototype.unsafeHandlePartialRefetch = function(t) {
      t.partial && this.queryHookOptions.partialRefetch && !t.loading && (!t.data || Object.keys(t.data).length === 0) && this.observable.options.fetchPolicy !== "cache-only" && (Object.assign(t, {
        loading: !0,
        networkStatus: Ee.refetch
      }), this.observable.refetch());
    }, e;
  }()
);
function J2(e, t) {
  var r = Xc(t == null ? void 0 : t.client);
  gv(e, Qt.Mutation);
  var n = Xe.useState({
    called: !1,
    loading: !1,
    client: r
  }), i = n[0], a = n[1], o = Xe.useRef({
    result: i,
    mutationId: 0,
    isMounted: !0,
    client: r,
    mutation: e,
    options: t
  });
  Xe.useLayoutEffect(function() {
    Object.assign(o.current, { client: r, options: t, mutation: e });
  });
  var s = Xe.useCallback(function(l) {
    l === void 0 && (l = {});
    var c = o.current, d = c.options, f = c.mutation, h = B(B({}, d), { mutation: f }), p = l.client || o.current.client;
    !o.current.result.loading && !h.ignoreResults && o.current.isMounted && a(o.current.result = {
      loading: !0,
      error: void 0,
      data: void 0,
      called: !0,
      client: p
    });
    var v = ++o.current.mutationId, g = ji(h, l);
    return p.mutate(g).then(function($) {
      var m, b, D = $.data, S = $.errors, T = S && S.length > 0 ? new or({ graphQLErrors: S }) : void 0, R = l.onError || ((m = o.current.options) === null || m === void 0 ? void 0 : m.onError);
      if (T && R && R(T, g), v === o.current.mutationId && !g.ignoreResults) {
        var y = {
          called: !0,
          loading: !1,
          data: D,
          error: T,
          client: p
        };
        o.current.isMounted && !Te(o.current.result, y) && a(o.current.result = y);
      }
      var A = l.onCompleted || ((b = o.current.options) === null || b === void 0 ? void 0 : b.onCompleted);
      return T || A == null || A($.data, g), $;
    }).catch(function($) {
      var m;
      if (v === o.current.mutationId && o.current.isMounted) {
        var b = {
          loading: !1,
          error: $,
          data: void 0,
          called: !0,
          client: p
        };
        Te(o.current.result, b) || a(o.current.result = b);
      }
      var D = l.onError || ((m = o.current.options) === null || m === void 0 ? void 0 : m.onError);
      if (D)
        return D($, g), { data: void 0, errors: $ };
      throw $;
    });
  }, []), u = Xe.useCallback(function() {
    if (o.current.isMounted) {
      var l = {
        called: !1,
        loading: !1,
        client: o.current.client
      };
      Object.assign(o.current, { mutationId: 0, result: l }), a(l);
    }
  }, []);
  return Xe.useEffect(function() {
    var l = o.current;
    return l.isMounted = !0, function() {
      l.isMounted = !1;
    };
  }, []), [s, B({ reset: u }, i)];
}
const X2 = new Zc();
async function eE({ mode: e, ownerId: t }) {
  const r = e === "development" ? Yn.engageGraphqlDevEndpoint : Yn.engageGraphqlEndpoint, n = Wm({ uri: r }), i = hv((s, { headers: u }) => {
    const l = Qp({ ownerId: t }), c = l ? `Accounts ${l}` : "";
    return {
      headers: {
        ...u,
        authorization: c
      }
    };
  }), a = Jc(({ networkError: s, operation: u, forward: l }) => {
    if (s && s.statusCode === 401)
      return console.log("Re-authenticating..."), new Ce((c) => {
        Cc({ mode: e, ownerId: t }).then((d) => {
          u.setContext(({ headers: h }) => ({
            headers: {
              ...h,
              authorization: d ? `Accounts ${d}` : ""
            }
          }));
          const f = {
            next: c.next.bind(c),
            error: c.error.bind(c),
            complete: c.complete.bind(c)
          };
          l(u).subscribe(f);
        }).catch(c.error.bind(c));
      });
  });
  return new Yc({
    link: jt.from([a, i, n]),
    cache: X2
  });
}
const bv = de({
  apolloClient: null
});
function tE({ children: e, mode: t, ownerId: r }) {
  const [n, i] = re(null);
  return ue(() => {
    async function a() {
      i(await eE({ mode: t, ownerId: r }));
    }
    a().catch(console.error);
  }, [t, r]), n ? /* @__PURE__ */ N(bv.Provider, { value: { client: n }, children: e }) : /* @__PURE__ */ N("h2", { children: "Initializing..." });
}
function rE() {
  const e = ce(bv);
  if (!e)
    throw new Error("useEngage must be used within an EngageProvider");
  return e;
}
function nE(e, t = {}) {
  const { client: r } = rE();
  return J2(e, { ...t, client: r });
}
const iE = new Zc();
async function aE({ mode: e, ownerId: t }) {
  const r = e === "development" ? Yn.accountsGraphqlDevEndpoint : Yn.accountsGraphqlEndpoint, n = Wm({ uri: r }), i = hv((s, { headers: u }) => {
    const l = Qp({ ownerId: t }), c = l ? `Bearer ${l}` : "";
    return {
      headers: {
        ...u,
        accept: "application/json",
        // Necessary to get a 401 instead of a redirect on auth errors.
        authorization: c
      }
    };
  }), a = Jc(({ networkError: s, operation: u, forward: l }) => {
    if (s && s.statusCode === 401)
      return console.log("Re-authenticating..."), new Ce((c) => {
        Cc({ mode: e, ownerId: t }).then((d) => {
          u.setContext(({ headers: h }) => ({
            headers: {
              ...h,
              authorization: d ? `Accounts ${d}` : ""
            }
          }));
          const f = {
            next: c.next.bind(c),
            error: c.error.bind(c),
            complete: c.complete.bind(c)
          };
          l(u).subscribe(f);
        }).catch(c.error.bind(c));
      });
  });
  return new Yc({
    link: jt.from([a, i, n]),
    cache: iE
  });
}
const $v = de({
  apolloClient: null
});
function oE({ children: e, mode: t, ownerId: r }) {
  const [n, i] = re(null);
  return ue(() => {
    async function a() {
      i(await aE({ mode: t, ownerId: r }));
    }
    a().catch(console.error);
  }, [t, r]), n ? /* @__PURE__ */ N($v.Provider, { value: { client: n }, children: e }) : /* @__PURE__ */ N("h2", { children: "Initializing..." });
}
function sE() {
  const e = ce($v);
  if (!e)
    throw new Error("useAccounts must be used within an AccountsProvider");
  return e;
}
function xv(e, t = {}) {
  const { client: r } = sE();
  return Q2(e, { ...t, client: r });
}
const Dv = de({}), uE = () => ce(Dv);
function lE({ children: e, options: t = {} }) {
  return t.isProd = t.mode === "production", t.isDev = !t.isProd, /* @__PURE__ */ N(Dv.Provider, { value: t, children: e });
}
function FT({
  ownerId: e,
  senalysisBusinessId: t,
  spilloverBusinessId: r,
  children: n,
  mode: i = "production"
}) {
  return /* @__PURE__ */ N(lE, { options: {
    mode: i,
    ownerId: e,
    senalysisBusinessId: t,
    spilloverBusinessId: r
  }, children: /* @__PURE__ */ N(mx, { mode: i, ownerId: e, children: /* @__PURE__ */ N(oE, { mode: i, ownerId: e, children: /* @__PURE__ */ N(tE, { mode: i, ownerId: e, children: /* @__PURE__ */ Se(
    "div",
    {
      className: "sfs-isolate",
      style: { height: "100%", width: "100%" },
      children: [
        n,
        /* @__PURE__ */ N(R$, {})
      ]
    }
  ) }) }) }) });
}
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const cE = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), Ev = (...e) => e.filter((t, r, n) => !!t && n.indexOf(t) === r).join(" ");
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var dE = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fE = Ae(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: r = 2,
    absoluteStrokeWidth: n,
    className: i = "",
    children: a,
    iconNode: o,
    ...s
  }, u) => rl(
    "svg",
    {
      ref: u,
      ...dE,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: n ? Number(r) * 24 / Number(t) : r,
      className: Ev("lucide", i),
      ...s
    },
    [
      ...o.map(([l, c]) => rl(l, c)),
      ...Array.isArray(a) ? a : [a]
    ]
  )
);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const je = (e, t) => {
  const r = Ae(
    ({ className: n, ...i }, a) => rl(fE, {
      ref: a,
      iconNode: t,
      className: Ev(`lucide-${cE(e)}`, n),
      ...i
    })
  );
  return r.displayName = `${e}`, r;
};
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const hE = je("BookA", [
  ["path", { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20", key: "t4utmx" }],
  ["path", { d: "m8 13 4-7 4 7", key: "4rari8" }],
  ["path", { d: "M9.1 11h5.7", key: "1gkovt" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pE = je("Calendar", [
  ["path", { d: "M8 2v4", key: "1cmpym" }],
  ["path", { d: "M16 2v4", key: "4m81vk" }],
  ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
  ["path", { d: "M3 10h18", key: "8toen8" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const mE = je("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const wv = je("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Al = je("ChevronLeft", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nh = je("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vE = je("CircleMinus", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M8 12h8", key: "1wcyev" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const yE = je("CirclePlus", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M8 12h8", key: "1wcyev" }],
  ["path", { d: "M12 8v8", key: "napkw2" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const gE = je("Ellipsis", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const bE = je("Feather", [
  [
    "path",
    {
      d: "M12.67 19a2 2 0 0 0 1.416-.588l6.154-6.172a6 6 0 0 0-8.49-8.49L5.586 9.914A2 2 0 0 0 5 11.328V18a1 1 0 0 0 1 1z",
      key: "18jl4k"
    }
  ],
  ["path", { d: "M16 8 2 22", key: "vp34q" }],
  ["path", { d: "M17.5 15H9", key: "1oz8nu" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const $E = je("FileDown", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M12 18v-6", key: "17g6i2" }],
  ["path", { d: "m9 15 3 3 3-3", key: "1npd3o" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ih = je("FileText", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xE = je("Languages", [
  ["path", { d: "m5 8 6 6", key: "1wu5hv" }],
  ["path", { d: "m4 14 6-6 2-3", key: "1k1g8d" }],
  ["path", { d: "M2 5h12", key: "or177f" }],
  ["path", { d: "M7 2h1", key: "1t2jsx" }],
  ["path", { d: "m22 22-5-10-5 10", key: "don7ne" }],
  ["path", { d: "M14 18h6", key: "1m8k6r" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const DE = je("List", [
  ["line", { x1: "8", x2: "21", y1: "6", y2: "6", key: "7ey8pc" }],
  ["line", { x1: "8", x2: "21", y1: "12", y2: "12", key: "rjfblc" }],
  ["line", { x1: "8", x2: "21", y1: "18", y2: "18", key: "c3b1m8" }],
  ["line", { x1: "3", x2: "3.01", y1: "6", y2: "6", key: "1g7gq3" }],
  ["line", { x1: "3", x2: "3.01", y1: "12", y2: "12", key: "1pjlvk" }],
  ["line", { x1: "3", x2: "3.01", y1: "18", y2: "18", key: "28t2mc" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Cv = je("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const EE = je("Loader", [
  ["path", { d: "M12 2v4", key: "3427ic" }],
  ["path", { d: "m16.2 7.8 2.9-2.9", key: "r700ao" }],
  ["path", { d: "M18 12h4", key: "wj9ykh" }],
  ["path", { d: "m16.2 16.2 2.9 2.9", key: "1bxg5t" }],
  ["path", { d: "M12 18v4", key: "jadmvz" }],
  ["path", { d: "m4.9 19.1 2.9-2.9", key: "bwix9q" }],
  ["path", { d: "M2 12h4", key: "j09sii" }],
  ["path", { d: "m4.9 4.9 2.9 2.9", key: "giyufr" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const wE = je("RefreshCw", [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CE = je("Reply", [
  ["polyline", { points: "9 17 4 12 9 7", key: "hvgpf2" }],
  ["path", { d: "M20 18v-2a4 4 0 0 0-4-4H4", key: "5vmcpk" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SE = je("SmilePlus", [
  ["path", { d: "M22 11v1a10 10 0 1 1-9-10", key: "ew0xw9" }],
  ["path", { d: "M8 14s1.5 2 4 2 4-2 4-2", key: "1y1vjs" }],
  ["line", { x1: "9", x2: "9.01", y1: "9", y2: "9", key: "yxxnd0" }],
  ["line", { x1: "15", x2: "15.01", y1: "9", y2: "9", key: "1p4y9e" }],
  ["path", { d: "M16 5h6", key: "1vod17" }],
  ["path", { d: "M19 2v6", key: "4bpg5p" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const kE = je("SpellCheck", [
  ["path", { d: "m6 16 6-12 6 12", key: "1b4byz" }],
  ["path", { d: "M8 12h8", key: "1wcyev" }],
  ["path", { d: "m16 20 2 2 4-4", key: "13tcca" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const TE = je("Star", [
  [
    "polygon",
    {
      points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2",
      key: "8f66p6"
    }
  ]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ps = je("WandSparkles", [
  [
    "path",
    {
      d: "m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72",
      key: "ul74o6"
    }
  ],
  ["path", { d: "m14 7 3 3", key: "1r5n42" }],
  ["path", { d: "M5 6v4", key: "ilb8ba" }],
  ["path", { d: "M19 14v4", key: "blhpug" }],
  ["path", { d: "M10 2v2", key: "7u0qdc" }],
  ["path", { d: "M7 8H3", key: "zfb6yr" }],
  ["path", { d: "M21 16h-4", key: "1cnmox" }],
  ["path", { d: "M11 3H9", key: "1obp7u" }]
]);
/**
 * @license lucide-react v0.395.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Sv = je("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), kv = de({
  currentScreen: null
});
function ed() {
  const e = ce(kv);
  if (!e)
    throw new Error("useMiniApp must be used within a MiniAppProvider");
  return e;
}
function PE({ onCloseButtonClick: e, children: t }) {
  const [r, n] = re(null), i = () => n(null);
  return /* @__PURE__ */ N(kv.Provider, { value: { currentScreen: r, setCurrentScreen: n, goHome: i, onCloseButtonClick: e }, children: t });
}
function AE({ title: e, Icon: t, noBack: r }) {
  const { goHome: n, onCloseButtonClick: i } = ed();
  return /* @__PURE__ */ Se("header", { className: "w-full h-12 flex flex-row items-center", children: [
    r ? /* @__PURE__ */ N("div", { className: "w-14" }) : /* @__PURE__ */ N(
      "div",
      {
        onClick: n,
        className: "h-full px-4 flex flex-row items-center cursor-pointer hover:bg-gray-200 transition duration-200",
        children: /* @__PURE__ */ N(Al, {})
      }
    ),
    /* @__PURE__ */ Se("div", { className: "flex grow justify-center items-center gap-2 py-3 text-gray-800", children: [
      t && /* @__PURE__ */ N(t, {}),
      /* @__PURE__ */ N("p", { className: "font-semibold", children: e })
    ] }),
    i && /* @__PURE__ */ N(
      "div",
      {
        onClick: i,
        className: "h-full px-4 flex flex-row items-center cursor-pointer hover:bg-gray-200 transition duration-200",
        children: /* @__PURE__ */ N(Sv, {})
      }
    )
  ] });
}
function Tv({ title: e, Icon: t, noBack: r, children: n }) {
  return /* @__PURE__ */ Se(_p, { children: [
    /* @__PURE__ */ N(AE, { title: e, Icon: t, noBack: r }),
    /* @__PURE__ */ N("main", { className: "h-full grow w-full overflow-y-auto", children: n })
  ] });
}
function _E({ title: e, Icon: t, children: r }) {
  const { setCurrentScreen: n } = ed();
  return /* @__PURE__ */ N(Tv, { title: e, Icon: t, noBack: !0, children: /* @__PURE__ */ N("div", { className: "w-full h-full flex flex-col gap-2 px-2", children: r.map((i, a) => {
    const { Icon: o } = i.props;
    return /* @__PURE__ */ Se(
      "div",
      {
        onClick: () => n(i),
        className: "flex flex-row items-center gap-2 p-3 text-md bg-gray-200 rounded-md cursor-pointer transition duration-200 hover:bg-gray-300",
        children: [
          o && /* @__PURE__ */ N(o, {}),
          /* @__PURE__ */ N("p", { className: "m-0", children: i.props.title })
        ]
      },
      a
    );
  }) }) });
}
function FE({ title: e, Icon: t, children: r }) {
  const { currentScreen: n } = ed();
  return /* @__PURE__ */ N("div", { className: "w-full h-full flex flex-col gap-2 pb-2 text-gray-800 bg-white", children: n || /* @__PURE__ */ N(_E, { title: e, Icon: t, children: r }) });
}
function OE({ title: e, Icon: t, children: r, onCloseButtonClick: n }) {
  return /* @__PURE__ */ N(PE, { onCloseButtonClick: n, children: /* @__PURE__ */ N(FE, { title: e, Icon: t, children: r }) });
}
var Sa = (e) => e.type === "checkbox", Rn = (e) => e instanceof Date, dt = (e) => e == null;
const Pv = (e) => typeof e == "object";
var rt = (e) => !dt(e) && !Array.isArray(e) && Pv(e) && !Rn(e), IE = (e) => rt(e) && e.target ? Sa(e.target) ? e.target.checked : e.target.value : e, RE = (e) => e.substring(0, e.search(/\.\d+(\.|$)/)) || e, BE = (e, t) => e.has(RE(t)), ME = (e) => {
  const t = e.constructor && e.constructor.prototype;
  return rt(t) && t.hasOwnProperty("isPrototypeOf");
}, td = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function kt(e) {
  let t;
  const r = Array.isArray(e);
  if (e instanceof Date)
    t = new Date(e);
  else if (e instanceof Set)
    t = new Set(e);
  else if (!(td && (e instanceof Blob || e instanceof FileList)) && (r || rt(e)))
    if (t = r ? [] : {}, !r && !ME(e))
      t = e;
    else
      for (const n in e)
        e.hasOwnProperty(n) && (t[n] = kt(e[n]));
  else
    return e;
  return t;
}
var ka = (e) => Array.isArray(e) ? e.filter(Boolean) : [], Qe = (e) => e === void 0, X = (e, t, r) => {
  if (!t || !rt(e))
    return r;
  const n = ka(t.split(/[,[\].]+?/)).reduce((i, a) => dt(i) ? i : i[a], e);
  return Qe(n) || n === e ? Qe(e[t]) ? r : e[t] : n;
}, _r = (e) => typeof e == "boolean", rd = (e) => /^\w*$/.test(e), Av = (e) => ka(e.replace(/["|']|\]/g, "").split(/\.|\[/)), Le = (e, t, r) => {
  let n = -1;
  const i = rd(t) ? [t] : Av(t), a = i.length, o = a - 1;
  for (; ++n < a; ) {
    const s = i[n];
    let u = r;
    if (n !== o) {
      const l = e[s];
      u = rt(l) || Array.isArray(l) ? l : isNaN(+i[n + 1]) ? {} : [];
    }
    if (s === "__proto__")
      return;
    e[s] = u, e = e[s];
  }
  return e;
};
const ah = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
}, Bt = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
}, er = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
F.createContext(null);
var NE = (e, t, r, n = !0) => {
  const i = {
    defaultValues: t._defaultValues
  };
  for (const a in e)
    Object.defineProperty(i, a, {
      get: () => {
        const o = a;
        return t._proxyFormState[o] !== Bt.all && (t._proxyFormState[o] = !n || Bt.all), e[o];
      }
    });
  return i;
}, Et = (e) => rt(e) && !Object.keys(e).length, LE = (e, t, r, n) => {
  r(e);
  const { name: i, ...a } = e;
  return Et(a) || Object.keys(a).length >= Object.keys(t).length || Object.keys(a).find((o) => t[o] === Bt.all);
}, wu = (e) => Array.isArray(e) ? e : [e];
function VE(e) {
  const t = F.useRef(e);
  t.current = e, F.useEffect(() => {
    const r = !e.disabled && t.current.subject && t.current.subject.subscribe({
      next: t.current.next
    });
    return () => {
      r && r.unsubscribe();
    };
  }, [e.disabled]);
}
var qt = (e) => typeof e == "string", jE = (e, t, r, n, i) => qt(e) ? (n && t.watch.add(e), X(r, e, i)) : Array.isArray(e) ? e.map((a) => (n && t.watch.add(a), X(r, a))) : (n && (t.watchAll = !0), r), _v = (e, t, r, n, i) => t ? {
  ...r[e],
  types: {
    ...r[e] && r[e].types ? r[e].types : {},
    [n]: i || !0
  }
} : {}, oh = (e) => ({
  isOnSubmit: !e || e === Bt.onSubmit,
  isOnBlur: e === Bt.onBlur,
  isOnChange: e === Bt.onChange,
  isOnAll: e === Bt.all,
  isOnTouch: e === Bt.onTouched
}), sh = (e, t, r) => !r && (t.watchAll || t.watch.has(e) || [...t.watch].some((n) => e.startsWith(n) && /^\.\w+/.test(e.slice(n.length))));
const Ui = (e, t, r, n) => {
  for (const i of r || Object.keys(e)) {
    const a = X(e, i);
    if (a) {
      const { _f: o, ...s } = a;
      if (o) {
        if (o.refs && o.refs[0] && t(o.refs[0], i) && !n)
          break;
        if (o.ref && t(o.ref, o.name) && !n)
          break;
        Ui(s, t);
      } else rt(s) && Ui(s, t);
    }
  }
};
var zE = (e, t, r) => {
  const n = ka(X(e, r));
  return Le(n, "root", t[r]), Le(e, r, n), e;
}, nd = (e) => e.type === "file", Fr = (e) => typeof e == "function", Oo = (e) => {
  if (!td)
    return !1;
  const t = e ? e.ownerDocument : 0;
  return e instanceof (t && t.defaultView ? t.defaultView.HTMLElement : HTMLElement);
}, bo = (e) => qt(e), id = (e) => e.type === "radio", Io = (e) => e instanceof RegExp;
const uh = {
  value: !1,
  isValid: !1
}, lh = { value: !0, isValid: !0 };
var Fv = (e) => {
  if (Array.isArray(e)) {
    if (e.length > 1) {
      const t = e.filter((r) => r && r.checked && !r.disabled).map((r) => r.value);
      return { value: t, isValid: !!t.length };
    }
    return e[0].checked && !e[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      e[0].attributes && !Qe(e[0].attributes.value) ? Qe(e[0].value) || e[0].value === "" ? lh : { value: e[0].value, isValid: !0 } : lh
    ) : uh;
  }
  return uh;
};
const ch = {
  isValid: !1,
  value: null
};
var Ov = (e) => Array.isArray(e) ? e.reduce((t, r) => r && r.checked && !r.disabled ? {
  isValid: !0,
  value: r.value
} : t, ch) : ch;
function dh(e, t, r = "validate") {
  if (bo(e) || Array.isArray(e) && e.every(bo) || _r(e) && !e)
    return {
      type: r,
      message: bo(e) ? e : "",
      ref: t
    };
}
var Dn = (e) => rt(e) && !Io(e) ? e : {
  value: e,
  message: ""
}, fh = async (e, t, r, n, i) => {
  const { ref: a, refs: o, required: s, maxLength: u, minLength: l, min: c, max: d, pattern: f, validate: h, name: p, valueAsNumber: v, mount: g, disabled: $ } = e._f, m = X(t, p);
  if (!g || $)
    return {};
  const b = o ? o[0] : a, D = (k) => {
    n && b.reportValidity && (b.setCustomValidity(_r(k) ? "" : k || ""), b.reportValidity());
  }, S = {}, T = id(a), R = Sa(a), y = T || R, A = (v || nd(a)) && Qe(a.value) && Qe(m) || Oo(a) && a.value === "" || m === "" || Array.isArray(m) && !m.length, w = _v.bind(null, p, r, S), E = (k, C, P, L = er.maxLength, O = er.minLength) => {
    const x = k ? C : P;
    S[p] = {
      type: k ? L : O,
      message: x,
      ref: a,
      ...w(k ? L : O, x)
    };
  };
  if (i ? !Array.isArray(m) || !m.length : s && (!y && (A || dt(m)) || _r(m) && !m || R && !Fv(o).isValid || T && !Ov(o).isValid)) {
    const { value: k, message: C } = bo(s) ? { value: !!s, message: s } : Dn(s);
    if (k && (S[p] = {
      type: er.required,
      message: C,
      ref: b,
      ...w(er.required, C)
    }, !r))
      return D(C), S;
  }
  if (!A && (!dt(c) || !dt(d))) {
    let k, C;
    const P = Dn(d), L = Dn(c);
    if (!dt(m) && !isNaN(m)) {
      const O = a.valueAsNumber || m && +m;
      dt(P.value) || (k = O > P.value), dt(L.value) || (C = O < L.value);
    } else {
      const O = a.valueAsDate || new Date(m), x = (j) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + j), U = a.type == "time", K = a.type == "week";
      qt(P.value) && m && (k = U ? x(m) > x(P.value) : K ? m > P.value : O > new Date(P.value)), qt(L.value) && m && (C = U ? x(m) < x(L.value) : K ? m < L.value : O < new Date(L.value));
    }
    if ((k || C) && (E(!!k, P.message, L.message, er.max, er.min), !r))
      return D(S[p].message), S;
  }
  if ((u || l) && !A && (qt(m) || i && Array.isArray(m))) {
    const k = Dn(u), C = Dn(l), P = !dt(k.value) && m.length > +k.value, L = !dt(C.value) && m.length < +C.value;
    if ((P || L) && (E(P, k.message, C.message), !r))
      return D(S[p].message), S;
  }
  if (f && !A && qt(m)) {
    const { value: k, message: C } = Dn(f);
    if (Io(k) && !m.match(k) && (S[p] = {
      type: er.pattern,
      message: C,
      ref: a,
      ...w(er.pattern, C)
    }, !r))
      return D(C), S;
  }
  if (h) {
    if (Fr(h)) {
      const k = await h(m, t), C = dh(k, b);
      if (C && (S[p] = {
        ...C,
        ...w(er.validate, C.message)
      }, !r))
        return D(C.message), S;
    } else if (rt(h)) {
      let k = {};
      for (const C in h) {
        if (!Et(k) && !r)
          break;
        const P = dh(await h[C](m, t), b, C);
        P && (k = {
          ...P,
          ...w(C, P.message)
        }, D(P.message), r && (S[p] = k));
      }
      if (!Et(k) && (S[p] = {
        ref: b,
        ...k
      }, !r))
        return S;
    }
  }
  return D(!0), S;
};
function KE(e, t) {
  const r = t.slice(0, -1).length;
  let n = 0;
  for (; n < r; )
    e = Qe(e) ? n++ : e[t[n++]];
  return e;
}
function UE(e) {
  for (const t in e)
    if (e.hasOwnProperty(t) && !Qe(e[t]))
      return !1;
  return !0;
}
function tt(e, t) {
  const r = Array.isArray(t) ? t : rd(t) ? [t] : Av(t), n = r.length === 1 ? e : KE(e, r), i = r.length - 1, a = r[i];
  return n && delete n[a], i !== 0 && (rt(n) && Et(n) || Array.isArray(n) && UE(n)) && tt(e, r.slice(0, -1)), e;
}
var Cu = () => {
  let e = [];
  return {
    get observers() {
      return e;
    },
    next: (i) => {
      for (const a of e)
        a.next && a.next(i);
    },
    subscribe: (i) => (e.push(i), {
      unsubscribe: () => {
        e = e.filter((a) => a !== i);
      }
    }),
    unsubscribe: () => {
      e = [];
    }
  };
}, Ro = (e) => dt(e) || !Pv(e);
function Jr(e, t) {
  if (Ro(e) || Ro(t))
    return e === t;
  if (Rn(e) && Rn(t))
    return e.getTime() === t.getTime();
  const r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length)
    return !1;
  for (const i of r) {
    const a = e[i];
    if (!n.includes(i))
      return !1;
    if (i !== "ref") {
      const o = t[i];
      if (Rn(a) && Rn(o) || rt(a) && rt(o) || Array.isArray(a) && Array.isArray(o) ? !Jr(a, o) : a !== o)
        return !1;
    }
  }
  return !0;
}
var Iv = (e) => e.type === "select-multiple", qE = (e) => id(e) || Sa(e), Su = (e) => Oo(e) && e.isConnected, Rv = (e) => {
  for (const t in e)
    if (Fr(e[t]))
      return !0;
  return !1;
};
function Bo(e, t = {}) {
  const r = Array.isArray(e);
  if (rt(e) || r)
    for (const n in e)
      Array.isArray(e[n]) || rt(e[n]) && !Rv(e[n]) ? (t[n] = Array.isArray(e[n]) ? [] : {}, Bo(e[n], t[n])) : dt(e[n]) || (t[n] = !0);
  return t;
}
function Bv(e, t, r) {
  const n = Array.isArray(e);
  if (rt(e) || n)
    for (const i in e)
      Array.isArray(e[i]) || rt(e[i]) && !Rv(e[i]) ? Qe(t) || Ro(r[i]) ? r[i] = Array.isArray(e[i]) ? Bo(e[i], []) : { ...Bo(e[i]) } : Bv(e[i], dt(t) ? {} : t[i], r[i]) : r[i] = !Jr(e[i], t[i]);
  return r;
}
var Za = (e, t) => Bv(e, t, Bo(t)), Mv = (e, { valueAsNumber: t, valueAsDate: r, setValueAs: n }) => Qe(e) ? e : t ? e === "" ? NaN : e && +e : r && qt(e) ? new Date(e) : n ? n(e) : e;
function ku(e) {
  const t = e.ref;
  if (!(e.refs ? e.refs.every((r) => r.disabled) : t.disabled))
    return nd(t) ? t.files : id(t) ? Ov(e.refs).value : Iv(t) ? [...t.selectedOptions].map(({ value: r }) => r) : Sa(t) ? Fv(e.refs).value : Mv(Qe(t.value) ? e.ref.value : t.value, e);
}
var HE = (e, t, r, n) => {
  const i = {};
  for (const a of e) {
    const o = X(t, a);
    o && Le(i, a, o._f);
  }
  return {
    criteriaMode: r,
    names: [...e],
    fields: i,
    shouldUseNativeValidation: n
  };
}, Ei = (e) => Qe(e) ? e : Io(e) ? e.source : rt(e) ? Io(e.value) ? e.value.source : e.value : e, WE = (e) => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate);
function hh(e, t, r) {
  const n = X(e, r);
  if (n || rd(r))
    return {
      error: n,
      name: r
    };
  const i = r.split(".");
  for (; i.length; ) {
    const a = i.join("."), o = X(t, a), s = X(e, a);
    if (o && !Array.isArray(o) && r !== a)
      return { name: r };
    if (s && s.type)
      return {
        name: a,
        error: s
      };
    i.pop();
  }
  return {
    name: r
  };
}
var QE = (e, t, r, n, i) => i.isOnAll ? !1 : !r && i.isOnTouch ? !(t || e) : (r ? n.isOnBlur : i.isOnBlur) ? !e : (r ? n.isOnChange : i.isOnChange) ? e : !0, GE = (e, t) => !ka(X(e, t)).length && tt(e, t);
const ZE = {
  mode: Bt.onSubmit,
  reValidateMode: Bt.onChange,
  shouldFocusError: !0
};
function YE(e = {}) {
  let t = {
    ...ZE,
    ...e
  }, r = {
    submitCount: 0,
    isDirty: !1,
    isLoading: Fr(t.defaultValues),
    isValidating: !1,
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: t.errors || {},
    disabled: t.disabled || !1
  }, n = {}, i = rt(t.defaultValues) || rt(t.values) ? kt(t.defaultValues || t.values) || {} : {}, a = t.shouldUnregister ? {} : kt(i), o = {
    action: !1,
    mount: !1,
    watch: !1
  }, s = {
    mount: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  }, u, l = 0;
  const c = {
    isDirty: !1,
    dirtyFields: !1,
    validatingFields: !1,
    touchedFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  }, d = {
    values: Cu(),
    array: Cu(),
    state: Cu()
  }, f = oh(t.mode), h = oh(t.reValidateMode), p = t.criteriaMode === Bt.all, v = (_) => (I) => {
    clearTimeout(l), l = setTimeout(_, I);
  }, g = async (_) => {
    if (c.isValid || _) {
      const I = t.resolver ? Et((await y()).errors) : await w(n, !0);
      I !== r.isValid && d.state.next({
        isValid: I
      });
    }
  }, $ = (_, I) => {
    (c.isValidating || c.validatingFields) && ((_ || Array.from(s.mount)).forEach((M) => {
      M && (I ? Le(r.validatingFields, M, I) : tt(r.validatingFields, M));
    }), d.state.next({
      validatingFields: r.validatingFields,
      isValidating: !Et(r.validatingFields)
    }));
  }, m = (_, I = [], M, W, Z = !0, Q = !0) => {
    if (W && M) {
      if (o.action = !0, Q && Array.isArray(X(n, _))) {
        const le = M(X(n, _), W.argA, W.argB);
        Z && Le(n, _, le);
      }
      if (Q && Array.isArray(X(r.errors, _))) {
        const le = M(X(r.errors, _), W.argA, W.argB);
        Z && Le(r.errors, _, le), GE(r.errors, _);
      }
      if (c.touchedFields && Q && Array.isArray(X(r.touchedFields, _))) {
        const le = M(X(r.touchedFields, _), W.argA, W.argB);
        Z && Le(r.touchedFields, _, le);
      }
      c.dirtyFields && (r.dirtyFields = Za(i, a)), d.state.next({
        name: _,
        isDirty: k(_, I),
        dirtyFields: r.dirtyFields,
        errors: r.errors,
        isValid: r.isValid
      });
    } else
      Le(a, _, I);
  }, b = (_, I) => {
    Le(r.errors, _, I), d.state.next({
      errors: r.errors
    });
  }, D = (_) => {
    r.errors = _, d.state.next({
      errors: r.errors,
      isValid: !1
    });
  }, S = (_, I, M, W) => {
    const Z = X(n, _);
    if (Z) {
      const Q = X(a, _, Qe(M) ? X(i, _) : M);
      Qe(Q) || W && W.defaultChecked || I ? Le(a, _, I ? Q : ku(Z._f)) : L(_, Q), o.mount && g();
    }
  }, T = (_, I, M, W, Z) => {
    let Q = !1, le = !1;
    const ke = {
      name: _
    }, Ge = !!(X(n, _) && X(n, _)._f && X(n, _)._f.disabled);
    if (!M || W) {
      c.isDirty && (le = r.isDirty, r.isDirty = ke.isDirty = k(), Q = le !== ke.isDirty);
      const Dt = Ge || Jr(X(i, _), I);
      le = !!(!Ge && X(r.dirtyFields, _)), Dt || Ge ? tt(r.dirtyFields, _) : Le(r.dirtyFields, _, !0), ke.dirtyFields = r.dirtyFields, Q = Q || c.dirtyFields && le !== !Dt;
    }
    if (M) {
      const Dt = X(r.touchedFields, _);
      Dt || (Le(r.touchedFields, _, M), ke.touchedFields = r.touchedFields, Q = Q || c.touchedFields && Dt !== M);
    }
    return Q && Z && d.state.next(ke), Q ? ke : {};
  }, R = (_, I, M, W) => {
    const Z = X(r.errors, _), Q = c.isValid && _r(I) && r.isValid !== I;
    if (e.delayError && M ? (u = v(() => b(_, M)), u(e.delayError)) : (clearTimeout(l), u = null, M ? Le(r.errors, _, M) : tt(r.errors, _)), (M ? !Jr(Z, M) : Z) || !Et(W) || Q) {
      const le = {
        ...W,
        ...Q && _r(I) ? { isValid: I } : {},
        errors: r.errors,
        name: _
      };
      r = {
        ...r,
        ...le
      }, d.state.next(le);
    }
  }, y = async (_) => {
    $(_, !0);
    const I = await t.resolver(a, t.context, HE(_ || s.mount, n, t.criteriaMode, t.shouldUseNativeValidation));
    return $(_), I;
  }, A = async (_) => {
    const { errors: I } = await y(_);
    if (_)
      for (const M of _) {
        const W = X(I, M);
        W ? Le(r.errors, M, W) : tt(r.errors, M);
      }
    else
      r.errors = I;
    return I;
  }, w = async (_, I, M = {
    valid: !0
  }) => {
    for (const W in _) {
      const Z = _[W];
      if (Z) {
        const { _f: Q, ...le } = Z;
        if (Q) {
          const ke = s.array.has(Q.name);
          $([W], !0);
          const Ge = await fh(Z, a, p, t.shouldUseNativeValidation && !I, ke);
          if ($([W]), Ge[Q.name] && (M.valid = !1, I))
            break;
          !I && (X(Ge, Q.name) ? ke ? zE(r.errors, Ge, Q.name) : Le(r.errors, Q.name, Ge[Q.name]) : tt(r.errors, Q.name));
        }
        le && await w(le, I, M);
      }
    }
    return M.valid;
  }, E = () => {
    for (const _ of s.unMount) {
      const I = X(n, _);
      I && (I._f.refs ? I._f.refs.every((M) => !Su(M)) : !Su(I._f.ref)) && Fe(_);
    }
    s.unMount = /* @__PURE__ */ new Set();
  }, k = (_, I) => (_ && I && Le(a, _, I), !Jr(ae(), i)), C = (_, I, M) => jE(_, s, {
    ...o.mount ? a : Qe(I) ? i : qt(_) ? { [_]: I } : I
  }, M, I), P = (_) => ka(X(o.mount ? a : i, _, e.shouldUnregister ? X(i, _, []) : [])), L = (_, I, M = {}) => {
    const W = X(n, _);
    let Z = I;
    if (W) {
      const Q = W._f;
      Q && (!Q.disabled && Le(a, _, Mv(I, Q)), Z = Oo(Q.ref) && dt(I) ? "" : I, Iv(Q.ref) ? [...Q.ref.options].forEach((le) => le.selected = Z.includes(le.value)) : Q.refs ? Sa(Q.ref) ? Q.refs.length > 1 ? Q.refs.forEach((le) => (!le.defaultChecked || !le.disabled) && (le.checked = Array.isArray(Z) ? !!Z.find((ke) => ke === le.value) : Z === le.value)) : Q.refs[0] && (Q.refs[0].checked = !!Z) : Q.refs.forEach((le) => le.checked = le.value === Z) : nd(Q.ref) ? Q.ref.value = "" : (Q.ref.value = Z, Q.ref.type || d.values.next({
        name: _,
        values: { ...a }
      })));
    }
    (M.shouldDirty || M.shouldTouch) && T(_, Z, M.shouldTouch, M.shouldDirty, !0), M.shouldValidate && j(_);
  }, O = (_, I, M) => {
    for (const W in I) {
      const Z = I[W], Q = `${_}.${W}`, le = X(n, Q);
      (s.array.has(_) || !Ro(Z) || le && !le._f) && !Rn(Z) ? O(Q, Z, M) : L(Q, Z, M);
    }
  }, x = (_, I, M = {}) => {
    const W = X(n, _), Z = s.array.has(_), Q = kt(I);
    Le(a, _, Q), Z ? (d.array.next({
      name: _,
      values: { ...a }
    }), (c.isDirty || c.dirtyFields) && M.shouldDirty && d.state.next({
      name: _,
      dirtyFields: Za(i, a),
      isDirty: k(_, Q)
    })) : W && !W._f && !dt(Q) ? O(_, Q, M) : L(_, Q, M), sh(_, s) && d.state.next({ ...r }), d.values.next({
      name: o.mount ? _ : void 0,
      values: { ...a }
    });
  }, U = async (_) => {
    o.mount = !0;
    const I = _.target;
    let M = I.name, W = !0;
    const Z = X(n, M), Q = () => I.type ? ku(Z._f) : IE(_), le = (ke) => {
      W = Number.isNaN(ke) || ke === X(a, M, ke);
    };
    if (Z) {
      let ke, Ge;
      const Dt = Q(), xn = _.type === ah.BLUR || _.type === ah.FOCUS_OUT, y$ = !WE(Z._f) && !t.resolver && !X(r.errors, M) && !Z._f.deps || QE(xn, X(r.touchedFields, M), r.isSubmitted, h, f), ru = sh(M, s, xn);
      Le(a, M, Dt), xn ? (Z._f.onBlur && Z._f.onBlur(_), u && u(0)) : Z._f.onChange && Z._f.onChange(_);
      const nu = T(M, Dt, xn, !1), g$ = !Et(nu) || ru;
      if (!xn && d.values.next({
        name: M,
        type: _.type,
        values: { ...a }
      }), y$)
        return c.isValid && g(), g$ && d.state.next({ name: M, ...ru ? {} : nu });
      if (!xn && ru && d.state.next({ ...r }), t.resolver) {
        const { errors: Zd } = await y([M]);
        if (le(Dt), W) {
          const b$ = hh(r.errors, n, M), Yd = hh(Zd, n, b$.name || M);
          ke = Yd.error, M = Yd.name, Ge = Et(Zd);
        }
      } else
        $([M], !0), ke = (await fh(Z, a, p, t.shouldUseNativeValidation))[M], $([M]), le(Dt), W && (ke ? Ge = !1 : c.isValid && (Ge = await w(n, !0)));
      W && (Z._f.deps && j(Z._f.deps), R(M, Ge, ke, nu));
    }
  }, K = (_, I) => {
    if (X(r.errors, I) && _.focus)
      return _.focus(), 1;
  }, j = async (_, I = {}) => {
    let M, W;
    const Z = wu(_);
    if (t.resolver) {
      const Q = await A(Qe(_) ? _ : Z);
      M = Et(Q), W = _ ? !Z.some((le) => X(Q, le)) : M;
    } else _ ? (W = (await Promise.all(Z.map(async (Q) => {
      const le = X(n, Q);
      return await w(le && le._f ? { [Q]: le } : le);
    }))).every(Boolean), !(!W && !r.isValid) && g()) : W = M = await w(n);
    return d.state.next({
      ...!qt(_) || c.isValid && M !== r.isValid ? {} : { name: _ },
      ...t.resolver || !_ ? { isValid: M } : {},
      errors: r.errors
    }), I.shouldFocus && !W && Ui(n, K, _ ? Z : s.mount), W;
  }, ae = (_) => {
    const I = {
      ...o.mount ? a : i
    };
    return Qe(_) ? I : qt(_) ? X(I, _) : _.map((M) => X(I, M));
  }, ne = (_, I) => ({
    invalid: !!X((I || r).errors, _),
    isDirty: !!X((I || r).dirtyFields, _),
    error: X((I || r).errors, _),
    isValidating: !!X(r.validatingFields, _),
    isTouched: !!X((I || r).touchedFields, _)
  }), me = (_) => {
    _ && wu(_).forEach((I) => tt(r.errors, I)), d.state.next({
      errors: _ ? r.errors : {}
    });
  }, $e = (_, I, M) => {
    const W = (X(n, _, { _f: {} })._f || {}).ref, Z = X(r.errors, _) || {}, { ref: Q, message: le, type: ke, ...Ge } = Z;
    Le(r.errors, _, {
      ...Ge,
      ...I,
      ref: W
    }), d.state.next({
      name: _,
      errors: r.errors,
      isValid: !1
    }), M && M.shouldFocus && W && W.focus && W.focus();
  }, _e = (_, I) => Fr(_) ? d.values.subscribe({
    next: (M) => _(C(void 0, I), M)
  }) : C(_, I, !0), Fe = (_, I = {}) => {
    for (const M of _ ? wu(_) : s.mount)
      s.mount.delete(M), s.array.delete(M), I.keepValue || (tt(n, M), tt(a, M)), !I.keepError && tt(r.errors, M), !I.keepDirty && tt(r.dirtyFields, M), !I.keepTouched && tt(r.touchedFields, M), !I.keepIsValidating && tt(r.validatingFields, M), !t.shouldUnregister && !I.keepDefaultValue && tt(i, M);
    d.values.next({
      values: { ...a }
    }), d.state.next({
      ...r,
      ...I.keepDirty ? { isDirty: k() } : {}
    }), !I.keepIsValid && g();
  }, V = ({ disabled: _, name: I, field: M, fields: W, value: Z }) => {
    if (_r(_) && o.mount || _) {
      const Q = _ ? void 0 : Qe(Z) ? ku(M ? M._f : X(W, I)._f) : Z;
      Le(a, I, Q), T(I, Q, !1, !1, !0);
    }
  }, ie = (_, I = {}) => {
    let M = X(n, _);
    const W = _r(I.disabled);
    return Le(n, _, {
      ...M || {},
      _f: {
        ...M && M._f ? M._f : { ref: { name: _ } },
        name: _,
        mount: !0,
        ...I
      }
    }), s.mount.add(_), M ? V({
      field: M,
      disabled: I.disabled,
      name: _,
      value: I.value
    }) : S(_, !0, I.value), {
      ...W ? { disabled: I.disabled } : {},
      ...t.progressive ? {
        required: !!I.required,
        min: Ei(I.min),
        max: Ei(I.max),
        minLength: Ei(I.minLength),
        maxLength: Ei(I.maxLength),
        pattern: Ei(I.pattern)
      } : {},
      name: _,
      onChange: U,
      onBlur: U,
      ref: (Z) => {
        if (Z) {
          ie(_, I), M = X(n, _);
          const Q = Qe(Z.value) && Z.querySelectorAll && Z.querySelectorAll("input,select,textarea")[0] || Z, le = qE(Q), ke = M._f.refs || [];
          if (le ? ke.find((Ge) => Ge === Q) : Q === M._f.ref)
            return;
          Le(n, _, {
            _f: {
              ...M._f,
              ...le ? {
                refs: [
                  ...ke.filter(Su),
                  Q,
                  ...Array.isArray(X(i, _)) ? [{}] : []
                ],
                ref: { type: Q.type, name: _ }
              } : { ref: Q }
            }
          }), S(_, !1, void 0, Q);
        } else
          M = X(n, _, {}), M._f && (M._f.mount = !1), (t.shouldUnregister || I.shouldUnregister) && !(BE(s.array, _) && o.action) && s.unMount.add(_);
      }
    };
  }, De = () => t.shouldFocusError && Ui(n, K, s.mount), ze = (_) => {
    _r(_) && (d.state.next({ disabled: _ }), Ui(n, (I, M) => {
      const W = X(n, M);
      W && (I.disabled = W._f.disabled || _, Array.isArray(W._f.refs) && W._f.refs.forEach((Z) => {
        Z.disabled = W._f.disabled || _;
      }));
    }, 0, !1));
  }, He = (_, I) => async (M) => {
    let W;
    M && (M.preventDefault && M.preventDefault(), M.persist && M.persist());
    let Z = kt(a);
    if (d.state.next({
      isSubmitting: !0
    }), t.resolver) {
      const { errors: Q, values: le } = await y();
      r.errors = Q, Z = le;
    } else
      await w(n);
    if (tt(r.errors, "root"), Et(r.errors)) {
      d.state.next({
        errors: {}
      });
      try {
        await _(Z, M);
      } catch (Q) {
        W = Q;
      }
    } else
      I && await I({ ...r.errors }, M), De(), setTimeout(De);
    if (d.state.next({
      isSubmitted: !0,
      isSubmitting: !1,
      isSubmitSuccessful: Et(r.errors) && !W,
      submitCount: r.submitCount + 1,
      errors: r.errors
    }), W)
      throw W;
  }, xr = (_, I = {}) => {
    X(n, _) && (Qe(I.defaultValue) ? x(_, kt(X(i, _))) : (x(_, I.defaultValue), Le(i, _, kt(I.defaultValue))), I.keepTouched || tt(r.touchedFields, _), I.keepDirty || (tt(r.dirtyFields, _), r.isDirty = I.defaultValue ? k(_, kt(X(i, _))) : k()), I.keepError || (tt(r.errors, _), c.isValid && g()), d.state.next({ ...r }));
  }, qr = (_, I = {}) => {
    const M = _ ? kt(_) : i, W = kt(M), Z = Et(_), Q = Z ? i : W;
    if (I.keepDefaultValues || (i = M), !I.keepValues) {
      if (I.keepDirtyValues)
        for (const le of s.mount)
          X(r.dirtyFields, le) ? Le(Q, le, X(a, le)) : x(le, X(Q, le));
      else {
        if (td && Qe(_))
          for (const le of s.mount) {
            const ke = X(n, le);
            if (ke && ke._f) {
              const Ge = Array.isArray(ke._f.refs) ? ke._f.refs[0] : ke._f.ref;
              if (Oo(Ge)) {
                const Dt = Ge.closest("form");
                if (Dt) {
                  Dt.reset();
                  break;
                }
              }
            }
          }
        n = {};
      }
      a = e.shouldUnregister ? I.keepDefaultValues ? kt(i) : {} : kt(Q), d.array.next({
        values: { ...Q }
      }), d.values.next({
        values: { ...Q }
      });
    }
    s = {
      mount: I.keepDirtyValues ? s.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: !1,
      focus: ""
    }, o.mount = !c.isValid || !!I.keepIsValid || !!I.keepDirtyValues, o.watch = !!e.shouldUnregister, d.state.next({
      submitCount: I.keepSubmitCount ? r.submitCount : 0,
      isDirty: Z ? !1 : I.keepDirty ? r.isDirty : !!(I.keepDefaultValues && !Jr(_, i)),
      isSubmitted: I.keepIsSubmitted ? r.isSubmitted : !1,
      dirtyFields: Z ? [] : I.keepDirtyValues ? I.keepDefaultValues && a ? Za(i, a) : r.dirtyFields : I.keepDefaultValues && _ ? Za(i, _) : I.keepDirty ? r.dirtyFields : {},
      touchedFields: I.keepTouched ? r.touchedFields : {},
      errors: I.keepErrors ? r.errors : {},
      isSubmitSuccessful: I.keepIsSubmitSuccessful ? r.isSubmitSuccessful : !1,
      isSubmitting: !1
    });
  }, $n = (_, I) => qr(Fr(_) ? _(a) : _, I);
  return {
    control: {
      register: ie,
      unregister: Fe,
      getFieldState: ne,
      handleSubmit: He,
      setError: $e,
      _executeSchema: y,
      _getWatch: C,
      _getDirty: k,
      _updateValid: g,
      _removeUnmounted: E,
      _updateFieldArray: m,
      _updateDisabledField: V,
      _getFieldArray: P,
      _reset: qr,
      _resetDefaultValues: () => Fr(t.defaultValues) && t.defaultValues().then((_) => {
        $n(_, t.resetOptions), d.state.next({
          isLoading: !1
        });
      }),
      _updateFormState: (_) => {
        r = {
          ...r,
          ..._
        };
      },
      _disableForm: ze,
      _subjects: d,
      _proxyFormState: c,
      _setErrors: D,
      get _fields() {
        return n;
      },
      get _formValues() {
        return a;
      },
      get _state() {
        return o;
      },
      set _state(_) {
        o = _;
      },
      get _defaultValues() {
        return i;
      },
      get _names() {
        return s;
      },
      set _names(_) {
        s = _;
      },
      get _formState() {
        return r;
      },
      set _formState(_) {
        r = _;
      },
      get _options() {
        return t;
      },
      set _options(_) {
        t = {
          ...t,
          ..._
        };
      }
    },
    trigger: j,
    register: ie,
    handleSubmit: He,
    watch: _e,
    setValue: x,
    getValues: ae,
    reset: $n,
    resetField: xr,
    clearErrors: me,
    unregister: Fe,
    setError: $e,
    setFocus: (_, I = {}) => {
      const M = X(n, _), W = M && M._f;
      if (W) {
        const Z = W.refs ? W.refs[0] : W.ref;
        Z.focus && (Z.focus(), I.shouldSelect && Z.select());
      }
    },
    getFieldState: ne
  };
}
function Nv(e = {}) {
  const t = F.useRef(), r = F.useRef(), [n, i] = F.useState({
    isDirty: !1,
    isValidating: !1,
    isLoading: Fr(e.defaultValues),
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: e.errors || {},
    disabled: e.disabled || !1,
    defaultValues: Fr(e.defaultValues) ? void 0 : e.defaultValues
  });
  t.current || (t.current = {
    ...YE(e),
    formState: n
  });
  const a = t.current.control;
  return a._options = e, VE({
    subject: a._subjects.state,
    next: (o) => {
      LE(o, a._proxyFormState, a._updateFormState) && i({ ...a._formState });
    }
  }), F.useEffect(() => a._disableForm(e.disabled), [a, e.disabled]), F.useEffect(() => {
    if (a._proxyFormState.isDirty) {
      const o = a._getDirty();
      o !== n.isDirty && a._subjects.state.next({
        isDirty: o
      });
    }
  }, [a, n.isDirty]), F.useEffect(() => {
    e.values && !Jr(e.values, r.current) ? (a._reset(e.values, a._options.resetOptions), r.current = e.values, i((o) => ({ ...o }))) : a._resetDefaultValues();
  }, [e.values, a]), F.useEffect(() => {
    e.errors && a._setErrors(e.errors);
  }, [e.errors, a]), F.useEffect(() => {
    a._state.mount || (a._updateValid(), a._state.mount = !0), a._state.watch && (a._state.watch = !1, a._subjects.state.next({ ...a._formState })), a._removeUnmounted();
  }), F.useEffect(() => {
    e.shouldUnregister && a._subjects.values.next({
      values: a._getWatch()
    });
  }, [e.shouldUnregister, a]), t.current.formState = NE(n, a), t.current;
}
var ph = function(e, t, r) {
  if (e && "reportValidity" in e) {
    var n = X(r, t);
    e.setCustomValidity(n && n.message || ""), e.reportValidity();
  }
}, Lv = function(e, t) {
  var r = function(i) {
    var a = t.fields[i];
    a && a.ref && "reportValidity" in a.ref ? ph(a.ref, i, e) : a.refs && a.refs.forEach(function(o) {
      return ph(o, i, e);
    });
  };
  for (var n in t.fields) r(n);
}, JE = function(e) {
  return e instanceof Date;
}, XE = function(e) {
  return e == null;
}, ew = function(e) {
  return typeof e == "object";
}, tw = function(e) {
  return !XE(e) && !Array.isArray(e) && ew(e) && !JE(e);
}, rw = function(e) {
  return /^\w*$/.test(e);
}, Tu = function(e, t, r) {
  for (var n = -1, i = rw(t) ? [t] : function(c) {
    return d = c.replace(/["|']|\]/g, "").split(/\.|\[/), Array.isArray(d) ? d.filter(Boolean) : [];
    var d;
  }(t), a = i.length, o = a - 1; ++n < a; ) {
    var s = i[n], u = r;
    if (n !== o) {
      var l = e[s];
      u = tw(l) || Array.isArray(l) ? l : isNaN(+i[n + 1]) ? {} : [];
    }
    e[s] = u, e = e[s];
  }
  return e;
}, nw = function(e, t) {
  t.shouldUseNativeValidation && Lv(e, t);
  var r = {};
  for (var n in e) {
    var i = X(t.fields, n), a = Object.assign(e[n] || {}, { ref: i && i.ref });
    if (iw(t.names || Object.keys(e), n)) {
      var o = Object.assign({}, X(r, n));
      Tu(o, "root", a), Tu(r, n, o);
    } else Tu(r, n, a);
  }
  return r;
}, iw = function(e, t) {
  return e.some(function(r) {
    return r.startsWith(t + ".");
  });
}, aw = function(e, t) {
  for (var r = {}; e.length; ) {
    var n = e[0], i = n.code, a = n.message, o = n.path.join(".");
    if (!r[o]) if ("unionErrors" in n) {
      var s = n.unionErrors[0].errors[0];
      r[o] = { message: s.message, type: s.code };
    } else r[o] = { message: a, type: i };
    if ("unionErrors" in n && n.unionErrors.forEach(function(c) {
      return c.errors.forEach(function(d) {
        return e.push(d);
      });
    }), t) {
      var u = r[o].types, l = u && u[n.code];
      r[o] = _v(o, t, r, i, l ? [].concat(l, n.message) : n.message);
    }
    e.shift();
  }
  return r;
}, Vv = function(e, t, r) {
  return r === void 0 && (r = {}), function(n, i, a) {
    try {
      return Promise.resolve(function(o, s) {
        try {
          var u = Promise.resolve(e[r.mode === "sync" ? "parse" : "parseAsync"](n, t)).then(function(l) {
            return a.shouldUseNativeValidation && Lv({}, a), { errors: {}, values: r.raw ? n : l };
          });
        } catch (l) {
          return s(l);
        }
        return u && u.then ? u.then(void 0, s) : u;
      }(0, function(o) {
        if (function(s) {
          return s.errors != null;
        }(o)) return { values: {}, errors: nw(aw(o.errors, !a.shouldUseNativeValidation && a.criteriaMode === "all"), a) };
        throw o;
      }));
    } catch (o) {
      return Promise.reject(o);
    }
  };
}, we;
(function(e) {
  e.assertEqual = (i) => i;
  function t(i) {
  }
  e.assertIs = t;
  function r(i) {
    throw new Error();
  }
  e.assertNever = r, e.arrayToEnum = (i) => {
    const a = {};
    for (const o of i)
      a[o] = o;
    return a;
  }, e.getValidEnumValues = (i) => {
    const a = e.objectKeys(i).filter((s) => typeof i[i[s]] != "number"), o = {};
    for (const s of a)
      o[s] = i[s];
    return e.objectValues(o);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(a) {
    return i[a];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const a = [];
    for (const o in i)
      Object.prototype.hasOwnProperty.call(i, o) && a.push(o);
    return a;
  }, e.find = (i, a) => {
    for (const o of i)
      if (a(o))
        return o;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function n(i, a = " | ") {
    return i.map((o) => typeof o == "string" ? `'${o}'` : o).join(a);
  }
  e.joinValues = n, e.jsonStringifyReplacer = (i, a) => typeof a == "bigint" ? a.toString() : a;
})(we || (we = {}));
var mh;
(function(e) {
  e.mergeShapes = (t, r) => ({
    ...t,
    ...r
    // second overwrites first
  });
})(mh || (mh = {}));
const J = we.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Qr = (e) => {
  switch (typeof e) {
    case "undefined":
      return J.undefined;
    case "string":
      return J.string;
    case "number":
      return isNaN(e) ? J.nan : J.number;
    case "boolean":
      return J.boolean;
    case "function":
      return J.function;
    case "bigint":
      return J.bigint;
    case "symbol":
      return J.symbol;
    case "object":
      return Array.isArray(e) ? J.array : e === null ? J.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? J.promise : typeof Map < "u" && e instanceof Map ? J.map : typeof Set < "u" && e instanceof Set ? J.set : typeof Date < "u" && e instanceof Date ? J.date : J.object;
    default:
      return J.unknown;
  }
}, H = we.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class _t extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(a) {
      return a.message;
    }, n = { _errors: [] }, i = (a) => {
      for (const o of a.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(i);
        else if (o.code === "invalid_return_type")
          i(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          i(o.argumentsError);
        else if (o.path.length === 0)
          n._errors.push(r(o));
        else {
          let s = n, u = 0;
          for (; u < o.path.length; ) {
            const l = o.path[u];
            u === o.path.length - 1 ? (s[l] = s[l] || { _errors: [] }, s[l]._errors.push(r(o))) : s[l] = s[l] || { _errors: [] }, s = s[l], u++;
          }
        }
    };
    return i(this), n;
  }
  static assert(t) {
    if (!(t instanceof _t))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, we.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, n = [];
    for (const i of this.issues)
      i.path.length > 0 ? (r[i.path[0]] = r[i.path[0]] || [], r[i.path[0]].push(t(i))) : n.push(t(i));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
_t.create = (e) => new _t(e);
const oa = (e, t) => {
  let r;
  switch (e.code) {
    case H.invalid_type:
      e.received === J.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case H.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, we.jsonStringifyReplacer)}`;
      break;
    case H.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${we.joinValues(e.keys, ", ")}`;
      break;
    case H.invalid_union:
      r = "Invalid input";
      break;
    case H.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${we.joinValues(e.options)}`;
      break;
    case H.invalid_enum_value:
      r = `Invalid enum value. Expected ${we.joinValues(e.options)}, received '${e.received}'`;
      break;
    case H.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case H.invalid_return_type:
      r = "Invalid function return type";
      break;
    case H.invalid_date:
      r = "Invalid date";
      break;
    case H.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : we.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case H.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case H.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case H.custom:
      r = "Invalid input";
      break;
    case H.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case H.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case H.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, we.assertNever(e);
  }
  return { message: r };
};
let ow = oa;
function _l() {
  return ow;
}
const Fl = (e) => {
  const { data: t, path: r, errorMaps: n, issueData: i } = e, a = [...r, ...i.path || []], o = {
    ...i,
    path: a
  };
  if (i.message !== void 0)
    return {
      ...i,
      path: a,
      message: i.message
    };
  let s = "";
  const u = n.filter((l) => !!l).slice().reverse();
  for (const l of u)
    s = l(o, { data: t, defaultError: s }).message;
  return {
    ...i,
    path: a,
    message: s
  };
};
function Y(e, t) {
  const r = _l(), n = Fl({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      r,
      r === oa ? void 0 : oa
      // then global default map
    ].filter((i) => !!i)
  });
  e.common.issues.push(n);
}
class pt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, r) {
    const n = [];
    for (const i of r) {
      if (i.status === "aborted")
        return he;
      i.status === "dirty" && t.dirty(), n.push(i.value);
    }
    return { status: t.value, value: n };
  }
  static async mergeObjectAsync(t, r) {
    const n = [];
    for (const i of r) {
      const a = await i.key, o = await i.value;
      n.push({
        key: a,
        value: o
      });
    }
    return pt.mergeObjectSync(t, n);
  }
  static mergeObjectSync(t, r) {
    const n = {};
    for (const i of r) {
      const { key: a, value: o } = i;
      if (a.status === "aborted" || o.status === "aborted")
        return he;
      a.status === "dirty" && t.dirty(), o.status === "dirty" && t.dirty(), a.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (n[a.value] = o.value);
    }
    return { status: t.value, value: n };
  }
}
const he = Object.freeze({
  status: "aborted"
}), Fi = (e) => ({ status: "dirty", value: e }), $t = (e) => ({ status: "valid", value: e }), vh = (e) => e.status === "aborted", yh = (e) => e.status === "dirty", Mo = (e) => e.status === "valid", No = (e) => typeof Promise < "u" && e instanceof Promise;
function Lo(e, t, r, n) {
  if (typeof t == "function" ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t.get(e);
}
function jv(e, t, r, n, i) {
  if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(e, r), r;
}
var oe;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(oe || (oe = {}));
var Oi, Ii;
class Yt {
  constructor(t, r, n, i) {
    this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const gh = (e, t) => {
  if (Mo(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new _t(e.common.issues);
      return this._error = r, this._error;
    }
  };
};
function pe(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: r, required_error: n, description: i } = e;
  if (t && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (o, s) => {
    var u, l;
    const { message: c } = e;
    return o.code === "invalid_enum_value" ? { message: c ?? s.defaultError } : typeof s.data > "u" ? { message: (u = c ?? n) !== null && u !== void 0 ? u : s.defaultError } : o.code !== "invalid_type" ? { message: s.defaultError } : { message: (l = c ?? r) !== null && l !== void 0 ? l : s.defaultError };
  }, description: i };
}
class be {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Qr(t.data);
  }
  _getOrReturnCtx(t, r) {
    return r || {
      common: t.parent.common,
      data: t.data,
      parsedType: Qr(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new pt(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Qr(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const r = this._parse(t);
    if (No(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(t) {
    const r = this._parse(t);
    return Promise.resolve(r);
  }
  parse(t, r) {
    const n = this.safeParse(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(t, r) {
    var n;
    const i = {
      common: {
        issues: [],
        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Qr(t)
    }, a = this._parseSync({ data: t, path: i.path, parent: i });
    return gh(i, a);
  }
  async parseAsync(t, r) {
    const n = await this.safeParseAsync(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(t, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: !0
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Qr(t)
    }, i = this._parse({ data: t, path: n.path, parent: n }), a = await (No(i) ? i : Promise.resolve(i));
    return gh(n, a);
  }
  refine(t, r) {
    const n = (i) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(i) : r;
    return this._refinement((i, a) => {
      const o = t(i), s = () => a.addIssue({
        code: H.custom,
        ...n(i)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((u) => u ? !0 : (s(), !1)) : o ? !0 : (s(), !1);
    });
  }
  refinement(t, r) {
    return this._refinement((n, i) => t(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1));
  }
  _refinement(t) {
    return new vr({
      schema: this,
      typeName: fe.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return fr.create(this, this._def);
  }
  nullable() {
    return un.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Gt.create(this, this._def);
  }
  promise() {
    return ua.create(this, this._def);
  }
  or(t) {
    return zo.create([this, t], this._def);
  }
  and(t) {
    return Ko.create(this, t, this._def);
  }
  transform(t) {
    return new vr({
      ...pe(this._def),
      schema: this,
      typeName: fe.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const r = typeof t == "function" ? t : () => t;
    return new Qo({
      ...pe(this._def),
      innerType: this,
      defaultValue: r,
      typeName: fe.ZodDefault
    });
  }
  brand() {
    return new qv({
      typeName: fe.ZodBranded,
      type: this,
      ...pe(this._def)
    });
  }
  catch(t) {
    const r = typeof t == "function" ? t : () => t;
    return new Go({
      ...pe(this._def),
      innerType: this,
      catchValue: r,
      typeName: fe.ZodCatch
    });
  }
  describe(t) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return As.create(this, t);
  }
  readonly() {
    return Zo.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const sw = /^c[^\s-]{8,}$/i, uw = /^[0-9a-z]+$/, lw = /^[0-9A-HJKMNP-TV-Z]{26}$/, cw = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, dw = /^[a-z0-9_-]{21}$/i, fw = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, hw = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, pw = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let Pu;
const mw = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, vw = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, yw = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, zv = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", gw = new RegExp(`^${zv}$`);
function Kv(e) {
  let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t;
}
function bw(e) {
  return new RegExp(`^${Kv(e)}$`);
}
function $w(e) {
  let t = `${zv}T${Kv(e)}`;
  const r = [];
  return r.push(e.local ? "Z?" : "Z"), e.offset && r.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${r.join("|")})`, new RegExp(`^${t}$`);
}
function xw(e, t) {
  return !!((t === "v4" || !t) && mw.test(e) || (t === "v6" || !t) && vw.test(e));
}
class lr extends be {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== J.string) {
      const a = this._getOrReturnCtx(t);
      return Y(a, {
        code: H.invalid_type,
        expected: J.string,
        received: a.parsedType
      }), he;
    }
    const n = new pt();
    let i;
    for (const a of this._def.checks)
      if (a.kind === "min")
        t.data.length < a.value && (i = this._getOrReturnCtx(t, i), Y(i, {
          code: H.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), n.dirty());
      else if (a.kind === "max")
        t.data.length > a.value && (i = this._getOrReturnCtx(t, i), Y(i, {
          code: H.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), n.dirty());
      else if (a.kind === "length") {
        const o = t.data.length > a.value, s = t.data.length < a.value;
        (o || s) && (i = this._getOrReturnCtx(t, i), o ? Y(i, {
          code: H.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : s && Y(i, {
          code: H.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), n.dirty());
      } else if (a.kind === "email")
        hw.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "email",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "emoji")
        Pu || (Pu = new RegExp(pw, "u")), Pu.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "emoji",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "uuid")
        cw.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "uuid",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "nanoid")
        dw.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "nanoid",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "cuid")
        sw.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "cuid",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "cuid2")
        uw.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "cuid2",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "ulid")
        lw.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
          validation: "ulid",
          code: H.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), Y(i, {
            validation: "url",
            code: H.invalid_string,
            message: a.message
          }), n.dirty();
        }
      else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
        validation: "regex",
        code: H.invalid_string,
        message: a.message
      }), n.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.invalid_string,
        validation: { includes: a.value, position: a.position },
        message: a.message
      }), n.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a.kind === "startsWith" ? t.data.startsWith(a.value) || (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.invalid_string,
        validation: { startsWith: a.value },
        message: a.message
      }), n.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.invalid_string,
        validation: { endsWith: a.value },
        message: a.message
      }), n.dirty()) : a.kind === "datetime" ? $w(a).test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.invalid_string,
        validation: "datetime",
        message: a.message
      }), n.dirty()) : a.kind === "date" ? gw.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.invalid_string,
        validation: "date",
        message: a.message
      }), n.dirty()) : a.kind === "time" ? bw(a).test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.invalid_string,
        validation: "time",
        message: a.message
      }), n.dirty()) : a.kind === "duration" ? fw.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
        validation: "duration",
        code: H.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "ip" ? xw(t.data, a.version) || (i = this._getOrReturnCtx(t, i), Y(i, {
        validation: "ip",
        code: H.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "base64" ? yw.test(t.data) || (i = this._getOrReturnCtx(t, i), Y(i, {
        validation: "base64",
        code: H.invalid_string,
        message: a.message
      }), n.dirty()) : we.assertNever(a);
    return { status: n.value, value: t.data };
  }
  _regex(t, r, n) {
    return this.refinement((i) => t.test(i), {
      validation: r,
      code: H.invalid_string,
      ...oe.errToObj(n)
    });
  }
  _addCheck(t) {
    return new lr({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...oe.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...oe.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...oe.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...oe.errToObj(t) });
  }
  nanoid(t) {
    return this._addCheck({ kind: "nanoid", ...oe.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...oe.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...oe.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...oe.errToObj(t) });
  }
  base64(t) {
    return this._addCheck({ kind: "base64", ...oe.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...oe.errToObj(t) });
  }
  datetime(t) {
    var r, n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
      local: (n = t == null ? void 0 : t.local) !== null && n !== void 0 ? n : !1,
      ...oe.errToObj(t == null ? void 0 : t.message)
    });
  }
  date(t) {
    return this._addCheck({ kind: "date", message: t });
  }
  time(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: t
    }) : this._addCheck({
      kind: "time",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      ...oe.errToObj(t == null ? void 0 : t.message)
    });
  }
  duration(t) {
    return this._addCheck({ kind: "duration", ...oe.errToObj(t) });
  }
  regex(t, r) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...oe.errToObj(r)
    });
  }
  includes(t, r) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: r == null ? void 0 : r.position,
      ...oe.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(t, r) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...oe.errToObj(r)
    });
  }
  endsWith(t, r) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...oe.errToObj(r)
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...oe.errToObj(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...oe.errToObj(r)
    });
  }
  length(t, r) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...oe.errToObj(r)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, oe.errToObj(t));
  }
  trim() {
    return new lr({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new lr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new lr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((t) => t.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((t) => t.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((t) => t.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((t) => t.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((t) => t.kind === "base64");
  }
  get minLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
lr.create = (e) => {
  var t;
  return new lr({
    checks: [],
    typeName: fe.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...pe(e)
  });
};
function Dw(e, t) {
  const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, i = r > n ? r : n, a = parseInt(e.toFixed(i).replace(".", "")), o = parseInt(t.toFixed(i).replace(".", ""));
  return a % o / Math.pow(10, i);
}
class ri extends be {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== J.number) {
      const a = this._getOrReturnCtx(t);
      return Y(a, {
        code: H.invalid_type,
        expected: J.number,
        received: a.parsedType
      }), he;
    }
    let n;
    const i = new pt();
    for (const a of this._def.checks)
      a.kind === "int" ? we.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), i.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? Dw(t.data, a.value) !== 0 && (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.not_finite,
        message: a.message
      }), i.dirty()) : we.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, oe.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, oe.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, oe.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, oe.toString(r));
  }
  setLimit(t, r, n, i) {
    return new ri({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: oe.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new ri({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: oe.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: oe.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: oe.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: oe.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: oe.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: oe.toString(r)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: oe.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: oe.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: oe.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && we.isInteger(t.value));
  }
  get isFinite() {
    let t = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(t);
  }
}
ri.create = (e) => new ri({
  checks: [],
  typeName: fe.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...pe(e)
});
class ni extends be {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== J.bigint) {
      const a = this._getOrReturnCtx(t);
      return Y(a, {
        code: H.invalid_type,
        expected: J.bigint,
        received: a.parsedType
      }), he;
    }
    let n;
    const i = new pt();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), Y(n, {
        code: H.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : we.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, oe.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, oe.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, oe.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, oe.toString(r));
  }
  setLimit(t, r, n, i) {
    return new ni({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: oe.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new ni({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: oe.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: oe.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: oe.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: oe.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: oe.toString(r)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
ni.create = (e) => {
  var t;
  return new ni({
    checks: [],
    typeName: fe.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...pe(e)
  });
};
class Ol extends be {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== J.boolean) {
      const n = this._getOrReturnCtx(t);
      return Y(n, {
        code: H.invalid_type,
        expected: J.boolean,
        received: n.parsedType
      }), he;
    }
    return $t(t.data);
  }
}
Ol.create = (e) => new Ol({
  typeName: fe.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...pe(e)
});
class sa extends be {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== J.date) {
      const a = this._getOrReturnCtx(t);
      return Y(a, {
        code: H.invalid_type,
        expected: J.date,
        received: a.parsedType
      }), he;
    }
    if (isNaN(t.data.getTime())) {
      const a = this._getOrReturnCtx(t);
      return Y(a, {
        code: H.invalid_date
      }), he;
    }
    const n = new pt();
    let i;
    for (const a of this._def.checks)
      a.kind === "min" ? t.data.getTime() < a.value && (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), n.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (i = this._getOrReturnCtx(t, i), Y(i, {
        code: H.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), n.dirty()) : we.assertNever(a);
    return {
      status: n.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new sa({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: oe.toString(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: oe.toString(r)
    });
  }
  get minDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
}
sa.create = (e) => new sa({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: fe.ZodDate,
  ...pe(e)
});
class Il extends be {
  _parse(t) {
    if (this._getType(t) !== J.symbol) {
      const n = this._getOrReturnCtx(t);
      return Y(n, {
        code: H.invalid_type,
        expected: J.symbol,
        received: n.parsedType
      }), he;
    }
    return $t(t.data);
  }
}
Il.create = (e) => new Il({
  typeName: fe.ZodSymbol,
  ...pe(e)
});
class Vo extends be {
  _parse(t) {
    if (this._getType(t) !== J.undefined) {
      const n = this._getOrReturnCtx(t);
      return Y(n, {
        code: H.invalid_type,
        expected: J.undefined,
        received: n.parsedType
      }), he;
    }
    return $t(t.data);
  }
}
Vo.create = (e) => new Vo({
  typeName: fe.ZodUndefined,
  ...pe(e)
});
class jo extends be {
  _parse(t) {
    if (this._getType(t) !== J.null) {
      const n = this._getOrReturnCtx(t);
      return Y(n, {
        code: H.invalid_type,
        expected: J.null,
        received: n.parsedType
      }), he;
    }
    return $t(t.data);
  }
}
jo.create = (e) => new jo({
  typeName: fe.ZodNull,
  ...pe(e)
});
class Rl extends be {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return $t(t.data);
  }
}
Rl.create = (e) => new Rl({
  typeName: fe.ZodAny,
  ...pe(e)
});
class Kn extends be {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return $t(t.data);
  }
}
Kn.create = (e) => new Kn({
  typeName: fe.ZodUnknown,
  ...pe(e)
});
class jr extends be {
  _parse(t) {
    const r = this._getOrReturnCtx(t);
    return Y(r, {
      code: H.invalid_type,
      expected: J.never,
      received: r.parsedType
    }), he;
  }
}
jr.create = (e) => new jr({
  typeName: fe.ZodNever,
  ...pe(e)
});
class Bl extends be {
  _parse(t) {
    if (this._getType(t) !== J.undefined) {
      const n = this._getOrReturnCtx(t);
      return Y(n, {
        code: H.invalid_type,
        expected: J.void,
        received: n.parsedType
      }), he;
    }
    return $t(t.data);
  }
}
Bl.create = (e) => new Bl({
  typeName: fe.ZodVoid,
  ...pe(e)
});
class Gt extends be {
  _parse(t) {
    const { ctx: r, status: n } = this._processInputParams(t), i = this._def;
    if (r.parsedType !== J.array)
      return Y(r, {
        code: H.invalid_type,
        expected: J.array,
        received: r.parsedType
      }), he;
    if (i.exactLength !== null) {
      const o = r.data.length > i.exactLength.value, s = r.data.length < i.exactLength.value;
      (o || s) && (Y(r, {
        code: o ? H.too_big : H.too_small,
        minimum: s ? i.exactLength.value : void 0,
        maximum: o ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), n.dirty());
    }
    if (i.minLength !== null && r.data.length < i.minLength.value && (Y(r, {
      code: H.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), n.dirty()), i.maxLength !== null && r.data.length > i.maxLength.value && (Y(r, {
      code: H.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((o, s) => i.type._parseAsync(new Yt(r, o, r.path, s)))).then((o) => pt.mergeArray(n, o));
    const a = [...r.data].map((o, s) => i.type._parseSync(new Yt(r, o, r.path, s)));
    return pt.mergeArray(n, a);
  }
  get element() {
    return this._def.type;
  }
  min(t, r) {
    return new Gt({
      ...this._def,
      minLength: { value: t, message: oe.toString(r) }
    });
  }
  max(t, r) {
    return new Gt({
      ...this._def,
      maxLength: { value: t, message: oe.toString(r) }
    });
  }
  length(t, r) {
    return new Gt({
      ...this._def,
      exactLength: { value: t, message: oe.toString(r) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Gt.create = (e, t) => new Gt({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: fe.ZodArray,
  ...pe(t)
});
function Tn(e) {
  if (e instanceof Ke) {
    const t = {};
    for (const r in e.shape) {
      const n = e.shape[r];
      t[r] = fr.create(Tn(n));
    }
    return new Ke({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof Gt ? new Gt({
    ...e._def,
    type: Tn(e.element)
  }) : e instanceof fr ? fr.create(Tn(e.unwrap())) : e instanceof un ? un.create(Tn(e.unwrap())) : e instanceof mr ? mr.create(e.items.map((t) => Tn(t))) : e;
}
class Ke extends be {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), r = we.objectKeys(t);
    return this._cached = { shape: t, keys: r };
  }
  _parse(t) {
    if (this._getType(t) !== J.object) {
      const l = this._getOrReturnCtx(t);
      return Y(l, {
        code: H.invalid_type,
        expected: J.object,
        received: l.parsedType
      }), he;
    }
    const { status: n, ctx: i } = this._processInputParams(t), { shape: a, keys: o } = this._getCached(), s = [];
    if (!(this._def.catchall instanceof jr && this._def.unknownKeys === "strip"))
      for (const l in i.data)
        o.includes(l) || s.push(l);
    const u = [];
    for (const l of o) {
      const c = a[l], d = i.data[l];
      u.push({
        key: { status: "valid", value: l },
        value: c._parse(new Yt(i, d, i.path, l)),
        alwaysSet: l in i.data
      });
    }
    if (this._def.catchall instanceof jr) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const c of s)
          u.push({
            key: { status: "valid", value: c },
            value: { status: "valid", value: i.data[c] }
          });
      else if (l === "strict")
        s.length > 0 && (Y(i, {
          code: H.unrecognized_keys,
          keys: s
        }), n.dirty());
      else if (l !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const c of s) {
        const d = i.data[c];
        u.push({
          key: { status: "valid", value: c },
          value: l._parse(
            new Yt(i, d, i.path, c)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: c in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const c of u) {
        const d = await c.key, f = await c.value;
        l.push({
          key: d,
          value: f,
          alwaysSet: c.alwaysSet
        });
      }
      return l;
    }).then((l) => pt.mergeObjectSync(n, l)) : pt.mergeObjectSync(n, u);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return oe.errToObj, new Ke({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (r, n) => {
          var i, a, o, s;
          const u = (o = (a = (i = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(i, r, n).message) !== null && o !== void 0 ? o : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (s = oe.errToObj(t).message) !== null && s !== void 0 ? s : u
          } : {
            message: u
          };
        }
      } : {}
    });
  }
  strip() {
    return new Ke({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Ke({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new Ke({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new Ke({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: fe.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, r) {
    return this.augment({ [t]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new Ke({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const r = {};
    return we.objectKeys(t).forEach((n) => {
      t[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new Ke({
      ...this._def,
      shape: () => r
    });
  }
  omit(t) {
    const r = {};
    return we.objectKeys(this.shape).forEach((n) => {
      t[n] || (r[n] = this.shape[n]);
    }), new Ke({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Tn(this);
  }
  partial(t) {
    const r = {};
    return we.objectKeys(this.shape).forEach((n) => {
      const i = this.shape[n];
      t && !t[n] ? r[n] = i : r[n] = i.optional();
    }), new Ke({
      ...this._def,
      shape: () => r
    });
  }
  required(t) {
    const r = {};
    return we.objectKeys(this.shape).forEach((n) => {
      if (t && !t[n])
        r[n] = this.shape[n];
      else {
        let a = this.shape[n];
        for (; a instanceof fr; )
          a = a._def.innerType;
        r[n] = a;
      }
    }), new Ke({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return Uv(we.objectKeys(this.shape));
  }
}
Ke.create = (e, t) => new Ke({
  shape: () => e,
  unknownKeys: "strip",
  catchall: jr.create(),
  typeName: fe.ZodObject,
  ...pe(t)
});
Ke.strictCreate = (e, t) => new Ke({
  shape: () => e,
  unknownKeys: "strict",
  catchall: jr.create(),
  typeName: fe.ZodObject,
  ...pe(t)
});
Ke.lazycreate = (e, t) => new Ke({
  shape: e,
  unknownKeys: "strip",
  catchall: jr.create(),
  typeName: fe.ZodObject,
  ...pe(t)
});
class zo extends be {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = this._def.options;
    function i(a) {
      for (const s of a)
        if (s.result.status === "valid")
          return s.result;
      for (const s of a)
        if (s.result.status === "dirty")
          return r.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((s) => new _t(s.ctx.common.issues));
      return Y(r, {
        code: H.invalid_union,
        unionErrors: o
      }), he;
    }
    if (r.common.async)
      return Promise.all(n.map(async (a) => {
        const o = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: r.data,
            path: r.path,
            parent: o
          }),
          ctx: o
        };
      })).then(i);
    {
      let a;
      const o = [];
      for (const u of n) {
        const l = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, c = u._parseSync({
          data: r.data,
          path: r.path,
          parent: l
        });
        if (c.status === "valid")
          return c;
        c.status === "dirty" && !a && (a = { result: c, ctx: l }), l.common.issues.length && o.push(l.common.issues);
      }
      if (a)
        return r.common.issues.push(...a.ctx.common.issues), a.result;
      const s = o.map((u) => new _t(u));
      return Y(r, {
        code: H.invalid_union,
        unionErrors: s
      }), he;
    }
  }
  get options() {
    return this._def.options;
  }
}
zo.create = (e, t) => new zo({
  options: e,
  typeName: fe.ZodUnion,
  ...pe(t)
});
const ir = (e) => e instanceof qo ? ir(e.schema) : e instanceof vr ? ir(e.innerType()) : e instanceof Ho ? [e.value] : e instanceof sn ? e.options : e instanceof Wo ? we.objectValues(e.enum) : e instanceof Qo ? ir(e._def.innerType) : e instanceof Vo ? [void 0] : e instanceof jo ? [null] : e instanceof fr ? [void 0, ...ir(e.unwrap())] : e instanceof un ? [null, ...ir(e.unwrap())] : e instanceof qv || e instanceof Zo ? ir(e.unwrap()) : e instanceof Go ? ir(e._def.innerType) : [];
class ad extends be {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== J.object)
      return Y(r, {
        code: H.invalid_type,
        expected: J.object,
        received: r.parsedType
      }), he;
    const n = this.discriminator, i = r.data[n], a = this.optionsMap.get(i);
    return a ? r.common.async ? a._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : a._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (Y(r, {
      code: H.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), he);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, r, n) {
    const i = /* @__PURE__ */ new Map();
    for (const a of r) {
      const o = ir(a.shape[t]);
      if (!o.length)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const s of o) {
        if (i.has(s))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
        i.set(s, a);
      }
    }
    return new ad({
      typeName: fe.ZodDiscriminatedUnion,
      discriminator: t,
      options: r,
      optionsMap: i,
      ...pe(n)
    });
  }
}
function Ml(e, t) {
  const r = Qr(e), n = Qr(t);
  if (e === t)
    return { valid: !0, data: e };
  if (r === J.object && n === J.object) {
    const i = we.objectKeys(t), a = we.objectKeys(e).filter((s) => i.indexOf(s) !== -1), o = { ...e, ...t };
    for (const s of a) {
      const u = Ml(e[s], t[s]);
      if (!u.valid)
        return { valid: !1 };
      o[s] = u.data;
    }
    return { valid: !0, data: o };
  } else if (r === J.array && n === J.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let a = 0; a < e.length; a++) {
      const o = e[a], s = t[a], u = Ml(o, s);
      if (!u.valid)
        return { valid: !1 };
      i.push(u.data);
    }
    return { valid: !0, data: i };
  } else return r === J.date && n === J.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class Ko extends be {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), i = (a, o) => {
      if (vh(a) || vh(o))
        return he;
      const s = Ml(a.value, o.value);
      return s.valid ? ((yh(a) || yh(o)) && r.dirty(), { status: r.value, value: s.data }) : (Y(n, {
        code: H.invalid_intersection_types
      }), he);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([a, o]) => i(a, o)) : i(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
Ko.create = (e, t, r) => new Ko({
  left: e,
  right: t,
  typeName: fe.ZodIntersection,
  ...pe(r)
});
class mr extends be {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== J.array)
      return Y(n, {
        code: H.invalid_type,
        expected: J.array,
        received: n.parsedType
      }), he;
    if (n.data.length < this._def.items.length)
      return Y(n, {
        code: H.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), he;
    !this._def.rest && n.data.length > this._def.items.length && (Y(n, {
      code: H.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const a = [...n.data].map((o, s) => {
      const u = this._def.items[s] || this._def.rest;
      return u ? u._parse(new Yt(n, o, n.path, s)) : null;
    }).filter((o) => !!o);
    return n.common.async ? Promise.all(a).then((o) => pt.mergeArray(r, o)) : pt.mergeArray(r, a);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new mr({
      ...this._def,
      rest: t
    });
  }
}
mr.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new mr({
    items: e,
    typeName: fe.ZodTuple,
    rest: null,
    ...pe(t)
  });
};
class Uo extends be {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== J.object)
      return Y(n, {
        code: H.invalid_type,
        expected: J.object,
        received: n.parsedType
      }), he;
    const i = [], a = this._def.keyType, o = this._def.valueType;
    for (const s in n.data)
      i.push({
        key: a._parse(new Yt(n, s, n.path, s)),
        value: o._parse(new Yt(n, n.data[s], n.path, s)),
        alwaysSet: s in n.data
      });
    return n.common.async ? pt.mergeObjectAsync(r, i) : pt.mergeObjectSync(r, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, r, n) {
    return r instanceof be ? new Uo({
      keyType: t,
      valueType: r,
      typeName: fe.ZodRecord,
      ...pe(n)
    }) : new Uo({
      keyType: lr.create(),
      valueType: t,
      typeName: fe.ZodRecord,
      ...pe(r)
    });
  }
}
class Nl extends be {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== J.map)
      return Y(n, {
        code: H.invalid_type,
        expected: J.map,
        received: n.parsedType
      }), he;
    const i = this._def.keyType, a = this._def.valueType, o = [...n.data.entries()].map(([s, u], l) => ({
      key: i._parse(new Yt(n, s, n.path, [l, "key"])),
      value: a._parse(new Yt(n, u, n.path, [l, "value"]))
    }));
    if (n.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const u of o) {
          const l = await u.key, c = await u.value;
          if (l.status === "aborted" || c.status === "aborted")
            return he;
          (l.status === "dirty" || c.status === "dirty") && r.dirty(), s.set(l.value, c.value);
        }
        return { status: r.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const u of o) {
        const l = u.key, c = u.value;
        if (l.status === "aborted" || c.status === "aborted")
          return he;
        (l.status === "dirty" || c.status === "dirty") && r.dirty(), s.set(l.value, c.value);
      }
      return { status: r.value, value: s };
    }
  }
}
Nl.create = (e, t, r) => new Nl({
  valueType: t,
  keyType: e,
  typeName: fe.ZodMap,
  ...pe(r)
});
class ii extends be {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== J.set)
      return Y(n, {
        code: H.invalid_type,
        expected: J.set,
        received: n.parsedType
      }), he;
    const i = this._def;
    i.minSize !== null && n.data.size < i.minSize.value && (Y(n, {
      code: H.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), r.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (Y(n, {
      code: H.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), r.dirty());
    const a = this._def.valueType;
    function o(u) {
      const l = /* @__PURE__ */ new Set();
      for (const c of u) {
        if (c.status === "aborted")
          return he;
        c.status === "dirty" && r.dirty(), l.add(c.value);
      }
      return { status: r.value, value: l };
    }
    const s = [...n.data.values()].map((u, l) => a._parse(new Yt(n, u, n.path, l)));
    return n.common.async ? Promise.all(s).then((u) => o(u)) : o(s);
  }
  min(t, r) {
    return new ii({
      ...this._def,
      minSize: { value: t, message: oe.toString(r) }
    });
  }
  max(t, r) {
    return new ii({
      ...this._def,
      maxSize: { value: t, message: oe.toString(r) }
    });
  }
  size(t, r) {
    return this.min(t, r).max(t, r);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
ii.create = (e, t) => new ii({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: fe.ZodSet,
  ...pe(t)
});
class qi extends be {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== J.function)
      return Y(r, {
        code: H.invalid_type,
        expected: J.function,
        received: r.parsedType
      }), he;
    function n(s, u) {
      return Fl({
        data: s,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          _l(),
          oa
        ].filter((l) => !!l),
        issueData: {
          code: H.invalid_arguments,
          argumentsError: u
        }
      });
    }
    function i(s, u) {
      return Fl({
        data: s,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          _l(),
          oa
        ].filter((l) => !!l),
        issueData: {
          code: H.invalid_return_type,
          returnTypeError: u
        }
      });
    }
    const a = { errorMap: r.common.contextualErrorMap }, o = r.data;
    if (this._def.returns instanceof ua) {
      const s = this;
      return $t(async function(...u) {
        const l = new _t([]), c = await s._def.args.parseAsync(u, a).catch((h) => {
          throw l.addIssue(n(u, h)), l;
        }), d = await Reflect.apply(o, this, c);
        return await s._def.returns._def.type.parseAsync(d, a).catch((h) => {
          throw l.addIssue(i(d, h)), l;
        });
      });
    } else {
      const s = this;
      return $t(function(...u) {
        const l = s._def.args.safeParse(u, a);
        if (!l.success)
          throw new _t([n(u, l.error)]);
        const c = Reflect.apply(o, this, l.data), d = s._def.returns.safeParse(c, a);
        if (!d.success)
          throw new _t([i(c, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new qi({
      ...this._def,
      args: mr.create(t).rest(Kn.create())
    });
  }
  returns(t) {
    return new qi({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, r, n) {
    return new qi({
      args: t || mr.create([]).rest(Kn.create()),
      returns: r || Kn.create(),
      typeName: fe.ZodFunction,
      ...pe(n)
    });
  }
}
class qo extends be {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
qo.create = (e, t) => new qo({
  getter: e,
  typeName: fe.ZodLazy,
  ...pe(t)
});
class Ho extends be {
  _parse(t) {
    if (t.data !== this._def.value) {
      const r = this._getOrReturnCtx(t);
      return Y(r, {
        received: r.data,
        code: H.invalid_literal,
        expected: this._def.value
      }), he;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
Ho.create = (e, t) => new Ho({
  value: e,
  typeName: fe.ZodLiteral,
  ...pe(t)
});
function Uv(e, t) {
  return new sn({
    values: e,
    typeName: fe.ZodEnum,
    ...pe(t)
  });
}
class sn extends be {
  constructor() {
    super(...arguments), Oi.set(this, void 0);
  }
  _parse(t) {
    if (typeof t.data != "string") {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return Y(r, {
        expected: we.joinValues(n),
        received: r.parsedType,
        code: H.invalid_type
      }), he;
    }
    if (Lo(this, Oi) || jv(this, Oi, new Set(this._def.values)), !Lo(this, Oi).has(t.data)) {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return Y(r, {
        received: r.data,
        code: H.invalid_enum_value,
        options: n
      }), he;
    }
    return $t(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Values() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  extract(t, r = this._def) {
    return sn.create(t, {
      ...this._def,
      ...r
    });
  }
  exclude(t, r = this._def) {
    return sn.create(this.options.filter((n) => !t.includes(n)), {
      ...this._def,
      ...r
    });
  }
}
Oi = /* @__PURE__ */ new WeakMap();
sn.create = Uv;
class Wo extends be {
  constructor() {
    super(...arguments), Ii.set(this, void 0);
  }
  _parse(t) {
    const r = we.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
    if (n.parsedType !== J.string && n.parsedType !== J.number) {
      const i = we.objectValues(r);
      return Y(n, {
        expected: we.joinValues(i),
        received: n.parsedType,
        code: H.invalid_type
      }), he;
    }
    if (Lo(this, Ii) || jv(this, Ii, new Set(we.getValidEnumValues(this._def.values))), !Lo(this, Ii).has(t.data)) {
      const i = we.objectValues(r);
      return Y(n, {
        received: n.data,
        code: H.invalid_enum_value,
        options: i
      }), he;
    }
    return $t(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Ii = /* @__PURE__ */ new WeakMap();
Wo.create = (e, t) => new Wo({
  values: e,
  typeName: fe.ZodNativeEnum,
  ...pe(t)
});
class ua extends be {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== J.promise && r.common.async === !1)
      return Y(r, {
        code: H.invalid_type,
        expected: J.promise,
        received: r.parsedType
      }), he;
    const n = r.parsedType === J.promise ? r.data : Promise.resolve(r.data);
    return $t(n.then((i) => this._def.type.parseAsync(i, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
ua.create = (e, t) => new ua({
  type: e,
  typeName: fe.ZodPromise,
  ...pe(t)
});
class vr extends be {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === fe.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), i = this._def.effect || null, a = {
      addIssue: (o) => {
        Y(n, o), o.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), i.type === "preprocess") {
      const o = i.transform(n.data, a);
      if (n.common.async)
        return Promise.resolve(o).then(async (s) => {
          if (r.value === "aborted")
            return he;
          const u = await this._def.schema._parseAsync({
            data: s,
            path: n.path,
            parent: n
          });
          return u.status === "aborted" ? he : u.status === "dirty" || r.value === "dirty" ? Fi(u.value) : u;
        });
      {
        if (r.value === "aborted")
          return he;
        const s = this._def.schema._parseSync({
          data: o,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? he : s.status === "dirty" || r.value === "dirty" ? Fi(s.value) : s;
      }
    }
    if (i.type === "refinement") {
      const o = (s) => {
        const u = i.refinement(s, a);
        if (n.common.async)
          return Promise.resolve(u);
        if (u instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      };
      if (n.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? he : (s.status === "dirty" && r.dirty(), o(s.value), { status: r.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((s) => s.status === "aborted" ? he : (s.status === "dirty" && r.dirty(), o(s.value).then(() => ({ status: r.value, value: s.value }))));
    }
    if (i.type === "transform")
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!Mo(o))
          return o;
        const s = i.transform(o.value, a);
        if (s instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => Mo(o) ? Promise.resolve(i.transform(o.value, a)).then((s) => ({ status: r.value, value: s })) : o);
    we.assertNever(i);
  }
}
vr.create = (e, t, r) => new vr({
  schema: e,
  typeName: fe.ZodEffects,
  effect: t,
  ...pe(r)
});
vr.createWithPreprocess = (e, t, r) => new vr({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: fe.ZodEffects,
  ...pe(r)
});
class fr extends be {
  _parse(t) {
    return this._getType(t) === J.undefined ? $t(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
fr.create = (e, t) => new fr({
  innerType: e,
  typeName: fe.ZodOptional,
  ...pe(t)
});
class un extends be {
  _parse(t) {
    return this._getType(t) === J.null ? $t(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
un.create = (e, t) => new un({
  innerType: e,
  typeName: fe.ZodNullable,
  ...pe(t)
});
class Qo extends be {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    let n = r.data;
    return r.parsedType === J.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Qo.create = (e, t) => new Qo({
  innerType: e,
  typeName: fe.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...pe(t)
});
class Go extends be {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return No(i) ? i.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new _t(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new _t(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Go.create = (e, t) => new Go({
  innerType: e,
  typeName: fe.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...pe(t)
});
class Ll extends be {
  _parse(t) {
    if (this._getType(t) !== J.nan) {
      const n = this._getOrReturnCtx(t);
      return Y(n, {
        code: H.invalid_type,
        expected: J.nan,
        received: n.parsedType
      }), he;
    }
    return { status: "valid", value: t.data };
  }
}
Ll.create = (e) => new Ll({
  typeName: fe.ZodNaN,
  ...pe(e)
});
class qv extends be {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class As extends be {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return a.status === "aborted" ? he : a.status === "dirty" ? (r.dirty(), Fi(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return i.status === "aborted" ? he : i.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(t, r) {
    return new As({
      in: t,
      out: r,
      typeName: fe.ZodPipeline
    });
  }
}
class Zo extends be {
  _parse(t) {
    const r = this._def.innerType._parse(t), n = (i) => (Mo(i) && (i.value = Object.freeze(i.value)), i);
    return No(r) ? r.then((i) => n(i)) : n(r);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Zo.create = (e, t) => new Zo({
  innerType: e,
  typeName: fe.ZodReadonly,
  ...pe(t)
});
Ke.lazycreate;
var fe;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(fe || (fe = {}));
const Hv = lr.create;
ri.create;
Ll.create;
ni.create;
Ol.create;
sa.create;
Il.create;
Vo.create;
jo.create;
Rl.create;
Kn.create;
jr.create;
Bl.create;
Gt.create;
const Wv = Ke.create;
Ke.strictCreate;
zo.create;
ad.create;
Ko.create;
mr.create;
Uo.create;
Nl.create;
ii.create;
qi.create;
qo.create;
Ho.create;
sn.create;
Wo.create;
ua.create;
vr.create;
fr.create;
un.create;
vr.createWithPreprocess;
As.create;
const Ew = Vr`
  mutation GenerateAIReply($senalysisBusinessId: String, $spilloverBusinessId: String, $message: String!, $type: String!, $n: Int) {
    generateAiReply(input: {
      senalysisBusinessId: $senalysisBusinessId,
      spilloverBusinessId: $spilloverBusinessId,
      message: $message,
      type: $type,
      n: $n
    }) {
      replies
      errors {
        message
      }
    }
  }
`;
function od() {
  var a, o;
  const { senalysisBusinessId: e, spilloverBusinessId: t } = uE(), [r, n] = nE(Ew);
  return n.generatedOptions = (o = (a = n.data) == null ? void 0 : a.generateAiReply) == null ? void 0 : o.replies, [async (s, u, l = { n: 1 }) => {
    try {
      const { data: c } = await r({
        variables: {
          type: s,
          message: u,
          senalysisBusinessId: e,
          spilloverBusinessId: t,
          n: l.n
        }
      }), d = (c == null ? void 0 : c.generateAiReply.errors) || [];
      for (const f of d)
        console.error(`AI Error: ${f.message}`), Ie.error(f.message, { position: "bottom-right" });
      return c.generateAiReply.replies;
    } catch {
      return null;
    }
  }, n];
}
de(null);
de(null);
de(null);
de(null);
de(null);
const sd = de({}), Oe = typeof document < "u" ? F.useLayoutEffect : () => {
};
function st(e) {
  const t = q(null);
  return Oe(() => {
    t.current = e;
  }, [
    e
  ]), ye((...r) => {
    const n = t.current;
    return n == null ? void 0 : n(...r);
  }, []);
}
function ww(e) {
  let [t, r] = re(e), n = q(null), i = st(() => {
    if (!n.current) return;
    let o = n.current.next();
    if (o.done) {
      n.current = null;
      return;
    }
    t === o.value ? i() : r(o.value);
  });
  Oe(() => {
    n.current && i();
  });
  let a = st((o) => {
    n.current = o(t), i();
  });
  return [
    t,
    a
  ];
}
const Yo = {
  prefix: String(Math.round(Math.random() * 1e10)),
  current: 0
}, Qv = /* @__PURE__ */ F.createContext(Yo), Cw = /* @__PURE__ */ F.createContext(!1);
let Sw = !!(typeof window < "u" && window.document && window.document.createElement), Au = /* @__PURE__ */ new WeakMap();
function kw(e = !1) {
  let t = ce(Qv), r = q(null);
  if (r.current === null && !e) {
    var n, i;
    let a = (i = F.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || i === void 0 || (n = i.ReactCurrentOwner) === null || n === void 0 ? void 0 : n.current;
    if (a) {
      let o = Au.get(a);
      o == null ? Au.set(a, {
        id: t.current,
        state: a.memoizedState
      }) : a.memoizedState !== o.state && (t.current = o.id, Au.delete(a));
    }
    r.current = ++t.current;
  }
  return r.current;
}
function Tw(e) {
  let t = ce(Qv);
  t === Yo && !Sw && console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
  let r = kw(!!e), n = t === Yo && process.env.NODE_ENV === "test" ? "react-aria" : `react-aria${t.prefix}`;
  return e || `${n}-${r}`;
}
function Pw(e) {
  let t = F.useId(), [r] = re(vn()), n = r || process.env.NODE_ENV === "test" ? "react-aria" : `react-aria${Yo.prefix}`;
  return e || `${n}-${t}`;
}
const Aw = typeof F.useId == "function" ? Pw : Tw;
function _w() {
  return !1;
}
function Fw() {
  return !0;
}
function Ow(e) {
  return () => {
  };
}
function vn() {
  return typeof F.useSyncExternalStore == "function" ? F.useSyncExternalStore(Ow, _w, Fw) : ce(Cw);
}
let Iw = !!(typeof window < "u" && window.document && window.document.createElement), Jo = /* @__PURE__ */ new Map();
function Ct(e) {
  let [t, r] = re(e), n = q(null), i = Aw(t), a = ye((o) => {
    n.current = o;
  }, []);
  return Iw && Jo.set(i, a), Oe(() => {
    let o = i;
    return () => {
      Jo.delete(o);
    };
  }, [
    i
  ]), ue(() => {
    let o = n.current;
    o && (n.current = null, r(o));
  }), i;
}
function Rw(e, t) {
  if (e === t) return e;
  let r = Jo.get(e);
  if (r)
    return r(t), t;
  let n = Jo.get(t);
  return n ? (n(e), e) : t;
}
function ai(e = []) {
  let t = Ct(), [r, n] = ww(t), i = ye(() => {
    n(function* () {
      yield t, yield document.getElementById(t) ? t : void 0;
    });
  }, [
    t,
    n
  ]);
  return Oe(i, [
    t,
    i,
    ...e
  ]), r;
}
function zr(...e) {
  return (...t) => {
    for (let r of e) typeof r == "function" && r(...t);
  };
}
const Re = (e) => {
  var t;
  return (t = e == null ? void 0 : e.ownerDocument) !== null && t !== void 0 ? t : document;
}, At = (e) => e && "window" in e && e.window === e ? e : Re(e).defaultView || window;
function ge(...e) {
  let t = {
    ...e[0]
  };
  for (let r = 1; r < e.length; r++) {
    let n = e[r];
    for (let i in n) {
      let a = t[i], o = n[i];
      typeof a == "function" && typeof o == "function" && // This is a lot faster than a regex.
      i[0] === "o" && i[1] === "n" && i.charCodeAt(2) >= /* 'A' */
      65 && i.charCodeAt(2) <= /* 'Z' */
      90 ? t[i] = zr(a, o) : (i === "className" || i === "UNSAFE_className") && typeof a == "string" && typeof o == "string" ? t[i] = ur(a, o) : i === "id" && a && o ? t.id = Rw(a, o) : t[i] = o !== void 0 ? o : a;
    }
  }
  return t;
}
function Gv(...e) {
  return e.length === 1 ? e[0] : (t) => {
    for (let r of e)
      typeof r == "function" ? r(t) : r != null && (r.current = t);
  };
}
const Bw = /* @__PURE__ */ new Set([
  "id"
]), Mw = /* @__PURE__ */ new Set([
  "aria-label",
  "aria-labelledby",
  "aria-describedby",
  "aria-details"
]), Nw = /* @__PURE__ */ new Set([
  "href",
  "hrefLang",
  "target",
  "rel",
  "download",
  "ping",
  "referrerPolicy"
]), Lw = /^(data-.*)$/;
function Me(e, t = {}) {
  let { labelable: r, isLink: n, propNames: i } = t, a = {};
  for (const o in e) Object.prototype.hasOwnProperty.call(e, o) && (Bw.has(o) || r && Mw.has(o) || n && Nw.has(o) || i != null && i.has(o) || Lw.test(o)) && (a[o] = e[o]);
  return a;
}
function Ht(e) {
  if (Vw()) e.focus({
    preventScroll: !0
  });
  else {
    let t = jw(e);
    e.focus(), zw(t);
  }
}
let Ya = null;
function Vw() {
  if (Ya == null) {
    Ya = !1;
    try {
      document.createElement("div").focus({
        get preventScroll() {
          return Ya = !0, !0;
        }
      });
    } catch {
    }
  }
  return Ya;
}
function jw(e) {
  let t = e.parentNode, r = [], n = document.scrollingElement || document.documentElement;
  for (; t instanceof HTMLElement && t !== n; )
    (t.offsetHeight < t.scrollHeight || t.offsetWidth < t.scrollWidth) && r.push({
      element: t,
      scrollTop: t.scrollTop,
      scrollLeft: t.scrollLeft
    }), t = t.parentNode;
  return n instanceof HTMLElement && r.push({
    element: n,
    scrollTop: n.scrollTop,
    scrollLeft: n.scrollLeft
  }), r;
}
function zw(e) {
  for (let { element: t, scrollTop: r, scrollLeft: n } of e)
    t.scrollTop = r, t.scrollLeft = n;
}
function _s(e) {
  var t;
  return typeof window > "u" || window.navigator == null ? !1 : ((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.brands.some((r) => e.test(r.brand))) || e.test(window.navigator.userAgent);
}
function ud(e) {
  var t;
  return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
}
function yr() {
  return ud(/^Mac/i);
}
function Kw() {
  return ud(/^iPhone/i);
}
function Zv() {
  return ud(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  yr() && navigator.maxTouchPoints > 1;
}
function Ta() {
  return Kw() || Zv();
}
function $o() {
  return yr() || Ta();
}
function ld() {
  return _s(/AppleWebKit/i) && !Uw();
}
function Uw() {
  return _s(/Chrome/i);
}
function Yv() {
  return _s(/Android/i);
}
function qw() {
  return _s(/Firefox/i);
}
const Hw = /* @__PURE__ */ de({
  isNative: !0,
  open: Qw,
  useHref: (e) => e
});
function Fs() {
  return ce(Hw);
}
function ln(e, t, r = !0) {
  var n, i;
  let { metaKey: a, ctrlKey: o, altKey: s, shiftKey: u } = t;
  qw() && (!((i = window.event) === null || i === void 0 || (n = i.type) === null || n === void 0) && n.startsWith("key")) && e.target === "_blank" && (yr() ? a = !0 : o = !0);
  let l = ld() && yr() && !Zv() ? new KeyboardEvent("keydown", {
    keyIdentifier: "Enter",
    metaKey: a,
    ctrlKey: o,
    altKey: s,
    shiftKey: u
  }) : new MouseEvent("click", {
    metaKey: a,
    ctrlKey: o,
    altKey: s,
    shiftKey: u,
    bubbles: !0,
    cancelable: !0
  });
  ln.isOpening = r, Ht(e), e.dispatchEvent(l), ln.isOpening = !1;
}
ln.isOpening = !1;
function Ww(e, t) {
  if (e instanceof HTMLAnchorElement) t(e);
  else if (e.hasAttribute("data-href")) {
    let r = document.createElement("a");
    r.href = e.getAttribute("data-href"), e.hasAttribute("data-target") && (r.target = e.getAttribute("data-target")), e.hasAttribute("data-rel") && (r.rel = e.getAttribute("data-rel")), e.hasAttribute("data-download") && (r.download = e.getAttribute("data-download")), e.hasAttribute("data-ping") && (r.ping = e.getAttribute("data-ping")), e.hasAttribute("data-referrer-policy") && (r.referrerPolicy = e.getAttribute("data-referrer-policy")), e.appendChild(r), t(r), e.removeChild(r);
  }
}
function Qw(e, t) {
  Ww(e, (r) => ln(r, t));
}
function Gw(e) {
  let t = Fs();
  return {
    href: e != null && e.href ? t.useHref(e == null ? void 0 : e.href) : void 0,
    target: e == null ? void 0 : e.target,
    rel: e == null ? void 0 : e.rel,
    download: e == null ? void 0 : e.download,
    ping: e == null ? void 0 : e.ping,
    referrerPolicy: e == null ? void 0 : e.referrerPolicy
  };
}
let Pn = /* @__PURE__ */ new Map(), Vl = /* @__PURE__ */ new Set();
function bh() {
  if (typeof window > "u") return;
  function e(n) {
    return "propertyName" in n;
  }
  let t = (n) => {
    if (!e(n) || !n.target) return;
    let i = Pn.get(n.target);
    i || (i = /* @__PURE__ */ new Set(), Pn.set(n.target, i), n.target.addEventListener("transitioncancel", r, {
      once: !0
    })), i.add(n.propertyName);
  }, r = (n) => {
    if (!e(n) || !n.target) return;
    let i = Pn.get(n.target);
    if (i && (i.delete(n.propertyName), i.size === 0 && (n.target.removeEventListener("transitioncancel", r), Pn.delete(n.target)), Pn.size === 0)) {
      for (let a of Vl) a();
      Vl.clear();
    }
  };
  document.body.addEventListener("transitionrun", t), document.body.addEventListener("transitionend", r);
}
typeof document < "u" && (document.readyState !== "loading" ? bh() : document.addEventListener("DOMContentLoaded", bh));
function Jv(e) {
  requestAnimationFrame(() => {
    Pn.size === 0 ? e() : Vl.add(e);
  });
}
function cd() {
  let e = q(/* @__PURE__ */ new Map()), t = ye((i, a, o, s) => {
    let u = s != null && s.once ? (...l) => {
      e.current.delete(o), o(...l);
    } : o;
    e.current.set(o, {
      type: a,
      eventTarget: i,
      fn: u,
      options: s
    }), i.addEventListener(a, o, s);
  }, []), r = ye((i, a, o, s) => {
    var u;
    let l = ((u = e.current.get(o)) === null || u === void 0 ? void 0 : u.fn) || o;
    i.removeEventListener(a, l, s), e.current.delete(o);
  }, []), n = ye(() => {
    e.current.forEach((i, a) => {
      r(i.eventTarget, i.type, a, i.options);
    });
  }, [
    r
  ]);
  return ue(() => n, [
    n
  ]), {
    addGlobalListener: t,
    removeGlobalListener: r,
    removeAllGlobalListeners: n
  };
}
function cn(e, t) {
  let { id: r, "aria-label": n, "aria-labelledby": i } = e;
  return r = Ct(r), i && n ? i = [
    .../* @__PURE__ */ new Set([
      r,
      ...i.trim().split(/\s+/)
    ])
  ].join(" ") : i && (i = i.trim().split(/\s+/).join(" ")), !n && !i && t && (n = t), {
    id: r,
    "aria-label": n,
    "aria-labelledby": i
  };
}
function Pa(e) {
  const t = q(null);
  return G(() => ({
    get current() {
      return t.current;
    },
    set current(r) {
      t.current = r, typeof e == "function" ? e(r) : e && (e.current = r);
    }
  }), [
    e
  ]);
}
function $h(e, t) {
  const r = q(!0), n = q(null);
  ue(() => (r.current = !0, () => {
    r.current = !1;
  }), []), ue(() => {
    r.current ? r.current = !1 : (!n.current || t.some((i, a) => !Object.is(i, n[a]))) && e(), n.current = t;
  }, t);
}
function Zw() {
  return typeof window.ResizeObserver < "u";
}
function Os(e) {
  const { ref: t, onResize: r } = e;
  ue(() => {
    let n = t == null ? void 0 : t.current;
    if (n)
      if (Zw()) {
        const i = new window.ResizeObserver((a) => {
          a.length && r();
        });
        return i.observe(n), () => {
          n && i.unobserve(n);
        };
      } else
        return window.addEventListener("resize", r, !1), () => {
          window.removeEventListener("resize", r, !1);
        };
  }, [
    r,
    t
  ]);
}
function dd(e, t) {
  Oe(() => {
    if (e && e.ref && t)
      return e.ref.current = t.current, () => {
        e.ref && (e.ref.current = null);
      };
  });
}
function la(e, t) {
  let r = window.getComputedStyle(e), n = /(auto|scroll)/.test(r.overflow + r.overflowX + r.overflowY);
  return n && t && (n = e.scrollHeight !== e.clientHeight || e.scrollWidth !== e.clientWidth), n;
}
function Is(e, t) {
  let r = e;
  for (la(r, t) && (r = r.parentElement); r && !la(r, t); ) r = r.parentElement;
  return r || document.scrollingElement || document.documentElement;
}
function Yw(e, t) {
  const r = [];
  for (; e && e !== document.documentElement; )
    la(e, t) && r.push(e), e = e.parentElement;
  return r;
}
let Jw = 0;
const _u = /* @__PURE__ */ new Map();
function Rs(e) {
  let [t, r] = re();
  return Oe(() => {
    if (!e) return;
    let n = _u.get(e);
    if (n)
      r(n.element.id);
    else {
      let i = `react-aria-description-${Jw++}`;
      r(i);
      let a = document.createElement("div");
      a.id = i, a.style.display = "none", a.textContent = e, document.body.appendChild(a), n = {
        refCount: 0,
        element: a
      }, _u.set(e, n);
    }
    return n.refCount++, () => {
      n && --n.refCount === 0 && (n.element.remove(), _u.delete(e));
    };
  }, [
    e
  ]), {
    "aria-describedby": e ? t : void 0
  };
}
function Un(e, t, r, n) {
  let i = st(r), a = r == null;
  ue(() => {
    if (a || !e.current) return;
    let o = e.current;
    return o.addEventListener(t, i, n), () => {
      o.removeEventListener(t, i, n);
    };
  }, [
    e,
    t,
    n,
    a,
    i
  ]);
}
function Xv(e, t) {
  let r = xh(e, t, "left"), n = xh(e, t, "top"), i = t.offsetWidth, a = t.offsetHeight, o = e.scrollLeft, s = e.scrollTop, { borderTopWidth: u, borderLeftWidth: l } = getComputedStyle(e), c = e.scrollLeft + parseInt(l, 10), d = e.scrollTop + parseInt(u, 10), f = c + e.clientWidth, h = d + e.clientHeight;
  r <= o ? o = r - parseInt(l, 10) : r + i > f && (o += r + i - f), n <= d ? s = n - parseInt(u, 10) : n + a > h && (s += n + a - h), e.scrollLeft = o, e.scrollTop = s;
}
function xh(e, t, r) {
  const n = r === "left" ? "offsetLeft" : "offsetTop";
  let i = 0;
  for (; t.offsetParent && (i += t[n], t.offsetParent !== e); ) {
    if (t.offsetParent.contains(e)) {
      i -= e[n];
      break;
    }
    t = t.offsetParent;
  }
  return i;
}
function Xo(e, t) {
  if (document.contains(e)) {
    let o = document.scrollingElement || document.documentElement;
    if (window.getComputedStyle(o).overflow === "hidden") {
      let u = Yw(e);
      for (let l of u) Xv(l, e);
    } else {
      var r;
      let { left: u, top: l } = e.getBoundingClientRect();
      e == null || (r = e.scrollIntoView) === null || r === void 0 || r.call(e, {
        block: "nearest"
      });
      let { left: c, top: d } = e.getBoundingClientRect();
      if (Math.abs(u - c) > 1 || Math.abs(l - d) > 1) {
        var n, i, a;
        t == null || (i = t.containingElement) === null || i === void 0 || (n = i.scrollIntoView) === null || n === void 0 || n.call(i, {
          block: "center",
          inline: "center"
        }), (a = e.scrollIntoView) === null || a === void 0 || a.call(e, {
          block: "nearest"
        });
      }
    }
  }
}
function jl(e) {
  return e.mozInputSource === 0 && e.isTrusted ? !0 : Yv() && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType;
}
function Xw(e) {
  return !Yv() && e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "mouse";
}
function ey(e, t) {
  let r = q(null);
  return e && r.current && t(e, r.current) && (e = r.current), r.current = e, e;
}
function fd(e, t, r) {
  let n = q(t), i = st(() => {
    r && r(n.current);
  });
  ue(() => {
    var a;
    let o = e == null || (a = e.current) === null || a === void 0 ? void 0 : a.form;
    return o == null || o.addEventListener("reset", i), () => {
      o == null || o.removeEventListener("reset", i);
    };
  }, [
    e,
    i
  ]);
}
function Jt(e, t, r) {
  let [n, i] = re(e || t), a = q(e !== void 0), o = e !== void 0;
  ue(() => {
    let l = a.current;
    l !== o && console.warn(`WARN: A component changed from ${l ? "controlled" : "uncontrolled"} to ${o ? "controlled" : "uncontrolled"}.`), a.current = o;
  }, [
    o
  ]);
  let s = o ? e : n, u = ye((l, ...c) => {
    let d = (f, ...h) => {
      r && (Object.is(s, f) || r(f, ...h)), o || (s = f);
    };
    typeof l == "function" ? (console.warn("We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320"), i((h, ...p) => {
      let v = l(o ? s : h, ...p);
      return d(v, ...c), o ? h : v;
    })) : (o || i(l), d(l, ...c));
  }, [
    o,
    s,
    r
  ]);
  return [
    s,
    u
  ];
}
function zl(e, t = -1 / 0, r = 1 / 0) {
  return Math.min(Math.max(e, t), r);
}
let Bn = "default", Kl = "", xo = /* @__PURE__ */ new WeakMap();
function Dh(e) {
  if (Ta()) {
    if (Bn === "default") {
      const t = Re(e);
      Kl = t.documentElement.style.webkitUserSelect, t.documentElement.style.webkitUserSelect = "none";
    }
    Bn = "disabled";
  } else (e instanceof HTMLElement || e instanceof SVGElement) && (xo.set(e, e.style.userSelect), e.style.userSelect = "none");
}
function Ja(e) {
  if (Ta()) {
    if (Bn !== "disabled") return;
    Bn = "restoring", setTimeout(() => {
      Jv(() => {
        if (Bn === "restoring") {
          const t = Re(e);
          t.documentElement.style.webkitUserSelect === "none" && (t.documentElement.style.webkitUserSelect = Kl || ""), Kl = "", Bn = "default";
        }
      });
    }, 300);
  } else if ((e instanceof HTMLElement || e instanceof SVGElement) && e && xo.has(e)) {
    let t = xo.get(e);
    e.style.userSelect === "none" && (e.style.userSelect = t), e.getAttribute("style") === "" && e.removeAttribute("style"), xo.delete(e);
  }
}
const ca = F.createContext({
  register: () => {
  }
});
ca.displayName = "PressResponderContext";
function e6(e, t) {
  return t.get ? t.get.call(e) : t.value;
}
function ty(e, t, r) {
  if (!t.has(e)) throw new TypeError("attempted to " + r + " private field on non-instance");
  return t.get(e);
}
function t6(e, t) {
  var r = ty(e, t, "get");
  return e6(e, r);
}
function r6(e, t) {
  if (t.has(e))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function Aa(e, t, r) {
  r6(e, t), t.set(e, r);
}
function n6(e, t, r) {
  if (t.set) t.set.call(e, r);
  else {
    if (!t.writable)
      throw new TypeError("attempted to set read only private field");
    t.value = r;
  }
}
function Eh(e, t, r) {
  var n = ty(e, t, "set");
  return n6(e, n, r), r;
}
function i6(e) {
  let t = ce(ca);
  if (t) {
    let { register: r, ...n } = t;
    e = ge(n, e), r();
  }
  return dd(t, e.ref), e;
}
var Xa = /* @__PURE__ */ new WeakMap();
class eo {
  continuePropagation() {
    Eh(this, Xa, !1);
  }
  get shouldStopPropagation() {
    return t6(this, Xa);
  }
  constructor(t, r, n) {
    Aa(this, Xa, {
      writable: !0,
      value: void 0
    }), Eh(this, Xa, !0), this.type = t, this.pointerType = r, this.target = n.currentTarget, this.shiftKey = n.shiftKey, this.metaKey = n.metaKey, this.ctrlKey = n.ctrlKey, this.altKey = n.altKey;
  }
}
const wh = Symbol("linkClicked");
function _a(e) {
  let {
    onPress: t,
    onPressChange: r,
    onPressStart: n,
    onPressEnd: i,
    onPressUp: a,
    isDisabled: o,
    isPressed: s,
    preventFocusOnPress: u,
    shouldCancelOnPointerExit: l,
    allowTextSelectionOnPress: c,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: d,
    ...f
  } = i6(e), [h, p] = re(!1), v = q({
    isPressed: !1,
    ignoreEmulatedMouseEvents: !1,
    ignoreClickAfterPress: !1,
    didFirePressStart: !1,
    isTriggeringEvent: !1,
    activePointerId: null,
    target: null,
    isOverTarget: !1,
    pointerType: null
  }), { addGlobalListener: g, removeAllGlobalListeners: $ } = cd(), m = st((y, A) => {
    let w = v.current;
    if (o || w.didFirePressStart) return !1;
    let E = !0;
    if (w.isTriggeringEvent = !0, n) {
      let k = new eo("pressstart", A, y);
      n(k), E = k.shouldStopPropagation;
    }
    return r && r(!0), w.isTriggeringEvent = !1, w.didFirePressStart = !0, p(!0), E;
  }), b = st((y, A, w = !0) => {
    let E = v.current;
    if (!E.didFirePressStart) return !1;
    E.ignoreClickAfterPress = !0, E.didFirePressStart = !1, E.isTriggeringEvent = !0;
    let k = !0;
    if (i) {
      let C = new eo("pressend", A, y);
      i(C), k = C.shouldStopPropagation;
    }
    if (r && r(!1), p(!1), t && w && !o) {
      let C = new eo("press", A, y);
      t(C), k && (k = C.shouldStopPropagation);
    }
    return E.isTriggeringEvent = !1, k;
  }), D = st((y, A) => {
    let w = v.current;
    if (o) return !1;
    if (a) {
      w.isTriggeringEvent = !0;
      let E = new eo("pressup", A, y);
      return a(E), w.isTriggeringEvent = !1, E.shouldStopPropagation;
    }
    return !0;
  }), S = st((y) => {
    let A = v.current;
    A.isPressed && A.target && (A.isOverTarget && A.pointerType != null && b(tr(A.target, y), A.pointerType, !1), A.isPressed = !1, A.isOverTarget = !1, A.activePointerId = null, A.pointerType = null, $(), c || Ja(A.target));
  }), T = st((y) => {
    l && S(y);
  }), R = G(() => {
    let y = v.current, A = {
      onKeyDown(E) {
        if (Fu(E.nativeEvent, E.currentTarget) && E.currentTarget.contains(E.target)) {
          var k;
          Sh(E.target, E.key) && E.preventDefault();
          let C = !0;
          if (!y.isPressed && !E.repeat) {
            y.target = E.currentTarget, y.isPressed = !0, C = m(E, "keyboard");
            let P = E.currentTarget, L = (O) => {
              Fu(O, P) && !O.repeat && P.contains(O.target) && y.target && D(tr(y.target, O), "keyboard");
            };
            g(Re(E.currentTarget), "keyup", zr(L, w), !0);
          }
          C && E.stopPropagation(), E.metaKey && yr() && ((k = y.metaKeyEvents) === null || k === void 0 || k.set(E.key, E.nativeEvent));
        } else E.key === "Meta" && (y.metaKeyEvents = /* @__PURE__ */ new Map());
      },
      onClick(E) {
        if (!(E && !E.currentTarget.contains(E.target)) && E && E.button === 0 && !y.isTriggeringEvent && !ln.isOpening) {
          let k = !0;
          if (o && E.preventDefault(), !y.ignoreClickAfterPress && !y.ignoreEmulatedMouseEvents && !y.isPressed && (y.pointerType === "virtual" || jl(E.nativeEvent))) {
            !o && !u && Ht(E.currentTarget);
            let C = m(E, "virtual"), P = D(E, "virtual"), L = b(E, "virtual");
            k = C && P && L;
          }
          y.ignoreEmulatedMouseEvents = !1, y.ignoreClickAfterPress = !1, k && E.stopPropagation();
        }
      }
    }, w = (E) => {
      var k;
      if (y.isPressed && y.target && Fu(E, y.target)) {
        var C;
        Sh(E.target, E.key) && E.preventDefault();
        let L = E.target;
        b(tr(y.target, E), "keyboard", y.target.contains(L)), $(), E.key !== "Enter" && hd(y.target) && y.target.contains(L) && !E[wh] && (E[wh] = !0, ln(y.target, E, !1)), y.isPressed = !1, (C = y.metaKeyEvents) === null || C === void 0 || C.delete(E.key);
      } else if (E.key === "Meta" && (!((k = y.metaKeyEvents) === null || k === void 0) && k.size)) {
        var P;
        let L = y.metaKeyEvents;
        y.metaKeyEvents = void 0;
        for (let O of L.values()) (P = y.target) === null || P === void 0 || P.dispatchEvent(new KeyboardEvent("keyup", O));
      }
    };
    if (typeof PointerEvent < "u") {
      A.onPointerDown = (P) => {
        if (P.button !== 0 || !P.currentTarget.contains(P.target)) return;
        if (Xw(P.nativeEvent)) {
          y.pointerType = "virtual";
          return;
        }
        Ou(P.currentTarget) && P.preventDefault(), y.pointerType = P.pointerType;
        let L = !0;
        y.isPressed || (y.isPressed = !0, y.isOverTarget = !0, y.activePointerId = P.pointerId, y.target = P.currentTarget, !o && !u && Ht(P.currentTarget), c || Dh(y.target), L = m(P, y.pointerType), g(Re(P.currentTarget), "pointermove", E, !1), g(Re(P.currentTarget), "pointerup", k, !1), g(Re(P.currentTarget), "pointercancel", C, !1)), L && P.stopPropagation();
      }, A.onMouseDown = (P) => {
        P.currentTarget.contains(P.target) && P.button === 0 && (Ou(P.currentTarget) && P.preventDefault(), P.stopPropagation());
      }, A.onPointerUp = (P) => {
        !P.currentTarget.contains(P.target) || y.pointerType === "virtual" || P.button === 0 && En(P, P.currentTarget) && D(P, y.pointerType || P.pointerType);
      };
      let E = (P) => {
        P.pointerId === y.activePointerId && (y.target && En(P, y.target) ? !y.isOverTarget && y.pointerType != null && (y.isOverTarget = !0, m(tr(y.target, P), y.pointerType)) : y.target && y.isOverTarget && y.pointerType != null && (y.isOverTarget = !1, b(tr(y.target, P), y.pointerType, !1), T(P)));
      }, k = (P) => {
        P.pointerId === y.activePointerId && y.isPressed && P.button === 0 && y.target && (En(P, y.target) && y.pointerType != null ? b(tr(y.target, P), y.pointerType) : y.isOverTarget && y.pointerType != null && b(tr(y.target, P), y.pointerType, !1), y.isPressed = !1, y.isOverTarget = !1, y.activePointerId = null, y.pointerType = null, $(), c || Ja(y.target));
      }, C = (P) => {
        S(P);
      };
      A.onDragStart = (P) => {
        P.currentTarget.contains(P.target) && S(P);
      };
    } else {
      A.onMouseDown = (C) => {
        if (C.button !== 0 || !C.currentTarget.contains(C.target)) return;
        if (Ou(C.currentTarget) && C.preventDefault(), y.ignoreEmulatedMouseEvents) {
          C.stopPropagation();
          return;
        }
        y.isPressed = !0, y.isOverTarget = !0, y.target = C.currentTarget, y.pointerType = jl(C.nativeEvent) ? "virtual" : "mouse", !o && !u && Ht(C.currentTarget), m(C, y.pointerType) && C.stopPropagation(), g(Re(C.currentTarget), "mouseup", E, !1);
      }, A.onMouseEnter = (C) => {
        if (!C.currentTarget.contains(C.target)) return;
        let P = !0;
        y.isPressed && !y.ignoreEmulatedMouseEvents && y.pointerType != null && (y.isOverTarget = !0, P = m(C, y.pointerType)), P && C.stopPropagation();
      }, A.onMouseLeave = (C) => {
        if (!C.currentTarget.contains(C.target)) return;
        let P = !0;
        y.isPressed && !y.ignoreEmulatedMouseEvents && y.pointerType != null && (y.isOverTarget = !1, P = b(C, y.pointerType, !1), T(C)), P && C.stopPropagation();
      }, A.onMouseUp = (C) => {
        C.currentTarget.contains(C.target) && !y.ignoreEmulatedMouseEvents && C.button === 0 && D(C, y.pointerType || "mouse");
      };
      let E = (C) => {
        if (C.button === 0) {
          if (y.isPressed = !1, $(), y.ignoreEmulatedMouseEvents) {
            y.ignoreEmulatedMouseEvents = !1;
            return;
          }
          y.target && En(C, y.target) && y.pointerType != null ? b(tr(y.target, C), y.pointerType) : y.target && y.isOverTarget && y.pointerType != null && b(tr(y.target, C), y.pointerType, !1), y.isOverTarget = !1;
        }
      };
      A.onTouchStart = (C) => {
        if (!C.currentTarget.contains(C.target)) return;
        let P = a6(C.nativeEvent);
        if (!P) return;
        y.activePointerId = P.identifier, y.ignoreEmulatedMouseEvents = !0, y.isOverTarget = !0, y.isPressed = !0, y.target = C.currentTarget, y.pointerType = "touch", !o && !u && Ht(C.currentTarget), c || Dh(y.target), m(C, y.pointerType) && C.stopPropagation(), g(At(C.currentTarget), "scroll", k, !0);
      }, A.onTouchMove = (C) => {
        if (!C.currentTarget.contains(C.target)) return;
        if (!y.isPressed) {
          C.stopPropagation();
          return;
        }
        let P = Ch(C.nativeEvent, y.activePointerId), L = !0;
        P && En(P, C.currentTarget) ? !y.isOverTarget && y.pointerType != null && (y.isOverTarget = !0, L = m(C, y.pointerType)) : y.isOverTarget && y.pointerType != null && (y.isOverTarget = !1, L = b(C, y.pointerType, !1), T(C)), L && C.stopPropagation();
      }, A.onTouchEnd = (C) => {
        if (!C.currentTarget.contains(C.target)) return;
        if (!y.isPressed) {
          C.stopPropagation();
          return;
        }
        let P = Ch(C.nativeEvent, y.activePointerId), L = !0;
        P && En(P, C.currentTarget) && y.pointerType != null ? (D(C, y.pointerType), L = b(C, y.pointerType)) : y.isOverTarget && y.pointerType != null && (L = b(C, y.pointerType, !1)), L && C.stopPropagation(), y.isPressed = !1, y.activePointerId = null, y.isOverTarget = !1, y.ignoreEmulatedMouseEvents = !0, y.target && !c && Ja(y.target), $();
      }, A.onTouchCancel = (C) => {
        C.currentTarget.contains(C.target) && (C.stopPropagation(), y.isPressed && S(C));
      };
      let k = (C) => {
        y.isPressed && C.target.contains(y.target) && S({
          currentTarget: y.target,
          shiftKey: !1,
          ctrlKey: !1,
          metaKey: !1,
          altKey: !1
        });
      };
      A.onDragStart = (C) => {
        C.currentTarget.contains(C.target) && S(C);
      };
    }
    return A;
  }, [
    g,
    o,
    u,
    $,
    c,
    S,
    T,
    b,
    m,
    D
  ]);
  return ue(() => () => {
    var y;
    c || Ja((y = v.current.target) !== null && y !== void 0 ? y : void 0);
  }, [
    c
  ]), {
    isPressed: s || h,
    pressProps: ge(f, R)
  };
}
function hd(e) {
  return e.tagName === "A" && e.hasAttribute("href");
}
function Fu(e, t) {
  const { key: r, code: n } = e, i = t, a = i.getAttribute("role");
  return (r === "Enter" || r === " " || r === "Spacebar" || n === "Space") && !(i instanceof At(i).HTMLInputElement && !ry(i, r) || i instanceof At(i).HTMLTextAreaElement || i.isContentEditable) && // Links should only trigger with Enter key
  !((a === "link" || !a && hd(i)) && r !== "Enter");
}
function a6(e) {
  const { targetTouches: t } = e;
  return t.length > 0 ? t[0] : null;
}
function Ch(e, t) {
  const r = e.changedTouches;
  for (let n = 0; n < r.length; n++) {
    const i = r[n];
    if (i.identifier === t) return i;
  }
  return null;
}
function tr(e, t) {
  return {
    currentTarget: e,
    shiftKey: t.shiftKey,
    ctrlKey: t.ctrlKey,
    metaKey: t.metaKey,
    altKey: t.altKey
  };
}
function o6(e) {
  let t = 0, r = 0;
  return e.width !== void 0 ? t = e.width / 2 : e.radiusX !== void 0 && (t = e.radiusX), e.height !== void 0 ? r = e.height / 2 : e.radiusY !== void 0 && (r = e.radiusY), {
    top: e.clientY - r,
    right: e.clientX + t,
    bottom: e.clientY + r,
    left: e.clientX - t
  };
}
function s6(e, t) {
  return !(e.left > t.right || t.left > e.right || e.top > t.bottom || t.top > e.bottom);
}
function En(e, t) {
  let r = t.getBoundingClientRect(), n = o6(e);
  return s6(r, n);
}
function Ou(e) {
  return !(e instanceof HTMLElement) || !e.hasAttribute("draggable");
}
function Sh(e, t) {
  return e instanceof HTMLInputElement ? !ry(e, t) : e instanceof HTMLButtonElement ? e.type !== "submit" && e.type !== "reset" : !hd(e);
}
const u6 = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function ry(e, t) {
  return e.type === "checkbox" || e.type === "radio" ? t === " " : u6.has(e.type);
}
const l6 = /* @__PURE__ */ F.forwardRef(({ children: e, ...t }, r) => {
  let n = q(!1), i = ce(ca);
  r = Pa(r || (i == null ? void 0 : i.ref));
  let a = ge(i || {}, {
    ...t,
    ref: r,
    register() {
      n.current = !0, i && i.register();
    }
  });
  return dd(i, r), ue(() => {
    n.current || (console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component."), n.current = !0);
  }, []), /* @__PURE__ */ F.createElement(ca.Provider, {
    value: a
  }, e);
});
function c6({ children: e }) {
  let t = G(() => ({
    register: () => {
    }
  }), []);
  return /* @__PURE__ */ F.createElement(ca.Provider, {
    value: t
  }, e);
}
class d6 {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = !0, this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation(), this.isPropagationStopped = () => !0;
  }
  isPropagationStopped() {
    return !1;
  }
  persist() {
  }
  constructor(t, r) {
    this.nativeEvent = r, this.target = r.target, this.currentTarget = r.currentTarget, this.relatedTarget = r.relatedTarget, this.bubbles = r.bubbles, this.cancelable = r.cancelable, this.defaultPrevented = r.defaultPrevented, this.eventPhase = r.eventPhase, this.isTrusted = r.isTrusted, this.timeStamp = r.timeStamp, this.type = t;
  }
}
function ny(e) {
  let t = q({
    isFocused: !1,
    observer: null
  });
  Oe(() => {
    const n = t.current;
    return () => {
      n.observer && (n.observer.disconnect(), n.observer = null);
    };
  }, []);
  let r = st((n) => {
    e == null || e(n);
  });
  return ye((n) => {
    if (n.target instanceof HTMLButtonElement || n.target instanceof HTMLInputElement || n.target instanceof HTMLTextAreaElement || n.target instanceof HTMLSelectElement) {
      t.current.isFocused = !0;
      let i = n.target, a = (o) => {
        t.current.isFocused = !1, i.disabled && r(new d6("blur", o)), t.current.observer && (t.current.observer.disconnect(), t.current.observer = null);
      };
      i.addEventListener("focusout", a, {
        once: !0
      }), t.current.observer = new MutationObserver(() => {
        if (t.current.isFocused && i.disabled) {
          var o;
          (o = t.current.observer) === null || o === void 0 || o.disconnect();
          let s = i === document.activeElement ? null : document.activeElement;
          i.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: s
          })), i.dispatchEvent(new FocusEvent("focusout", {
            bubbles: !0,
            relatedTarget: s
          }));
        }
      }), t.current.observer.observe(i, {
        attributes: !0,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    r
  ]);
}
function iy(e) {
  let { isDisabled: t, onFocus: r, onBlur: n, onFocusChange: i } = e;
  const a = ye((u) => {
    if (u.target === u.currentTarget)
      return n && n(u), i && i(!1), !0;
  }, [
    n,
    i
  ]), o = ny(a), s = ye((u) => {
    const l = Re(u.target);
    u.target === u.currentTarget && l.activeElement === u.target && (r && r(u), i && i(!0), o(u));
  }, [
    i,
    r,
    o
  ]);
  return {
    focusProps: {
      onFocus: !t && (r || i || n) ? s : void 0,
      onBlur: !t && (n || i) ? a : void 0
    }
  };
}
let gr = null, da = /* @__PURE__ */ new Set(), Hi = /* @__PURE__ */ new Map(), dn = !1, Ul = !1;
const f6 = {
  Tab: !0,
  Escape: !0
};
function Bs(e, t) {
  for (let r of da) r(e, t);
}
function h6(e) {
  return !(e.metaKey || !yr() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function es(e) {
  dn = !0, h6(e) && (gr = "keyboard", Bs("keyboard", e));
}
function Pt(e) {
  gr = "pointer", (e.type === "mousedown" || e.type === "pointerdown") && (dn = !0, Bs("pointer", e));
}
function ay(e) {
  jl(e) && (dn = !0, gr = "virtual");
}
function oy(e) {
  e.target === window || e.target === document || (!dn && !Ul && (gr = "virtual", Bs("virtual", e)), dn = !1, Ul = !1);
}
function sy() {
  dn = !1, Ul = !0;
}
function ts(e) {
  if (typeof window > "u" || Hi.get(At(e))) return;
  const t = At(e), r = Re(e);
  let n = t.HTMLElement.prototype.focus;
  t.HTMLElement.prototype.focus = function() {
    dn = !0, n.apply(this, arguments);
  }, r.addEventListener("keydown", es, !0), r.addEventListener("keyup", es, !0), r.addEventListener("click", ay, !0), t.addEventListener("focus", oy, !0), t.addEventListener("blur", sy, !1), typeof PointerEvent < "u" ? (r.addEventListener("pointerdown", Pt, !0), r.addEventListener("pointermove", Pt, !0), r.addEventListener("pointerup", Pt, !0)) : (r.addEventListener("mousedown", Pt, !0), r.addEventListener("mousemove", Pt, !0), r.addEventListener("mouseup", Pt, !0)), t.addEventListener("beforeunload", () => {
    uy(e);
  }, {
    once: !0
  }), Hi.set(t, {
    focus: n
  });
}
const uy = (e, t) => {
  const r = At(e), n = Re(e);
  t && n.removeEventListener("DOMContentLoaded", t), Hi.has(r) && (r.HTMLElement.prototype.focus = Hi.get(r).focus, n.removeEventListener("keydown", es, !0), n.removeEventListener("keyup", es, !0), n.removeEventListener("click", ay, !0), r.removeEventListener("focus", oy, !0), r.removeEventListener("blur", sy, !1), typeof PointerEvent < "u" ? (n.removeEventListener("pointerdown", Pt, !0), n.removeEventListener("pointermove", Pt, !0), n.removeEventListener("pointerup", Pt, !0)) : (n.removeEventListener("mousedown", Pt, !0), n.removeEventListener("mousemove", Pt, !0), n.removeEventListener("mouseup", Pt, !0)), Hi.delete(r));
};
function p6(e) {
  const t = Re(e);
  let r;
  return t.readyState !== "loading" ? ts(e) : (r = () => {
    ts(e);
  }, t.addEventListener("DOMContentLoaded", r)), () => uy(e, r);
}
typeof document < "u" && p6();
function rs() {
  return gr !== "pointer";
}
function ns() {
  return gr;
}
function ly(e) {
  gr = e, Bs(e, null);
}
function m6() {
  ts();
  let [e, t] = re(gr);
  return ue(() => {
    let r = () => {
      t(gr);
    };
    return da.add(r), () => {
      da.delete(r);
    };
  }, []), vn() ? null : e;
}
const v6 = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function y6(e, t, r) {
  var n;
  const i = typeof window < "u" ? At(r == null ? void 0 : r.target).HTMLInputElement : HTMLInputElement, a = typeof window < "u" ? At(r == null ? void 0 : r.target).HTMLTextAreaElement : HTMLTextAreaElement, o = typeof window < "u" ? At(r == null ? void 0 : r.target).HTMLElement : HTMLElement, s = typeof window < "u" ? At(r == null ? void 0 : r.target).KeyboardEvent : KeyboardEvent;
  return e = e || (r == null ? void 0 : r.target) instanceof i && !v6.has(r == null || (n = r.target) === null || n === void 0 ? void 0 : n.type) || (r == null ? void 0 : r.target) instanceof a || (r == null ? void 0 : r.target) instanceof o && (r == null ? void 0 : r.target.isContentEditable), !(e && t === "keyboard" && r instanceof s && !f6[r.key]);
}
function g6(e, t, r) {
  ts(), ue(() => {
    let n = (i, a) => {
      y6(!!(r != null && r.isTextInput), i, a) && e(rs());
    };
    return da.add(n), () => {
      da.delete(n);
    };
  }, t);
}
function ci(e) {
  let { isDisabled: t, onBlurWithin: r, onFocusWithin: n, onFocusWithinChange: i } = e, a = q({
    isFocusWithin: !1
  }), o = ye((l) => {
    a.current.isFocusWithin && !l.currentTarget.contains(l.relatedTarget) && (a.current.isFocusWithin = !1, r && r(l), i && i(!1));
  }, [
    r,
    i,
    a
  ]), s = ny(o), u = ye((l) => {
    !a.current.isFocusWithin && document.activeElement === l.target && (n && n(l), i && i(!0), a.current.isFocusWithin = !0, s(l));
  }, [
    n,
    i,
    s
  ]);
  return t ? {
    focusWithinProps: {
      // These should not have been null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  } : {
    focusWithinProps: {
      onFocus: u,
      onBlur: o
    }
  };
}
let is = !1, Iu = 0;
function ql() {
  is = !0, setTimeout(() => {
    is = !1;
  }, 50);
}
function kh(e) {
  e.pointerType === "touch" && ql();
}
function b6() {
  if (!(typeof document > "u"))
    return typeof PointerEvent < "u" ? document.addEventListener("pointerup", kh) : document.addEventListener("touchend", ql), Iu++, () => {
      Iu--, !(Iu > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", kh) : document.removeEventListener("touchend", ql));
    };
}
function yn(e) {
  let { onHoverStart: t, onHoverChange: r, onHoverEnd: n, isDisabled: i } = e, [a, o] = re(!1), s = q({
    isHovered: !1,
    ignoreEmulatedMouseEvents: !1,
    pointerType: "",
    target: null
  }).current;
  ue(b6, []);
  let { hoverProps: u, triggerHoverEnd: l } = G(() => {
    let c = (h, p) => {
      if (s.pointerType = p, i || p === "touch" || s.isHovered || !h.currentTarget.contains(h.target)) return;
      s.isHovered = !0;
      let v = h.currentTarget;
      s.target = v, t && t({
        type: "hoverstart",
        target: v,
        pointerType: p
      }), r && r(!0), o(!0);
    }, d = (h, p) => {
      if (s.pointerType = "", s.target = null, p === "touch" || !s.isHovered) return;
      s.isHovered = !1;
      let v = h.currentTarget;
      n && n({
        type: "hoverend",
        target: v,
        pointerType: p
      }), r && r(!1), o(!1);
    }, f = {};
    return typeof PointerEvent < "u" ? (f.onPointerEnter = (h) => {
      is && h.pointerType === "mouse" || c(h, h.pointerType);
    }, f.onPointerLeave = (h) => {
      !i && h.currentTarget.contains(h.target) && d(h, h.pointerType);
    }) : (f.onTouchStart = () => {
      s.ignoreEmulatedMouseEvents = !0;
    }, f.onMouseEnter = (h) => {
      !s.ignoreEmulatedMouseEvents && !is && c(h, "mouse"), s.ignoreEmulatedMouseEvents = !1;
    }, f.onMouseLeave = (h) => {
      !i && h.currentTarget.contains(h.target) && d(h, "mouse");
    }), {
      hoverProps: f,
      triggerHoverEnd: d
    };
  }, [
    t,
    r,
    n,
    i,
    s
  ]);
  return ue(() => {
    i && l({
      currentTarget: s.target
    }, s.pointerType);
  }, [
    i
  ]), {
    hoverProps: u,
    isHovered: a
  };
}
function $6(e) {
  let { ref: t, onInteractOutside: r, isDisabled: n, onInteractOutsideStart: i } = e, a = q({
    isPointerDown: !1,
    ignoreEmulatedMouseEvents: !1
  }), o = st((u) => {
    r && to(u, t) && (i && i(u), a.current.isPointerDown = !0);
  }), s = st((u) => {
    r && r(u);
  });
  ue(() => {
    let u = a.current;
    if (n) return;
    const l = t.current, c = Re(l);
    if (typeof PointerEvent < "u") {
      let d = (f) => {
        u.isPointerDown && to(f, t) && s(f), u.isPointerDown = !1;
      };
      return c.addEventListener("pointerdown", o, !0), c.addEventListener("pointerup", d, !0), () => {
        c.removeEventListener("pointerdown", o, !0), c.removeEventListener("pointerup", d, !0);
      };
    } else {
      let d = (h) => {
        u.ignoreEmulatedMouseEvents ? u.ignoreEmulatedMouseEvents = !1 : u.isPointerDown && to(h, t) && s(h), u.isPointerDown = !1;
      }, f = (h) => {
        u.ignoreEmulatedMouseEvents = !0, u.isPointerDown && to(h, t) && s(h), u.isPointerDown = !1;
      };
      return c.addEventListener("mousedown", o, !0), c.addEventListener("mouseup", d, !0), c.addEventListener("touchstart", o, !0), c.addEventListener("touchend", f, !0), () => {
        c.removeEventListener("mousedown", o, !0), c.removeEventListener("mouseup", d, !0), c.removeEventListener("touchstart", o, !0), c.removeEventListener("touchend", f, !0);
      };
    }
  }, [
    t,
    n,
    o,
    s
  ]);
}
function to(e, t) {
  if (e.button > 0) return !1;
  if (e.target) {
    const r = e.target.ownerDocument;
    if (!r || !r.documentElement.contains(e.target) || e.target.closest("[data-react-aria-top-layer]")) return !1;
  }
  return t.current && !t.current.contains(e.target);
}
function Th(e) {
  if (!e) return;
  let t = !0;
  return (r) => {
    let n = {
      ...r,
      preventDefault() {
        r.preventDefault();
      },
      isDefaultPrevented() {
        return r.isDefaultPrevented();
      },
      stopPropagation() {
        console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
      },
      continuePropagation() {
        t = !1;
      }
    };
    e(n), t && r.stopPropagation();
  };
}
function x6(e) {
  return {
    keyboardProps: e.isDisabled ? {} : {
      onKeyDown: Th(e.onKeyDown),
      onKeyUp: Th(e.onKeyUp)
    }
  };
}
const D6 = 500;
function cy(e) {
  let { isDisabled: t, onLongPressStart: r, onLongPressEnd: n, onLongPress: i, threshold: a = D6, accessibilityDescription: o } = e;
  const s = q();
  let { addGlobalListener: u, removeGlobalListener: l } = cd(), { pressProps: c } = _a({
    isDisabled: t,
    onPressStart(f) {
      if (f.continuePropagation(), (f.pointerType === "mouse" || f.pointerType === "touch") && (r && r({
        ...f,
        type: "longpressstart"
      }), s.current = setTimeout(() => {
        f.target.dispatchEvent(new PointerEvent("pointercancel", {
          bubbles: !0
        })), i && i({
          ...f,
          type: "longpress"
        }), s.current = void 0;
      }, a), f.pointerType === "touch")) {
        let h = (p) => {
          p.preventDefault();
        };
        u(f.target, "contextmenu", h, {
          once: !0
        }), u(window, "pointerup", () => {
          setTimeout(() => {
            l(f.target, "contextmenu", h);
          }, 30);
        }, {
          once: !0
        });
      }
    },
    onPressEnd(f) {
      s.current && clearTimeout(s.current), n && (f.pointerType === "mouse" || f.pointerType === "touch") && n({
        ...f,
        type: "longpressend"
      });
    }
  }), d = Rs(i && !t ? o : void 0);
  return {
    longPressProps: ge(c, d)
  };
}
function fn(e) {
  const t = Re(e);
  if (ns() === "virtual") {
    let r = t.activeElement;
    Jv(() => {
      t.activeElement === r && e.isConnected && Ht(e);
    });
  } else Ht(e);
}
function E6(e) {
  const t = At(e);
  if (!(e instanceof t.HTMLElement) && !(e instanceof t.SVGElement)) return !1;
  let { display: r, visibility: n } = e.style, i = r !== "none" && n !== "hidden" && n !== "collapse";
  if (i) {
    const { getComputedStyle: a } = e.ownerDocument.defaultView;
    let { display: o, visibility: s } = a(e);
    i = o !== "none" && s !== "hidden" && s !== "collapse";
  }
  return i;
}
function w6(e, t) {
  return !e.hasAttribute("hidden") && // Ignore HiddenSelect when tree walking.
  !e.hasAttribute("data-react-aria-prevent-focus") && (e.nodeName === "DETAILS" && t && t.nodeName !== "SUMMARY" ? e.hasAttribute("open") : !0);
}
function dy(e, t) {
  return e.nodeName !== "#comment" && E6(e) && w6(e, t) && (!e.parentElement || dy(e.parentElement, e));
}
const Ph = /* @__PURE__ */ F.createContext(null);
let Be = null;
function fy(e) {
  let { children: t, contain: r, restoreFocus: n, autoFocus: i } = e, a = q(null), o = q(null), s = q([]), { parentNode: u } = ce(Ph) || {}, l = G(() => new Hl({
    scopeRef: s
  }), [
    s
  ]);
  Oe(() => {
    let f = u || Ye.root;
    if (Ye.getTreeNode(f.scopeRef) && Be && !os(Be, f.scopeRef)) {
      let h = Ye.getTreeNode(Be);
      h && (f = h);
    }
    f.addChild(l), Ye.addNode(l);
  }, [
    l,
    u
  ]), Oe(() => {
    let f = Ye.getTreeNode(s);
    f && (f.contain = !!r);
  }, [
    r
  ]), Oe(() => {
    var f;
    let h = (f = a.current) === null || f === void 0 ? void 0 : f.nextSibling, p = [];
    for (; h && h !== o.current; )
      p.push(h), h = h.nextSibling;
    s.current = p;
  }, [
    t
  ]), _6(s, n, r), T6(s, r), O6(s, n, r), A6(s, i), ue(() => {
    const f = Re(s.current ? s.current[0] : void 0).activeElement;
    let h = null;
    if (ut(f, s.current)) {
      for (let p of Ye.traverse()) p.scopeRef && ut(f, p.scopeRef.current) && (h = p);
      h === Ye.getTreeNode(s) && (Be = h.scopeRef);
    }
  }, [
    s
  ]), Oe(() => () => {
    var f, h, p;
    let v = (p = (h = Ye.getTreeNode(s)) === null || h === void 0 || (f = h.parent) === null || f === void 0 ? void 0 : f.scopeRef) !== null && p !== void 0 ? p : null;
    (s === Be || os(s, Be)) && (!v || Ye.getTreeNode(v)) && (Be = v), Ye.removeTreeNode(s);
  }, [
    s
  ]);
  let c = G(() => C6(s), []), d = G(() => ({
    focusManager: c,
    parentNode: l
  }), [
    l,
    c
  ]);
  return /* @__PURE__ */ F.createElement(Ph.Provider, {
    value: d
  }, /* @__PURE__ */ F.createElement("span", {
    "data-focus-scope-start": !0,
    hidden: !0,
    ref: a
  }), t, /* @__PURE__ */ F.createElement("span", {
    "data-focus-scope-end": !0,
    hidden: !0,
    ref: o
  }));
}
function C6(e) {
  return {
    focusNext(t = {}) {
      let r = e.current, { from: n, tabbable: i, wrap: a, accept: o } = t, s = n || Re(r[0]).activeElement, u = r[0].previousElementSibling, l = Xr(r), c = gt(l, {
        tabbable: i,
        accept: o
      }, r);
      c.currentNode = ut(s, r) ? s : u;
      let d = c.nextNode();
      return !d && a && (c.currentNode = u, d = c.nextNode()), d && yt(d, !0), d;
    },
    focusPrevious(t = {}) {
      let r = e.current, { from: n, tabbable: i, wrap: a, accept: o } = t, s = n || Re(r[0]).activeElement, u = r[r.length - 1].nextElementSibling, l = Xr(r), c = gt(l, {
        tabbable: i,
        accept: o
      }, r);
      c.currentNode = ut(s, r) ? s : u;
      let d = c.previousNode();
      return !d && a && (c.currentNode = u, d = c.previousNode()), d && yt(d, !0), d;
    },
    focusFirst(t = {}) {
      let r = e.current, { tabbable: n, accept: i } = t, a = Xr(r), o = gt(a, {
        tabbable: n,
        accept: i
      }, r);
      o.currentNode = r[0].previousElementSibling;
      let s = o.nextNode();
      return s && yt(s, !0), s;
    },
    focusLast(t = {}) {
      let r = e.current, { tabbable: n, accept: i } = t, a = Xr(r), o = gt(a, {
        tabbable: n,
        accept: i
      }, r);
      o.currentNode = r[r.length - 1].nextElementSibling;
      let s = o.previousNode();
      return s && yt(s, !0), s;
    }
  };
}
const pd = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[contenteditable]"
], S6 = pd.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
pd.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const k6 = pd.join(':not([hidden]):not([tabindex="-1"]),');
function Xr(e) {
  return e[0].parentElement;
}
function Ri(e) {
  let t = Ye.getTreeNode(Be);
  for (; t && t.scopeRef !== e; ) {
    if (t.contain) return !1;
    t = t.parent;
  }
  return !0;
}
function T6(e, t) {
  let r = q(), n = q();
  Oe(() => {
    let i = e.current;
    if (!t) {
      n.current && (cancelAnimationFrame(n.current), n.current = void 0);
      return;
    }
    const a = Re(i ? i[0] : void 0);
    let o = (l) => {
      if (l.key !== "Tab" || l.altKey || l.ctrlKey || l.metaKey || !Ri(e) || l.isComposing) return;
      let c = a.activeElement, d = e.current;
      if (!d || !ut(c, d)) return;
      let f = Xr(d), h = gt(f, {
        tabbable: !0
      }, d);
      if (!c) return;
      h.currentNode = c;
      let p = l.shiftKey ? h.previousNode() : h.nextNode();
      p || (h.currentNode = l.shiftKey ? d[d.length - 1].nextElementSibling : d[0].previousElementSibling, p = l.shiftKey ? h.previousNode() : h.nextNode()), l.preventDefault(), p && yt(p, !0);
    }, s = (l) => {
      (!Be || os(Be, e)) && ut(l.target, e.current) ? (Be = e, r.current = l.target) : Ri(e) && !as(l.target, e) ? r.current ? r.current.focus() : Be && Be.current && ss(Be.current) : Ri(e) && (r.current = l.target);
    }, u = (l) => {
      n.current && cancelAnimationFrame(n.current), n.current = requestAnimationFrame(() => {
        if (a.activeElement && Ri(e) && !as(a.activeElement, e))
          if (Be = e, a.body.contains(l.target)) {
            var c;
            r.current = l.target, (c = r.current) === null || c === void 0 || c.focus();
          } else Be.current && ss(Be.current);
      });
    };
    return a.addEventListener("keydown", o, !1), a.addEventListener("focusin", s, !1), i == null || i.forEach((l) => l.addEventListener("focusin", s, !1)), i == null || i.forEach((l) => l.addEventListener("focusout", u, !1)), () => {
      a.removeEventListener("keydown", o, !1), a.removeEventListener("focusin", s, !1), i == null || i.forEach((l) => l.removeEventListener("focusin", s, !1)), i == null || i.forEach((l) => l.removeEventListener("focusout", u, !1));
    };
  }, [
    e,
    t
  ]), Oe(() => () => {
    n.current && cancelAnimationFrame(n.current);
  }, [
    n
  ]);
}
function hy(e) {
  return as(e);
}
function ut(e, t) {
  return !e || !t ? !1 : t.some((r) => r.contains(e));
}
function as(e, t = null) {
  if (e instanceof Element && e.closest("[data-react-aria-top-layer]")) return !0;
  for (let { scopeRef: r } of Ye.traverse(Ye.getTreeNode(t)))
    if (r && ut(e, r.current)) return !0;
  return !1;
}
function P6(e) {
  return as(e, Be);
}
function os(e, t) {
  var r;
  let n = (r = Ye.getTreeNode(t)) === null || r === void 0 ? void 0 : r.parent;
  for (; n; ) {
    if (n.scopeRef === e) return !0;
    n = n.parent;
  }
  return !1;
}
function yt(e, t = !1) {
  if (e != null && !t) try {
    fn(e);
  } catch {
  }
  else if (e != null) try {
    e.focus();
  } catch {
  }
}
function ss(e, t = !0) {
  let r = e[0].previousElementSibling, n = Xr(e), i = gt(n, {
    tabbable: t
  }, e);
  i.currentNode = r;
  let a = i.nextNode();
  t && !a && (n = Xr(e), i = gt(n, {
    tabbable: !1
  }, e), i.currentNode = r, a = i.nextNode()), yt(a);
}
function A6(e, t) {
  const r = F.useRef(t);
  ue(() => {
    if (r.current) {
      Be = e;
      const n = Re(e.current ? e.current[0] : void 0);
      !ut(n.activeElement, Be.current) && e.current && ss(e.current);
    }
    r.current = !1;
  }, [
    e
  ]);
}
function _6(e, t, r) {
  Oe(() => {
    if (t || r) return;
    let n = e.current;
    const i = Re(n ? n[0] : void 0);
    let a = (o) => {
      let s = o.target;
      ut(s, e.current) ? Be = e : hy(s) || (Be = null);
    };
    return i.addEventListener("focusin", a, !1), n == null || n.forEach((o) => o.addEventListener("focusin", a, !1)), () => {
      i.removeEventListener("focusin", a, !1), n == null || n.forEach((o) => o.removeEventListener("focusin", a, !1));
    };
  }, [
    e,
    t,
    r
  ]);
}
function F6(e) {
  let t = Ye.getTreeNode(Be);
  for (; t && t.scopeRef !== e; ) {
    if (t.nodeToRestore) return !1;
    t = t.parent;
  }
  return (t == null ? void 0 : t.scopeRef) === e;
}
function O6(e, t, r) {
  const n = q(typeof document < "u" ? Re(e.current ? e.current[0] : void 0).activeElement : null);
  Oe(() => {
    let i = e.current;
    const a = Re(i ? i[0] : void 0);
    if (!t || r) return;
    let o = () => {
      (!Be || os(Be, e)) && ut(a.activeElement, e.current) && (Be = e);
    };
    return a.addEventListener("focusin", o, !1), i == null || i.forEach((s) => s.addEventListener("focusin", o, !1)), () => {
      a.removeEventListener("focusin", o, !1), i == null || i.forEach((s) => s.removeEventListener("focusin", o, !1));
    };
  }, [
    e,
    r
  ]), Oe(() => {
    const i = Re(e.current ? e.current[0] : void 0);
    if (!t) return;
    let a = (o) => {
      if (o.key !== "Tab" || o.altKey || o.ctrlKey || o.metaKey || !Ri(e) || o.isComposing) return;
      let s = i.activeElement;
      if (!ut(s, e.current)) return;
      let u = Ye.getTreeNode(e);
      if (!u) return;
      let l = u.nodeToRestore, c = gt(i.body, {
        tabbable: !0
      });
      c.currentNode = s;
      let d = o.shiftKey ? c.previousNode() : c.nextNode();
      if ((!l || !i.body.contains(l) || l === i.body) && (l = void 0, u.nodeToRestore = void 0), (!d || !ut(d, e.current)) && l) {
        c.currentNode = l;
        do
          d = o.shiftKey ? c.previousNode() : c.nextNode();
        while (ut(d, e.current));
        o.preventDefault(), o.stopPropagation(), d ? yt(d, !0) : hy(l) ? yt(l, !0) : s.blur();
      }
    };
    return r || i.addEventListener("keydown", a, !0), () => {
      r || i.removeEventListener("keydown", a, !0);
    };
  }, [
    e,
    t,
    r
  ]), Oe(() => {
    const i = Re(e.current ? e.current[0] : void 0);
    if (!t) return;
    let a = Ye.getTreeNode(e);
    if (a) {
      var o;
      return a.nodeToRestore = (o = n.current) !== null && o !== void 0 ? o : void 0, () => {
        let s = Ye.getTreeNode(e);
        if (!s) return;
        let u = s.nodeToRestore;
        if (t && u && // eslint-disable-next-line react-hooks/exhaustive-deps
        (ut(i.activeElement, e.current) || i.activeElement === i.body && F6(e))) {
          let l = Ye.clone();
          requestAnimationFrame(() => {
            if (i.activeElement === i.body) {
              let c = l.getTreeNode(e);
              for (; c; ) {
                if (c.nodeToRestore && c.nodeToRestore.isConnected) {
                  yt(c.nodeToRestore);
                  return;
                }
                c = c.parent;
              }
              for (c = l.getTreeNode(e); c; ) {
                if (c.scopeRef && c.scopeRef.current && Ye.getTreeNode(c.scopeRef)) {
                  ss(c.scopeRef.current, !0);
                  return;
                }
                c = c.parent;
              }
            }
          });
        }
      };
    }
  }, [
    e,
    t
  ]);
}
function gt(e, t, r) {
  let n = t != null && t.tabbable ? k6 : S6, i = Re(e).createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode(a) {
      var o;
      return !(t == null || (o = t.from) === null || o === void 0) && o.contains(a) ? NodeFilter.FILTER_REJECT : a.matches(n) && dy(a) && (!r || ut(a, r)) && (!(t != null && t.accept) || t.accept(a)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  return t != null && t.from && (i.currentNode = t.from), i;
}
function md(e, t = {}) {
  return {
    focusNext(r = {}) {
      let n = e.current;
      if (!n) return null;
      let { from: i, tabbable: a = t.tabbable, wrap: o = t.wrap, accept: s = t.accept } = r, u = i || Re(n).activeElement, l = gt(n, {
        tabbable: a,
        accept: s
      });
      n.contains(u) && (l.currentNode = u);
      let c = l.nextNode();
      return !c && o && (l.currentNode = n, c = l.nextNode()), c && yt(c, !0), c;
    },
    focusPrevious(r = t) {
      let n = e.current;
      if (!n) return null;
      let { from: i, tabbable: a = t.tabbable, wrap: o = t.wrap, accept: s = t.accept } = r, u = i || Re(n).activeElement, l = gt(n, {
        tabbable: a,
        accept: s
      });
      if (n.contains(u)) l.currentNode = u;
      else {
        let d = Ru(l);
        return d && yt(d, !0), d ?? null;
      }
      let c = l.previousNode();
      if (!c && o) {
        l.currentNode = n;
        let d = Ru(l);
        if (!d)
          return null;
        c = d;
      }
      return c && yt(c, !0), c ?? null;
    },
    focusFirst(r = t) {
      let n = e.current;
      if (!n) return null;
      let { tabbable: i = t.tabbable, accept: a = t.accept } = r, s = gt(n, {
        tabbable: i,
        accept: a
      }).nextNode();
      return s && yt(s, !0), s;
    },
    focusLast(r = t) {
      let n = e.current;
      if (!n) return null;
      let { tabbable: i = t.tabbable, accept: a = t.accept } = r, o = gt(n, {
        tabbable: i,
        accept: a
      }), s = Ru(o);
      return s && yt(s, !0), s ?? null;
    }
  };
}
function Ru(e) {
  let t, r;
  do
    r = e.lastChild(), r && (t = r);
  while (r);
  return t;
}
class vd {
  get size() {
    return this.fastMap.size;
  }
  getTreeNode(t) {
    return this.fastMap.get(t);
  }
  addTreeNode(t, r, n) {
    let i = this.fastMap.get(r ?? null);
    if (!i) return;
    let a = new Hl({
      scopeRef: t
    });
    i.addChild(a), a.parent = i, this.fastMap.set(t, a), n && (a.nodeToRestore = n);
  }
  addNode(t) {
    this.fastMap.set(t.scopeRef, t);
  }
  removeTreeNode(t) {
    if (t === null) return;
    let r = this.fastMap.get(t);
    if (!r) return;
    let n = r.parent;
    for (let a of this.traverse()) a !== r && r.nodeToRestore && a.nodeToRestore && r.scopeRef && r.scopeRef.current && ut(a.nodeToRestore, r.scopeRef.current) && (a.nodeToRestore = r.nodeToRestore);
    let i = r.children;
    n && (n.removeChild(r), i.size > 0 && i.forEach((a) => n && n.addChild(a))), this.fastMap.delete(r.scopeRef);
  }
  // Pre Order Depth First
  *traverse(t = this.root) {
    if (t.scopeRef != null && (yield t), t.children.size > 0) for (let r of t.children) yield* this.traverse(r);
  }
  clone() {
    var t;
    let r = new vd();
    var n;
    for (let i of this.traverse()) r.addTreeNode(i.scopeRef, (n = (t = i.parent) === null || t === void 0 ? void 0 : t.scopeRef) !== null && n !== void 0 ? n : null, i.nodeToRestore);
    return r;
  }
  constructor() {
    this.fastMap = /* @__PURE__ */ new Map(), this.root = new Hl({
      scopeRef: null
    }), this.fastMap.set(null, this.root);
  }
}
class Hl {
  addChild(t) {
    this.children.add(t), t.parent = this;
  }
  removeChild(t) {
    this.children.delete(t), t.parent = void 0;
  }
  constructor(t) {
    this.children = /* @__PURE__ */ new Set(), this.contain = !1, this.scopeRef = t.scopeRef;
  }
}
let Ye = new vd();
function Kr(e = {}) {
  let { autoFocus: t = !1, isTextInput: r, within: n } = e, i = q({
    isFocused: !1,
    isFocusVisible: t || rs()
  }), [a, o] = re(!1), [s, u] = re(() => i.current.isFocused && i.current.isFocusVisible), l = ye(() => u(i.current.isFocused && i.current.isFocusVisible), []), c = ye((h) => {
    i.current.isFocused = h, o(h), l();
  }, [
    l
  ]);
  g6((h) => {
    i.current.isFocusVisible = h, l();
  }, [], {
    isTextInput: r
  });
  let { focusProps: d } = iy({
    isDisabled: n,
    onFocusChange: c
  }), { focusWithinProps: f } = ci({
    isDisabled: !n,
    onFocusWithinChange: c
  });
  return {
    isFocused: a,
    isFocusVisible: s,
    focusProps: n ? f : d
  };
}
let I6 = /* @__PURE__ */ F.createContext(null);
function R6(e) {
  let t = ce(I6) || {};
  dd(t, e);
  let { ref: r, ...n } = t;
  return n;
}
function py(e, t) {
  let { focusProps: r } = iy(e), { keyboardProps: n } = x6(e), i = ge(r, n), a = R6(t), o = e.isDisabled ? {} : a, s = q(e.autoFocus);
  return ue(() => {
    s.current && t.current && fn(t.current), s.current = !1;
  }, [
    t
  ]), {
    focusableProps: ge({
      ...i,
      tabIndex: e.excludeFromTabOrder && !e.isDisabled ? -1 : void 0
    }, o)
  };
}
const B6 = /* @__PURE__ */ new Set([
  "Arab",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]), M6 = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function N6(e) {
  if (Intl.Locale) {
    let r = new Intl.Locale(e).maximize(), n = typeof r.getTextInfo == "function" ? r.getTextInfo() : r.textInfo;
    if (n) return n.direction === "rtl";
    if (r.script) return B6.has(r.script);
  }
  let t = e.split("-")[0];
  return M6.has(t);
}
const L6 = Symbol.for("react-aria.i18n.locale");
function my() {
  let e = typeof window < "u" && window[L6] || typeof navigator < "u" && (navigator.language || navigator.userLanguage) || "en-US";
  try {
    Intl.DateTimeFormat.supportedLocalesOf([
      e
    ]);
  } catch {
    e = "en-US";
  }
  return {
    locale: e,
    direction: N6(e) ? "rtl" : "ltr"
  };
}
let Wl = my(), Bi = /* @__PURE__ */ new Set();
function Ah() {
  Wl = my();
  for (let e of Bi) e(Wl);
}
function V6() {
  let e = vn(), [t, r] = re(Wl);
  return ue(() => (Bi.size === 0 && window.addEventListener("languagechange", Ah), Bi.add(r), () => {
    Bi.delete(r), Bi.size === 0 && window.removeEventListener("languagechange", Ah);
  }), []), e ? {
    locale: "en-US",
    direction: "ltr"
  } : t;
}
const j6 = /* @__PURE__ */ F.createContext(null);
function lt() {
  let e = V6();
  return ce(j6) || e;
}
const z6 = Symbol.for("react-aria.i18n.locale"), K6 = Symbol.for("react-aria.i18n.strings");
let wn;
class Ur {
  /** Returns a localized string for the given key and locale. */
  getStringForLocale(t, r) {
    let i = this.getStringsForLocale(r)[t];
    if (!i) throw new Error(`Could not find intl message ${t} in ${r} locale`);
    return i;
  }
  /** Returns all localized strings for the given locale. */
  getStringsForLocale(t) {
    let r = this.strings[t];
    return r || (r = U6(t, this.strings, this.defaultLocale), this.strings[t] = r), r;
  }
  static getGlobalDictionaryForPackage(t) {
    if (typeof window > "u") return null;
    let r = window[z6];
    if (wn === void 0) {
      let i = window[K6];
      if (!i) return null;
      wn = {};
      for (let a in i) wn[a] = new Ur({
        [r]: i[a]
      }, r);
    }
    let n = wn == null ? void 0 : wn[t];
    if (!n) throw new Error(`Strings for package "${t}" were not included by LocalizedStringProvider. Please add it to the list passed to createLocalizedStringDictionary.`);
    return n;
  }
  constructor(t, r = "en-US") {
    this.strings = Object.fromEntries(Object.entries(t).filter(([, n]) => n)), this.defaultLocale = r;
  }
}
function U6(e, t, r = "en-US") {
  if (t[e]) return t[e];
  let n = q6(e);
  if (t[n]) return t[n];
  for (let i in t)
    if (i.startsWith(n + "-")) return t[i];
  return t[r];
}
function q6(e) {
  return Intl.Locale ? new Intl.Locale(e).language : e.split("-")[0];
}
const _h = /* @__PURE__ */ new Map(), Fh = /* @__PURE__ */ new Map();
class vy {
  /** Formats a localized string for the given key with the provided variables. */
  format(t, r) {
    let n = this.strings.getStringForLocale(t, this.locale);
    return typeof n == "function" ? n(r, this) : n;
  }
  plural(t, r, n = "cardinal") {
    let i = r["=" + t];
    if (i) return typeof i == "function" ? i() : i;
    let a = this.locale + ":" + n, o = _h.get(a);
    o || (o = new Intl.PluralRules(this.locale, {
      type: n
    }), _h.set(a, o));
    let s = o.select(t);
    return i = r[s] || r.other, typeof i == "function" ? i() : i;
  }
  number(t) {
    let r = Fh.get(this.locale);
    return r || (r = new Intl.NumberFormat(this.locale), Fh.set(this.locale, r)), r.format(t);
  }
  select(t, r) {
    let n = t[r] || t.other;
    return typeof n == "function" ? n() : n;
  }
  constructor(t, r) {
    this.locale = t, this.strings = r;
  }
}
const Oh = /* @__PURE__ */ new WeakMap();
function H6(e) {
  let t = Oh.get(e);
  return t || (t = new Ur(e), Oh.set(e, t)), t;
}
function yy(e, t) {
  return t && Ur.getGlobalDictionaryForPackage(t) || H6(e);
}
function zt(e, t) {
  let { locale: r } = lt(), n = yy(e, t);
  return G(() => new vy(r, n), [
    r,
    n
  ]);
}
function qn(e, t) {
  return e - t * Math.floor(e / t);
}
const gy = 1721426;
function en(e, t, r, n) {
  t = Fa(e, t);
  let i = t - 1, a = -2;
  return r <= 2 ? a = 0 : Or(t) && (a = -1), gy - 1 + 365 * i + Math.floor(i / 4) - Math.floor(i / 100) + Math.floor(i / 400) + Math.floor((367 * r - 362) / 12 + a + n);
}
function Or(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function Fa(e, t) {
  return e === "BC" ? 1 - t : t;
}
function Ms(e) {
  let t = "AD";
  return e <= 0 && (t = "BC", e = 1 - e), [
    t,
    e
  ];
}
const W6 = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
class xt {
  fromJulianDay(t) {
    let r = t, n = r - gy, i = Math.floor(n / 146097), a = qn(n, 146097), o = Math.floor(a / 36524), s = qn(a, 36524), u = Math.floor(s / 1461), l = qn(s, 1461), c = Math.floor(l / 365), d = i * 400 + o * 100 + u * 4 + c + (o !== 4 && c !== 4 ? 1 : 0), [f, h] = Ms(d), p = r - en(f, h, 1, 1), v = 2;
    r < en(f, h, 3, 1) ? v = 0 : Or(h) && (v = 1);
    let g = Math.floor(((p + v) * 12 + 373) / 367), $ = r - en(f, h, g, 1) + 1;
    return new et(f, h, g, $);
  }
  toJulianDay(t) {
    return en(t.era, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    return W6[Or(t.year) ? "leapyear" : "standard"][t.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(t) {
    return 12;
  }
  getDaysInYear(t) {
    return Or(t.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(t) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(t) {
    return t.era === "BC";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BC" ? "AD" : "BC", t.year = 1 - t.year);
  }
  constructor() {
    this.identifier = "gregory";
  }
}
const Q6 = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};
function Je(e, t) {
  return t = Ve(t, e.calendar), e.era === t.era && e.year === t.year && e.month === t.month && e.day === t.day;
}
function G6(e, t) {
  return t = Ve(t, e.calendar), e = br(e), t = br(t), e.era === t.era && e.year === t.year && e.month === t.month;
}
function Ql(e, t) {
  return e.calendar.identifier === t.calendar.identifier && e.era === t.era && e.year === t.year && e.month === t.month && e.day === t.day;
}
function Z6(e, t) {
  return Je(e, Ns(t));
}
function yd(e, t) {
  let r = e.calendar.toJulianDay(e), n = Math.ceil(r + 1 - tC(t)) % 7;
  return n < 0 && (n += 7), n;
}
function by(e) {
  return cr(Date.now(), e);
}
function Ns(e) {
  return bt(by(e));
}
function $y(e, t) {
  return e.calendar.toJulianDay(e) - t.calendar.toJulianDay(t);
}
function xy(e, t) {
  return Ih(e) - Ih(t);
}
function Ih(e) {
  return e.hour * 36e5 + e.minute * 6e4 + e.second * 1e3 + e.millisecond;
}
let Bu = null;
function fa() {
  return Bu == null && (Bu = new Intl.DateTimeFormat().resolvedOptions().timeZone), Bu;
}
function br(e) {
  return e.subtract({
    days: e.day - 1
  });
}
function oi(e) {
  return e.add({
    days: e.calendar.getDaysInMonth(e) - e.day
  });
}
function Gl(e) {
  return br(e.subtract({
    months: e.month - 1
  }));
}
function Y6(e) {
  return oi(e.add({
    months: e.calendar.getMonthsInYear(e) - e.month
  }));
}
function J6(e) {
  return e.calendar.getMinimumMonthInYear ? e.calendar.getMinimumMonthInYear(e) : 1;
}
function X6(e) {
  return e.calendar.getMinimumDayInMonth ? e.calendar.getMinimumDayInMonth(e) : 1;
}
function hn(e, t) {
  let r = yd(e, t);
  return e.subtract({
    days: r
  });
}
function Dy(e, t) {
  return hn(e, t).add({
    days: 6
  });
}
const Rh = /* @__PURE__ */ new Map();
function eC(e) {
  if (Intl.Locale) {
    let r = Rh.get(e);
    return r || (r = new Intl.Locale(e).maximize().region, r && Rh.set(e, r)), r;
  }
  let t = e.split("-")[1];
  return t === "u" ? void 0 : t;
}
function tC(e) {
  let t = eC(e);
  return t && Q6[t] || 0;
}
function rC(e, t) {
  let r = e.calendar.getDaysInMonth(e);
  return Math.ceil((yd(br(e), t) + r) / 7);
}
function gd(e, t) {
  return e && t ? e.compare(t) <= 0 ? e : t : e || t;
}
function bd(e, t) {
  return e && t ? e.compare(t) >= 0 ? e : t : e || t;
}
function si(e) {
  e = Ve(e, new xt());
  let t = Fa(e.era, e.year);
  return Ey(t, e.month, e.day, e.hour, e.minute, e.second, e.millisecond);
}
function Ey(e, t, r, n, i, a, o) {
  let s = /* @__PURE__ */ new Date();
  return s.setUTCHours(n, i, a, o), s.setUTCFullYear(e, t - 1, r), s.getTime();
}
function Zl(e, t) {
  if (t === "UTC") return 0;
  if (e > 0 && t === fa()) return new Date(e).getTimezoneOffset() * -6e4;
  let { year: r, month: n, day: i, hour: a, minute: o, second: s } = wy(e, t);
  return Ey(r, n, i, a, o, s, 0) - Math.floor(e / 1e3) * 1e3;
}
const Bh = /* @__PURE__ */ new Map();
function wy(e, t) {
  let r = Bh.get(t);
  r || (r = new Intl.DateTimeFormat("en-US", {
    timeZone: t,
    hour12: !1,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), Bh.set(t, r));
  let n = r.formatToParts(new Date(e)), i = {};
  for (let a of n) a.type !== "literal" && (i[a.type] = a.value);
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: i.era === "BC" || i.era === "B" ? -i.year + 1 : +i.year,
    month: +i.month,
    day: +i.day,
    hour: i.hour === "24" ? 0 : +i.hour,
    minute: +i.minute,
    second: +i.second
  };
}
const Mh = 864e5;
function nC(e, t, r, n) {
  return (r === n ? [
    r
  ] : [
    r,
    n
  ]).filter((a) => iC(e, t, a));
}
function iC(e, t, r) {
  let n = wy(r, t);
  return e.year === n.year && e.month === n.month && e.day === n.day && e.hour === n.hour && e.minute === n.minute && e.second === n.second;
}
function sr(e, t, r = "compatible") {
  let n = $r(e);
  if (t === "UTC") return si(n);
  if (t === fa() && r === "compatible") {
    n = Ve(n, new xt());
    let u = /* @__PURE__ */ new Date(), l = Fa(n.era, n.year);
    return u.setFullYear(l, n.month - 1, n.day), u.setHours(n.hour, n.minute, n.second, n.millisecond), u.getTime();
  }
  let i = si(n), a = Zl(i - Mh, t), o = Zl(i + Mh, t), s = nC(n, t, i - a, i - o);
  if (s.length === 1) return s[0];
  if (s.length > 1) switch (r) {
    case "compatible":
    case "earlier":
      return s[0];
    case "later":
      return s[s.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (r) {
    case "earlier":
      return Math.min(i - a, i - o);
    case "compatible":
    case "later":
      return Math.max(i - a, i - o);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function Cy(e, t, r = "compatible") {
  return new Date(sr(e, t, r));
}
function cr(e, t) {
  let r = Zl(e, t), n = new Date(e + r), i = n.getUTCFullYear(), a = n.getUTCMonth() + 1, o = n.getUTCDate(), s = n.getUTCHours(), u = n.getUTCMinutes(), l = n.getUTCSeconds(), c = n.getUTCMilliseconds();
  return new pa(i, a, o, t, r, s, u, l, c);
}
function bt(e) {
  return new et(e.calendar, e.era, e.year, e.month, e.day);
}
function $r(e, t) {
  let r = 0, n = 0, i = 0, a = 0;
  if ("timeZone" in e) ({ hour: r, minute: n, second: i, millisecond: a } = e);
  else if ("hour" in e && !t) return e;
  return t && ({ hour: r, minute: n, second: i, millisecond: a } = t), new us(e.calendar, e.era, e.year, e.month, e.day, r, n, i, a);
}
function Ve(e, t) {
  if (e.calendar.identifier === t.identifier) return e;
  let r = t.fromJulianDay(e.calendar.toJulianDay(e)), n = e.copy();
  return n.calendar = t, n.era = r.era, n.year = r.year, n.month = r.month, n.day = r.day, pn(n), n;
}
function aC(e, t, r) {
  if (e instanceof pa)
    return e.timeZone === t ? e : sC(e, t);
  let n = sr(e, t, r);
  return cr(n, t);
}
function oC(e) {
  let t = si(e) - e.offset;
  return new Date(t);
}
function sC(e, t) {
  let r = si(e) - e.offset;
  return Ve(cr(r, t), e.calendar);
}
const wi = 36e5;
function Ls(e, t) {
  let r = e.copy(), n = "hour" in r ? Py(r, t) : 0;
  Yl(r, t.years || 0), r.calendar.balanceYearMonth && r.calendar.balanceYearMonth(r, e), r.month += t.months || 0, Jl(r), Sy(r), r.day += (t.weeks || 0) * 7, r.day += t.days || 0, r.day += n, uC(r), r.calendar.balanceDate && r.calendar.balanceDate(r), r.year < 1 && (r.year = 1, r.month = 1, r.day = 1);
  let i = r.calendar.getYearsInEra(r);
  if (r.year > i) {
    var a, o;
    let u = (a = (o = r.calendar).isInverseEra) === null || a === void 0 ? void 0 : a.call(o, r);
    r.year = i, r.month = u ? 1 : r.calendar.getMonthsInYear(r), r.day = u ? 1 : r.calendar.getDaysInMonth(r);
  }
  r.month < 1 && (r.month = 1, r.day = 1);
  let s = r.calendar.getMonthsInYear(r);
  return r.month > s && (r.month = s, r.day = r.calendar.getDaysInMonth(r)), r.day = Math.max(1, Math.min(r.calendar.getDaysInMonth(r), r.day)), r;
}
function Yl(e, t) {
  var r, n;
  !((r = (n = e.calendar).isInverseEra) === null || r === void 0) && r.call(n, e) && (t = -t), e.year += t;
}
function Jl(e) {
  for (; e.month < 1; )
    Yl(e, -1), e.month += e.calendar.getMonthsInYear(e);
  let t = 0;
  for (; e.month > (t = e.calendar.getMonthsInYear(e)); )
    e.month -= t, Yl(e, 1);
}
function uC(e) {
  for (; e.day < 1; )
    e.month--, Jl(e), e.day += e.calendar.getDaysInMonth(e);
  for (; e.day > e.calendar.getDaysInMonth(e); )
    e.day -= e.calendar.getDaysInMonth(e), e.month++, Jl(e);
}
function Sy(e) {
  e.month = Math.max(1, Math.min(e.calendar.getMonthsInYear(e), e.month)), e.day = Math.max(1, Math.min(e.calendar.getDaysInMonth(e), e.day));
}
function pn(e) {
  e.calendar.constrainDate && e.calendar.constrainDate(e), e.year = Math.max(1, Math.min(e.calendar.getYearsInEra(e), e.year)), Sy(e);
}
function $d(e) {
  let t = {};
  for (let r in e) typeof e[r] == "number" && (t[r] = -e[r]);
  return t;
}
function ky(e, t) {
  return Ls(e, $d(t));
}
function xd(e, t) {
  let r = e.copy();
  return t.era != null && (r.era = t.era), t.year != null && (r.year = t.year), t.month != null && (r.month = t.month), t.day != null && (r.day = t.day), pn(r), r;
}
function ha(e, t) {
  let r = e.copy();
  return t.hour != null && (r.hour = t.hour), t.minute != null && (r.minute = t.minute), t.second != null && (r.second = t.second), t.millisecond != null && (r.millisecond = t.millisecond), Ty(r), r;
}
function lC(e) {
  e.second += Math.floor(e.millisecond / 1e3), e.millisecond = ro(e.millisecond, 1e3), e.minute += Math.floor(e.second / 60), e.second = ro(e.second, 60), e.hour += Math.floor(e.minute / 60), e.minute = ro(e.minute, 60);
  let t = Math.floor(e.hour / 24);
  return e.hour = ro(e.hour, 24), t;
}
function Ty(e) {
  e.millisecond = Math.max(0, Math.min(e.millisecond, 1e3)), e.second = Math.max(0, Math.min(e.second, 59)), e.minute = Math.max(0, Math.min(e.minute, 59)), e.hour = Math.max(0, Math.min(e.hour, 23));
}
function ro(e, t) {
  let r = e % t;
  return r < 0 && (r += t), r;
}
function Py(e, t) {
  return e.hour += t.hours || 0, e.minute += t.minutes || 0, e.second += t.seconds || 0, e.millisecond += t.milliseconds || 0, lC(e);
}
function Ay(e, t) {
  let r = e.copy();
  return Py(r, t), r;
}
function cC(e, t) {
  return Ay(e, $d(t));
}
function Dd(e, t, r, n) {
  let i = e.copy();
  switch (t) {
    case "era": {
      let s = e.calendar.getEras(), u = s.indexOf(e.era);
      if (u < 0) throw new Error("Invalid era: " + e.era);
      u = dr(u, r, 0, s.length - 1, n == null ? void 0 : n.round), i.era = s[u], pn(i);
      break;
    }
    case "year":
      var a, o;
      !((a = (o = i.calendar).isInverseEra) === null || a === void 0) && a.call(o, i) && (r = -r), i.year = dr(e.year, r, -1 / 0, 9999, n == null ? void 0 : n.round), i.year === -1 / 0 && (i.year = 1), i.calendar.balanceYearMonth && i.calendar.balanceYearMonth(i, e);
      break;
    case "month":
      i.month = dr(e.month, r, 1, e.calendar.getMonthsInYear(e), n == null ? void 0 : n.round);
      break;
    case "day":
      i.day = dr(e.day, r, 1, e.calendar.getDaysInMonth(e), n == null ? void 0 : n.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return e.calendar.balanceDate && e.calendar.balanceDate(i), pn(i), i;
}
function Ed(e, t, r, n) {
  let i = e.copy();
  switch (t) {
    case "hour": {
      let a = e.hour, o = 0, s = 23;
      if ((n == null ? void 0 : n.hourCycle) === 12) {
        let u = a >= 12;
        o = u ? 12 : 0, s = u ? 23 : 11;
      }
      i.hour = dr(a, r, o, s, n == null ? void 0 : n.round);
      break;
    }
    case "minute":
      i.minute = dr(e.minute, r, 0, 59, n == null ? void 0 : n.round);
      break;
    case "second":
      i.second = dr(e.second, r, 0, 59, n == null ? void 0 : n.round);
      break;
    case "millisecond":
      i.millisecond = dr(e.millisecond, r, 0, 999, n == null ? void 0 : n.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return i;
}
function dr(e, t, r, n, i = !1) {
  if (i) {
    e += Math.sign(t), e < r && (e = n);
    let a = Math.abs(t);
    t > 0 ? e = Math.ceil(e / a) * a : e = Math.floor(e / a) * a, e > n && (e = r);
  } else
    e += t, e < r ? e = n - (r - e - 1) : e > n && (e = r + (e - n - 1));
  return e;
}
function _y(e, t) {
  let r;
  if (t.years != null && t.years !== 0 || t.months != null && t.months !== 0 || t.weeks != null && t.weeks !== 0 || t.days != null && t.days !== 0) {
    let i = Ls($r(e), {
      years: t.years,
      months: t.months,
      weeks: t.weeks,
      days: t.days
    });
    r = sr(i, e.timeZone);
  } else
    r = si(e) - e.offset;
  r += t.milliseconds || 0, r += (t.seconds || 0) * 1e3, r += (t.minutes || 0) * 6e4, r += (t.hours || 0) * 36e5;
  let n = cr(r, e.timeZone);
  return Ve(n, e.calendar);
}
function dC(e, t) {
  return _y(e, $d(t));
}
function fC(e, t, r, n) {
  switch (t) {
    case "hour": {
      let i = 0, a = 23;
      if ((n == null ? void 0 : n.hourCycle) === 12) {
        let p = e.hour >= 12;
        i = p ? 12 : 0, a = p ? 23 : 11;
      }
      let o = $r(e), s = Ve(ha(o, {
        hour: i
      }), new xt()), u = [
        sr(s, e.timeZone, "earlier"),
        sr(s, e.timeZone, "later")
      ].filter((p) => cr(p, e.timeZone).day === s.day)[0], l = Ve(ha(o, {
        hour: a
      }), new xt()), c = [
        sr(l, e.timeZone, "earlier"),
        sr(l, e.timeZone, "later")
      ].filter((p) => cr(p, e.timeZone).day === l.day).pop(), d = si(e) - e.offset, f = Math.floor(d / wi), h = d % wi;
      return d = dr(f, r, Math.floor(u / wi), Math.floor(c / wi), n == null ? void 0 : n.round) * wi + h, Ve(cr(d, e.timeZone), e.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return Ed(e, t, r, n);
    case "era":
    case "year":
    case "month":
    case "day": {
      let i = Dd($r(e), t, r, n), a = sr(i, e.timeZone);
      return Ve(cr(a, e.timeZone), e.calendar);
    }
    default:
      throw new Error("Unsupported field " + t);
  }
}
function hC(e, t, r) {
  let n = $r(e), i = ha(xd(n, t), t);
  if (i.compare(n) === 0) return e;
  let a = sr(i, e.timeZone, r);
  return Ve(cr(a, e.timeZone), e.calendar);
}
function Fy(e) {
  return `${String(e.hour).padStart(2, "0")}:${String(e.minute).padStart(2, "0")}:${String(e.second).padStart(2, "0")}${e.millisecond ? String(e.millisecond / 1e3).slice(1) : ""}`;
}
function Oy(e) {
  let t = Ve(e, new xt());
  return `${String(t.year).padStart(4, "0")}-${String(t.month).padStart(2, "0")}-${String(t.day).padStart(2, "0")}`;
}
function Iy(e) {
  return `${Oy(e)}T${Fy(e)}`;
}
function pC(e) {
  let t = Math.sign(e) < 0 ? "-" : "+";
  e = Math.abs(e);
  let r = Math.floor(e / 36e5), n = e % 36e5 / 6e4;
  return `${t}${String(r).padStart(2, "0")}:${String(n).padStart(2, "0")}`;
}
function mC(e) {
  return `${Iy(e)}${pC(e.offset)}[${e.timeZone}]`;
}
function wd(e) {
  let t = typeof e[0] == "object" ? e.shift() : new xt(), r;
  if (typeof e[0] == "string") r = e.shift();
  else {
    let o = t.getEras();
    r = o[o.length - 1];
  }
  let n = e.shift(), i = e.shift(), a = e.shift();
  return [
    t,
    r,
    n,
    i,
    a
  ];
}
var vC = /* @__PURE__ */ new WeakMap();
class et {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new et(this.calendar, this.era, this.year, this.month, this.day) : new et(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(t) {
    return Ls(this, t);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(t) {
    return ky(this, t);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return xd(this, t);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, r, n) {
    return Dd(this, t, r, n);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(t) {
    return Cy(this, t);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return Oy(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return $y(this, t);
  }
  constructor(...t) {
    Aa(this, vC, {
      writable: !0,
      value: void 0
    });
    let [r, n, i, a, o] = wd(t);
    this.calendar = r, this.era = n, this.year = i, this.month = a, this.day = o, pn(this);
  }
}
var yC = /* @__PURE__ */ new WeakMap();
class Cd {
  /** Returns a copy of this time. */
  copy() {
    return new Cd(this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `Time` with the given duration added to it. */
  add(t) {
    return Ay(this, t);
  }
  /** Returns a new `Time` with the given duration subtracted from it. */
  subtract(t) {
    return cC(this, t);
  }
  /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return ha(this, t);
  }
  /**
  * Returns a new `Time` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, r, n) {
    return Ed(this, t, r, n);
  }
  /** Converts the time to an ISO 8601 formatted string. */
  toString() {
    return Fy(this);
  }
  /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */
  compare(t) {
    return xy(this, t);
  }
  constructor(t = 0, r = 0, n = 0, i = 0) {
    Aa(this, yC, {
      writable: !0,
      value: void 0
    }), this.hour = t, this.minute = r, this.second = n, this.millisecond = i, Ty(this);
  }
}
var gC = /* @__PURE__ */ new WeakMap();
class us {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new us(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond) : new us(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(t) {
    return Ls(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return ky(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return xd(ha(this, t), t);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, r, n) {
    switch (t) {
      case "era":
      case "year":
      case "month":
      case "day":
        return Dd(this, t, r, n);
      default:
        return Ed(this, t, r, n);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(t, r) {
    return Cy(this, t, r);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return Iy(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    let r = $y(this, t);
    return r === 0 ? xy(this, $r(t)) : r;
  }
  constructor(...t) {
    Aa(this, gC, {
      writable: !0,
      value: void 0
    });
    let [r, n, i, a, o] = wd(t);
    this.calendar = r, this.era = n, this.year = i, this.month = a, this.day = o, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, pn(this);
  }
}
var bC = /* @__PURE__ */ new WeakMap();
class pa {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new pa(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond) : new pa(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(t) {
    return _y(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return dC(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t, r) {
    return hC(this, t, r);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, r, n) {
    return fC(this, t, r, n);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return oC(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return mC(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return this.toDate().getTime() - aC(t, this.timeZone).toDate().getTime();
  }
  constructor(...t) {
    Aa(this, bC, {
      writable: !0,
      value: void 0
    });
    let [r, n, i, a, o] = wd(t), s = t.shift(), u = t.shift();
    this.calendar = r, this.era = n, this.year = i, this.month = a, this.day = o, this.timeZone = s, this.offset = u, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, pn(this);
  }
}
const Hn = [
  [
    1868,
    9,
    8
  ],
  [
    1912,
    7,
    30
  ],
  [
    1926,
    12,
    25
  ],
  [
    1989,
    1,
    8
  ],
  [
    2019,
    5,
    1
  ]
], $C = [
  [
    1912,
    7,
    29
  ],
  [
    1926,
    12,
    24
  ],
  [
    1989,
    1,
    7
  ],
  [
    2019,
    4,
    30
  ]
], Do = [
  1867,
  1911,
  1925,
  1988,
  2018
], Ar = [
  "meiji",
  "taisho",
  "showa",
  "heisei",
  "reiwa"
];
function Nh(e) {
  const t = Hn.findIndex(([r, n, i]) => e.year < r || e.year === r && e.month < n || e.year === r && e.month === n && e.day < i);
  return t === -1 ? Hn.length - 1 : t === 0 ? 0 : t - 1;
}
function Mu(e) {
  let t = Do[Ar.indexOf(e.era)];
  if (!t) throw new Error("Unknown era: " + e.era);
  return new et(e.year + t, e.month, e.day);
}
class xC extends xt {
  fromJulianDay(t) {
    let r = super.fromJulianDay(t), n = Nh(r);
    return new et(this, Ar[n], r.year - Do[n], r.month, r.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(Mu(t));
  }
  balanceDate(t) {
    let r = Mu(t), n = Nh(r);
    Ar[n] !== t.era && (t.era = Ar[n], t.year = r.year - Do[n]), this.constrainDate(t);
  }
  constrainDate(t) {
    let r = Ar.indexOf(t.era), n = $C[r];
    if (n != null) {
      let [i, a, o] = n, s = i - Do[r];
      t.year = Math.max(1, Math.min(s, t.year)), t.year === s && (t.month = Math.min(a, t.month), t.month === a && (t.day = Math.min(o, t.day)));
    }
    if (t.year === 1 && r >= 0) {
      let [, i, a] = Hn[r];
      t.month = Math.max(i, t.month), t.month === i && (t.day = Math.max(a, t.day));
    }
  }
  getEras() {
    return Ar;
  }
  getYearsInEra(t) {
    let r = Ar.indexOf(t.era), n = Hn[r], i = Hn[r + 1];
    if (i == null)
      return 9999 - n[0] + 1;
    let a = i[0] - n[0];
    return (t.month < i[1] || t.month === i[1] && t.day < i[2]) && a++, a;
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(Mu(t));
  }
  getMinimumMonthInYear(t) {
    let r = Lh(t);
    return r ? r[1] : 1;
  }
  getMinimumDayInMonth(t) {
    let r = Lh(t);
    return r && t.month === r[1] ? r[2] : 1;
  }
  constructor(...t) {
    super(...t), this.identifier = "japanese";
  }
}
function Lh(e) {
  if (e.year === 1) {
    let t = Ar.indexOf(e.era);
    return Hn[t];
  }
}
const Ry = -543;
class DC extends xt {
  fromJulianDay(t) {
    let r = super.fromJulianDay(t), n = Fa(r.era, r.year);
    return new et(this, n - Ry, r.month, r.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(Vh(t));
  }
  getEras() {
    return [
      "BE"
    ];
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(Vh(t));
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "buddhist";
  }
}
function Vh(e) {
  let [t, r] = Ms(e.year + Ry);
  return new et(t, r, e.month, e.day);
}
const ls = 1911;
function By(e) {
  return e.era === "minguo" ? e.year + ls : 1 - e.year + ls;
}
function jh(e) {
  let t = e - ls;
  return t > 0 ? [
    "minguo",
    t
  ] : [
    "before_minguo",
    1 - t
  ];
}
class EC extends xt {
  fromJulianDay(t) {
    let r = super.fromJulianDay(t), n = Fa(r.era, r.year), [i, a] = jh(n);
    return new et(this, i, a, r.month, r.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(zh(t));
  }
  getEras() {
    return [
      "before_minguo",
      "minguo"
    ];
  }
  balanceDate(t) {
    let [r, n] = jh(By(t));
    t.era = r, t.year = n;
  }
  isInverseEra(t) {
    return t.era === "before_minguo";
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(zh(t));
  }
  getYearsInEra(t) {
    return t.era === "before_minguo" ? 9999 : 9999 - ls;
  }
  constructor(...t) {
    super(...t), this.identifier = "roc";
  }
}
function zh(e) {
  let [t, r] = Ms(By(e));
  return new et(t, r, e.month, e.day);
}
const Kh = 1948320, Uh = [
  0,
  31,
  62,
  93,
  124,
  155,
  186,
  216,
  246,
  276,
  306,
  336
  // Esfand
];
class wC {
  fromJulianDay(t) {
    let r = t - Kh, n = 1 + Math.floor((33 * r + 3) / 12053), i = 365 * (n - 1) + Math.floor((8 * n + 21) / 33), a = r - i, o = a < 216 ? Math.floor(a / 31) : Math.floor((a - 6) / 30), s = a - Uh[o] + 1;
    return new et(this, n, o + 1, s);
  }
  toJulianDay(t) {
    let r = Kh - 1 + 365 * (t.year - 1) + Math.floor((8 * t.year + 21) / 33);
    return r += Uh[t.month - 1], r += t.day, r;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInMonth(t) {
    return t.month <= 6 ? 31 : t.month <= 11 || qn(25 * t.year + 11, 33) < 8 ? 30 : 29;
  }
  getEras() {
    return [
      "AP"
    ];
  }
  getYearsInEra() {
    return 9377;
  }
  constructor() {
    this.identifier = "persian";
  }
}
const Nu = 78, qh = 80;
class CC extends xt {
  fromJulianDay(t) {
    let r = super.fromJulianDay(t), n = r.year - Nu, i = t - en(r.era, r.year, 1, 1), a;
    i < qh ? (n--, a = Or(r.year - 1) ? 31 : 30, i += a + 155 + 90 + 10) : (a = Or(r.year) ? 31 : 30, i -= qh);
    let o, s;
    if (i < a)
      o = 1, s = i + 1;
    else {
      let u = i - a;
      u < 155 ? (o = Math.floor(u / 31) + 2, s = u % 31 + 1) : (u -= 155, o = Math.floor(u / 30) + 7, s = u % 30 + 1);
    }
    return new et(this, n, o, s);
  }
  toJulianDay(t) {
    let r = t.year + Nu, [n, i] = Ms(r), a, o;
    return Or(i) ? (a = 31, o = en(n, i, 3, 21)) : (a = 30, o = en(n, i, 3, 22)), t.month === 1 ? o + t.day - 1 : (o += a + Math.min(t.month - 2, 5) * 31, t.month >= 8 && (o += (t.month - 7) * 30), o += t.day - 1, o);
  }
  getDaysInMonth(t) {
    return t.month === 1 && Or(t.year + Nu) || t.month >= 2 && t.month <= 6 ? 31 : 30;
  }
  getYearsInEra() {
    return 9919;
  }
  getEras() {
    return [
      "saka"
    ];
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "indian";
  }
}
const cs = 1948440, Hh = 1948439, Tt = 1300, Cn = 1600, SC = 460322;
function ds(e, t, r, n) {
  return n + Math.ceil(29.5 * (r - 1)) + (t - 1) * 354 + Math.floor((3 + 11 * t) / 30) + e - 1;
}
function My(e, t, r) {
  let n = Math.floor((30 * (r - t) + 10646) / 10631), i = Math.min(12, Math.ceil((r - (29 + ds(t, n, 1, 1))) / 29.5) + 1), a = r - ds(t, n, i, 1) + 1;
  return new et(e, n, i, a);
}
function Wh(e) {
  return (14 + 11 * e) % 30 < 11;
}
class Sd {
  fromJulianDay(t) {
    return My(this, cs, t);
  }
  toJulianDay(t) {
    return ds(cs, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    let r = 29 + t.month % 2;
    return t.month === 12 && Wh(t.year) && r++, r;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInYear(t) {
    return Wh(t.year) ? 355 : 354;
  }
  getYearsInEra() {
    return 9665;
  }
  getEras() {
    return [
      "AH"
    ];
  }
  constructor() {
    this.identifier = "islamic-civil";
  }
}
class kC extends Sd {
  fromJulianDay(t) {
    return My(this, Hh, t);
  }
  toJulianDay(t) {
    return ds(Hh, t.year, t.month, t.day);
  }
  constructor(...t) {
    super(...t), this.identifier = "islamic-tbla";
  }
}
const TC = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
let Xl, Wn;
function Eo(e) {
  return SC + Wn[e - Tt];
}
function Mi(e, t) {
  let r = e - Tt, n = 1 << 11 - (t - 1);
  return Xl[r] & n ? 30 : 29;
}
function Qh(e, t) {
  let r = Eo(e);
  for (let n = 1; n < t; n++) r += Mi(e, n);
  return r;
}
function Gh(e) {
  return Wn[e + 1 - Tt] - Wn[e - Tt];
}
class PC extends Sd {
  fromJulianDay(t) {
    let r = t - cs, n = Eo(Tt), i = Eo(Cn);
    if (r < n || r > i) return super.fromJulianDay(t);
    {
      let a = Tt - 1, o = 1, s = 1;
      for (; s > 0; ) {
        a++, s = r - Eo(a) + 1;
        let u = Gh(a);
        if (s === u) {
          o = 12;
          break;
        } else if (s < u) {
          let l = Mi(a, o);
          for (o = 1; s > l; )
            s -= l, o++, l = Mi(a, o);
          break;
        }
      }
      return new et(this, a, o, r - Qh(a, o) + 1);
    }
  }
  toJulianDay(t) {
    return t.year < Tt || t.year > Cn ? super.toJulianDay(t) : cs + Qh(t.year, t.month) + (t.day - 1);
  }
  getDaysInMonth(t) {
    return t.year < Tt || t.year > Cn ? super.getDaysInMonth(t) : Mi(t.year, t.month);
  }
  getDaysInYear(t) {
    return t.year < Tt || t.year > Cn ? super.getDaysInYear(t) : Gh(t.year);
  }
  constructor() {
    if (super(), this.identifier = "islamic-umalqura", Xl || (Xl = new Uint16Array(Uint8Array.from(atob(TC), (t) => t.charCodeAt(0)).buffer)), !Wn) {
      Wn = new Uint32Array(Cn - Tt + 1);
      let t = 0;
      for (let r = Tt; r <= Cn; r++) {
        Wn[r - Tt] = t;
        for (let n = 1; n <= 12; n++) t += Mi(r, n);
      }
    }
  }
}
const Zh = 347997, Ny = 1080, Ly = 24 * Ny, AC = 29, _C = 12 * Ny + 793, FC = AC * Ly + _C;
function Gr(e) {
  return qn(e * 7 + 1, 19) < 7;
}
function wo(e) {
  let t = Math.floor((235 * e - 234) / 19), r = 12084 + 13753 * t, n = t * 29 + Math.floor(r / 25920);
  return qn(3 * (n + 1), 7) < 3 && (n += 1), n;
}
function OC(e) {
  let t = wo(e - 1), r = wo(e);
  return wo(e + 1) - r === 356 ? 2 : r - t === 382 ? 1 : 0;
}
function Wi(e) {
  return wo(e) + OC(e);
}
function Vy(e) {
  return Wi(e + 1) - Wi(e);
}
function IC(e) {
  let t = Vy(e);
  switch (t > 380 && (t -= 30), t) {
    case 353:
      return 0;
    case 354:
      return 1;
    case 355:
      return 2;
  }
}
function no(e, t) {
  if (t >= 6 && !Gr(e) && t++, t === 4 || t === 7 || t === 9 || t === 11 || t === 13) return 29;
  let r = IC(e);
  return t === 2 ? r === 2 ? 30 : 29 : t === 3 ? r === 0 ? 29 : 30 : t === 6 ? Gr(e) ? 30 : 0 : 30;
}
class RC {
  fromJulianDay(t) {
    let r = t - Zh, n = r * Ly / FC, i = Math.floor((19 * n + 234) / 235) + 1, a = Wi(i), o = Math.floor(r - a);
    for (; o < 1; )
      i--, a = Wi(i), o = Math.floor(r - a);
    let s = 1, u = 0;
    for (; u < o; )
      u += no(i, s), s++;
    s--, u -= no(i, s);
    let l = o - u;
    return new et(this, i, s, l);
  }
  toJulianDay(t) {
    let r = Wi(t.year);
    for (let n = 1; n < t.month; n++) r += no(t.year, n);
    return r + t.day + Zh;
  }
  getDaysInMonth(t) {
    return no(t.year, t.month);
  }
  getMonthsInYear(t) {
    return Gr(t.year) ? 13 : 12;
  }
  getDaysInYear(t) {
    return Vy(t.year);
  }
  getYearsInEra() {
    return 9999;
  }
  getEras() {
    return [
      "AM"
    ];
  }
  balanceYearMonth(t, r) {
    r.year !== t.year && (Gr(r.year) && !Gr(t.year) && r.month > 6 ? t.month-- : !Gr(r.year) && Gr(t.year) && r.month > 6 && t.month++);
  }
  constructor() {
    this.identifier = "hebrew";
  }
}
const ec = 1723856, Yh = 1824665, tc = 5500;
function fs(e, t, r, n) {
  return e + 365 * t + Math.floor(t / 4) + 30 * (r - 1) + n - 1;
}
function kd(e, t) {
  let r = Math.floor(4 * (t - e) / 1461), n = 1 + Math.floor((t - fs(e, r, 1, 1)) / 30), i = t + 1 - fs(e, r, n, 1);
  return [
    r,
    n,
    i
  ];
}
function jy(e) {
  return Math.floor(e % 4 / 3);
}
function zy(e, t) {
  return t % 13 !== 0 ? 30 : jy(e) + 5;
}
class Td {
  fromJulianDay(t) {
    let [r, n, i] = kd(ec, t), a = "AM";
    return r <= 0 && (a = "AA", r += tc), new et(this, a, r, n, i);
  }
  toJulianDay(t) {
    let r = t.year;
    return t.era === "AA" && (r -= tc), fs(ec, r, t.month, t.day);
  }
  getDaysInMonth(t) {
    return zy(t.year, t.month);
  }
  getMonthsInYear() {
    return 13;
  }
  getDaysInYear(t) {
    return 365 + jy(t.year);
  }
  getYearsInEra(t) {
    return t.era === "AA" ? 9999 : 9991;
  }
  getEras() {
    return [
      "AA",
      "AM"
    ];
  }
  constructor() {
    this.identifier = "ethiopic";
  }
}
class BC extends Td {
  fromJulianDay(t) {
    let [r, n, i] = kd(ec, t);
    return r += tc, new et(this, "AA", r, n, i);
  }
  getEras() {
    return [
      "AA"
    ];
  }
  getYearsInEra() {
    return 9999;
  }
  constructor(...t) {
    super(...t), this.identifier = "ethioaa";
  }
}
class MC extends Td {
  fromJulianDay(t) {
    let [r, n, i] = kd(Yh, t), a = "CE";
    return r <= 0 && (a = "BCE", r = 1 - r), new et(this, a, r, n, i);
  }
  toJulianDay(t) {
    let r = t.year;
    return t.era === "BCE" && (r = 1 - r), fs(Yh, r, t.month, t.day);
  }
  getDaysInMonth(t) {
    let r = t.year;
    return t.era === "BCE" && (r = 1 - r), zy(r, t.month);
  }
  isInverseEra(t) {
    return t.era === "BCE";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BCE" ? "CE" : "BCE", t.year = 1 - t.year);
  }
  getEras() {
    return [
      "BCE",
      "CE"
    ];
  }
  getYearsInEra(t) {
    return t.era === "BCE" ? 9999 : 9715;
  }
  constructor(...t) {
    super(...t), this.identifier = "coptic";
  }
}
function Ky(e) {
  switch (e) {
    case "buddhist":
      return new DC();
    case "ethiopic":
      return new Td();
    case "ethioaa":
      return new BC();
    case "coptic":
      return new MC();
    case "hebrew":
      return new RC();
    case "indian":
      return new CC();
    case "islamic-civil":
      return new Sd();
    case "islamic-tbla":
      return new kC();
    case "islamic-umalqura":
      return new PC();
    case "japanese":
      return new xC();
    case "persian":
      return new wC();
    case "roc":
      return new EC();
    case "gregory":
    default:
      return new xt();
  }
}
let Lu = /* @__PURE__ */ new Map();
class hr {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(t) {
    return this.formatter.format(t);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(t) {
    return this.formatter.formatToParts(t);
  }
  /** Formats a date range as a string. */
  formatRange(t, r) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(t, r);
    if (r < t) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(t)} – ${this.formatter.format(r)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(t, r) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(t, r);
    if (r < t) throw new RangeError("End date must be >= start date");
    let n = this.formatter.formatToParts(t), i = this.formatter.formatToParts(r);
    return [
      ...n.map((a) => ({
        ...a,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...i.map((a) => ({
        ...a,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.formatter.resolvedOptions();
    return VC() && (this.resolvedHourCycle || (this.resolvedHourCycle = jC(t.locale, this.options)), t.hourCycle = this.resolvedHourCycle, t.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), t.calendar === "ethiopic-amete-alem" && (t.calendar = "ethioaa"), t;
  }
  constructor(t, r = {}) {
    this.formatter = Uy(t, r), this.options = r;
  }
}
const NC = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function Uy(e, t = {}) {
  if (typeof t.hour12 == "boolean" && LC()) {
    t = {
      ...t
    };
    let i = NC[String(t.hour12)][e.split("-")[0]], a = t.hour12 ? "h12" : "h23";
    t.hourCycle = i ?? a, delete t.hour12;
  }
  let r = e + (t ? Object.entries(t).sort((i, a) => i[0] < a[0] ? -1 : 1).join() : "");
  if (Lu.has(r)) return Lu.get(r);
  let n = new Intl.DateTimeFormat(e, t);
  return Lu.set(r, n), n;
}
let Vu = null;
function LC() {
  return Vu == null && (Vu = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), Vu;
}
let ju = null;
function VC() {
  return ju == null && (ju = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), ju;
}
function jC(e, t) {
  if (!t.timeStyle && !t.hour) return;
  e = e.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), e += (e.includes("-u-") ? "" : "-u") + "-nu-latn";
  let r = Uy(e, {
    ...t,
    timeZone: void 0
    // use local timezone
  }), n = parseInt(r.formatToParts(new Date(2020, 2, 3, 0)).find((a) => a.type === "hour").value, 10), i = parseInt(r.formatToParts(new Date(2020, 2, 3, 23)).find((a) => a.type === "hour").value, 10);
  if (n === 0 && i === 23) return "h23";
  if (n === 24 && i === 23) return "h24";
  if (n === 0 && i === 11) return "h11";
  if (n === 12 && i === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
function Wt(e) {
  e = ey(e ?? {}, zC);
  let { locale: t } = lt();
  return G(() => new hr(t, e), [
    t,
    e
  ]);
}
function zC(e, t) {
  if (e === t) return !0;
  let r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length) return !1;
  for (let i of r)
    if (t[i] !== e[i]) return !1;
  return !0;
}
let zu = /* @__PURE__ */ new Map(), rc = !1;
try {
  rc = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
let hs = !1;
try {
  hs = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
const qy = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
class KC {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(t) {
    let r = "";
    if (!rc && this.options.signDisplay != null ? r = qC(this.numberFormatter, this.options.signDisplay, t) : r = this.numberFormatter.format(t), this.options.style === "unit" && !hs) {
      var n;
      let { unit: i, unitDisplay: a = "short", locale: o } = this.resolvedOptions();
      if (!i) return r;
      let s = (n = qy[i]) === null || n === void 0 ? void 0 : n[a];
      r += s[o] || s.default;
    }
    return r;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(t) {
    return this.numberFormatter.formatToParts(t);
  }
  /** Formats a number range as a string. */
  formatRange(t, r) {
    if (typeof this.numberFormatter.formatRange == "function")
      return this.numberFormatter.formatRange(t, r);
    if (r < t) throw new RangeError("End date must be >= start date");
    return `${this.format(t)} – ${this.format(r)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(t, r) {
    if (typeof this.numberFormatter.formatRangeToParts == "function")
      return this.numberFormatter.formatRangeToParts(t, r);
    if (r < t) throw new RangeError("End date must be >= start date");
    let n = this.numberFormatter.formatToParts(t), i = this.numberFormatter.formatToParts(r);
    return [
      ...n.map((a) => ({
        ...a,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...i.map((a) => ({
        ...a,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.numberFormatter.resolvedOptions();
    return !rc && this.options.signDisplay != null && (t = {
      ...t,
      signDisplay: this.options.signDisplay
    }), !hs && this.options.style === "unit" && (t = {
      ...t,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    }), t;
  }
  constructor(t, r = {}) {
    this.numberFormatter = UC(t, r), this.options = r;
  }
}
function UC(e, t = {}) {
  let { numberingSystem: r } = t;
  if (r && e.includes("-nu-") && (e.includes("-u-") || (e += "-u-"), e += `-nu-${r}`), t.style === "unit" && !hs) {
    var n;
    let { unit: o, unitDisplay: s = "short" } = t;
    if (!o) throw new Error('unit option must be provided with style: "unit"');
    if (!(!((n = qy[o]) === null || n === void 0) && n[s])) throw new Error(`Unsupported unit ${o} with unitDisplay = ${s}`);
    t = {
      ...t,
      style: "decimal"
    };
  }
  let i = e + (t ? Object.entries(t).sort((o, s) => o[0] < s[0] ? -1 : 1).join() : "");
  if (zu.has(i)) return zu.get(i);
  let a = new Intl.NumberFormat(e, t);
  return zu.set(i, a), a;
}
function qC(e, t, r) {
  if (t === "auto") return e.format(r);
  if (t === "never") return e.format(Math.abs(r));
  {
    let n = !1;
    if (t === "always" ? n = r > 0 || Object.is(r, 0) : t === "exceptZero" && (Object.is(r, -0) || Object.is(r, 0) ? r = Math.abs(r) : n = r > 0), n) {
      let i = e.format(-r), a = e.format(r), o = i.replace(a, "").replace(/\u200e|\u061C/, "");
      return [
        ...o
      ].length !== 1 && console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case"), i.replace(a, "!!!").replace(o, "+").replace("!!!", a);
    } else return e.format(r);
  }
}
const HC = new RegExp("^.*\\(.*\\).*$"), WC = [
  "latn",
  "arab",
  "hanidec"
];
class Hy {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(t) {
    return Ku(this.locale, this.options, t).parse(t);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(t, r, n) {
    return Ku(this.locale, this.options, t).isValidPartialNumber(t, r, n);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(t) {
    return Ku(this.locale, this.options, t).options.numberingSystem;
  }
  constructor(t, r = {}) {
    this.locale = t, this.options = r;
  }
}
const Jh = /* @__PURE__ */ new Map();
function Ku(e, t, r) {
  let n = Xh(e, t);
  if (!e.includes("-nu-") && !n.isValidPartialNumber(r)) {
    for (let i of WC) if (i !== n.options.numberingSystem) {
      let a = Xh(e + (e.includes("-u-") ? "-nu-" : "-u-nu-") + i, t);
      if (a.isValidPartialNumber(r)) return a;
    }
  }
  return n;
}
function Xh(e, t) {
  let r = e + (t ? Object.entries(t).sort((i, a) => i[0] < a[0] ? -1 : 1).join() : ""), n = Jh.get(r);
  return n || (n = new QC(e, t), Jh.set(r, n)), n;
}
class QC {
  parse(t) {
    let r = this.sanitize(t);
    if (this.symbols.group && (r = io(r, this.symbols.group, "")), this.symbols.decimal && (r = r.replace(this.symbols.decimal, ".")), this.symbols.minusSign && (r = r.replace(this.symbols.minusSign, "-")), r = r.replace(this.symbols.numeral, this.symbols.index), this.options.style === "percent") {
      let o = r.indexOf("-");
      r = r.replace("-", "");
      let s = r.indexOf(".");
      s === -1 && (s = r.length), r = r.replace(".", ""), s - 2 === 0 ? r = `0.${r}` : s - 2 === -1 ? r = `0.0${r}` : s - 2 === -2 ? r = "0.00" : r = `${r.slice(0, s - 2)}.${r.slice(s - 2)}`, o > -1 && (r = `-${r}`);
    }
    let n = r ? +r : NaN;
    if (isNaN(n)) return NaN;
    if (this.options.style === "percent") {
      var i, a;
      let o = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((i = this.options.minimumFractionDigits) !== null && i !== void 0 ? i : 0) + 2, 20),
        maximumFractionDigits: Math.min(((a = this.options.maximumFractionDigits) !== null && a !== void 0 ? a : 0) + 2, 20)
      };
      return new Hy(this.locale, o).parse(new KC(this.locale, o).format(n));
    }
    return this.options.currencySign === "accounting" && HC.test(t) && (n = -1 * n), n;
  }
  sanitize(t) {
    return t = t.replace(this.symbols.literals, ""), this.symbols.minusSign && (t = t.replace("-", this.symbols.minusSign)), this.options.numberingSystem === "arab" && (this.symbols.decimal && (t = t.replace(",", this.symbols.decimal), t = t.replace("،", this.symbols.decimal)), this.symbols.group && (t = io(t, ".", this.symbols.group))), this.options.locale === "fr-FR" && (t = io(t, ".", " ")), t;
  }
  isValidPartialNumber(t, r = -1 / 0, n = 1 / 0) {
    return t = this.sanitize(t), this.symbols.minusSign && t.startsWith(this.symbols.minusSign) && r < 0 ? t = t.slice(this.symbols.minusSign.length) : this.symbols.plusSign && t.startsWith(this.symbols.plusSign) && n > 0 && (t = t.slice(this.symbols.plusSign.length)), this.symbols.group && t.startsWith(this.symbols.group) || this.symbols.decimal && t.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0 ? !1 : (this.symbols.group && (t = io(t, this.symbols.group, "")), t = t.replace(this.symbols.numeral, ""), this.symbols.decimal && (t = t.replace(this.symbols.decimal, "")), t.length === 0);
  }
  constructor(t, r = {}) {
    this.locale = t, this.formatter = new Intl.NumberFormat(t, r), this.options = this.formatter.resolvedOptions(), this.symbols = ZC(t, this.formatter, this.options, r);
    var n, i;
    this.options.style === "percent" && (((n = this.options.minimumFractionDigits) !== null && n !== void 0 ? n : 0) > 18 || ((i = this.options.maximumFractionDigits) !== null && i !== void 0 ? i : 0) > 18) && console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
}
const ep = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]), GC = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function ZC(e, t, r, n) {
  var i, a, o, s;
  let u = new Intl.NumberFormat(e, {
    ...r,
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21
  }), l = u.formatToParts(-10000.111), c = u.formatToParts(10000.111), d = GC.map((w) => u.formatToParts(w));
  var f;
  let h = (f = (i = l.find((w) => w.type === "minusSign")) === null || i === void 0 ? void 0 : i.value) !== null && f !== void 0 ? f : "-", p = (a = c.find((w) => w.type === "plusSign")) === null || a === void 0 ? void 0 : a.value;
  !p && ((n == null ? void 0 : n.signDisplay) === "exceptZero" || (n == null ? void 0 : n.signDisplay) === "always") && (p = "+");
  let g = (o = new Intl.NumberFormat(e, {
    ...r,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3).find((w) => w.type === "decimal")) === null || o === void 0 ? void 0 : o.value, $ = (s = l.find((w) => w.type === "group")) === null || s === void 0 ? void 0 : s.value, m = l.filter((w) => !ep.has(w.type)).map((w) => tp(w.value)), b = d.flatMap((w) => w.filter((E) => !ep.has(E.type)).map((E) => tp(E.value))), D = [
    .../* @__PURE__ */ new Set([
      ...m,
      ...b
    ])
  ].sort((w, E) => E.length - w.length), S = D.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${D.join("|")}|[\\p{White_Space}]`, "gu"), T = [
    ...new Intl.NumberFormat(r.locale, {
      useGrouping: !1
    }).format(9876543210)
  ].reverse(), R = new Map(T.map((w, E) => [
    w,
    E
  ])), y = new RegExp(`[${T.join("")}]`, "g");
  return {
    minusSign: h,
    plusSign: p,
    decimal: g,
    group: $,
    literals: S,
    numeral: y,
    index: (w) => String(R.get(w))
  };
}
function io(e, t, r) {
  return e.replaceAll ? e.replaceAll(t, r) : e.split(t).join(r);
}
function tp(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
let Uu = /* @__PURE__ */ new Map();
function Vs(e) {
  let { locale: t } = lt(), r = t + (e ? Object.entries(e).sort((i, a) => i[0] < a[0] ? -1 : 1).join() : "");
  if (Uu.has(r)) return Uu.get(r);
  let n = new Intl.Collator(t, e);
  return Uu.set(r, n), n;
}
function Wy(e) {
  let t = Vs({
    usage: "search",
    ...e
  }), r = ye((a, o) => o.length === 0 ? !0 : (a = a.normalize("NFC"), o = o.normalize("NFC"), t.compare(a.slice(0, o.length), o) === 0), [
    t
  ]), n = ye((a, o) => o.length === 0 ? !0 : (a = a.normalize("NFC"), o = o.normalize("NFC"), t.compare(a.slice(-o.length), o) === 0), [
    t
  ]), i = ye((a, o) => {
    if (o.length === 0) return !0;
    a = a.normalize("NFC"), o = o.normalize("NFC");
    let s = 0, u = o.length;
    for (; s + u <= a.length; s++) {
      let l = a.slice(s, s + u);
      if (t.compare(o, l) === 0) return !0;
    }
    return !1;
  }, [
    t
  ]);
  return G(() => ({
    startsWith: r,
    endsWith: n,
    contains: i
  }), [
    r,
    n,
    i
  ]);
}
function YC(e, t) {
  let {
    elementType: r = "button",
    isDisabled: n,
    onPress: i,
    onPressStart: a,
    onPressEnd: o,
    onPressUp: s,
    onPressChange: u,
    preventFocusOnPress: l,
    allowFocusWhenDisabled: c,
    // @ts-ignore
    onClick: d,
    href: f,
    target: h,
    rel: p,
    type: v = "button"
  } = e, g;
  r === "button" ? g = {
    type: v,
    disabled: n
  } : g = {
    role: "button",
    tabIndex: n ? void 0 : 0,
    href: r === "a" && n ? void 0 : f,
    target: r === "a" ? h : void 0,
    type: r === "input" ? v : void 0,
    disabled: r === "input" ? n : void 0,
    "aria-disabled": !n || r === "input" ? void 0 : n,
    rel: r === "a" ? p : void 0
  };
  let { pressProps: $, isPressed: m } = _a({
    onPressStart: a,
    onPressEnd: o,
    onPressChange: u,
    onPress: i,
    onPressUp: s,
    isDisabled: n,
    preventFocusOnPress: l,
    ref: t
  }), { focusableProps: b } = py(e, t);
  c && (b.tabIndex = n ? -1 : b.tabIndex);
  let D = ge(b, $, Me(e, {
    labelable: !0
  }));
  return {
    isPressed: m,
    buttonProps: ge(g, D, {
      "aria-haspopup": e["aria-haspopup"],
      "aria-expanded": e["aria-expanded"],
      "aria-controls": e["aria-controls"],
      "aria-pressed": e["aria-pressed"],
      onClick: (S) => {
        d && (d(S), console.warn("onClick is deprecated, please use onPress"));
      }
    })
  };
}
var Qy = {};
Qy = {
  dateRange: (e) => `${e.startDate} إلى ${e.endDate}`,
  dateSelected: (e) => `${e.date} المحدد`,
  finishRangeSelectionPrompt: "انقر لإنهاء عملية تحديد نطاق التاريخ",
  maximumDate: "آخر تاريخ متاح",
  minimumDate: "أول تاريخ متاح",
  next: "التالي",
  previous: "السابق",
  selectedDateDescription: (e) => `تاريخ محدد: ${e.date}`,
  selectedRangeDescription: (e) => `المدى الزمني المحدد: ${e.dateRange}`,
  startRangeSelectionPrompt: "انقر لبدء عملية تحديد نطاق التاريخ",
  todayDate: (e) => `اليوم، ${e.date}`,
  todayDateSelected: (e) => `اليوم، ${e.date} محدد`
};
var Gy = {};
Gy = {
  dateRange: (e) => `${e.startDate} до ${e.endDate}`,
  dateSelected: (e) => `Избрано е ${e.date}`,
  finishRangeSelectionPrompt: "Натиснете, за да довършите избора на времеви интервал",
  maximumDate: "Последна налична дата",
  minimumDate: "Първа налична дата",
  next: "Напред",
  previous: "Назад",
  selectedDateDescription: (e) => `Избрана дата: ${e.date}`,
  selectedRangeDescription: (e) => `Избран диапазон: ${e.dateRange}`,
  startRangeSelectionPrompt: "Натиснете, за да пристъпите към избора на времеви интервал",
  todayDate: (e) => `Днес, ${e.date}`,
  todayDateSelected: (e) => `Днес, ${e.date} са избрани`
};
var Zy = {};
Zy = {
  dateRange: (e) => `${e.startDate} až ${e.endDate}`,
  dateSelected: (e) => `Vybráno ${e.date}`,
  finishRangeSelectionPrompt: "Kliknutím dokončíte výběr rozsahu dat",
  maximumDate: "Poslední dostupné datum",
  minimumDate: "První dostupné datum",
  next: "Další",
  previous: "Předchozí",
  selectedDateDescription: (e) => `Vybrané datum: ${e.date}`,
  selectedRangeDescription: (e) => `Vybrané období: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kliknutím zahájíte výběr rozsahu dat",
  todayDate: (e) => `Dnes, ${e.date}`,
  todayDateSelected: (e) => `Dnes, vybráno ${e.date}`
};
var Yy = {};
Yy = {
  dateRange: (e) => `${e.startDate} til ${e.endDate}`,
  dateSelected: (e) => `${e.date} valgt`,
  finishRangeSelectionPrompt: "Klik for at fuldføre valg af datoområde",
  maximumDate: "Sidste ledige dato",
  minimumDate: "Første ledige dato",
  next: "Næste",
  previous: "Forrige",
  selectedDateDescription: (e) => `Valgt dato: ${e.date}`,
  selectedRangeDescription: (e) => `Valgt interval: ${e.dateRange}`,
  startRangeSelectionPrompt: "Klik for at starte valg af datoområde",
  todayDate: (e) => `I dag, ${e.date}`,
  todayDateSelected: (e) => `I dag, ${e.date} valgt`
};
var Jy = {};
Jy = {
  dateRange: (e) => `${e.startDate} bis ${e.endDate}`,
  dateSelected: (e) => `${e.date} ausgewählt`,
  finishRangeSelectionPrompt: "Klicken, um die Auswahl des Datumsbereichs zu beenden",
  maximumDate: "Letztes verfügbares Datum",
  minimumDate: "Erstes verfügbares Datum",
  next: "Weiter",
  previous: "Zurück",
  selectedDateDescription: (e) => `Ausgewähltes Datum: ${e.date}`,
  selectedRangeDescription: (e) => `Ausgewählter Bereich: ${e.dateRange}`,
  startRangeSelectionPrompt: "Klicken, um die Auswahl des Datumsbereichs zu beginnen",
  todayDate: (e) => `Heute, ${e.date}`,
  todayDateSelected: (e) => `Heute, ${e.date} ausgewählt`
};
var Xy = {};
Xy = {
  dateRange: (e) => `${e.startDate} έως ${e.endDate}`,
  dateSelected: (e) => `Επιλέχθηκε ${e.date}`,
  finishRangeSelectionPrompt: "Κάντε κλικ για να ολοκληρώσετε την επιλογή εύρους ημερομηνιών",
  maximumDate: "Τελευταία διαθέσιμη ημερομηνία",
  minimumDate: "Πρώτη διαθέσιμη ημερομηνία",
  next: "Επόμενο",
  previous: "Προηγούμενο",
  selectedDateDescription: (e) => `Επιλεγμένη ημερομηνία: ${e.date}`,
  selectedRangeDescription: (e) => `Επιλεγμένο εύρος: ${e.dateRange}`,
  startRangeSelectionPrompt: "Κάντε κλικ για να ξεκινήσετε την επιλογή εύρους ημερομηνιών",
  todayDate: (e) => `Σήμερα, ${e.date}`,
  todayDateSelected: (e) => `Σήμερα, επιλέχτηκε ${e.date}`
};
var eg = {};
eg = {
  previous: "Previous",
  next: "Next",
  selectedDateDescription: (e) => `Selected Date: ${e.date}`,
  selectedRangeDescription: (e) => `Selected Range: ${e.dateRange}`,
  todayDate: (e) => `Today, ${e.date}`,
  todayDateSelected: (e) => `Today, ${e.date} selected`,
  dateSelected: (e) => `${e.date} selected`,
  startRangeSelectionPrompt: "Click to start selecting date range",
  finishRangeSelectionPrompt: "Click to finish selecting date range",
  minimumDate: "First available date",
  maximumDate: "Last available date",
  dateRange: (e) => `${e.startDate} to ${e.endDate}`
};
var tg = {};
tg = {
  dateRange: (e) => `${e.startDate} a ${e.endDate}`,
  dateSelected: (e) => `${e.date} seleccionado`,
  finishRangeSelectionPrompt: "Haga clic para terminar de seleccionar rango de fechas",
  maximumDate: "Última fecha disponible",
  minimumDate: "Primera fecha disponible",
  next: "Siguiente",
  previous: "Anterior",
  selectedDateDescription: (e) => `Fecha seleccionada: ${e.date}`,
  selectedRangeDescription: (e) => `Intervalo seleccionado: ${e.dateRange}`,
  startRangeSelectionPrompt: "Haga clic para comenzar a seleccionar un rango de fechas",
  todayDate: (e) => `Hoy, ${e.date}`,
  todayDateSelected: (e) => `Hoy, ${e.date} seleccionado`
};
var rg = {};
rg = {
  dateRange: (e) => `${e.startDate} kuni ${e.endDate}`,
  dateSelected: (e) => `${e.date} valitud`,
  finishRangeSelectionPrompt: "Klõpsake kuupäevavahemiku valimise lõpetamiseks",
  maximumDate: "Viimane saadaolev kuupäev",
  minimumDate: "Esimene saadaolev kuupäev",
  next: "Järgmine",
  previous: "Eelmine",
  selectedDateDescription: (e) => `Valitud kuupäev: ${e.date}`,
  selectedRangeDescription: (e) => `Valitud vahemik: ${e.dateRange}`,
  startRangeSelectionPrompt: "Klõpsake kuupäevavahemiku valimiseks",
  todayDate: (e) => `Täna, ${e.date}`,
  todayDateSelected: (e) => `Täna, ${e.date} valitud`
};
var ng = {};
ng = {
  dateRange: (e) => `${e.startDate} – ${e.endDate}`,
  dateSelected: (e) => `${e.date} valittu`,
  finishRangeSelectionPrompt: "Lopeta päivämääräalueen valinta napsauttamalla tätä.",
  maximumDate: "Viimeinen varattavissa oleva päivämäärä",
  minimumDate: "Ensimmäinen varattavissa oleva päivämäärä",
  next: "Seuraava",
  previous: "Edellinen",
  selectedDateDescription: (e) => `Valittu päivämäärä: ${e.date}`,
  selectedRangeDescription: (e) => `Valittu aikaväli: ${e.dateRange}`,
  startRangeSelectionPrompt: "Aloita päivämääräalueen valinta napsauttamalla tätä.",
  todayDate: (e) => `Tänään, ${e.date}`,
  todayDateSelected: (e) => `Tänään, ${e.date} valittu`
};
var ig = {};
ig = {
  dateRange: (e) => `${e.startDate} à ${e.endDate}`,
  dateSelected: (e) => `${e.date} sélectionné`,
  finishRangeSelectionPrompt: "Cliquer pour finir de sélectionner la plage de dates",
  maximumDate: "Dernière date disponible",
  minimumDate: "Première date disponible",
  next: "Suivant",
  previous: "Précédent",
  selectedDateDescription: (e) => `Date sélectionnée : ${e.date}`,
  selectedRangeDescription: (e) => `Plage sélectionnée : ${e.dateRange}`,
  startRangeSelectionPrompt: "Cliquer pour commencer à sélectionner la plage de dates",
  todayDate: (e) => `Aujourd'hui, ${e.date}`,
  todayDateSelected: (e) => `Aujourd’hui, ${e.date} sélectionné`
};
var ag = {};
ag = {
  dateRange: (e) => `${e.startDate} עד ${e.endDate}`,
  dateSelected: (e) => `${e.date} נבחר`,
  finishRangeSelectionPrompt: "חץ כדי לסיים את בחירת טווח התאריכים",
  maximumDate: "תאריך פנוי אחרון",
  minimumDate: "תאריך פנוי ראשון",
  next: "הבא",
  previous: "הקודם",
  selectedDateDescription: (e) => `תאריך נבחר: ${e.date}`,
  selectedRangeDescription: (e) => `טווח נבחר: ${e.dateRange}`,
  startRangeSelectionPrompt: "לחץ כדי להתחיל בבחירת טווח התאריכים",
  todayDate: (e) => `היום, ${e.date}`,
  todayDateSelected: (e) => `היום, ${e.date} נבחר`
};
var og = {};
og = {
  dateRange: (e) => `${e.startDate} do ${e.endDate}`,
  dateSelected: (e) => `${e.date} odabran`,
  finishRangeSelectionPrompt: "Kliknite da dovršite raspon odabranih datuma",
  maximumDate: "Posljednji raspoloživi datum",
  minimumDate: "Prvi raspoloživi datum",
  next: "Sljedeći",
  previous: "Prethodni",
  selectedDateDescription: (e) => `Odabrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Odabrani raspon: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kliknite da započnete raspon odabranih datuma",
  todayDate: (e) => `Danas, ${e.date}`,
  todayDateSelected: (e) => `Danas, odabran ${e.date}`
};
var sg = {};
sg = {
  dateRange: (e) => `${e.startDate}–${e.endDate}`,
  dateSelected: (e) => `${e.date} kiválasztva`,
  finishRangeSelectionPrompt: "Kattintson a dátumtartomány kijelölésének befejezéséhez",
  maximumDate: "Utolsó elérhető dátum",
  minimumDate: "Az első elérhető dátum",
  next: "Következő",
  previous: "Előző",
  selectedDateDescription: (e) => `Kijelölt dátum: ${e.date}`,
  selectedRangeDescription: (e) => `Kijelölt tartomány: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kattintson a dátumtartomány kijelölésének indításához",
  todayDate: (e) => `Ma, ${e.date}`,
  todayDateSelected: (e) => `Ma, ${e.date} kijelölve`
};
var ug = {};
ug = {
  dateRange: (e) => `Da ${e.startDate} a ${e.endDate}`,
  dateSelected: (e) => `${e.date} selezionata`,
  finishRangeSelectionPrompt: "Fai clic per completare la selezione dell’intervallo di date",
  maximumDate: "Ultima data disponibile",
  minimumDate: "Prima data disponibile",
  next: "Successivo",
  previous: "Precedente",
  selectedDateDescription: (e) => `Data selezionata: ${e.date}`,
  selectedRangeDescription: (e) => `Intervallo selezionato: ${e.dateRange}`,
  startRangeSelectionPrompt: "Fai clic per selezionare l’intervallo di date",
  todayDate: (e) => `Oggi, ${e.date}`,
  todayDateSelected: (e) => `Oggi, ${e.date} selezionata`
};
var lg = {};
lg = {
  dateRange: (e) => `${e.startDate} から ${e.endDate}`,
  dateSelected: (e) => `${e.date} を選択`,
  finishRangeSelectionPrompt: "クリックして日付範囲の選択を終了",
  maximumDate: "最終利用可能日",
  minimumDate: "最初の利用可能日",
  next: "次へ",
  previous: "前へ",
  selectedDateDescription: (e) => `選択した日付 : ${e.date}`,
  selectedRangeDescription: (e) => `選択範囲 : ${e.dateRange}`,
  startRangeSelectionPrompt: "クリックして日付範囲の選択を開始",
  todayDate: (e) => `本日、${e.date}`,
  todayDateSelected: (e) => `本日、${e.date} を選択`
};
var cg = {};
cg = {
  dateRange: (e) => `${e.startDate} ~ ${e.endDate}`,
  dateSelected: (e) => `${e.date} 선택됨`,
  finishRangeSelectionPrompt: "날짜 범위 선택을 완료하려면 클릭하십시오.",
  maximumDate: "마지막으로 사용 가능한 일자",
  minimumDate: "처음으로 사용 가능한 일자",
  next: "다음",
  previous: "이전",
  selectedDateDescription: (e) => `선택 일자: ${e.date}`,
  selectedRangeDescription: (e) => `선택 범위: ${e.dateRange}`,
  startRangeSelectionPrompt: "날짜 범위 선택을 시작하려면 클릭하십시오.",
  todayDate: (e) => `오늘, ${e.date}`,
  todayDateSelected: (e) => `오늘, ${e.date} 선택됨`
};
var dg = {};
dg = {
  dateRange: (e) => `Nuo ${e.startDate} iki ${e.endDate}`,
  dateSelected: (e) => `Pasirinkta ${e.date}`,
  finishRangeSelectionPrompt: "Spustelėkite, kad baigtumėte pasirinkti datų intervalą",
  maximumDate: "Paskutinė galima data",
  minimumDate: "Pirmoji galima data",
  next: "Paskesnis",
  previous: "Ankstesnis",
  selectedDateDescription: (e) => `Pasirinkta data: ${e.date}`,
  selectedRangeDescription: (e) => `Pasirinktas intervalas: ${e.dateRange}`,
  startRangeSelectionPrompt: "Spustelėkite, kad pradėtumėte pasirinkti datų intervalą",
  todayDate: (e) => `Šiandien, ${e.date}`,
  todayDateSelected: (e) => `Šiandien, pasirinkta ${e.date}`
};
var fg = {};
fg = {
  dateRange: (e) => `No ${e.startDate} līdz ${e.endDate}`,
  dateSelected: (e) => `Atlasīts: ${e.date}`,
  finishRangeSelectionPrompt: "Noklikšķiniet, lai pabeigtu datumu diapazona atlasi",
  maximumDate: "Pēdējais pieejamais datums",
  minimumDate: "Pirmais pieejamais datums",
  next: "Tālāk",
  previous: "Atpakaļ",
  selectedDateDescription: (e) => `Atlasītais datums: ${e.date}`,
  selectedRangeDescription: (e) => `Atlasītais diapazons: ${e.dateRange}`,
  startRangeSelectionPrompt: "Noklikšķiniet, lai sāktu datumu diapazona atlasi",
  todayDate: (e) => `Šodien, ${e.date}`,
  todayDateSelected: (e) => `Atlasīta šodiena, ${e.date}`
};
var hg = {};
hg = {
  dateRange: (e) => `${e.startDate} til ${e.endDate}`,
  dateSelected: (e) => `${e.date} valgt`,
  finishRangeSelectionPrompt: "Klikk for å fullføre valg av datoområde",
  maximumDate: "Siste tilgjengelige dato",
  minimumDate: "Første tilgjengelige dato",
  next: "Neste",
  previous: "Forrige",
  selectedDateDescription: (e) => `Valgt dato: ${e.date}`,
  selectedRangeDescription: (e) => `Valgt område: ${e.dateRange}`,
  startRangeSelectionPrompt: "Klikk for å starte valg av datoområde",
  todayDate: (e) => `I dag, ${e.date}`,
  todayDateSelected: (e) => `I dag, ${e.date} valgt`
};
var pg = {};
pg = {
  dateRange: (e) => `${e.startDate} tot ${e.endDate}`,
  dateSelected: (e) => `${e.date} geselecteerd`,
  finishRangeSelectionPrompt: "Klik om de selectie van het datumbereik te voltooien",
  maximumDate: "Laatste beschikbare datum",
  minimumDate: "Eerste beschikbare datum",
  next: "Volgende",
  previous: "Vorige",
  selectedDateDescription: (e) => `Geselecteerde datum: ${e.date}`,
  selectedRangeDescription: (e) => `Geselecteerd bereik: ${e.dateRange}`,
  startRangeSelectionPrompt: "Klik om het datumbereik te selecteren",
  todayDate: (e) => `Vandaag, ${e.date}`,
  todayDateSelected: (e) => `Vandaag, ${e.date} geselecteerd`
};
var mg = {};
mg = {
  dateRange: (e) => `${e.startDate} do ${e.endDate}`,
  dateSelected: (e) => `Wybrano ${e.date}`,
  finishRangeSelectionPrompt: "Kliknij, aby zakończyć wybór zakresu dat",
  maximumDate: "Ostatnia dostępna data",
  minimumDate: "Pierwsza dostępna data",
  next: "Dalej",
  previous: "Wstecz",
  selectedDateDescription: (e) => `Wybrana data: ${e.date}`,
  selectedRangeDescription: (e) => `Wybrany zakres: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kliknij, aby rozpocząć wybór zakresu dat",
  todayDate: (e) => `Dzisiaj, ${e.date}`,
  todayDateSelected: (e) => `Dzisiaj wybrano ${e.date}`
};
var vg = {};
vg = {
  dateRange: (e) => `${e.startDate} a ${e.endDate}`,
  dateSelected: (e) => `${e.date} selecionado`,
  finishRangeSelectionPrompt: "Clique para concluir a seleção do intervalo de datas",
  maximumDate: "Última data disponível",
  minimumDate: "Primeira data disponível",
  next: "Próximo",
  previous: "Anterior",
  selectedDateDescription: (e) => `Data selecionada: ${e.date}`,
  selectedRangeDescription: (e) => `Intervalo selecionado: ${e.dateRange}`,
  startRangeSelectionPrompt: "Clique para iniciar a seleção do intervalo de datas",
  todayDate: (e) => `Hoje, ${e.date}`,
  todayDateSelected: (e) => `Hoje, ${e.date} selecionado`
};
var yg = {};
yg = {
  dateRange: (e) => `${e.startDate} a ${e.endDate}`,
  dateSelected: (e) => `${e.date} selecionado`,
  finishRangeSelectionPrompt: "Clique para terminar de selecionar o intervalo de datas",
  maximumDate: "Última data disponível",
  minimumDate: "Primeira data disponível",
  next: "Próximo",
  previous: "Anterior",
  selectedDateDescription: (e) => `Data selecionada: ${e.date}`,
  selectedRangeDescription: (e) => `Intervalo selecionado: ${e.dateRange}`,
  startRangeSelectionPrompt: "Clique para começar a selecionar o intervalo de datas",
  todayDate: (e) => `Hoje, ${e.date}`,
  todayDateSelected: (e) => `Hoje, ${e.date} selecionado`
};
var gg = {};
gg = {
  dateRange: (e) => `De la ${e.startDate} până la ${e.endDate}`,
  dateSelected: (e) => `${e.date} selectată`,
  finishRangeSelectionPrompt: "Apăsaţi pentru a finaliza selecţia razei pentru dată",
  maximumDate: "Ultima dată disponibilă",
  minimumDate: "Prima dată disponibilă",
  next: "Următorul",
  previous: "Înainte",
  selectedDateDescription: (e) => `Dată selectată: ${e.date}`,
  selectedRangeDescription: (e) => `Interval selectat: ${e.dateRange}`,
  startRangeSelectionPrompt: "Apăsaţi pentru a începe selecţia razei pentru dată",
  todayDate: (e) => `Astăzi, ${e.date}`,
  todayDateSelected: (e) => `Azi, ${e.date} selectată`
};
var bg = {};
bg = {
  dateRange: (e) => `С ${e.startDate} по ${e.endDate}`,
  dateSelected: (e) => `Выбрано ${e.date}`,
  finishRangeSelectionPrompt: "Щелкните, чтобы завершить выбор диапазона дат",
  maximumDate: "Последняя доступная дата",
  minimumDate: "Первая доступная дата",
  next: "Далее",
  previous: "Назад",
  selectedDateDescription: (e) => `Выбранная дата: ${e.date}`,
  selectedRangeDescription: (e) => `Выбранный диапазон: ${e.dateRange}`,
  startRangeSelectionPrompt: "Щелкните, чтобы начать выбор диапазона дат",
  todayDate: (e) => `Сегодня, ${e.date}`,
  todayDateSelected: (e) => `Сегодня, выбрано ${e.date}`
};
var $g = {};
$g = {
  dateRange: (e) => `Od ${e.startDate} do ${e.endDate}`,
  dateSelected: (e) => `Vybratý dátum ${e.date}`,
  finishRangeSelectionPrompt: "Kliknutím dokončíte výber rozsahu dátumov",
  maximumDate: "Posledný dostupný dátum",
  minimumDate: "Prvý dostupný dátum",
  next: "Nasledujúce",
  previous: "Predchádzajúce",
  selectedDateDescription: (e) => `Vybratý dátum: ${e.date}`,
  selectedRangeDescription: (e) => `Vybratý rozsah: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kliknutím spustíte výber rozsahu dátumov",
  todayDate: (e) => `Dnes ${e.date}`,
  todayDateSelected: (e) => `Vybratý dnešný dátum ${e.date}`
};
var xg = {};
xg = {
  dateRange: (e) => `${e.startDate} do ${e.endDate}`,
  dateSelected: (e) => `${e.date} izbrano`,
  finishRangeSelectionPrompt: "Kliknite za dokončanje izbire datumskega obsega",
  maximumDate: "Zadnji razpoložljivi datum",
  minimumDate: "Prvi razpoložljivi datum",
  next: "Naprej",
  previous: "Nazaj",
  selectedDateDescription: (e) => `Izbrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Izbrano območje: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kliknite za začetek izbire datumskega obsega",
  todayDate: (e) => `Danes, ${e.date}`,
  todayDateSelected: (e) => `Danes, ${e.date} izbrano`
};
var Dg = {};
Dg = {
  dateRange: (e) => `${e.startDate} do ${e.endDate}`,
  dateSelected: (e) => `${e.date} izabran`,
  finishRangeSelectionPrompt: "Kliknite da dovršite opseg izabranih datuma",
  maximumDate: "Zadnji raspoloživi datum",
  minimumDate: "Prvi raspoloživi datum",
  next: "Sledeći",
  previous: "Prethodni",
  selectedDateDescription: (e) => `Izabrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Izabrani period: ${e.dateRange}`,
  startRangeSelectionPrompt: "Kliknite da započnete opseg izabranih datuma",
  todayDate: (e) => `Danas, ${e.date}`,
  todayDateSelected: (e) => `Danas, izabran ${e.date}`
};
var Eg = {};
Eg = {
  dateRange: (e) => `${e.startDate} till ${e.endDate}`,
  dateSelected: (e) => `${e.date} har valts`,
  finishRangeSelectionPrompt: "Klicka för att avsluta val av datumintervall",
  maximumDate: "Sista tillgängliga datum",
  minimumDate: "Första tillgängliga datum",
  next: "Nästa",
  previous: "Föregående",
  selectedDateDescription: (e) => `Valt datum: ${e.date}`,
  selectedRangeDescription: (e) => `Valt intervall: ${e.dateRange}`,
  startRangeSelectionPrompt: "Klicka för att välja datumintervall",
  todayDate: (e) => `Idag, ${e.date}`,
  todayDateSelected: (e) => `Idag, ${e.date} har valts`
};
var wg = {};
wg = {
  dateRange: (e) => `${e.startDate} - ${e.endDate}`,
  dateSelected: (e) => `${e.date} seçildi`,
  finishRangeSelectionPrompt: "Tarih aralığı seçimini tamamlamak için tıklayın",
  maximumDate: "Son müsait tarih",
  minimumDate: "İlk müsait tarih",
  next: "Sonraki",
  previous: "Önceki",
  selectedDateDescription: (e) => `Seçilen Tarih: ${e.date}`,
  selectedRangeDescription: (e) => `Seçilen Aralık: ${e.dateRange}`,
  startRangeSelectionPrompt: "Tarih aralığı seçimini başlatmak için tıklayın",
  todayDate: (e) => `Bugün, ${e.date}`,
  todayDateSelected: (e) => `Bugün, ${e.date} seçildi`
};
var Cg = {};
Cg = {
  dateRange: (e) => `${e.startDate} — ${e.endDate}`,
  dateSelected: (e) => `Вибрано ${e.date}`,
  finishRangeSelectionPrompt: "Натисніть, щоб завершити вибір діапазону дат",
  maximumDate: "Остання доступна дата",
  minimumDate: "Перша доступна дата",
  next: "Наступний",
  previous: "Попередній",
  selectedDateDescription: (e) => `Вибрана дата: ${e.date}`,
  selectedRangeDescription: (e) => `Вибраний діапазон: ${e.dateRange}`,
  startRangeSelectionPrompt: "Натисніть, щоб почати вибір діапазону дат",
  todayDate: (e) => `Сьогодні, ${e.date}`,
  todayDateSelected: (e) => `Сьогодні, вибрано ${e.date}`
};
var Sg = {};
Sg = {
  dateRange: (e) => `${e.startDate} 至 ${e.endDate}`,
  dateSelected: (e) => `已选择 ${e.date}`,
  finishRangeSelectionPrompt: "单击以完成选择日期范围",
  maximumDate: "最后一个可用日期",
  minimumDate: "第一个可用日期",
  next: "下一页",
  previous: "上一页",
  selectedDateDescription: (e) => `选定的日期：${e.date}`,
  selectedRangeDescription: (e) => `选定的范围：${e.dateRange}`,
  startRangeSelectionPrompt: "单击以开始选择日期范围",
  todayDate: (e) => `今天，即 ${e.date}`,
  todayDateSelected: (e) => `已选择今天，即 ${e.date}`
};
var kg = {};
kg = {
  dateRange: (e) => `${e.startDate} 至 ${e.endDate}`,
  dateSelected: (e) => `已選取 ${e.date}`,
  finishRangeSelectionPrompt: "按一下以完成選取日期範圍",
  maximumDate: "最後一個可用日期",
  minimumDate: "第一個可用日期",
  next: "下一頁",
  previous: "上一頁",
  selectedDateDescription: (e) => `選定的日期：${e.date}`,
  selectedRangeDescription: (e) => `選定的範圍：${e.dateRange}`,
  startRangeSelectionPrompt: "按一下以開始選取日期範圍",
  todayDate: (e) => `今天，${e.date}`,
  todayDateSelected: (e) => `已選取今天，${e.date}`
};
var Oa = {};
Oa = {
  "ar-AE": Qy,
  "bg-BG": Gy,
  "cs-CZ": Zy,
  "da-DK": Yy,
  "de-DE": Jy,
  "el-GR": Xy,
  "en-US": eg,
  "es-ES": tg,
  "et-EE": rg,
  "fi-FI": ng,
  "fr-FR": ig,
  "he-IL": ag,
  "hr-HR": og,
  "hu-HU": sg,
  "it-IT": ug,
  "ja-JP": lg,
  "ko-KR": cg,
  "lt-LT": dg,
  "lv-LV": fg,
  "nb-NO": hg,
  "nl-NL": pg,
  "pl-PL": mg,
  "pt-BR": vg,
  "pt-PT": yg,
  "ro-RO": gg,
  "ru-RU": bg,
  "sk-SK": $g,
  "sl-SI": xg,
  "sr-SP": Dg,
  "sv-SE": Eg,
  "tr-TR": wg,
  "uk-UA": Cg,
  "zh-CN": Sg,
  "zh-TW": kg
};
function Tg(e) {
  return e && e.__esModule ? e.default : e;
}
const Pd = /* @__PURE__ */ new WeakMap();
function ma(e) {
  return (e == null ? void 0 : e.calendar.identifier) === "gregory" && e.era === "BC" ? "short" : void 0;
}
function JC(e) {
  let t = zt(Tg(Oa), "@react-aria/calendar"), r, n;
  "highlightedRange" in e ? { start: r, end: n } = e.highlightedRange || {} : r = n = e.value;
  let i = Wt({
    weekday: "long",
    month: "long",
    year: "numeric",
    day: "numeric",
    era: ma(r) || ma(n),
    timeZone: e.timeZone
  }), a = "anchorDate" in e ? e.anchorDate : null;
  return G(() => {
    if (!a && r && n)
      if (Je(r, n)) {
        let o = i.format(r.toDate(e.timeZone));
        return t.format("selectedDateDescription", {
          date: o
        });
      } else {
        let o = ic(i, t, r, n, e.timeZone);
        return t.format("selectedRangeDescription", {
          dateRange: o
        });
      }
    return "";
  }, [
    r,
    n,
    a,
    e.timeZone,
    t,
    i
  ]);
}
function nc(e, t, r, n) {
  let i = zt(Tg(Oa), "@react-aria/calendar"), a = ma(e) || ma(t), o = Wt({
    month: "long",
    year: "numeric",
    era: a,
    calendar: e.calendar.identifier,
    timeZone: r
  }), s = Wt({
    month: "long",
    year: "numeric",
    day: "numeric",
    era: a,
    calendar: e.calendar.identifier,
    timeZone: r
  });
  return G(() => {
    if (Je(e, br(e))) {
      if (Je(t, oi(e))) return o.format(e.toDate(r));
      if (Je(t, oi(t))) return n ? ic(o, i, e, t, r) : o.formatRange(e.toDate(r), t.toDate(r));
    }
    return n ? ic(s, i, e, t, r) : s.formatRange(e.toDate(r), t.toDate(r));
  }, [
    e,
    t,
    o,
    s,
    i,
    r,
    n
  ]);
}
function ic(e, t, r, n, i) {
  let a = e.formatRangeToParts(r.toDate(i), n.toDate(i)), o = -1;
  for (let l = 0; l < a.length; l++) {
    let c = a[l];
    if (c.source === "shared" && c.type === "literal") o = l;
    else if (c.source === "endRange") break;
  }
  let s = "", u = "";
  for (let l = 0; l < a.length; l++)
    l < o ? s += a[l].value : l > o && (u += a[l].value);
  return t.format("dateRange", {
    startDate: s,
    endDate: u
  });
}
const Pg = 7e3;
let Qi = null;
function Qn(e, t = "assertive", r = Pg) {
  Qi || (Qi = new eS()), Qi.announce(e, t, r);
}
function XC(e) {
  Qi && Qi.clear(e);
}
class eS {
  createLog(t) {
    let r = document.createElement("div");
    return r.setAttribute("role", "log"), r.setAttribute("aria-live", t), r.setAttribute("aria-relevant", "additions"), r;
  }
  destroy() {
    this.node && (document.body.removeChild(this.node), this.node = null);
  }
  announce(t, r = "assertive", n = Pg) {
    if (!this.node) return;
    let i = document.createElement("div");
    i.textContent = t, r === "assertive" ? this.assertiveLog.appendChild(i) : this.politeLog.appendChild(i), t !== "" && setTimeout(() => {
      i.remove();
    }, n);
  }
  clear(t) {
    this.node && ((!t || t === "assertive") && (this.assertiveLog.innerHTML = ""), (!t || t === "polite") && (this.politeLog.innerHTML = ""));
  }
  constructor() {
    this.node = document.createElement("div"), this.node.dataset.liveAnnouncer = "true", Object.assign(this.node.style, {
      border: 0,
      clip: "rect(0 0 0 0)",
      clipPath: "inset(50%)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: 0,
      position: "absolute",
      width: "1px",
      whiteSpace: "nowrap"
    }), this.assertiveLog = this.createLog("assertive"), this.node.appendChild(this.assertiveLog), this.politeLog = this.createLog("polite"), this.node.appendChild(this.politeLog), document.body.prepend(this.node);
  }
}
function tS(e) {
  return e && e.__esModule ? e.default : e;
}
function rS(e, t) {
  let r = zt(tS(Oa), "@react-aria/calendar"), n = Me(e), i = nc(t.visibleRange.start, t.visibleRange.end, t.timeZone, !1), a = nc(t.visibleRange.start, t.visibleRange.end, t.timeZone, !0);
  $h(() => {
    t.isFocused || Qn(a);
  }, [
    a
  ]);
  let o = JC(t);
  $h(() => {
    o && Qn(o, "polite", 4e3);
  }, [
    o
  ]);
  let s = ai([
    !!e.errorMessage,
    e.isInvalid,
    e.validationState
  ]);
  Pd.set(t, {
    ariaLabel: e["aria-label"],
    ariaLabelledBy: e["aria-labelledby"],
    errorMessageId: s,
    selectedDateDescription: o
  });
  let [u, l] = re(!1), c = e.isDisabled || t.isNextVisibleRangeInvalid();
  c && u && (l(!1), t.setFocused(!0));
  let [d, f] = re(!1), h = e.isDisabled || t.isPreviousVisibleRangeInvalid();
  h && d && (f(!1), t.setFocused(!0));
  let p = cn({
    id: e.id,
    "aria-label": [
      e["aria-label"],
      a
    ].filter(Boolean).join(", "),
    "aria-labelledby": e["aria-labelledby"]
  });
  return {
    calendarProps: ge(n, p, {
      role: "application",
      "aria-describedby": e["aria-describedby"] || void 0
    }),
    nextButtonProps: {
      onPress: () => t.focusNextPage(),
      "aria-label": r.format("next"),
      isDisabled: c,
      onFocusChange: l
    },
    prevButtonProps: {
      onPress: () => t.focusPreviousPage(),
      "aria-label": r.format("previous"),
      isDisabled: h,
      onFocusChange: f
    },
    errorMessageProps: {
      id: s
    },
    title: i
  };
}
function nS(e, t, r) {
  let n = rS(e, t), i = q(!1), a = q(typeof window < "u" ? window : null);
  return Un(a, "pointerdown", (s) => {
    i.current = s.width === 0 && s.height === 0;
  }), Un(a, "pointerup", (s) => {
    if (i.current) {
      i.current = !1;
      return;
    }
    if (t.setDragging(!1), !t.anchorDate) return;
    let u = s.target;
    r.current && r.current.contains(document.activeElement) && (!r.current.contains(u) || !u.closest('button, [role="button"]')) && t.selectFocusedDate();
  }), n.calendarProps.onBlur = (s) => {
    r.current && (!s.relatedTarget || !r.current.contains(s.relatedTarget)) && t.anchorDate && t.selectFocusedDate();
  }, Un(r, "touchmove", (s) => {
    t.isDragging && s.preventDefault();
  }, {
    passive: !1,
    capture: !0
  }), n;
}
function iS(e, t) {
  let { startDate: r = t.visibleRange.start, endDate: n = t.visibleRange.end } = e, { direction: i } = lt(), a = (h) => {
    switch (h.key) {
      case "Enter":
      case " ":
        h.preventDefault(), t.selectFocusedDate();
        break;
      case "PageUp":
        h.preventDefault(), h.stopPropagation(), t.focusPreviousSection(h.shiftKey);
        break;
      case "PageDown":
        h.preventDefault(), h.stopPropagation(), t.focusNextSection(h.shiftKey);
        break;
      case "End":
        h.preventDefault(), h.stopPropagation(), t.focusSectionEnd();
        break;
      case "Home":
        h.preventDefault(), h.stopPropagation(), t.focusSectionStart();
        break;
      case "ArrowLeft":
        h.preventDefault(), h.stopPropagation(), i === "rtl" ? t.focusNextDay() : t.focusPreviousDay();
        break;
      case "ArrowUp":
        h.preventDefault(), h.stopPropagation(), t.focusPreviousRow();
        break;
      case "ArrowRight":
        h.preventDefault(), h.stopPropagation(), i === "rtl" ? t.focusPreviousDay() : t.focusNextDay();
        break;
      case "ArrowDown":
        h.preventDefault(), h.stopPropagation(), t.focusNextRow();
        break;
      case "Escape":
        "setAnchorDate" in t && (h.preventDefault(), t.setAnchorDate(null));
        break;
    }
  }, o = nc(r, n, t.timeZone, !0), { ariaLabel: s, ariaLabelledBy: u } = Pd.get(t), l = cn({
    "aria-label": [
      s,
      o
    ].filter(Boolean).join(", "),
    "aria-labelledby": u
  }), c = Wt({
    weekday: e.weekdayStyle || "narrow",
    timeZone: t.timeZone
  }), { locale: d } = lt(), f = G(() => {
    let h = hn(Ns(t.timeZone), d);
    return [
      ...new Array(7).keys()
    ].map((p) => {
      let g = h.add({
        days: p
      }).toDate(t.timeZone);
      return c.format(g);
    });
  }, [
    d,
    t.timeZone,
    c
  ]);
  return {
    gridProps: ge(l, {
      role: "grid",
      "aria-readonly": t.isReadOnly || null,
      "aria-disabled": t.isDisabled || null,
      "aria-multiselectable": "highlightedRange" in t || void 0,
      onKeyDown: a,
      onFocus: () => t.setFocused(!0),
      onBlur: () => t.setFocused(!1)
    }),
    headerProps: {
      // Column headers are hidden to screen readers to make navigating with a touch screen reader easier.
      // The day names are already included in the label of each cell, so there's no need to announce them twice.
      "aria-hidden": !0
    },
    weekDays: f
  };
}
function aS(e) {
  return e && e.__esModule ? e.default : e;
}
function oS(e, t, r) {
  let { date: n, isDisabled: i } = e, { errorMessageId: a, selectedDateDescription: o } = Pd.get(t), s = zt(aS(Oa), "@react-aria/calendar"), u = Wt({
    weekday: "long",
    day: "numeric",
    month: "long",
    year: "numeric",
    era: ma(n),
    timeZone: t.timeZone
  }), l = t.isSelected(n), c = t.isCellFocused(n);
  i = i || t.isCellDisabled(n);
  let d = t.isCellUnavailable(n), f = !i && !d, h = t.isValueInvalid && ("highlightedRange" in t ? !t.anchorDate && t.highlightedRange && n.compare(t.highlightedRange.start) >= 0 && n.compare(t.highlightedRange.end) <= 0 : t.value && Je(t.value, n));
  h && (l = !0), n = ey(n, Ql);
  let p = G(() => n.toDate(t.timeZone), [
    n,
    t.timeZone
  ]), v = Z6(n, t.timeZone), g = G(() => {
    let E = "";
    return "highlightedRange" in t && t.value && !t.anchorDate && (Je(n, t.value.start) || Je(n, t.value.end)) && (E = o + ", "), E += u.format(p), v ? E = s.format(l ? "todayDateSelected" : "todayDate", {
      date: E
    }) : l && (E = s.format("dateSelected", {
      date: E
    })), t.minValue && Je(n, t.minValue) ? E += ", " + s.format("minimumDate") : t.maxValue && Je(n, t.maxValue) && (E += ", " + s.format("maximumDate")), E;
  }, [
    u,
    p,
    s,
    l,
    v,
    n,
    t,
    o
  ]), $ = "";
  "anchorDate" in t && c && !t.isReadOnly && f && (t.anchorDate ? $ = s.format("finishRangeSelectionPrompt") : $ = s.format("startRangeSelectionPrompt"));
  let m = Rs($), b = q(!1), D = q(!1), S = q(null), { pressProps: T, isPressed: R } = _a({
    // When dragging to select a range, we don't want dragging over the original anchor
    // again to trigger onPressStart. Cancel presses immediately when the pointer exits.
    shouldCancelOnPointerExit: "anchorDate" in t && !!t.anchorDate,
    preventFocusOnPress: !0,
    isDisabled: !f || t.isReadOnly,
    onPressStart(E) {
      if (t.isReadOnly) {
        t.setFocusedDate(n);
        return;
      }
      if ("highlightedRange" in t && !t.anchorDate && (E.pointerType === "mouse" || E.pointerType === "touch")) {
        if (t.highlightedRange && !h) {
          if (Je(n, t.highlightedRange.start)) {
            t.setAnchorDate(t.highlightedRange.end), t.setFocusedDate(n), t.setDragging(!0), D.current = !0;
            return;
          } else if (Je(n, t.highlightedRange.end)) {
            t.setAnchorDate(t.highlightedRange.start), t.setFocusedDate(n), t.setDragging(!0), D.current = !0;
            return;
          }
        }
        let k = () => {
          t.setDragging(!0), S.current = null, t.selectDate(n), t.setFocusedDate(n), b.current = !0;
        };
        E.pointerType === "touch" ? S.current = setTimeout(k, 200) : k();
      }
    },
    onPressEnd() {
      D.current = !1, b.current = !1, clearTimeout(S.current), S.current = null;
    },
    onPress() {
      !("anchorDate" in t) && !t.isReadOnly && (t.selectDate(n), t.setFocusedDate(n));
    },
    onPressUp(E) {
      if (!t.isReadOnly && ("anchorDate" in t && S.current && (t.selectDate(n), t.setFocusedDate(n)), "anchorDate" in t))
        if (D.current)
          t.setAnchorDate(n);
        else if (t.anchorDate && !b.current)
          t.selectDate(n), t.setFocusedDate(n);
        else if (E.pointerType === "keyboard" && !t.anchorDate) {
          t.selectDate(n);
          let k = n.add({
            days: 1
          });
          t.isInvalid(k) && (k = n.subtract({
            days: 1
          })), t.isInvalid(k) || t.setFocusedDate(k);
        } else E.pointerType === "virtual" && (t.selectDate(n), t.setFocusedDate(n));
    }
  }), y = null;
  i || (y = Je(n, t.focusedDate) ? 0 : -1), ue(() => {
    c && r.current && (Ht(r.current), ns() !== "pointer" && document.activeElement === r.current && Xo(r.current, {
      containingElement: Is(r.current)
    }));
  }, [
    c,
    r
  ]);
  let A = Wt({
    day: "numeric",
    timeZone: t.timeZone,
    calendar: n.calendar.identifier
  }), w = G(() => A.formatToParts(p).find((E) => E.type === "day").value, [
    A,
    p
  ]);
  return {
    cellProps: {
      role: "gridcell",
      "aria-disabled": !f || null,
      "aria-selected": l || null,
      "aria-invalid": h || null
    },
    buttonProps: ge(T, {
      onFocus() {
        i || t.setFocusedDate(n);
      },
      tabIndex: y,
      role: "button",
      "aria-disabled": !f || null,
      "aria-label": g,
      "aria-invalid": h || null,
      "aria-describedby": [
        h ? a : null,
        m["aria-describedby"]
      ].filter(Boolean).join(" ") || void 0,
      onPointerEnter(E) {
        "highlightDate" in t && (E.pointerType !== "touch" || t.isDragging) && f && t.highlightDate(n);
      },
      onPointerDown(E) {
        "releasePointerCapture" in E.target && E.target.releasePointerCapture(E.pointerId);
      },
      onContextMenu(E) {
        E.preventDefault();
      }
    }),
    isPressed: R,
    isFocused: c,
    isSelected: l,
    isDisabled: i,
    isUnavailable: d,
    isOutsideVisibleRange: n.compare(t.visibleRange.start) < 0 || n.compare(t.visibleRange.end) > 0,
    isInvalid: h,
    formattedDate: w
  };
}
function Ad(e, t, r) {
  let { validationBehavior: n, focus: i } = e;
  Oe(() => {
    if (n === "native" && (r != null && r.current)) {
      let u = t.realtimeValidation.isInvalid ? t.realtimeValidation.validationErrors.join(" ") || "Invalid value." : "";
      r.current.setCustomValidity(u), r.current.hasAttribute("title") || (r.current.title = ""), t.realtimeValidation.isInvalid || t.updateValidation(uS(r.current));
    }
  });
  let a = st(() => {
    t.resetValidation();
  }), o = st((u) => {
    var l;
    t.displayValidation.isInvalid || t.commitValidation();
    let c = r == null || (l = r.current) === null || l === void 0 ? void 0 : l.form;
    if (!u.defaultPrevented && r && c && lS(c) === r.current) {
      var d;
      i ? i() : (d = r.current) === null || d === void 0 || d.focus(), ly("keyboard");
    }
    u.preventDefault();
  }), s = st(() => {
    t.commitValidation();
  });
  ue(() => {
    let u = r == null ? void 0 : r.current;
    if (!u) return;
    let l = u.form;
    return u.addEventListener("invalid", o), u.addEventListener("change", s), l == null || l.addEventListener("reset", a), () => {
      u.removeEventListener("invalid", o), u.removeEventListener("change", s), l == null || l.removeEventListener("reset", a);
    };
  }, [
    r,
    o,
    s,
    a,
    n
  ]);
}
function sS(e) {
  let t = e.validity;
  return {
    badInput: t.badInput,
    customError: t.customError,
    patternMismatch: t.patternMismatch,
    rangeOverflow: t.rangeOverflow,
    rangeUnderflow: t.rangeUnderflow,
    stepMismatch: t.stepMismatch,
    tooLong: t.tooLong,
    tooShort: t.tooShort,
    typeMismatch: t.typeMismatch,
    valueMissing: t.valueMissing,
    valid: t.valid
  };
}
function uS(e) {
  return {
    isInvalid: !e.validity.valid,
    validationDetails: sS(e),
    validationErrors: e.validationMessage ? [
      e.validationMessage
    ] : []
  };
}
function lS(e) {
  for (let t = 0; t < e.elements.length; t++) {
    let r = e.elements[t];
    if (!r.validity.valid) return r;
  }
  return null;
}
const js = {
  badInput: !1,
  customError: !1,
  patternMismatch: !1,
  rangeOverflow: !1,
  rangeUnderflow: !1,
  stepMismatch: !1,
  tooLong: !1,
  tooShort: !1,
  typeMismatch: !1,
  valueMissing: !1,
  valid: !0
}, Ag = {
  ...js,
  customError: !0,
  valid: !1
}, Zr = {
  isInvalid: !1,
  validationDetails: js,
  validationErrors: []
}, cS = de({}), va = "__formValidationState" + Date.now();
function Ia(e) {
  if (e[va]) {
    let { realtimeValidation: t, displayValidation: r, updateValidation: n, resetValidation: i, commitValidation: a } = e[va];
    return {
      realtimeValidation: t,
      displayValidation: r,
      updateValidation: n,
      resetValidation: i,
      commitValidation: a
    };
  }
  return dS(e);
}
function dS(e) {
  let { isInvalid: t, validationState: r, name: n, value: i, builtinValidation: a, validate: o, validationBehavior: s = "aria" } = e;
  r && (t || (t = r === "invalid"));
  let u = t !== void 0 ? {
    isInvalid: t,
    validationErrors: [],
    validationDetails: Ag
  } : null, l = G(() => rp(fS(o, i)), [
    o,
    i
  ]);
  a != null && a.validationDetails.valid && (a = null);
  let c = ce(cS), d = G(() => n ? Array.isArray(n) ? n.flatMap((w) => ac(c[w])) : ac(c[n]) : [], [
    c,
    n
  ]), [f, h] = re(c), [p, v] = re(!1);
  c !== f && (h(c), v(!1));
  let g = G(() => rp(p ? [] : d), [
    p,
    d
  ]), $ = q(Zr), [m, b] = re(Zr), D = q(Zr), S = () => {
    if (!T) return;
    R(!1);
    let w = l || a || $.current;
    qu(w, D.current) || (D.current = w, b(w));
  }, [T, R] = re(!1);
  return ue(S), {
    realtimeValidation: u || g || l || a || Zr,
    displayValidation: s === "native" ? u || g || m : u || g || l || a || m,
    updateValidation(w) {
      s === "aria" && !qu(m, w) ? b(w) : $.current = w;
    },
    resetValidation() {
      let w = Zr;
      qu(w, D.current) || (D.current = w, b(w)), s === "native" && R(!1), v(!0);
    },
    commitValidation() {
      s === "native" && R(!0), v(!0);
    }
  };
}
function ac(e) {
  return e ? Array.isArray(e) ? e : [
    e
  ] : [];
}
function fS(e, t) {
  if (typeof e == "function") {
    let r = e(t);
    if (r && typeof r != "boolean") return ac(r);
  }
  return [];
}
function rp(e) {
  return e.length ? {
    isInvalid: !0,
    validationErrors: e,
    validationDetails: Ag
  } : null;
}
function qu(e, t) {
  return e === t ? !0 : e && t && e.isInvalid === t.isInvalid && e.validationErrors.length === t.validationErrors.length && e.validationErrors.every((r, n) => r === t.validationErrors[n]) && Object.entries(e.validationDetails).every(([r, n]) => t.validationDetails[r] === n);
}
function ps(...e) {
  let t = /* @__PURE__ */ new Set(), r = !1, n = {
    ...js
  };
  for (let o of e) {
    var i, a;
    for (let s of o.validationErrors) t.add(s);
    r || (r = o.isInvalid);
    for (let s in n) (i = n)[a = s] || (i[a] = o.validationDetails[s]);
  }
  return n.valid = !r, {
    isInvalid: r,
    validationErrors: [
      ...t
    ],
    validationDetails: n
  };
}
function _g(e) {
  let { id: t, label: r, "aria-labelledby": n, "aria-label": i, labelElementType: a = "label" } = e;
  t = Ct(t);
  let o = Ct(), s = {};
  r ? (n = n ? `${o} ${n}` : o, s = {
    id: o,
    htmlFor: a === "label" ? t : void 0
  }) : !n && !i && console.warn("If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility");
  let u = cn({
    id: t,
    "aria-label": i,
    "aria-labelledby": n
  });
  return {
    labelProps: s,
    fieldProps: u
  };
}
function zs(e) {
  let { description: t, errorMessage: r, isInvalid: n, validationState: i } = e, { labelProps: a, fieldProps: o } = _g(e), s = ai([
    !!t,
    !!r,
    n,
    i
  ]), u = ai([
    !!t,
    !!r,
    n,
    i
  ]);
  return o = ge(o, {
    "aria-describedby": [
      s,
      // Use aria-describedby for error message because aria-errormessage is unsupported using VoiceOver or NVDA. See https://github.com/adobe/react-spectrum/issues/1346#issuecomment-740136268
      u,
      e["aria-describedby"]
    ].filter(Boolean).join(" ") || void 0
  }), {
    labelProps: a,
    fieldProps: o,
    descriptionProps: {
      id: s
    },
    errorMessageProps: {
      id: u
    }
  };
}
var Fg = {};
Fg = {
  buttonLabel: "عرض المقترحات",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} خيار`,
    other: () => `${t.number(e.optionCount)} خيارات`
  })} متاحة.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `المجموعة المدخلة ${e.groupTitle}, مع ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} خيار`,
      other: () => `${t.number(e.groupCount)} خيارات`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", محدد",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "مقترحات",
  selectedAnnouncement: (e) => `${e.optionText}، محدد`
};
var Og = {};
Og = {
  buttonLabel: "Покажи предложения",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} опция`,
    other: () => `${t.number(e.optionCount)} опции`
  })} на разположение.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Въведена група ${e.groupTitle}, с ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} опция`,
      other: () => `${t.number(e.groupCount)} опции`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", избрани",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Предложения",
  selectedAnnouncement: (e) => `${e.optionText}, избрани`
};
var Ig = {};
Ig = {
  buttonLabel: "Zobrazit doporučení",
  countAnnouncement: (e, t) => `K dispozici ${t.plural(e.optionCount, {
    one: () => `je ${t.number(e.optionCount)} možnost`,
    other: () => `jsou/je ${t.number(e.optionCount)} možnosti/-í`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Zadaná skupina „${e.groupTitle}“ ${t.plural(e.groupCount, {
      one: () => `s ${t.number(e.groupCount)} možností`,
      other: () => `se ${t.number(e.groupCount)} možnostmi`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: " (vybráno)",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Návrhy",
  selectedAnnouncement: (e) => `${e.optionText}, vybráno`
};
var Rg = {};
Rg = {
  buttonLabel: "Vis forslag",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} mulighed tilgængelig`,
    other: () => `${t.number(e.optionCount)} muligheder tilgængelige`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Angivet gruppe ${e.groupTitle}, med ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} mulighed`,
      other: () => `${t.number(e.groupCount)} muligheder`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", valgt",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Forslag",
  selectedAnnouncement: (e) => `${e.optionText}, valgt`
};
var Bg = {};
Bg = {
  buttonLabel: "Empfehlungen anzeigen",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} Option`,
    other: () => `${t.number(e.optionCount)} Optionen`
  })} verfügbar.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Eingetretene Gruppe ${e.groupTitle}, mit ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} Option`,
      other: () => `${t.number(e.groupCount)} Optionen`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", ausgewählt",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Empfehlungen",
  selectedAnnouncement: (e) => `${e.optionText}, ausgewählt`
};
var Mg = {};
Mg = {
  buttonLabel: "Προβολή προτάσεων",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} επιλογή`,
    other: () => `${t.number(e.optionCount)} επιλογές `
  })} διαθέσιμες.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Εισαγμένη ομάδα ${e.groupTitle}, με ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} επιλογή`,
      other: () => `${t.number(e.groupCount)} επιλογές`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", επιλεγμένο",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Προτάσεις",
  selectedAnnouncement: (e) => `${e.optionText}, επιλέχθηκε`
};
var Ng = {};
Ng = {
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Entered group ${e.groupTitle}, with ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} option`,
      other: () => `${t.number(e.groupCount)} options`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", selected",
    other: ""
  }, e.isSelected)}`,
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} option`,
    other: () => `${t.number(e.optionCount)} options`
  })} available.`,
  selectedAnnouncement: (e) => `${e.optionText}, selected`,
  buttonLabel: "Show suggestions",
  listboxLabel: "Suggestions"
};
var Lg = {};
Lg = {
  buttonLabel: "Mostrar sugerencias",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opción`,
    other: () => `${t.number(e.optionCount)} opciones`
  })} disponible(s).`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Se ha unido al grupo ${e.groupTitle}, con ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opción`,
      other: () => `${t.number(e.groupCount)} opciones`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", seleccionado",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Sugerencias",
  selectedAnnouncement: (e) => `${e.optionText}, seleccionado`
};
var Vg = {};
Vg = {
  buttonLabel: "Kuva soovitused",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} valik`,
    other: () => `${t.number(e.optionCount)} valikud`
  })} saadaval.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Sisestatud rühm ${e.groupTitle}, valikuga ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} valik`,
      other: () => `${t.number(e.groupCount)} valikud`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", valitud",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Soovitused",
  selectedAnnouncement: (e) => `${e.optionText}, valitud`
};
var jg = {};
jg = {
  buttonLabel: "Näytä ehdotukset",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} vaihtoehto`,
    other: () => `${t.number(e.optionCount)} vaihtoehdot`
  })} saatavilla.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Mentiin ryhmään ${e.groupTitle}, ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} vaihtoehdon`,
      other: () => `${t.number(e.groupCount)} vaihtoehdon`
    })} kanssa.`,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", valittu",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Ehdotukset",
  selectedAnnouncement: (e) => `${e.optionText}, valittu`
};
var zg = {};
zg = {
  buttonLabel: "Afficher les suggestions",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} option`,
    other: () => `${t.number(e.optionCount)} options`
  })} disponible(s).`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Groupe ${e.groupTitle} rejoint, avec ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} option`,
      other: () => `${t.number(e.groupCount)} options`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", sélectionné(s)",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Suggestions",
  selectedAnnouncement: (e) => `${e.optionText}, sélectionné`
};
var Kg = {};
Kg = {
  buttonLabel: "הצג הצעות",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `אפשרות ${t.number(e.optionCount)}`,
    other: () => `${t.number(e.optionCount)} אפשרויות`
  })} במצב זמין.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `נכנס לקבוצה ${e.groupTitle}, עם ${t.plural(e.groupCount, {
      one: () => `אפשרות ${t.number(e.groupCount)}`,
      other: () => `${t.number(e.groupCount)} אפשרויות`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", נבחר",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "הצעות",
  selectedAnnouncement: (e) => `${e.optionText}, נבחר`
};
var Ug = {};
Ug = {
  buttonLabel: "Prikaži prijedloge",
  countAnnouncement: (e, t) => `Dostupno još: ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opcija`,
    other: () => `${t.number(e.optionCount)} opcije/a`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Unesena skupina ${e.groupTitle}, s ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opcijom`,
      other: () => `${t.number(e.groupCount)} opcije/a`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", odabranih",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Prijedlozi",
  selectedAnnouncement: (e) => `${e.optionText}, odabrano`
};
var qg = {};
qg = {
  buttonLabel: "Javaslatok megjelenítése",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} lehetőség`,
    other: () => `${t.number(e.optionCount)} lehetőség`
  })} áll rendelkezésre.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Belépett a(z) ${e.groupTitle} csoportba, amely ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} lehetőséget`,
      other: () => `${t.number(e.groupCount)} lehetőséget`
    })} tartalmaz. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", kijelölve",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Javaslatok",
  selectedAnnouncement: (e) => `${e.optionText}, kijelölve`
};
var Hg = {};
Hg = {
  buttonLabel: "Mostra suggerimenti",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opzione disponibile`,
    other: () => `${t.number(e.optionCount)} opzioni disponibili`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Ingresso nel gruppo ${e.groupTitle}, con ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opzione`,
      other: () => `${t.number(e.groupCount)} opzioni`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", selezionato",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Suggerimenti",
  selectedAnnouncement: (e) => `${e.optionText}, selezionato`
};
var Wg = {};
Wg = {
  buttonLabel: "候補を表示",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} 個のオプション`,
    other: () => `${t.number(e.optionCount)} 個のオプション`
  })}を利用できます。`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `入力されたグループ ${e.groupTitle}、${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} 個のオプション`,
      other: () => `${t.number(e.groupCount)} 個のオプション`
    })}を含む。`,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: "、選択済み",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "候補",
  selectedAnnouncement: (e) => `${e.optionText}、選択済み`
};
var Qg = {};
Qg = {
  buttonLabel: "제안 사항 표시",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)}개 옵션`,
    other: () => `${t.number(e.optionCount)}개 옵션`
  })}을 사용할 수 있습니다.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `입력한 그룹 ${e.groupTitle}, ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)}개 옵션`,
      other: () => `${t.number(e.groupCount)}개 옵션`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", 선택됨",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "제안",
  selectedAnnouncement: (e) => `${e.optionText}, 선택됨`
};
var Gg = {};
Gg = {
  buttonLabel: "Rodyti pasiūlymus",
  countAnnouncement: (e, t) => `Yra ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} parinktis`,
    other: () => `${t.number(e.optionCount)} parinktys (-ių)`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Įvesta grupė ${e.groupTitle}, su ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} parinktimi`,
      other: () => `${t.number(e.groupCount)} parinktimis (-ių)`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", pasirinkta",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Pasiūlymai",
  selectedAnnouncement: (e) => `${e.optionText}, pasirinkta`
};
var Zg = {};
Zg = {
  buttonLabel: "Rādīt ieteikumus",
  countAnnouncement: (e, t) => `Pieejamo opciju skaits: ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opcija`,
    other: () => `${t.number(e.optionCount)} opcijas`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Ievadīta grupa ${e.groupTitle}, ar ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opciju`,
      other: () => `${t.number(e.groupCount)} opcijām`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", atlasīta",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Ieteikumi",
  selectedAnnouncement: (e) => `${e.optionText}, atlasīta`
};
var Yg = {};
Yg = {
  buttonLabel: "Vis forslag",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} alternativ`,
    other: () => `${t.number(e.optionCount)} alternativer`
  })} finnes.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Angitt gruppe ${e.groupTitle}, med ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} alternativ`,
      other: () => `${t.number(e.groupCount)} alternativer`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", valgt",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Forslag",
  selectedAnnouncement: (e) => `${e.optionText}, valgt`
};
var Jg = {};
Jg = {
  buttonLabel: "Suggesties weergeven",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} optie`,
    other: () => `${t.number(e.optionCount)} opties`
  })} beschikbaar.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Groep ${e.groupTitle} ingevoerd met ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} optie`,
      other: () => `${t.number(e.groupCount)} opties`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", geselecteerd",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Suggesties",
  selectedAnnouncement: (e) => `${e.optionText}, geselecteerd`
};
var Xg = {};
Xg = {
  buttonLabel: "Wyświetlaj sugestie",
  countAnnouncement: (e, t) => `dostępna/dostępne(-nych) ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opcja`,
    other: () => `${t.number(e.optionCount)} opcje(-i)`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Dołączono do grupy ${e.groupTitle}, z ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opcją`,
      other: () => `${t.number(e.groupCount)} opcjami`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", wybrano",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Sugestie",
  selectedAnnouncement: (e) => `${e.optionText}, wybrano`
};
var e0 = {};
e0 = {
  buttonLabel: "Mostrar sugestões",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opção`,
    other: () => `${t.number(e.optionCount)} opções`
  })} disponível.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Grupo inserido ${e.groupTitle}, com ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opção`,
      other: () => `${t.number(e.groupCount)} opções`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", selecionado",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Sugestões",
  selectedAnnouncement: (e) => `${e.optionText}, selecionado`
};
var t0 = {};
t0 = {
  buttonLabel: "Apresentar sugestões",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opção`,
    other: () => `${t.number(e.optionCount)} opções`
  })} disponível.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Grupo introduzido ${e.groupTitle}, com ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opção`,
      other: () => `${t.number(e.groupCount)} opções`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", selecionado",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Sugestões",
  selectedAnnouncement: (e) => `${e.optionText}, selecionado`
};
var r0 = {};
r0 = {
  buttonLabel: "Afișare sugestii",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opțiune`,
    other: () => `${t.number(e.optionCount)} opțiuni`
  })} disponibile.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Grup ${e.groupTitle} introdus, cu ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opțiune`,
      other: () => `${t.number(e.groupCount)} opțiuni`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", selectat",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Sugestii",
  selectedAnnouncement: (e) => `${e.optionText}, selectat`
};
var n0 = {};
n0 = {
  buttonLabel: "Показать предложения",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} параметр`,
    other: () => `${t.number(e.optionCount)} параметров`
  })} доступно.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Введенная группа ${e.groupTitle}, с ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} параметром`,
      other: () => `${t.number(e.groupCount)} параметрами`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", выбранными",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Предложения",
  selectedAnnouncement: (e) => `${e.optionText}, выбрано`
};
var i0 = {};
i0 = {
  buttonLabel: "Zobraziť návrhy",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} možnosť`,
    other: () => `${t.number(e.optionCount)} možnosti/-í`
  })} k dispozícii.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Zadaná skupina ${e.groupTitle}, s ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} možnosťou`,
      other: () => `${t.number(e.groupCount)} možnosťami`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", vybraté",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Návrhy",
  selectedAnnouncement: (e) => `${e.optionText}, vybraté`
};
var a0 = {};
a0 = {
  buttonLabel: "Prikaži predloge",
  countAnnouncement: (e, t) => `Na voljo je ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opcija`,
    other: () => `${t.number(e.optionCount)} opcije`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Vnesena skupina ${e.groupTitle}, z ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opcija`,
      other: () => `${t.number(e.groupCount)} opcije`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", izbrano",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Predlogi",
  selectedAnnouncement: (e) => `${e.optionText}, izbrano`
};
var o0 = {};
o0 = {
  buttonLabel: "Prikaži predloge",
  countAnnouncement: (e, t) => `Dostupno još: ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} opcija`,
    other: () => `${t.number(e.optionCount)} opcije/a`
  })}.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Unesena grupa ${e.groupTitle}, s ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} opcijom`,
      other: () => `${t.number(e.groupCount)} optione/a`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", izabranih",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Predlozi",
  selectedAnnouncement: (e) => `${e.optionText}, izabrano`
};
var s0 = {};
s0 = {
  buttonLabel: "Visa förslag",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} alternativ`,
    other: () => `${t.number(e.optionCount)} alternativ`
  })} tillgängliga.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Ingick i gruppen ${e.groupTitle} med ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} alternativ`,
      other: () => `${t.number(e.groupCount)} alternativ`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", valda",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Förslag",
  selectedAnnouncement: (e) => `${e.optionText}, valda`
};
var u0 = {};
u0 = {
  buttonLabel: "Önerileri göster",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} seçenek`,
    other: () => `${t.number(e.optionCount)} seçenekler`
  })} kullanılabilir.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Girilen grup ${e.groupTitle}, ile ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} seçenek`,
      other: () => `${t.number(e.groupCount)} seçenekler`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", seçildi",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Öneriler",
  selectedAnnouncement: (e) => `${e.optionText}, seçildi`
};
var l0 = {};
l0 = {
  buttonLabel: "Показати пропозиції",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} параметр`,
    other: () => `${t.number(e.optionCount)} параметри(-ів)`
  })} доступно.`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `Введена група ${e.groupTitle}, з ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} параметр`,
      other: () => `${t.number(e.groupCount)} параметри(-ів)`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", вибрано",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "Пропозиції",
  selectedAnnouncement: (e) => `${e.optionText}, вибрано`
};
var c0 = {};
c0 = {
  buttonLabel: "显示建议",
  countAnnouncement: (e, t) => `有 ${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} 个选项`,
    other: () => `${t.number(e.optionCount)} 个选项`
  })}可用。`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `进入了 ${e.groupTitle} 组，其中有 ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} 个选项`,
      other: () => `${t.number(e.groupCount)} 个选项`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", 已选择",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "建议",
  selectedAnnouncement: (e) => `${e.optionText}, 已选择`
};
var d0 = {};
d0 = {
  buttonLabel: "顯示建議",
  countAnnouncement: (e, t) => `${t.plural(e.optionCount, {
    one: () => `${t.number(e.optionCount)} 選項`,
    other: () => `${t.number(e.optionCount)} 選項`
  })} 可用。`,
  focusAnnouncement: (e, t) => `${t.select({
    true: () => `輸入的群組 ${e.groupTitle}, 有 ${t.plural(e.groupCount, {
      one: () => `${t.number(e.groupCount)} 選項`,
      other: () => `${t.number(e.groupCount)} 選項`
    })}. `,
    other: ""
  }, e.isGroupChange)}${e.optionText}${t.select({
    true: ", 已選取",
    other: ""
  }, e.isSelected)}`,
  listboxLabel: "建議",
  selectedAnnouncement: (e) => `${e.optionText}, 已選取`
};
var f0 = {};
f0 = {
  "ar-AE": Fg,
  "bg-BG": Og,
  "cs-CZ": Ig,
  "da-DK": Rg,
  "de-DE": Bg,
  "el-GR": Mg,
  "en-US": Ng,
  "es-ES": Lg,
  "et-EE": Vg,
  "fi-FI": jg,
  "fr-FR": zg,
  "he-IL": Kg,
  "hr-HR": Ug,
  "hu-HU": qg,
  "it-IT": Hg,
  "ja-JP": Wg,
  "ko-KR": Qg,
  "lt-LT": Gg,
  "lv-LV": Zg,
  "nb-NO": Yg,
  "nl-NL": Jg,
  "pl-PL": Xg,
  "pt-BR": e0,
  "pt-PT": t0,
  "ro-RO": r0,
  "ru-RU": n0,
  "sk-SK": i0,
  "sl-SI": a0,
  "sr-SP": o0,
  "sv-SE": s0,
  "tr-TR": u0,
  "uk-UA": l0,
  "zh-CN": c0,
  "zh-TW": d0
};
const Mn = {
  top: "top",
  bottom: "top",
  left: "left",
  right: "left"
}, ms = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
}, hS = {
  top: "left",
  left: "top"
}, oc = {
  top: "height",
  left: "width"
}, h0 = {
  width: "totalWidth",
  height: "totalHeight"
}, ao = {};
let mt = typeof document < "u" && window.visualViewport;
function np(e) {
  let t = 0, r = 0, n = 0, i = 0, a = 0, o = 0, s = {}, u = (mt == null ? void 0 : mt.scale) > 1;
  if (e.tagName === "BODY") {
    let d = document.documentElement;
    n = d.clientWidth, i = d.clientHeight;
    var l;
    t = (l = mt == null ? void 0 : mt.width) !== null && l !== void 0 ? l : n;
    var c;
    r = (c = mt == null ? void 0 : mt.height) !== null && c !== void 0 ? c : i, s.top = d.scrollTop || e.scrollTop, s.left = d.scrollLeft || e.scrollLeft, mt && (a = mt.offsetTop, o = mt.offsetLeft);
  } else
    ({ width: t, height: r, top: a, left: o } = Gn(e)), s.top = e.scrollTop, s.left = e.scrollLeft, n = t, i = r;
  return ld() && (e.tagName === "BODY" || e.tagName === "HTML") && u && (s.top = 0, s.left = 0, a = mt.pageTop, o = mt.pageLeft), {
    width: t,
    height: r,
    totalWidth: n,
    totalHeight: i,
    scroll: s,
    top: a,
    left: o
  };
}
function pS(e) {
  return {
    top: e.scrollTop,
    left: e.scrollLeft,
    width: e.scrollWidth,
    height: e.scrollHeight
  };
}
function ip(e, t, r, n, i, a, o) {
  let s = i.scroll[e], u = n[oc[e]], l = n.scroll[Mn[e]] + a, c = u + n.scroll[Mn[e]] - a, d = t - s + o[e] - n[Mn[e]], f = t - s + r + o[e] - n[Mn[e]];
  return d < l ? l - d : f > c ? Math.max(c - f, l - d) : 0;
}
function mS(e) {
  let t = window.getComputedStyle(e);
  return {
    top: parseInt(t.marginTop, 10) || 0,
    bottom: parseInt(t.marginBottom, 10) || 0,
    left: parseInt(t.marginLeft, 10) || 0,
    right: parseInt(t.marginRight, 10) || 0
  };
}
function ap(e) {
  if (ao[e]) return ao[e];
  let [t, r] = e.split(" "), n = Mn[t] || "right", i = hS[n];
  Mn[r] || (r = "center");
  let a = oc[n], o = oc[i];
  return ao[e] = {
    placement: t,
    crossPlacement: r,
    axis: n,
    crossAxis: i,
    size: a,
    crossSize: o
  }, ao[e];
}
function Hu(e, t, r, n, i, a, o, s, u, l) {
  let { placement: c, crossPlacement: d, axis: f, crossAxis: h, size: p, crossSize: v } = n, g = {};
  g[h] = e[h], d === "center" ? g[h] += (e[v] - r[v]) / 2 : d !== h && (g[h] += e[v] - r[v]), g[h] += a;
  const $ = e[h] - r[v] + u + l, m = e[h] + e[v] - u - l;
  if (g[h] = zl(g[h], $, m), c === f) {
    const b = s ? o[p] : t[h0[p]];
    g[ms[f]] = Math.floor(b - e[f] + i);
  } else g[f] = Math.floor(e[f] + e[p] + i);
  return g;
}
function vS(e, t, r, n, i, a, o, s) {
  const u = n ? r.height : t[h0.height];
  let l = e.top != null ? r.top + e.top : r.top + (u - e.bottom - o), c = s !== "top" ? (
    // We want the distance between the top of the overlay to the bottom of the boundary
    Math.max(0, t.height + t.top + t.scroll.top - l - (i.top + i.bottom + a))
  ) : Math.max(0, l + o - (t.top + t.scroll.top) - (i.top + i.bottom + a));
  return Math.min(t.height - a * 2, c);
}
function op(e, t, r, n, i, a) {
  let { placement: o, axis: s, size: u } = a;
  return o === s ? Math.max(0, r[s] - e[s] - e.scroll[s] + t[s] - n[s] - n[ms[s]] - i) : Math.max(0, e[u] + e[s] + e.scroll[s] - t[s] - r[s] - r[u] - n[s] - n[ms[s]] - i);
}
function yS(e, t, r, n, i, a, o, s, u, l, c, d, f, h, p, v) {
  let g = ap(e), { size: $, crossAxis: m, crossSize: b, placement: D, crossPlacement: S } = g, T = Hu(t, s, r, g, c, d, l, f, p, v), R = c, y = op(s, l, t, i, a + c, g);
  if (o && n[$] > y) {
    let K = ap(`${ms[D]} ${S}`), j = Hu(t, s, r, K, c, d, l, f, p, v);
    op(s, l, t, i, a + c, K) > y && (g = K, T = j, R = c);
  }
  let A = "bottom";
  g.axis === "top" ? g.placement === "top" ? A = "top" : g.placement === "bottom" && (A = "bottom") : g.crossAxis === "top" && (g.crossPlacement === "top" ? A = "bottom" : g.crossPlacement === "bottom" && (A = "top"));
  let w = ip(m, T[m], r[b], s, u, a, l);
  T[m] += w;
  let E = vS(T, s, l, f, i, a, r.height, A);
  h && h < E && (E = h), r.height = Math.min(r.height, E), T = Hu(t, s, r, g, R, d, l, f, p, v), w = ip(m, T[m], r[b], s, u, a, l), T[m] += w;
  let k = {}, C = t[m] + 0.5 * t[b] - T[m];
  const P = p / 2 + v, L = r[b] - p / 2 - v, O = t[m] - T[m] + p / 2, x = t[m] + t[b] - T[m] - p / 2, U = zl(C, O, x);
  return k[m] = zl(U, P, L), {
    position: T,
    maxHeight: E,
    arrowOffsetLeft: k.left,
    arrowOffsetTop: k.top,
    placement: g.placement
  };
}
function gS(e) {
  let { placement: t, targetNode: r, overlayNode: n, scrollNode: i, padding: a, shouldFlip: o, boundaryElement: s, offset: u, crossOffset: l, maxHeight: c, arrowSize: d = 0, arrowBoundaryOffset: f = 0 } = e, h = n instanceof HTMLElement ? bS(n) : document.documentElement, p = h === document.documentElement;
  const v = window.getComputedStyle(h).position;
  let g = !!v && v !== "static", $ = p ? Gn(r) : sp(r, h);
  if (!p) {
    let { marginTop: y, marginLeft: A } = window.getComputedStyle(r);
    $.top += parseInt(y, 10) || 0, $.left += parseInt(A, 10) || 0;
  }
  let m = Gn(n), b = mS(n);
  m.width += b.left + b.right, m.height += b.top + b.bottom;
  let D = pS(i), S = np(s), T = np(h), R = s.tagName === "BODY" ? Gn(h) : sp(h, s);
  return h.tagName === "HTML" && s.tagName === "BODY" && (T.scroll.top = 0, T.scroll.left = 0), yS(t, $, m, D, b, a, o, S, T, R, u, l, g, c, d, f);
}
function Gn(e) {
  let { top: t, left: r, width: n, height: i } = e.getBoundingClientRect(), { scrollTop: a, scrollLeft: o, clientTop: s, clientLeft: u } = document.documentElement;
  return {
    top: t + a - s,
    left: r + o - u,
    width: n,
    height: i
  };
}
function sp(e, t) {
  let r = window.getComputedStyle(e), n;
  if (r.position === "fixed") {
    let { top: i, left: a, width: o, height: s } = e.getBoundingClientRect();
    n = {
      top: i,
      left: a,
      width: o,
      height: s
    };
  } else {
    n = Gn(e);
    let i = Gn(t), a = window.getComputedStyle(t);
    i.top += (parseInt(a.borderTopWidth, 10) || 0) - t.scrollTop, i.left += (parseInt(a.borderLeftWidth, 10) || 0) - t.scrollLeft, n.top -= i.top, n.left -= i.left;
  }
  return n.top -= parseInt(r.marginTop, 10) || 0, n.left -= parseInt(r.marginLeft, 10) || 0, n;
}
function bS(e) {
  let t = e.offsetParent;
  if (t && t === document.body && window.getComputedStyle(t).position === "static" && !up(t) && (t = document.documentElement), t == null)
    for (t = e.parentElement; t && !up(t); ) t = t.parentElement;
  return t || document.documentElement;
}
function up(e) {
  let t = window.getComputedStyle(e);
  return t.transform !== "none" || /transform|perspective/.test(t.willChange) || t.filter !== "none" || t.contain === "paint" || // @ts-ignore
  "backdropFilter" in t && t.backdropFilter !== "none" || // @ts-ignore
  "WebkitBackdropFilter" in t && t.WebkitBackdropFilter !== "none";
}
const p0 = /* @__PURE__ */ new WeakMap();
function $S(e) {
  let { triggerRef: t, isOpen: r, onClose: n } = e;
  ue(() => {
    if (!r || n === null) return;
    let i = (a) => {
      let o = a.target;
      if (!t.current || o instanceof Node && !o.contains(t.current)) return;
      let s = n || p0.get(t.current);
      s && s();
    };
    return window.addEventListener("scroll", i, !0), () => {
      window.removeEventListener("scroll", i, !0);
    };
  }, [
    r,
    n,
    t
  ]);
}
let We = typeof document < "u" && window.visualViewport;
function xS(e) {
  let { direction: t } = lt(), { arrowSize: r = 0, targetRef: n, overlayRef: i, scrollRef: a = i, placement: o = "bottom", containerPadding: s = 12, shouldFlip: u = !0, boundaryElement: l = typeof document < "u" ? document.body : null, offset: c = 0, crossOffset: d = 0, shouldUpdatePosition: f = !0, isOpen: h = !0, onClose: p, maxHeight: v, arrowBoundaryOffset: g = 0 } = e, [$, m] = re({
    position: {},
    arrowOffsetLeft: void 0,
    arrowOffsetTop: void 0,
    maxHeight: void 0,
    placement: void 0
  }), b = [
    f,
    o,
    i.current,
    n.current,
    a.current,
    s,
    u,
    l,
    c,
    d,
    h,
    t,
    v,
    g,
    r
  ], D = q(We == null ? void 0 : We.scale);
  ue(() => {
    h && (D.current = We == null ? void 0 : We.scale);
  }, [
    h
  ]);
  let S = ye(() => {
    if (f === !1 || !h || !i.current || !n.current || !a.current || !l || (We == null ? void 0 : We.scale) !== D.current) return;
    let y = i.current;
    if (!v && i.current) {
      var A;
      y.style.top = "0px", y.style.bottom = "";
      var w;
      y.style.maxHeight = ((w = (A = window.visualViewport) === null || A === void 0 ? void 0 : A.height) !== null && w !== void 0 ? w : window.innerHeight) + "px";
    }
    let E = gS({
      placement: ES(o, t),
      overlayNode: i.current,
      targetNode: n.current,
      scrollNode: a.current,
      padding: s,
      shouldFlip: u,
      boundaryElement: l,
      offset: c,
      crossOffset: d,
      maxHeight: v,
      arrowSize: r,
      arrowBoundaryOffset: g
    });
    y.style.top = "", y.style.bottom = "", Object.keys(E.position).forEach((k) => y.style[k] = E.position[k] + "px"), y.style.maxHeight = E.maxHeight != null ? E.maxHeight + "px" : void 0, m(E);
  }, b);
  Oe(S, b), DS(S), Os({
    ref: i,
    onResize: S
  });
  let T = q(!1);
  Oe(() => {
    let y, A = () => {
      T.current = !0, clearTimeout(y), y = setTimeout(() => {
        T.current = !1;
      }, 500), S();
    }, w = () => {
      T.current && A();
    };
    return We == null || We.addEventListener("resize", A), We == null || We.addEventListener("scroll", w), () => {
      We == null || We.removeEventListener("resize", A), We == null || We.removeEventListener("scroll", w);
    };
  }, [
    S
  ]);
  let R = ye(() => {
    T.current || p();
  }, [
    p,
    T
  ]);
  return $S({
    triggerRef: n,
    isOpen: h,
    onClose: p && R
  }), {
    overlayProps: {
      style: {
        position: "absolute",
        zIndex: 1e5,
        ...$.position,
        maxHeight: $.maxHeight
      }
    },
    placement: $.placement,
    arrowProps: {
      "aria-hidden": "true",
      role: "presentation",
      style: {
        left: $.arrowOffsetLeft,
        top: $.arrowOffsetTop
      }
    },
    updatePosition: S
  };
}
function DS(e) {
  Oe(() => (window.addEventListener("resize", e, !1), () => {
    window.removeEventListener("resize", e, !1);
  }), [
    e
  ]);
}
function ES(e, t) {
  return t === "rtl" ? e.replace("start", "right").replace("end", "left") : e.replace("start", "left").replace("end", "right");
}
const rr = [];
function wS(e, t) {
  let { onClose: r, shouldCloseOnBlur: n, isOpen: i, isDismissable: a = !1, isKeyboardDismissDisabled: o = !1, shouldCloseOnInteractOutside: s } = e;
  ue(() => (i && rr.push(t), () => {
    let p = rr.indexOf(t);
    p >= 0 && rr.splice(p, 1);
  }), [
    i,
    t
  ]);
  let u = () => {
    rr[rr.length - 1] === t && r && r();
  }, l = (p) => {
    (!s || s(p.target)) && rr[rr.length - 1] === t && (p.stopPropagation(), p.preventDefault());
  }, c = (p) => {
    (!s || s(p.target)) && (rr[rr.length - 1] === t && (p.stopPropagation(), p.preventDefault()), u());
  }, d = (p) => {
    p.key === "Escape" && !o && !p.nativeEvent.isComposing && (p.stopPropagation(), p.preventDefault(), u());
  };
  $6({
    ref: t,
    onInteractOutside: a && i ? c : null,
    onInteractOutsideStart: l
  });
  let { focusWithinProps: f } = ci({
    isDisabled: !n,
    onBlurWithin: (p) => {
      !p.relatedTarget || P6(p.relatedTarget) || (!s || s(p.relatedTarget)) && r();
    }
  }), h = (p) => {
    p.target === p.currentTarget && p.preventDefault();
  };
  return {
    overlayProps: {
      onKeyDown: d,
      ...f
    },
    underlayProps: {
      onPointerDown: h
    }
  };
}
function m0(e, t, r) {
  let { type: n } = e, { isOpen: i } = t;
  ue(() => {
    r && r.current && p0.set(r.current, t.close);
  });
  let a;
  n === "menu" ? a = !0 : n === "listbox" && (a = "listbox");
  let o = Ct();
  return {
    triggerProps: {
      "aria-haspopup": a,
      "aria-expanded": i,
      "aria-controls": i ? o : null,
      onPress: t.toggle
    },
    overlayProps: {
      id: o
    }
  };
}
const Wu = typeof document < "u" && window.visualViewport, CS = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
let oo = 0, Qu;
function SS(e = {}) {
  let { isDisabled: t } = e;
  Oe(() => {
    if (!t)
      return oo++, oo === 1 && (Ta() ? Qu = TS() : Qu = kS()), () => {
        oo--, oo === 0 && Qu();
      };
  }, [
    t
  ]);
}
function kS() {
  return zr(Nn(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), Nn(document.documentElement, "overflow", "hidden"));
}
function TS() {
  let e, t, r = (l) => {
    e = Is(l.target, !0), !(e === document.documentElement && e === document.body) && e instanceof HTMLElement && window.getComputedStyle(e).overscrollBehavior === "auto" && (t = Nn(e, "overscrollBehavior", "contain"));
  }, n = (l) => {
    if (!e || e === document.documentElement || e === document.body) {
      l.preventDefault();
      return;
    }
    e.scrollHeight === e.clientHeight && e.scrollWidth === e.clientWidth && l.preventDefault();
  }, i = (l) => {
    let c = l.target;
    cp(c) && c !== document.activeElement && (l.preventDefault(), s(), c.style.transform = "translateY(-2000px)", c.focus(), requestAnimationFrame(() => {
      c.style.transform = "";
    })), t && t();
  }, a = (l) => {
    let c = l.target;
    cp(c) && (s(), c.style.transform = "translateY(-2000px)", requestAnimationFrame(() => {
      c.style.transform = "", Wu && (Wu.height < window.innerHeight ? requestAnimationFrame(() => {
        lp(c);
      }) : Wu.addEventListener("resize", () => lp(c), {
        once: !0
      }));
    }));
  }, o = null, s = () => {
    if (o) return;
    let l = () => {
      window.scrollTo(0, 0);
    }, c = window.pageXOffset, d = window.pageYOffset;
    o = zr(Ci(window, "scroll", l), Nn(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), Nn(document.documentElement, "overflow", "hidden"), Nn(document.body, "marginTop", `-${d}px`), () => {
      window.scrollTo(c, d);
    }), window.scrollTo(0, 0);
  }, u = zr(Ci(document, "touchstart", r, {
    passive: !1,
    capture: !0
  }), Ci(document, "touchmove", n, {
    passive: !1,
    capture: !0
  }), Ci(document, "touchend", i, {
    passive: !1,
    capture: !0
  }), Ci(document, "focus", a, !0));
  return () => {
    t == null || t(), o == null || o(), u();
  };
}
function Nn(e, t, r) {
  let n = e.style[t];
  return e.style[t] = r, () => {
    e.style[t] = n;
  };
}
function Ci(e, t, r, n) {
  return e.addEventListener(t, r, n), () => {
    e.removeEventListener(t, r, n);
  };
}
function lp(e) {
  let t = document.scrollingElement || document.documentElement;
  for (; e && e !== t; ) {
    let r = Is(e);
    if (r !== document.documentElement && r !== document.body && r !== e) {
      let n = r.getBoundingClientRect().top, i = e.getBoundingClientRect().top;
      i > n + e.clientHeight && (r.scrollTop += i - n);
    }
    e = r.parentElement;
  }
}
function cp(e) {
  return e instanceof HTMLInputElement && !CS.has(e.type) || e instanceof HTMLTextAreaElement || e instanceof HTMLElement && e.isContentEditable;
}
var v0 = {};
v0 = {
  dismiss: "تجاهل"
};
var y0 = {};
y0 = {
  dismiss: "Отхвърляне"
};
var g0 = {};
g0 = {
  dismiss: "Odstranit"
};
var b0 = {};
b0 = {
  dismiss: "Luk"
};
var $0 = {};
$0 = {
  dismiss: "Schließen"
};
var x0 = {};
x0 = {
  dismiss: "Απόρριψη"
};
var D0 = {};
D0 = {
  dismiss: "Dismiss"
};
var E0 = {};
E0 = {
  dismiss: "Descartar"
};
var w0 = {};
w0 = {
  dismiss: "Lõpeta"
};
var C0 = {};
C0 = {
  dismiss: "Hylkää"
};
var S0 = {};
S0 = {
  dismiss: "Rejeter"
};
var k0 = {};
k0 = {
  dismiss: "התעלם"
};
var T0 = {};
T0 = {
  dismiss: "Odbaci"
};
var P0 = {};
P0 = {
  dismiss: "Elutasítás"
};
var A0 = {};
A0 = {
  dismiss: "Ignora"
};
var _0 = {};
_0 = {
  dismiss: "閉じる"
};
var F0 = {};
F0 = {
  dismiss: "무시"
};
var O0 = {};
O0 = {
  dismiss: "Atmesti"
};
var I0 = {};
I0 = {
  dismiss: "Nerādīt"
};
var R0 = {};
R0 = {
  dismiss: "Lukk"
};
var B0 = {};
B0 = {
  dismiss: "Negeren"
};
var M0 = {};
M0 = {
  dismiss: "Zignoruj"
};
var N0 = {};
N0 = {
  dismiss: "Descartar"
};
var L0 = {};
L0 = {
  dismiss: "Dispensar"
};
var V0 = {};
V0 = {
  dismiss: "Revocare"
};
var j0 = {};
j0 = {
  dismiss: "Пропустить"
};
var z0 = {};
z0 = {
  dismiss: "Zrušiť"
};
var K0 = {};
K0 = {
  dismiss: "Opusti"
};
var U0 = {};
U0 = {
  dismiss: "Odbaci"
};
var q0 = {};
q0 = {
  dismiss: "Avvisa"
};
var H0 = {};
H0 = {
  dismiss: "Kapat"
};
var W0 = {};
W0 = {
  dismiss: "Скасувати"
};
var Q0 = {};
Q0 = {
  dismiss: "取消"
};
var G0 = {};
G0 = {
  dismiss: "關閉"
};
var Z0 = {};
Z0 = {
  "ar-AE": v0,
  "bg-BG": y0,
  "cs-CZ": g0,
  "da-DK": b0,
  "de-DE": $0,
  "el-GR": x0,
  "en-US": D0,
  "es-ES": E0,
  "et-EE": w0,
  "fi-FI": C0,
  "fr-FR": S0,
  "he-IL": k0,
  "hr-HR": T0,
  "hu-HU": P0,
  "it-IT": A0,
  "ja-JP": _0,
  "ko-KR": F0,
  "lt-LT": O0,
  "lv-LV": I0,
  "nb-NO": R0,
  "nl-NL": B0,
  "pl-PL": M0,
  "pt-BR": N0,
  "pt-PT": L0,
  "ro-RO": V0,
  "ru-RU": j0,
  "sk-SK": z0,
  "sl-SI": K0,
  "sr-SP": U0,
  "sv-SE": q0,
  "tr-TR": H0,
  "uk-UA": W0,
  "zh-CN": Q0,
  "zh-TW": G0
};
const dp = {
  border: 0,
  clip: "rect(0 0 0 0)",
  clipPath: "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap"
};
function Y0(e = {}) {
  let { style: t, isFocusable: r } = e, [n, i] = re(!1), { focusWithinProps: a } = ci({
    isDisabled: !r,
    onFocusWithinChange: (s) => i(s)
  }), o = G(() => n ? t : t ? {
    ...dp,
    ...t
  } : dp, [
    n
  ]);
  return {
    visuallyHiddenProps: {
      ...a,
      style: o
    }
  };
}
function sc(e) {
  let { children: t, elementType: r = "div", isFocusable: n, style: i, ...a } = e, { visuallyHiddenProps: o } = Y0(e);
  return /* @__PURE__ */ F.createElement(r, ge(a, o), t);
}
function PS(e) {
  return e && e.__esModule ? e.default : e;
}
function fp(e) {
  let { onDismiss: t, ...r } = e, n = zt(PS(Z0), "@react-aria/overlays"), i = cn(r, n.format("dismiss")), a = () => {
    t && t();
  };
  return /* @__PURE__ */ F.createElement(sc, null, /* @__PURE__ */ F.createElement("button", {
    ...i,
    tabIndex: -1,
    onClick: a,
    style: {
      width: 1,
      height: 1
    }
  }));
}
let Si = /* @__PURE__ */ new WeakMap(), St = [];
function J0(e, t = document.body) {
  let r = new Set(e), n = /* @__PURE__ */ new Set(), i = (u) => {
    for (let f of u.querySelectorAll("[data-live-announcer], [data-react-aria-top-layer]")) r.add(f);
    let l = (f) => {
      if (r.has(f) || n.has(f.parentElement) && f.parentElement.getAttribute("role") !== "row") return NodeFilter.FILTER_REJECT;
      for (let h of r)
        if (f.contains(h)) return NodeFilter.FILTER_SKIP;
      return NodeFilter.FILTER_ACCEPT;
    }, c = document.createTreeWalker(u, NodeFilter.SHOW_ELEMENT, {
      acceptNode: l
    }), d = l(u);
    if (d === NodeFilter.FILTER_ACCEPT && a(u), d !== NodeFilter.FILTER_REJECT) {
      let f = c.nextNode();
      for (; f != null; )
        a(f), f = c.nextNode();
    }
  }, a = (u) => {
    var l;
    let c = (l = Si.get(u)) !== null && l !== void 0 ? l : 0;
    u.getAttribute("aria-hidden") === "true" && c === 0 || (c === 0 && u.setAttribute("aria-hidden", "true"), n.add(u), Si.set(u, c + 1));
  };
  St.length && St[St.length - 1].disconnect(), i(t);
  let o = new MutationObserver((u) => {
    for (let l of u)
      if (!(l.type !== "childList" || l.addedNodes.length === 0) && ![
        ...r,
        ...n
      ].some((c) => c.contains(l.target))) {
        for (let c of l.removedNodes) c instanceof Element && (r.delete(c), n.delete(c));
        for (let c of l.addedNodes)
          (c instanceof HTMLElement || c instanceof SVGElement) && (c.dataset.liveAnnouncer === "true" || c.dataset.reactAriaTopLayer === "true") ? r.add(c) : c instanceof Element && i(c);
      }
  });
  o.observe(t, {
    childList: !0,
    subtree: !0
  });
  let s = {
    observe() {
      o.observe(t, {
        childList: !0,
        subtree: !0
      });
    },
    disconnect() {
      o.disconnect();
    }
  };
  return St.push(s), () => {
    o.disconnect();
    for (let u of n) {
      let l = Si.get(u);
      l === 1 ? (u.removeAttribute("aria-hidden"), Si.delete(u)) : Si.set(u, l - 1);
    }
    s === St[St.length - 1] ? (St.pop(), St.length && St[St.length - 1].observe()) : St.splice(St.indexOf(s), 1);
  };
}
function AS(e, t) {
  let { triggerRef: r, popoverRef: n, isNonModal: i, isKeyboardDismissDisabled: a, shouldCloseOnInteractOutside: o, ...s } = e, { overlayProps: u, underlayProps: l } = wS({
    isOpen: t.isOpen,
    onClose: t.close,
    shouldCloseOnBlur: !0,
    isDismissable: !i,
    isKeyboardDismissDisabled: a,
    shouldCloseOnInteractOutside: o
  }, n), { overlayProps: c, arrowProps: d, placement: f } = xS({
    ...s,
    targetRef: r,
    overlayRef: n,
    isOpen: t.isOpen,
    onClose: i ? t.close : null
  });
  return SS({
    isDisabled: i || !t.isOpen
  }), Oe(() => {
    if (t.isOpen && !i && n.current) return J0([
      n.current
    ]);
  }, [
    i,
    t.isOpen,
    n
  ]), {
    popoverProps: ge(u, c),
    arrowProps: d,
    underlayProps: l,
    placement: f
  };
}
const _S = /* @__PURE__ */ de({});
function FS() {
  var e;
  return (e = ce(_S)) !== null && e !== void 0 ? e : {};
}
const X0 = /* @__PURE__ */ F.createContext(null);
function OS(e) {
  let t = vn(), { portalContainer: r = t ? null : document.body, isExiting: n } = e, [i, a] = re(!1), o = G(() => ({
    contain: i,
    setContain: a
  }), [
    i,
    a
  ]), { getContainer: s } = FS();
  if (!e.portalContainer && s && (r = s()), !r) return null;
  let u = e.children;
  return e.disableFocusManagement || (u = /* @__PURE__ */ F.createElement(fy, {
    restoreFocus: !0,
    contain: i && !n
  }, u)), u = /* @__PURE__ */ F.createElement(X0.Provider, {
    value: o
  }, /* @__PURE__ */ F.createElement(c6, null, u)), /* @__PURE__ */ xc.createPortal(u, r);
}
function IS() {
  let e = ce(X0), t = e == null ? void 0 : e.setContain;
  Oe(() => {
    t == null || t(!0);
  }, [
    t
  ]);
}
const Ks = /* @__PURE__ */ new WeakMap();
function RS(e) {
  return typeof e == "string" ? e.replace(/\s*/g, "") : "" + e;
}
function eb(e, t) {
  let r = Ks.get(e);
  if (!r) throw new Error("Unknown list");
  return `${r.id}-option-${RS(t)}`;
}
function uc(e) {
  return $o() ? e.altKey : e.ctrlKey;
}
function An(e) {
  return yr() ? e.metaKey : e.ctrlKey;
}
const BS = 1e3;
function tb(e) {
  let { keyboardDelegate: t, selectionManager: r, onTypeSelect: n } = e, i = q({
    search: "",
    timeout: null
  }).current, a = (o) => {
    let s = MS(o.key);
    if (!s || o.ctrlKey || o.metaKey || !o.currentTarget.contains(o.target)) return;
    s === " " && i.search.trim().length > 0 && (o.preventDefault(), "continuePropagation" in o || o.stopPropagation()), i.search += s;
    let u = t.getKeyForSearch(i.search, r.focusedKey);
    u == null && (u = t.getKeyForSearch(i.search)), u != null && (r.setFocusedKey(u), n && n(u)), clearTimeout(i.timeout), i.timeout = setTimeout(() => {
      i.search = "";
    }, BS);
  };
  return {
    typeSelectProps: {
      // Using a capturing listener to catch the keydown event before
      // other hooks in order to handle the Spacebar event.
      onKeyDownCapture: t.getKeyForSearch ? a : null
    }
  };
}
function MS(e) {
  return e.length === 1 || !/^[A-Z]/i.test(e) ? e : "";
}
function rb(e) {
  let { selectionManager: t, keyboardDelegate: r, ref: n, autoFocus: i = !1, shouldFocusWrap: a = !1, disallowEmptySelection: o = !1, disallowSelectAll: s = !1, selectOnFocus: u = t.selectionBehavior === "replace", disallowTypeAhead: l = !1, shouldUseVirtualFocus: c, allowsTabNavigation: d = !1, isVirtualized: f, scrollRef: h = n, linkBehavior: p = "action" } = e, { direction: v } = lt(), g = Fs(), $ = (w) => {
    if (w.altKey && w.key === "Tab" && w.preventDefault(), !n.current.contains(w.target)) return;
    const E = (j, ae) => {
      if (j != null) {
        if (t.isLink(j) && p === "selection" && u && !uc(w)) {
          x$(() => {
            t.setFocusedKey(j, ae);
          });
          let ne = h.current.querySelector(`[data-key="${CSS.escape(j.toString())}"]`), me = t.getItemProps(j);
          g.open(ne, w, me.href, me.routerOptions);
          return;
        }
        if (t.setFocusedKey(j, ae), t.isLink(j) && p === "override") return;
        w.shiftKey && t.selectionMode === "multiple" ? t.extendSelection(j) : u && !uc(w) && t.replaceSelection(j);
      }
    };
    switch (w.key) {
      case "ArrowDown":
        if (r.getKeyBelow) {
          var k, C;
          w.preventDefault();
          let j = t.focusedKey != null ? r.getKeyBelow(t.focusedKey) : (k = r.getFirstKey) === null || k === void 0 ? void 0 : k.call(r);
          j == null && a && (j = (C = r.getFirstKey) === null || C === void 0 ? void 0 : C.call(r, t.focusedKey)), E(j);
        }
        break;
      case "ArrowUp":
        if (r.getKeyAbove) {
          var P, L;
          w.preventDefault();
          let j = t.focusedKey != null ? r.getKeyAbove(t.focusedKey) : (P = r.getLastKey) === null || P === void 0 ? void 0 : P.call(r);
          j == null && a && (j = (L = r.getLastKey) === null || L === void 0 ? void 0 : L.call(r, t.focusedKey)), E(j);
        }
        break;
      case "ArrowLeft":
        if (r.getKeyLeftOf) {
          var O, x;
          w.preventDefault();
          let j = r.getKeyLeftOf(t.focusedKey);
          j == null && a && (j = v === "rtl" ? (O = r.getFirstKey) === null || O === void 0 ? void 0 : O.call(r, t.focusedKey) : (x = r.getLastKey) === null || x === void 0 ? void 0 : x.call(r, t.focusedKey)), E(j, v === "rtl" ? "first" : "last");
        }
        break;
      case "ArrowRight":
        if (r.getKeyRightOf) {
          var U, K;
          w.preventDefault();
          let j = r.getKeyRightOf(t.focusedKey);
          j == null && a && (j = v === "rtl" ? (U = r.getLastKey) === null || U === void 0 ? void 0 : U.call(r, t.focusedKey) : (K = r.getFirstKey) === null || K === void 0 ? void 0 : K.call(r, t.focusedKey)), E(j, v === "rtl" ? "last" : "first");
        }
        break;
      case "Home":
        if (r.getFirstKey) {
          w.preventDefault();
          let j = r.getFirstKey(t.focusedKey, An(w));
          t.setFocusedKey(j), An(w) && w.shiftKey && t.selectionMode === "multiple" ? t.extendSelection(j) : u && t.replaceSelection(j);
        }
        break;
      case "End":
        if (r.getLastKey) {
          w.preventDefault();
          let j = r.getLastKey(t.focusedKey, An(w));
          t.setFocusedKey(j), An(w) && w.shiftKey && t.selectionMode === "multiple" ? t.extendSelection(j) : u && t.replaceSelection(j);
        }
        break;
      case "PageDown":
        if (r.getKeyPageBelow) {
          w.preventDefault();
          let j = r.getKeyPageBelow(t.focusedKey);
          E(j);
        }
        break;
      case "PageUp":
        if (r.getKeyPageAbove) {
          w.preventDefault();
          let j = r.getKeyPageAbove(t.focusedKey);
          E(j);
        }
        break;
      case "a":
        An(w) && t.selectionMode === "multiple" && s !== !0 && (w.preventDefault(), t.selectAll());
        break;
      case "Escape":
        !o && t.selectedKeys.size !== 0 && (w.stopPropagation(), w.preventDefault(), t.clearSelection());
        break;
      case "Tab":
        if (!d) {
          if (w.shiftKey) n.current.focus();
          else {
            let j = gt(n.current, {
              tabbable: !0
            }), ae, ne;
            do
              ne = j.lastChild(), ne && (ae = ne);
            while (ne);
            ae && !ae.contains(document.activeElement) && Ht(ae);
          }
          break;
        }
    }
  }, m = q({
    top: 0,
    left: 0
  });
  Un(h, "scroll", f ? null : () => {
    m.current = {
      top: h.current.scrollTop,
      left: h.current.scrollLeft
    };
  });
  let b = (w) => {
    if (t.isFocused) {
      w.currentTarget.contains(w.target) || t.setFocused(!1);
      return;
    }
    if (w.currentTarget.contains(w.target)) {
      if (t.setFocused(!0), t.focusedKey == null) {
        let C = (L) => {
          L != null && (t.setFocusedKey(L), u && t.replaceSelection(L));
        }, P = w.relatedTarget;
        var E, k;
        P && w.currentTarget.compareDocumentPosition(P) & Node.DOCUMENT_POSITION_FOLLOWING ? C((E = t.lastSelectedKey) !== null && E !== void 0 ? E : r.getLastKey()) : C((k = t.firstSelectedKey) !== null && k !== void 0 ? k : r.getFirstKey());
      } else f || (h.current.scrollTop = m.current.top, h.current.scrollLeft = m.current.left);
      if (!f && t.focusedKey != null) {
        let C = h.current.querySelector(`[data-key="${CSS.escape(t.focusedKey.toString())}"]`);
        C && (C.contains(document.activeElement) || Ht(C), ns() === "keyboard" && Xo(C, {
          containingElement: n.current
        }));
      }
    }
  }, D = (w) => {
    w.currentTarget.contains(w.relatedTarget) || t.setFocused(!1);
  };
  const S = q(i);
  ue(() => {
    if (S.current) {
      let w = null;
      i === "first" && (w = r.getFirstKey()), i === "last" && (w = r.getLastKey());
      let E = t.selectedKeys;
      if (E.size) {
        for (let k of E) if (t.canSelectItem(k)) {
          w = k;
          break;
        }
      }
      t.setFocused(!0), t.setFocusedKey(w), w == null && !c && fn(n.current);
    }
  }, []);
  let T = q(t.focusedKey);
  ue(() => {
    let w = ns();
    if (t.isFocused && t.focusedKey != null && (h != null && h.current)) {
      let E = h.current.querySelector(`[data-key="${CSS.escape(t.focusedKey.toString())}"]`);
      E && (w === "keyboard" || S.current) && (f || Xv(h.current, E), w !== "virtual" && Xo(E, {
        containingElement: n.current
      }));
    }
    t.isFocused && t.focusedKey == null && T.current != null && fn(n.current), T.current = t.focusedKey, S.current = !1;
  }, [
    f,
    h,
    t.focusedKey,
    t.isFocused,
    n
  ]);
  let R = {
    onKeyDown: $,
    onFocus: b,
    onBlur: D,
    onMouseDown(w) {
      h.current === w.target && w.preventDefault();
    }
  }, { typeSelectProps: y } = tb({
    keyboardDelegate: r,
    selectionManager: t
  });
  l || (R = ge(y, R));
  let A;
  return c || (A = t.focusedKey == null ? 0 : -1), {
    collectionProps: {
      ...R,
      tabIndex: A
    }
  };
}
function NS(e) {
  let { selectionManager: t, key: r, ref: n, shouldSelectOnPressUp: i, shouldUseVirtualFocus: a, focus: o, isDisabled: s, onAction: u, allowsDifferentPressOrigin: l, linkBehavior: c = "action" } = e, d = Fs(), f = (x) => {
    if (x.pointerType === "keyboard" && uc(x)) t.toggleSelection(r);
    else {
      if (t.selectionMode === "none") return;
      if (t.isLink(r)) {
        if (c === "selection") {
          let U = t.getItemProps(r);
          d.open(n.current, x, U.href, U.routerOptions), t.setSelectedKeys(t.selectedKeys);
          return;
        } else if (c === "override" || c === "none") return;
      }
      t.selectionMode === "single" ? t.isSelected(r) && !t.disallowEmptySelection ? t.toggleSelection(r) : t.replaceSelection(r) : x && x.shiftKey ? t.extendSelection(r) : t.selectionBehavior === "toggle" || x && (An(x) || x.pointerType === "touch" || x.pointerType === "virtual") ? t.toggleSelection(r) : t.replaceSelection(r);
    }
  };
  ue(() => {
    r === t.focusedKey && t.isFocused && !a && (o ? o() : document.activeElement !== n.current && fn(n.current));
  }, [
    n,
    r,
    t.focusedKey,
    t.childFocusStrategy,
    t.isFocused,
    a
  ]), s = s || t.isDisabled(r);
  let h = {};
  !a && !s ? h = {
    tabIndex: r === t.focusedKey ? 0 : -1,
    onFocus(x) {
      x.target === n.current && t.setFocusedKey(r);
    }
  } : s && (h.onMouseDown = (x) => {
    x.preventDefault();
  });
  let p = t.isLink(r) && c === "override", v = t.isLink(r) && c !== "selection" && c !== "none", g = !s && t.canSelectItem(r) && !p, $ = (u || v) && !s, m = $ && (t.selectionBehavior === "replace" ? !g : !g || t.isEmpty), b = $ && g && t.selectionBehavior === "replace", D = m || b, S = q(null), T = D && g, R = q(!1), y = q(!1), A = (x) => {
    if (u && u(), v) {
      let U = t.getItemProps(r);
      d.open(n.current, x, U.href, U.routerOptions);
    }
  }, w = {};
  i ? (w.onPressStart = (x) => {
    S.current = x.pointerType, R.current = T, x.pointerType === "keyboard" && (!D || pp()) && f(x);
  }, l ? (w.onPressUp = m ? null : (x) => {
    x.pointerType !== "keyboard" && g && f(x);
  }, w.onPress = m ? A : null) : w.onPress = (x) => {
    if (m || b && x.pointerType !== "mouse") {
      if (x.pointerType === "keyboard" && !hp()) return;
      A(x);
    } else x.pointerType !== "keyboard" && g && f(x);
  }) : (w.onPressStart = (x) => {
    S.current = x.pointerType, R.current = T, y.current = m, g && (x.pointerType === "mouse" && !m || x.pointerType === "keyboard" && (!$ || pp())) && f(x);
  }, w.onPress = (x) => {
    (x.pointerType === "touch" || x.pointerType === "pen" || x.pointerType === "virtual" || x.pointerType === "keyboard" && D && hp() || x.pointerType === "mouse" && y.current) && (D ? A(x) : g && f(x));
  }), h["data-key"] = r, w.preventFocusOnPress = a;
  let { pressProps: E, isPressed: k } = _a(w), C = b ? (x) => {
    S.current === "mouse" && (x.stopPropagation(), x.preventDefault(), A(x));
  } : void 0, { longPressProps: P } = cy({
    isDisabled: !T,
    onLongPress(x) {
      x.pointerType === "touch" && (f(x), t.setSelectionBehavior("toggle"));
    }
  }), L = (x) => {
    S.current === "touch" && R.current && x.preventDefault();
  }, O = t.isLink(r) ? (x) => {
    ln.isOpening || x.preventDefault();
  } : void 0;
  return {
    itemProps: ge(h, g || m ? E : {}, T ? P : {}, {
      onDoubleClick: C,
      onDragStartCapture: L,
      onClick: O
    }),
    isPressed: k,
    isSelected: t.isSelected(r),
    isFocused: t.isFocused && t.focusedKey === r,
    isDisabled: s,
    allowsSelection: g,
    hasAction: D
  };
}
function hp() {
  let e = window.event;
  return (e == null ? void 0 : e.key) === "Enter";
}
function pp() {
  let e = window.event;
  return (e == null ? void 0 : e.key) === " " || (e == null ? void 0 : e.code) === "Space";
}
class Us {
  isDisabled(t) {
    var r;
    return this.disabledBehavior === "all" && (((r = t.props) === null || r === void 0 ? void 0 : r.isDisabled) || this.disabledKeys.has(t.key));
  }
  getNextKey(t) {
    for (t = this.collection.getKeyAfter(t); t != null; ) {
      let r = this.collection.getItem(t);
      if (r.type === "item" && !this.isDisabled(r)) return t;
      t = this.collection.getKeyAfter(t);
    }
    return null;
  }
  getPreviousKey(t) {
    for (t = this.collection.getKeyBefore(t); t != null; ) {
      let r = this.collection.getItem(t);
      if (r.type === "item" && !this.isDisabled(r)) return t;
      t = this.collection.getKeyBefore(t);
    }
    return null;
  }
  findKey(t, r, n) {
    let i = this.getItem(t);
    if (!i) return null;
    let a = i.getBoundingClientRect();
    do
      t = r(t), i = this.getItem(t);
    while (i && n(a, i.getBoundingClientRect()));
    return t;
  }
  isSameRow(t, r) {
    return t.top === r.top || t.left !== r.left;
  }
  isSameColumn(t, r) {
    return t.left === r.left || t.top !== r.top;
  }
  getKeyBelow(t) {
    return this.layout === "grid" && this.orientation === "vertical" ? this.findKey(t, (r) => this.getNextKey(r), this.isSameRow) : this.getNextKey(t);
  }
  getKeyAbove(t) {
    return this.layout === "grid" && this.orientation === "vertical" ? this.findKey(t, (r) => this.getPreviousKey(r), this.isSameRow) : this.getPreviousKey(t);
  }
  getNextColumn(t, r) {
    return r ? this.getPreviousKey(t) : this.getNextKey(t);
  }
  getKeyRightOf(t) {
    return this.layout === "grid" ? this.orientation === "vertical" ? this.getNextColumn(t, this.direction === "rtl") : this.findKey(t, (r) => this.getNextColumn(r, this.direction === "rtl"), this.isSameColumn) : this.orientation === "horizontal" ? this.getNextColumn(t, this.direction === "rtl") : null;
  }
  getKeyLeftOf(t) {
    return this.layout === "grid" ? this.orientation === "vertical" ? this.getNextColumn(t, this.direction === "ltr") : this.findKey(t, (r) => this.getNextColumn(r, this.direction === "ltr"), this.isSameColumn) : this.orientation === "horizontal" ? this.getNextColumn(t, this.direction === "ltr") : null;
  }
  getFirstKey() {
    let t = this.collection.getFirstKey();
    for (; t != null; ) {
      let r = this.collection.getItem(t);
      if ((r == null ? void 0 : r.type) === "item" && !this.isDisabled(r)) return t;
      t = this.collection.getKeyAfter(t);
    }
    return null;
  }
  getLastKey() {
    let t = this.collection.getLastKey();
    for (; t != null; ) {
      let r = this.collection.getItem(t);
      if (r.type === "item" && !this.isDisabled(r)) return t;
      t = this.collection.getKeyBefore(t);
    }
    return null;
  }
  getItem(t) {
    return t !== null ? this.ref.current.querySelector(`[data-key="${CSS.escape(t.toString())}"]`) : null;
  }
  getKeyPageAbove(t) {
    let r = this.ref.current, n = this.getItem(t);
    if (!n) return null;
    if (!la(r)) return this.getFirstKey();
    let i = r.getBoundingClientRect(), a = n.getBoundingClientRect();
    if (this.orientation === "horizontal") {
      let o = i.x - r.scrollLeft, s = Math.max(0, a.x - o + a.width - i.width);
      for (; n && a.x - o > s; )
        t = this.getKeyAbove(t), n = t == null ? null : this.getItem(t), a = n == null ? void 0 : n.getBoundingClientRect();
    } else {
      let o = i.y - r.scrollTop, s = Math.max(0, a.y - o + a.height - i.height);
      for (; n && a.y - o > s; )
        t = this.getKeyAbove(t), n = t == null ? null : this.getItem(t), a = n == null ? void 0 : n.getBoundingClientRect();
    }
    return t ?? this.getFirstKey();
  }
  getKeyPageBelow(t) {
    let r = this.ref.current, n = this.getItem(t);
    if (!n) return null;
    if (!la(r)) return this.getLastKey();
    let i = r.getBoundingClientRect(), a = n.getBoundingClientRect();
    if (this.orientation === "horizontal") {
      let o = i.x - r.scrollLeft, s = Math.min(r.scrollWidth, a.x - o - a.width + i.width);
      for (; n && a.x - o < s; )
        t = this.getKeyBelow(t), n = t == null ? null : this.getItem(t), a = n == null ? void 0 : n.getBoundingClientRect();
    } else {
      let o = i.y - r.scrollTop, s = Math.min(r.scrollHeight, a.y - o - a.height + i.height);
      for (; n && a.y - o < s; )
        t = this.getKeyBelow(t), n = t == null ? null : this.getItem(t), a = n == null ? void 0 : n.getBoundingClientRect();
    }
    return t ?? this.getLastKey();
  }
  getKeyForSearch(t, r) {
    if (!this.collator) return null;
    let n = this.collection, i = r || this.getFirstKey();
    for (; i != null; ) {
      let a = n.getItem(i), o = a.textValue.slice(0, t.length);
      if (a.textValue && this.collator.compare(o, t) === 0) return i;
      i = this.getKeyBelow(i);
    }
    return null;
  }
  constructor(...t) {
    if (t.length === 1) {
      let r = t[0];
      this.collection = r.collection, this.ref = r.ref, this.collator = r.collator, this.disabledKeys = r.disabledKeys || /* @__PURE__ */ new Set(), this.disabledBehavior = r.disabledBehavior || "all", this.orientation = r.orientation, this.direction = r.direction, this.layout = r.layout || "stack";
    } else
      this.collection = t[0], this.disabledKeys = t[1], this.ref = t[2], this.collator = t[3], this.layout = "stack", this.orientation = "vertical", this.disabledBehavior = "all";
    this.layout === "stack" && this.orientation === "vertical" && (this.getKeyLeftOf = void 0, this.getKeyRightOf = void 0);
  }
}
function LS(e) {
  let { selectionManager: t, collection: r, disabledKeys: n, ref: i, keyboardDelegate: a } = e, o = Vs({
    usage: "search",
    sensitivity: "base"
  }), s = t.disabledBehavior, u = G(() => a || new Us({
    collection: r,
    disabledKeys: n,
    disabledBehavior: s,
    ref: i,
    collator: o
  }), [
    a,
    r,
    n,
    i,
    o,
    s
  ]), { collectionProps: l } = rb({
    ...e,
    ref: i,
    selectionManager: t,
    keyboardDelegate: u
  });
  return {
    listProps: l
  };
}
function VS(e, t, r) {
  let n = Me(e, {
    labelable: !0
  }), i = e.selectionBehavior || "toggle", a = e.linkBehavior || (i === "replace" ? "action" : "override");
  i === "toggle" && a === "action" && (a = "override");
  let { listProps: o } = LS({
    ...e,
    ref: r,
    selectionManager: t.selectionManager,
    collection: t.collection,
    disabledKeys: t.disabledKeys,
    linkBehavior: a
  }), { focusWithinProps: s } = ci({
    onFocusWithin: e.onFocus,
    onBlurWithin: e.onBlur,
    onFocusWithinChange: e.onFocusChange
  }), u = Ct(e.id);
  Ks.set(t, {
    id: u,
    shouldUseVirtualFocus: e.shouldUseVirtualFocus,
    shouldSelectOnPressUp: e.shouldSelectOnPressUp,
    shouldFocusOnHover: e.shouldFocusOnHover,
    isVirtualized: e.isVirtualized,
    onAction: e.onAction,
    linkBehavior: a
  });
  let { labelProps: l, fieldProps: c } = _g({
    ...e,
    id: u,
    // listbox is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span"
  });
  return {
    labelProps: l,
    listBoxProps: ge(n, s, t.selectionManager.selectionMode === "multiple" ? {
      "aria-multiselectable": "true"
    } : {}, {
      role: "listbox",
      ...ge(c, o)
    })
  };
}
class jS {
  build(t, r) {
    return this.context = r, mp(() => this.iterateCollection(t));
  }
  *iterateCollection(t) {
    let { children: r, items: n } = t;
    if (typeof r == "function") {
      if (!n) throw new Error("props.children was a function but props.items is missing");
      for (let i of t.items) yield* this.getFullNode({
        value: i
      }, {
        renderer: r
      });
    } else {
      let i = [];
      F.Children.forEach(r, (o) => {
        i.push(o);
      });
      let a = 0;
      for (let o of i) {
        let s = this.getFullNode({
          element: o,
          index: a
        }, {});
        for (let u of s)
          a++, yield u;
      }
    }
  }
  getKey(t, r, n, i) {
    if (t.key != null) return t.key;
    if (r.type === "cell" && r.key != null) return `${i}${r.key}`;
    let a = r.value;
    if (a != null) {
      var o;
      let s = (o = a.key) !== null && o !== void 0 ? o : a.id;
      if (s == null) throw new Error("No key found for item");
      return s;
    }
    return i ? `${i}.${r.index}` : `$.${r.index}`;
  }
  getChildState(t, r) {
    return {
      renderer: r.renderer || t.renderer
    };
  }
  *getFullNode(t, r, n, i) {
    let a = t.element;
    if (!a && t.value && r && r.renderer) {
      let u = this.cache.get(t.value);
      if (u && (!u.shouldInvalidate || !u.shouldInvalidate(this.context))) {
        u.index = t.index, u.parentKey = i ? i.key : null, yield u;
        return;
      }
      a = r.renderer(t.value);
    }
    if (F.isValidElement(a)) {
      let u = a.type;
      if (typeof u != "function" && typeof u.getCollectionNode != "function") {
        let f = typeof a.type == "function" ? a.type.name : a.type;
        throw new Error(`Unknown element <${f}> in collection.`);
      }
      let l = u.getCollectionNode(a.props, this.context), c = t.index, d = l.next();
      for (; !d.done && d.value; ) {
        let f = d.value;
        t.index = c;
        let h = f.key;
        h || (h = f.element ? null : this.getKey(a, t, r, n));
        let v = [
          ...this.getFullNode({
            ...f,
            key: h,
            index: c,
            wrapper: zS(t.wrapper, f.wrapper)
          }, this.getChildState(r, f), n ? `${n}${a.key}` : a.key, i)
        ];
        for (let g of v) {
          if (g.value = f.value || t.value, g.value && this.cache.set(g.value, g), t.type && g.type !== t.type) throw new Error(`Unsupported type <${Gu(g.type)}> in <${Gu(i.type)}>. Only <${Gu(t.type)}> is supported.`);
          c++, yield g;
        }
        d = l.next(v);
      }
      return;
    }
    if (t.key == null) return;
    let o = this, s = {
      type: t.type,
      props: t.props,
      key: t.key,
      parentKey: i ? i.key : null,
      value: t.value,
      level: i ? i.level + 1 : 0,
      index: t.index,
      rendered: t.rendered,
      textValue: t.textValue,
      "aria-label": t["aria-label"],
      wrapper: t.wrapper,
      shouldInvalidate: t.shouldInvalidate,
      hasChildNodes: t.hasChildNodes,
      childNodes: mp(function* () {
        if (!t.hasChildNodes) return;
        let u = 0;
        for (let l of t.childNodes()) {
          l.key != null && (l.key = `${s.key}${l.key}`), l.index = u;
          let c = o.getFullNode(l, o.getChildState(r, l), s.key, s);
          for (let d of c)
            u++, yield d;
        }
      })
    };
    yield s;
  }
  constructor() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
}
function mp(e) {
  let t = [], r = null;
  return {
    *[Symbol.iterator]() {
      for (let n of t) yield n;
      r || (r = e());
      for (let n of r)
        t.push(n), yield n;
    }
  };
}
function zS(e, t) {
  if (e && t) return (r) => e(t(r));
  if (e) return e;
  if (t) return t;
}
function Gu(e) {
  return e[0].toUpperCase() + e.slice(1);
}
function KS(e, t, r) {
  let n = G(() => new jS(), []), { children: i, items: a, collection: o } = e;
  return G(() => {
    if (o) return o;
    let u = n.build({
      children: i,
      items: a
    }, r);
    return t(u);
  }, [
    n,
    i,
    a,
    o,
    r,
    t
  ]);
}
function qs(e, t) {
  return typeof t.getChildren == "function" ? t.getChildren(e.key) : e.childNodes;
}
function US(e) {
  return qS(e);
}
function qS(e, t) {
  for (let r of e)
    return r;
}
function Zu(e, t, r) {
  if (t.parentKey === r.parentKey) return t.index - r.index;
  let n = [
    ...vp(e, t),
    t
  ], i = [
    ...vp(e, r),
    r
  ], a = n.slice(0, i.length).findIndex((o, s) => o !== i[s]);
  return a !== -1 ? (t = n[a], r = i[a], t.index - r.index) : n.findIndex((o) => o === r) >= 0 ? 1 : (i.findIndex((o) => o === t) >= 0, -1);
}
function vp(e, t) {
  let r = [];
  for (; (t == null ? void 0 : t.parentKey) != null; )
    t = e.getItem(t.parentKey), r.unshift(t);
  return r;
}
const yp = /* @__PURE__ */ new WeakMap();
function nb(e) {
  let t = yp.get(e);
  if (t != null) return t;
  t = 0;
  let r = (n) => {
    for (let i of n) i.type === "section" ? r(qs(i, e)) : t++;
  };
  return r(e), yp.set(e, t), t;
}
function HS(e, t, r) {
  var n, i;
  let { key: a } = e, o = Ks.get(t);
  var s;
  let u = (s = e.isDisabled) !== null && s !== void 0 ? s : t.selectionManager.isDisabled(a);
  var l;
  let c = (l = e.isSelected) !== null && l !== void 0 ? l : t.selectionManager.isSelected(a);
  var d;
  let f = (d = e.shouldSelectOnPressUp) !== null && d !== void 0 ? d : o == null ? void 0 : o.shouldSelectOnPressUp;
  var h;
  let p = (h = e.shouldFocusOnHover) !== null && h !== void 0 ? h : o == null ? void 0 : o.shouldFocusOnHover;
  var v;
  let g = (v = e.shouldUseVirtualFocus) !== null && v !== void 0 ? v : o == null ? void 0 : o.shouldUseVirtualFocus;
  var $;
  let m = ($ = e.isVirtualized) !== null && $ !== void 0 ? $ : o == null ? void 0 : o.isVirtualized, b = ai(), D = ai(), S = {
    role: "option",
    "aria-disabled": u || void 0,
    "aria-selected": t.selectionManager.selectionMode !== "none" ? c : void 0
  };
  yr() && ld() || (S["aria-label"] = e["aria-label"], S["aria-labelledby"] = b, S["aria-describedby"] = D);
  let T = t.collection.getItem(a);
  if (m) {
    let O = Number(T == null ? void 0 : T.index);
    S["aria-posinset"] = Number.isNaN(O) ? void 0 : O + 1, S["aria-setsize"] = nb(t.collection);
  }
  let R = o != null && o.onAction ? () => {
    var O;
    return o == null || (O = o.onAction) === null || O === void 0 ? void 0 : O.call(o, a);
  } : void 0, { itemProps: y, isPressed: A, isFocused: w, hasAction: E, allowsSelection: k } = NS({
    selectionManager: t.selectionManager,
    key: a,
    ref: r,
    shouldSelectOnPressUp: f,
    allowsDifferentPressOrigin: f && p,
    isVirtualized: m,
    shouldUseVirtualFocus: g,
    isDisabled: u,
    onAction: R || !(T == null || (n = T.props) === null || n === void 0) && n.onAction ? zr(T == null || (i = T.props) === null || i === void 0 ? void 0 : i.onAction, R) : void 0,
    linkBehavior: o == null ? void 0 : o.linkBehavior
  }), { hoverProps: C } = yn({
    isDisabled: u || !p,
    onHoverStart() {
      rs() || (t.selectionManager.setFocused(!0), t.selectionManager.setFocusedKey(a));
    }
  }), P = Me(T == null ? void 0 : T.props);
  delete P.id;
  let L = Gw(T == null ? void 0 : T.props);
  return {
    optionProps: {
      ...S,
      ...ge(P, y, C, L),
      id: eb(t, a)
    },
    labelProps: {
      id: b
    },
    descriptionProps: {
      id: D
    },
    isFocused: w,
    isFocusVisible: w && rs(),
    isSelected: c,
    isDisabled: u,
    isPressed: A,
    allowsSelection: k,
    hasAction: E
  };
}
function WS(e) {
  let { heading: t, "aria-label": r } = e, n = Ct();
  return {
    itemProps: {
      role: "presentation"
    },
    headingProps: t ? {
      // Techincally, listbox cannot contain headings according to ARIA.
      // We hide the heading from assistive technology, using role="presentation",
      // and only use it as a visual label for the nested group.
      id: n,
      role: "presentation"
    } : {},
    groupProps: {
      role: "group",
      "aria-label": r,
      "aria-labelledby": t ? n : void 0
    }
  };
}
var ib = {};
ib = {
  longPressMessage: "اضغط مطولاً أو اضغط على Alt + السهم لأسفل لفتح القائمة"
};
var ab = {};
ab = {
  longPressMessage: "Натиснете продължително или натиснете Alt+ стрелка надолу, за да отворите менюто"
};
var ob = {};
ob = {
  longPressMessage: "Dlouhým stiskem nebo stisknutím kláves Alt + šipka dolů otevřete nabídku"
};
var sb = {};
sb = {
  longPressMessage: "Langt tryk eller tryk på Alt + pil ned for at åbne menuen"
};
var ub = {};
ub = {
  longPressMessage: "Drücken Sie lange oder drücken Sie Alt + Nach-unten, um das Menü zu öffnen"
};
var lb = {};
lb = {
  longPressMessage: "Πιέστε παρατεταμένα ή πατήστε Alt + κάτω βέλος για να ανοίξετε το μενού"
};
var cb = {};
cb = {
  longPressMessage: "Long press or press Alt + ArrowDown to open menu"
};
var db = {};
db = {
  longPressMessage: "Mantenga pulsado o pulse Alt + flecha abajo para abrir el menú"
};
var fb = {};
fb = {
  longPressMessage: "Menüü avamiseks vajutage pikalt või vajutage klahve Alt + allanool"
};
var hb = {};
hb = {
  longPressMessage: "Avaa valikko painamalla pohjassa tai näppäinyhdistelmällä Alt + Alanuoli"
};
var pb = {};
pb = {
  longPressMessage: "Appuyez de manière prolongée ou appuyez sur Alt + Flèche vers le bas pour ouvrir le menu."
};
var mb = {};
mb = {
  longPressMessage: "לחץ לחיצה ארוכה או הקש Alt + ArrowDown כדי לפתוח את התפריט"
};
var vb = {};
vb = {
  longPressMessage: "Dugo pritisnite ili pritisnite Alt + strelicu prema dolje za otvaranje izbornika"
};
var yb = {};
yb = {
  longPressMessage: "Nyomja meg hosszan, vagy nyomja meg az Alt + lefele nyíl gombot a menü megnyitásához"
};
var gb = {};
gb = {
  longPressMessage: "Premere a lungo o premere Alt + Freccia giù per aprire il menu"
};
var bb = {};
bb = {
  longPressMessage: "長押しまたは Alt+下矢印キーでメニューを開く"
};
var $b = {};
$b = {
  longPressMessage: "길게 누르거나 Alt + 아래쪽 화살표를 눌러 메뉴 열기"
};
var xb = {};
xb = {
  longPressMessage: "Norėdami atidaryti meniu, nuspaudę palaikykite arba paspauskite „Alt + ArrowDown“."
};
var Db = {};
Db = {
  longPressMessage: "Lai atvērtu izvēlni, turiet nospiestu vai nospiediet taustiņu kombināciju Alt + lejupvērstā bultiņa"
};
var Eb = {};
Eb = {
  longPressMessage: "Langt trykk eller trykk Alt + PilNed for å åpne menyen"
};
var wb = {};
wb = {
  longPressMessage: "Druk lang op Alt + pijl-omlaag of druk op Alt om het menu te openen"
};
var Cb = {};
Cb = {
  longPressMessage: "Naciśnij i przytrzymaj lub naciśnij klawisze Alt + Strzałka w dół, aby otworzyć menu"
};
var Sb = {};
Sb = {
  longPressMessage: "Pressione e segure ou pressione Alt + Seta para baixo para abrir o menu"
};
var kb = {};
kb = {
  longPressMessage: "Prima continuamente ou prima Alt + Seta Para Baixo para abrir o menu"
};
var Tb = {};
Tb = {
  longPressMessage: "Apăsați lung sau apăsați pe Alt + săgeată în jos pentru a deschide meniul"
};
var Pb = {};
Pb = {
  longPressMessage: "Нажмите и удерживайте или нажмите Alt + Стрелка вниз, чтобы открыть меню"
};
var Ab = {};
Ab = {
  longPressMessage: "Ponuku otvoríte dlhým stlačením alebo stlačením klávesu Alt + klávesu so šípkou nadol"
};
var _b = {};
_b = {
  longPressMessage: "Za odprtje menija pritisnite in držite gumb ali pritisnite Alt+puščica navzdol"
};
var Fb = {};
Fb = {
  longPressMessage: "Dugo pritisnite ili pritisnite Alt + strelicu prema dole da otvorite meni"
};
var Ob = {};
Ob = {
  longPressMessage: "Håll nedtryckt eller tryck på Alt + pil nedåt för att öppna menyn"
};
var Ib = {};
Ib = {
  longPressMessage: "Menüyü açmak için uzun basın veya Alt + Aşağı Ok tuşuna basın"
};
var Rb = {};
Rb = {
  longPressMessage: "Довго або звичайно натисніть комбінацію клавіш Alt і стрілка вниз, щоб відкрити меню"
};
var Bb = {};
Bb = {
  longPressMessage: "长按或按 Alt + 向下方向键以打开菜单"
};
var Mb = {};
Mb = {
  longPressMessage: "長按或按 Alt+向下鍵以開啟功能表"
};
var Nb = {};
Nb = {
  "ar-AE": ib,
  "bg-BG": ab,
  "cs-CZ": ob,
  "da-DK": sb,
  "de-DE": ub,
  "el-GR": lb,
  "en-US": cb,
  "es-ES": db,
  "et-EE": fb,
  "fi-FI": hb,
  "fr-FR": pb,
  "he-IL": mb,
  "hr-HR": vb,
  "hu-HU": yb,
  "it-IT": gb,
  "ja-JP": bb,
  "ko-KR": $b,
  "lt-LT": xb,
  "lv-LV": Db,
  "nb-NO": Eb,
  "nl-NL": wb,
  "pl-PL": Cb,
  "pt-BR": Sb,
  "pt-PT": kb,
  "ro-RO": Tb,
  "ru-RU": Pb,
  "sk-SK": Ab,
  "sl-SI": _b,
  "sr-SP": Fb,
  "sv-SE": Ob,
  "tr-TR": Ib,
  "uk-UA": Rb,
  "zh-CN": Bb,
  "zh-TW": Mb
};
function QS(e) {
  return e && e.__esModule ? e.default : e;
}
function Lb(e, t, r) {
  let { type: n = "menu", isDisabled: i, trigger: a = "press" } = e, o = Ct(), { triggerProps: s, overlayProps: u } = m0({
    type: n
  }, t, r), l = (h) => {
    if (!i && !(a === "longPress" && !h.altKey) && r && r.current)
      switch (h.key) {
        case "Enter":
        case " ":
          if (a === "longPress") return;
        case "ArrowDown":
          "continuePropagation" in h || h.stopPropagation(), h.preventDefault(), t.toggle("first");
          break;
        case "ArrowUp":
          "continuePropagation" in h || h.stopPropagation(), h.preventDefault(), t.toggle("last");
          break;
        default:
          "continuePropagation" in h && h.continuePropagation();
      }
  }, c = zt(QS(Nb), "@react-aria/menu"), { longPressProps: d } = cy({
    isDisabled: i || a !== "longPress",
    accessibilityDescription: c.format("longPressMessage"),
    onLongPressStart() {
      t.close();
    },
    onLongPress() {
      t.open("first");
    }
  }), f = {
    onPressStart(h) {
      h.pointerType !== "touch" && h.pointerType !== "keyboard" && !i && t.open(h.pointerType === "virtual" ? "first" : null);
    },
    onPress(h) {
      h.pointerType === "touch" && !i && t.toggle();
    }
  };
  return delete s.onPress, {
    menuTriggerProps: {
      ...s,
      ...a === "press" ? f : d,
      id: o,
      onKeyDown: l
    },
    menuProps: {
      ...u,
      "aria-labelledby": o,
      autoFocus: t.focusStrategy || !0,
      onClose: t.close
    }
  };
}
function GS(e, t) {
  let { inputElementType: r = "input", isDisabled: n = !1, isRequired: i = !1, isReadOnly: a = !1, type: o = "text", validationBehavior: s = "aria" } = e, [u, l] = Jt(e.value, e.defaultValue || "", e.onChange), { focusableProps: c } = py(e, t), d = Ia({
    ...e,
    value: u
  }), { isInvalid: f, validationErrors: h, validationDetails: p } = d.displayValidation, { labelProps: v, fieldProps: g, descriptionProps: $, errorMessageProps: m } = zs({
    ...e,
    isInvalid: f,
    errorMessage: e.errorMessage || h
  }), b = Me(e, {
    labelable: !0
  });
  const D = {
    type: o,
    pattern: e.pattern
  };
  return fd(t, u, l), Ad(e, d, t), ue(() => {
    if (t.current instanceof At(t.current).HTMLTextAreaElement) {
      let S = t.current;
      Object.defineProperty(S, "defaultValue", {
        get: () => S.value,
        set: () => {
        },
        configurable: !0
      });
    }
  }, [
    t
  ]), {
    labelProps: v,
    inputProps: ge(b, r === "input" && D, {
      disabled: n,
      readOnly: a,
      required: i && s === "native",
      "aria-required": i && s === "aria" || void 0,
      "aria-invalid": f || void 0,
      "aria-errormessage": e["aria-errormessage"],
      "aria-activedescendant": e["aria-activedescendant"],
      "aria-autocomplete": e["aria-autocomplete"],
      "aria-haspopup": e["aria-haspopup"],
      value: u,
      onChange: (S) => l(S.target.value),
      autoComplete: e.autoComplete,
      autoCapitalize: e.autoCapitalize,
      maxLength: e.maxLength,
      minLength: e.minLength,
      name: e.name,
      placeholder: e.placeholder,
      inputMode: e.inputMode,
      // Clipboard events
      onCopy: e.onCopy,
      onCut: e.onCut,
      onPaste: e.onPaste,
      // Composition events
      onCompositionEnd: e.onCompositionEnd,
      onCompositionStart: e.onCompositionStart,
      onCompositionUpdate: e.onCompositionUpdate,
      // Selection events
      onSelect: e.onSelect,
      // Input events
      onBeforeInput: e.onBeforeInput,
      onInput: e.onInput,
      ...c,
      ...g
    }),
    descriptionProps: $,
    errorMessageProps: m,
    isInvalid: f,
    validationErrors: h,
    validationDetails: p
  };
}
function ZS(e) {
  return e && e.__esModule ? e.default : e;
}
function YS(e, t) {
  let { buttonRef: r, popoverRef: n, inputRef: i, listBoxRef: a, keyboardDelegate: o, shouldFocusWrap: s, isReadOnly: u, isDisabled: l } = e, c = zt(ZS(f0), "@react-aria/combobox"), { menuTriggerProps: d, menuProps: f } = Lb({
    type: "listbox",
    isDisabled: l || u
  }, t, r);
  Ks.set(t, {
    id: f.id
  });
  let h = G(() => o || new Us(t.collection, t.disabledKeys, a), [
    o,
    t.collection,
    t.disabledKeys,
    a
  ]), { collectionProps: p } = rb({
    selectionManager: t.selectionManager,
    keyboardDelegate: h,
    disallowTypeAhead: !0,
    disallowEmptySelection: !0,
    shouldFocusWrap: s,
    ref: i,
    // Prevent item scroll behavior from being applied here, should be handled in the user's Popover + ListBox component
    isVirtualized: !0
  }), v = Fs(), g = (V) => {
    switch (V.key) {
      case "Enter":
      case "Tab":
        if (t.isOpen && V.key === "Enter" && V.preventDefault(), t.isOpen && t.selectionManager.focusedKey != null && t.selectionManager.isLink(t.selectionManager.focusedKey)) {
          if (V.key === "Enter") {
            let ie = a.current.querySelector(`[data-key="${CSS.escape(t.selectionManager.focusedKey.toString())}"]`);
            if (ie instanceof HTMLAnchorElement) {
              let De = t.collection.getItem(t.selectionManager.focusedKey);
              v.open(ie, V, De.props.href, De.props.routerOptions);
            }
          }
          t.close();
        } else t.commit();
        break;
      case "Escape":
        (t.selectedKey !== null || t.inputValue === "" || e.allowsCustomValue) && V.continuePropagation(), t.revert();
        break;
      case "ArrowDown":
        t.open("first", "manual");
        break;
      case "ArrowUp":
        t.open("last", "manual");
        break;
      case "ArrowLeft":
      case "ArrowRight":
        t.selectionManager.setFocusedKey(null);
        break;
    }
  }, $ = (V) => {
    var ie;
    let De = (r == null ? void 0 : r.current) && r.current === V.relatedTarget, ze = (ie = n.current) === null || ie === void 0 ? void 0 : ie.contains(V.relatedTarget);
    De || ze || (e.onBlur && e.onBlur(V), t.setFocused(!1));
  }, m = (V) => {
    t.isFocused || (e.onFocus && e.onFocus(V), t.setFocused(!0));
  }, { isInvalid: b, validationErrors: D, validationDetails: S } = t.displayValidation, { labelProps: T, inputProps: R, descriptionProps: y, errorMessageProps: A } = GS({
    ...e,
    onChange: t.setInputValue,
    onKeyDown: u ? e.onKeyDown : zr(t.isOpen && p.onKeyDown, g, e.onKeyDown),
    onBlur: $,
    value: t.inputValue,
    onFocus: m,
    autoComplete: "off",
    validate: void 0,
    [va]: t
  }, i), w = (V) => {
    V.pointerType === "touch" && (i.current.focus(), t.toggle(null, "manual"));
  }, E = (V) => {
    V.pointerType !== "touch" && (i.current.focus(), t.toggle(V.pointerType === "keyboard" || V.pointerType === "virtual" ? "first" : null, "manual"));
  }, k = cn({
    id: d.id,
    "aria-label": c.format("buttonLabel"),
    "aria-labelledby": e["aria-labelledby"] || T.id
  }), C = cn({
    id: f.id,
    "aria-label": c.format("listboxLabel"),
    "aria-labelledby": e["aria-labelledby"] || T.id
  }), P = q(0), L = (V) => {
    if (l || u) return;
    if (V.timeStamp - P.current < 500) {
      V.preventDefault(), i.current.focus();
      return;
    }
    let ie = V.target.getBoundingClientRect(), De = V.changedTouches[0], ze = Math.ceil(ie.left + 0.5 * ie.width), He = Math.ceil(ie.top + 0.5 * ie.height);
    De.clientX === ze && De.clientY === He && (V.preventDefault(), i.current.focus(), t.toggle(null, "manual"), P.current = V.timeStamp);
  }, O = t.selectionManager.focusedKey != null && t.isOpen ? t.collection.getItem(t.selectionManager.focusedKey) : void 0;
  var x;
  let U = (x = O == null ? void 0 : O.parentKey) !== null && x !== void 0 ? x : null;
  var K;
  let j = (K = t.selectionManager.focusedKey) !== null && K !== void 0 ? K : null, ae = q(U), ne = q(j);
  ue(() => {
    if ($o() && O != null && j !== ne.current) {
      let V = t.selectionManager.isSelected(j), ie = U != null ? t.collection.getItem(U) : null, De = (ie == null ? void 0 : ie["aria-label"]) || (typeof (ie == null ? void 0 : ie.rendered) == "string" ? ie.rendered : "") || "", ze = c.format("focusAnnouncement", {
        isGroupChange: ie && U !== ae.current,
        groupTitle: De,
        groupCount: ie ? [
          ...qs(ie, t.collection)
        ].length : 0,
        optionText: O["aria-label"] || O.textValue || "",
        isSelected: V
      });
      Qn(ze);
    }
    ae.current = U, ne.current = j;
  });
  let me = nb(t.collection), $e = q(me), _e = q(t.isOpen);
  ue(() => {
    let V = t.isOpen !== _e.current && (t.selectionManager.focusedKey == null || $o());
    if (t.isOpen && (V || me !== $e.current)) {
      let ie = c.format("countAnnouncement", {
        optionCount: me
      });
      Qn(ie);
    }
    $e.current = me, _e.current = t.isOpen;
  });
  let Fe = q(t.selectedKey);
  return ue(() => {
    if ($o() && t.isFocused && t.selectedItem && t.selectedKey !== Fe.current) {
      let V = t.selectedItem["aria-label"] || t.selectedItem.textValue || "", ie = c.format("selectedAnnouncement", {
        optionText: V
      });
      Qn(ie);
    }
    Fe.current = t.selectedKey;
  }), ue(() => {
    if (t.isOpen) return J0([
      i.current,
      n.current
    ]);
  }, [
    t.isOpen,
    i,
    n
  ]), {
    labelProps: T,
    buttonProps: {
      ...d,
      ...k,
      excludeFromTabOrder: !0,
      onPress: w,
      onPressStart: E,
      isDisabled: l || u
    },
    inputProps: ge(R, {
      role: "combobox",
      "aria-expanded": d["aria-expanded"],
      "aria-controls": t.isOpen ? f.id : void 0,
      // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)
      "aria-autocomplete": "list",
      "aria-activedescendant": O ? eb(t, O.key) : void 0,
      onTouchEnd: L,
      // This disable's iOS's autocorrect suggestions, since the combo box provides its own suggestions.
      autoCorrect: "off",
      // This disable's the macOS Safari spell check auto corrections.
      spellCheck: "false"
    }),
    listBoxProps: ge(f, C, {
      autoFocus: t.focusStrategy,
      shouldUseVirtualFocus: !0,
      shouldSelectOnPressUp: !0,
      shouldFocusOnHover: !0,
      linkBehavior: "selection"
    }),
    descriptionProps: y,
    errorMessageProps: A,
    isInvalid: b,
    validationErrors: D,
    validationDetails: S
  };
}
var Vb = {};
Vb = {
  calendar: "التقويم",
  day: "يوم",
  dayPeriod: "ص/م",
  endDate: "تاريخ الانتهاء",
  era: "العصر",
  hour: "الساعات",
  minute: "الدقائق",
  month: "الشهر",
  second: "الثواني",
  selectedDateDescription: (e) => `تاريخ محدد: ${e.date}`,
  selectedRangeDescription: (e) => `المدى الزمني المحدد: ${e.startDate} إلى ${e.endDate}`,
  selectedTimeDescription: (e) => `الوقت المحدد: ${e.time}`,
  startDate: "تاريخ البدء",
  timeZoneName: "التوقيت",
  weekday: "اليوم",
  year: "السنة"
};
var jb = {};
jb = {
  calendar: "Календар",
  day: "ден",
  dayPeriod: "пр.об./сл.об.",
  endDate: "Крайна дата",
  era: "ера",
  hour: "час",
  minute: "минута",
  month: "месец",
  second: "секунда",
  selectedDateDescription: (e) => `Избрана дата: ${e.date}`,
  selectedRangeDescription: (e) => `Избран диапазон: ${e.startDate} до ${e.endDate}`,
  selectedTimeDescription: (e) => `Избрано време: ${e.time}`,
  startDate: "Начална дата",
  timeZoneName: "часова зона",
  weekday: "ден от седмицата",
  year: "година"
};
var zb = {};
zb = {
  calendar: "Kalendář",
  day: "den",
  dayPeriod: "část dne",
  endDate: "Konečné datum",
  era: "letopočet",
  hour: "hodina",
  minute: "minuta",
  month: "měsíc",
  second: "sekunda",
  selectedDateDescription: (e) => `Vybrané datum: ${e.date}`,
  selectedRangeDescription: (e) => `Vybrané období: ${e.startDate} až ${e.endDate}`,
  selectedTimeDescription: (e) => `Vybraný čas: ${e.time}`,
  startDate: "Počáteční datum",
  timeZoneName: "časové pásmo",
  weekday: "den v týdnu",
  year: "rok"
};
var Kb = {};
Kb = {
  calendar: "Kalender",
  day: "dag",
  dayPeriod: "AM/PM",
  endDate: "Slutdato",
  era: "æra",
  hour: "time",
  minute: "minut",
  month: "måned",
  second: "sekund",
  selectedDateDescription: (e) => `Valgt dato: ${e.date}`,
  selectedRangeDescription: (e) => `Valgt interval: ${e.startDate} til ${e.endDate}`,
  selectedTimeDescription: (e) => `Valgt tidspunkt: ${e.time}`,
  startDate: "Startdato",
  timeZoneName: "tidszone",
  weekday: "ugedag",
  year: "år"
};
var Ub = {};
Ub = {
  calendar: "Kalender",
  day: "Tag",
  dayPeriod: "Tageshälfte",
  endDate: "Enddatum",
  era: "Epoche",
  hour: "Stunde",
  minute: "Minute",
  month: "Monat",
  second: "Sekunde",
  selectedDateDescription: (e) => `Ausgewähltes Datum: ${e.date}`,
  selectedRangeDescription: (e) => `Ausgewählter Bereich: ${e.startDate} bis ${e.endDate}`,
  selectedTimeDescription: (e) => `Ausgewählte Zeit: ${e.time}`,
  startDate: "Anfangsdatum",
  timeZoneName: "Zeitzone",
  weekday: "Wochentag",
  year: "Jahr"
};
var qb = {};
qb = {
  calendar: "Ημερολόγιο",
  day: "ημέρα",
  dayPeriod: "π.μ./μ.μ.",
  endDate: "Ημερομηνία λήξης",
  era: "περίοδος",
  hour: "ώρα",
  minute: "λεπτό",
  month: "μήνας",
  second: "δευτερόλεπτο",
  selectedDateDescription: (e) => `Επιλεγμένη ημερομηνία: ${e.date}`,
  selectedRangeDescription: (e) => `Επιλεγμένο εύρος: ${e.startDate} έως ${e.endDate}`,
  selectedTimeDescription: (e) => `Επιλεγμένη ώρα: ${e.time}`,
  startDate: "Ημερομηνία έναρξης",
  timeZoneName: "ζώνη ώρας",
  weekday: "καθημερινή",
  year: "έτος"
};
var Hb = {};
Hb = {
  era: "era",
  year: "year",
  month: "month",
  day: "day",
  hour: "hour",
  minute: "minute",
  second: "second",
  dayPeriod: "AM/PM",
  calendar: "Calendar",
  startDate: "Start Date",
  endDate: "End Date",
  weekday: "day of the week",
  timeZoneName: "time zone",
  selectedDateDescription: (e) => `Selected Date: ${e.date}`,
  selectedRangeDescription: (e) => `Selected Range: ${e.startDate} to ${e.endDate}`,
  selectedTimeDescription: (e) => `Selected Time: ${e.time}`
};
var Wb = {};
Wb = {
  calendar: "Calendario",
  day: "día",
  dayPeriod: "a. m./p. m.",
  endDate: "Fecha final",
  era: "era",
  hour: "hora",
  minute: "minuto",
  month: "mes",
  second: "segundo",
  selectedDateDescription: (e) => `Fecha seleccionada: ${e.date}`,
  selectedRangeDescription: (e) => `Rango seleccionado: ${e.startDate} a ${e.endDate}`,
  selectedTimeDescription: (e) => `Hora seleccionada: ${e.time}`,
  startDate: "Fecha de inicio",
  timeZoneName: "zona horaria",
  weekday: "día de la semana",
  year: "año"
};
var Qb = {};
Qb = {
  calendar: "Kalender",
  day: "päev",
  dayPeriod: "enne/pärast lõunat",
  endDate: "Lõppkuupäev",
  era: "ajastu",
  hour: "tund",
  minute: "minut",
  month: "kuu",
  second: "sekund",
  selectedDateDescription: (e) => `Valitud kuupäev: ${e.date}`,
  selectedRangeDescription: (e) => `Valitud vahemik: ${e.startDate} kuni ${e.endDate}`,
  selectedTimeDescription: (e) => `Valitud aeg: ${e.time}`,
  startDate: "Alguskuupäev",
  timeZoneName: "ajavöönd",
  weekday: "nädalapäev",
  year: "aasta"
};
var Gb = {};
Gb = {
  calendar: "Kalenteri",
  day: "päivä",
  dayPeriod: "vuorokaudenaika",
  endDate: "Päättymispäivä",
  era: "aikakausi",
  hour: "tunti",
  minute: "minuutti",
  month: "kuukausi",
  second: "sekunti",
  selectedDateDescription: (e) => `Valittu päivämäärä: ${e.date}`,
  selectedRangeDescription: (e) => `Valittu aikaväli: ${e.startDate} – ${e.endDate}`,
  selectedTimeDescription: (e) => `Valittu aika: ${e.time}`,
  startDate: "Alkamispäivä",
  timeZoneName: "aikavyöhyke",
  weekday: "viikonpäivä",
  year: "vuosi"
};
var Zb = {};
Zb = {
  calendar: "Calendrier",
  day: "jour",
  dayPeriod: "cadran",
  endDate: "Date de fin",
  era: "ère",
  hour: "heure",
  minute: "minute",
  month: "mois",
  second: "seconde",
  selectedDateDescription: (e) => `Date sélectionnée : ${e.date}`,
  selectedRangeDescription: (e) => `Plage sélectionnée : ${e.startDate} au ${e.endDate}`,
  selectedTimeDescription: (e) => `Heure choisie : ${e.time}`,
  startDate: "Date de début",
  timeZoneName: "fuseau horaire",
  weekday: "jour de la semaine",
  year: "année"
};
var Yb = {};
Yb = {
  calendar: "לוח שנה",
  day: "יום",
  dayPeriod: "לפנה״צ/אחה״צ",
  endDate: "תאריך סיום",
  era: "תקופה",
  hour: "שעה",
  minute: "דקה",
  month: "חודש",
  second: "שנייה",
  selectedDateDescription: (e) => `תאריך נבחר: ${e.date}`,
  selectedRangeDescription: (e) => `טווח נבחר: ${e.startDate} עד ${e.endDate}`,
  selectedTimeDescription: (e) => `זמן נבחר: ${e.time}`,
  startDate: "תאריך התחלה",
  timeZoneName: "אזור זמן",
  weekday: "יום בשבוע",
  year: "שנה"
};
var Jb = {};
Jb = {
  calendar: "Kalendar",
  day: "dan",
  dayPeriod: "AM/PM",
  endDate: "Datum završetka",
  era: "era",
  hour: "sat",
  minute: "minuta",
  month: "mjesec",
  second: "sekunda",
  selectedDateDescription: (e) => `Odabrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Odabrani raspon: ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Odabrano vrijeme: ${e.time}`,
  startDate: "Datum početka",
  timeZoneName: "vremenska zona",
  weekday: "dan u tjednu",
  year: "godina"
};
var Xb = {};
Xb = {
  calendar: "Naptár",
  day: "nap",
  dayPeriod: "napszak",
  endDate: "Befejező dátum",
  era: "éra",
  hour: "óra",
  minute: "perc",
  month: "hónap",
  second: "másodperc",
  selectedDateDescription: (e) => `Kijelölt dátum: ${e.date}`,
  selectedRangeDescription: (e) => `Kijelölt tartomány: ${e.startDate}–${e.endDate}`,
  selectedTimeDescription: (e) => `Kijelölt idő: ${e.time}`,
  startDate: "Kezdő dátum",
  timeZoneName: "időzóna",
  weekday: "hét napja",
  year: "év"
};
var e4 = {};
e4 = {
  calendar: "Calendario",
  day: "giorno",
  dayPeriod: "AM/PM",
  endDate: "Data finale",
  era: "era",
  hour: "ora",
  minute: "minuto",
  month: "mese",
  second: "secondo",
  selectedDateDescription: (e) => `Data selezionata: ${e.date}`,
  selectedRangeDescription: (e) => `Intervallo selezionato: da ${e.startDate} a ${e.endDate}`,
  selectedTimeDescription: (e) => `Ora selezionata: ${e.time}`,
  startDate: "Data iniziale",
  timeZoneName: "fuso orario",
  weekday: "giorno della settimana",
  year: "anno"
};
var t4 = {};
t4 = {
  calendar: "カレンダー",
  day: "日",
  dayPeriod: "午前/午後",
  endDate: "終了日",
  era: "時代",
  hour: "時",
  minute: "分",
  month: "月",
  second: "秒",
  selectedDateDescription: (e) => `選択した日付 : ${e.date}`,
  selectedRangeDescription: (e) => `選択範囲 : ${e.startDate} から ${e.endDate}`,
  selectedTimeDescription: (e) => `選択した時間 : ${e.time}`,
  startDate: "開始日",
  timeZoneName: "タイムゾーン",
  weekday: "曜日",
  year: "年"
};
var r4 = {};
r4 = {
  calendar: "달력",
  day: "일",
  dayPeriod: "오전/오후",
  endDate: "종료일",
  era: "연호",
  hour: "시",
  minute: "분",
  month: "월",
  second: "초",
  selectedDateDescription: (e) => `선택 일자: ${e.date}`,
  selectedRangeDescription: (e) => `선택 범위: ${e.startDate} ~ ${e.endDate}`,
  selectedTimeDescription: (e) => `선택 시간: ${e.time}`,
  startDate: "시작일",
  timeZoneName: "시간대",
  weekday: "요일",
  year: "년"
};
var n4 = {};
n4 = {
  calendar: "Kalendorius",
  day: "diena",
  dayPeriod: "iki pietų / po pietų",
  endDate: "Pabaigos data",
  era: "era",
  hour: "valanda",
  minute: "minutė",
  month: "mėnuo",
  second: "sekundė",
  selectedDateDescription: (e) => `Pasirinkta data: ${e.date}`,
  selectedRangeDescription: (e) => `Pasirinktas intervalas: nuo ${e.startDate} iki ${e.endDate}`,
  selectedTimeDescription: (e) => `Pasirinktas laikas: ${e.time}`,
  startDate: "Pradžios data",
  timeZoneName: "laiko juosta",
  weekday: "savaitės diena",
  year: "metai"
};
var i4 = {};
i4 = {
  calendar: "Kalendārs",
  day: "diena",
  dayPeriod: "priekšpusdienā/pēcpusdienā",
  endDate: "Beigu datums",
  era: "ēra",
  hour: "stundas",
  minute: "minūtes",
  month: "mēnesis",
  second: "sekundes",
  selectedDateDescription: (e) => `Atlasītais datums: ${e.date}`,
  selectedRangeDescription: (e) => `Atlasītais diapazons: no ${e.startDate} līdz ${e.endDate}`,
  selectedTimeDescription: (e) => `Atlasītais laiks: ${e.time}`,
  startDate: "Sākuma datums",
  timeZoneName: "laika josla",
  weekday: "nedēļas diena",
  year: "gads"
};
var a4 = {};
a4 = {
  calendar: "Kalender",
  day: "dag",
  dayPeriod: "a.m./p.m.",
  endDate: "Sluttdato",
  era: "tidsalder",
  hour: "time",
  minute: "minutt",
  month: "måned",
  second: "sekund",
  selectedDateDescription: (e) => `Valgt dato: ${e.date}`,
  selectedRangeDescription: (e) => `Valgt område: ${e.startDate} til ${e.endDate}`,
  selectedTimeDescription: (e) => `Valgt tid: ${e.time}`,
  startDate: "Startdato",
  timeZoneName: "tidssone",
  weekday: "ukedag",
  year: "år"
};
var o4 = {};
o4 = {
  calendar: "Kalender",
  day: "dag",
  dayPeriod: "a.m./p.m.",
  endDate: "Einddatum",
  era: "tijdperk",
  hour: "uur",
  minute: "minuut",
  month: "maand",
  second: "seconde",
  selectedDateDescription: (e) => `Geselecteerde datum: ${e.date}`,
  selectedRangeDescription: (e) => `Geselecteerd bereik: ${e.startDate} tot ${e.endDate}`,
  selectedTimeDescription: (e) => `Geselecteerde tijd: ${e.time}`,
  startDate: "Startdatum",
  timeZoneName: "tijdzone",
  weekday: "dag van de week",
  year: "jaar"
};
var s4 = {};
s4 = {
  calendar: "Kalendarz",
  day: "dzień",
  dayPeriod: "rano / po południu / wieczorem",
  endDate: "Data końcowa",
  era: "era",
  hour: "godzina",
  minute: "minuta",
  month: "miesiąc",
  second: "sekunda",
  selectedDateDescription: (e) => `Wybrana data: ${e.date}`,
  selectedRangeDescription: (e) => `Wybrany zakres: ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Wybrany czas: ${e.time}`,
  startDate: "Data początkowa",
  timeZoneName: "strefa czasowa",
  weekday: "dzień tygodnia",
  year: "rok"
};
var u4 = {};
u4 = {
  calendar: "Calendário",
  day: "dia",
  dayPeriod: "AM/PM",
  endDate: "Data final",
  era: "era",
  hour: "hora",
  minute: "minuto",
  month: "mês",
  second: "segundo",
  selectedDateDescription: (e) => `Data selecionada: ${e.date}`,
  selectedRangeDescription: (e) => `Intervalo selecionado: ${e.startDate} a ${e.endDate}`,
  selectedTimeDescription: (e) => `Hora selecionada: ${e.time}`,
  startDate: "Data inicial",
  timeZoneName: "fuso horário",
  weekday: "dia da semana",
  year: "ano"
};
var l4 = {};
l4 = {
  calendar: "Calendário",
  day: "dia",
  dayPeriod: "am/pm",
  endDate: "Data de Término",
  era: "era",
  hour: "hora",
  minute: "minuto",
  month: "mês",
  second: "segundo",
  selectedDateDescription: (e) => `Data selecionada: ${e.date}`,
  selectedRangeDescription: (e) => `Intervalo selecionado: ${e.startDate} a ${e.endDate}`,
  selectedTimeDescription: (e) => `Hora selecionada: ${e.time}`,
  startDate: "Data de Início",
  timeZoneName: "fuso horário",
  weekday: "dia da semana",
  year: "ano"
};
var c4 = {};
c4 = {
  calendar: "Calendar",
  day: "zi",
  dayPeriod: "a.m/p.m.",
  endDate: "Dată final",
  era: "eră",
  hour: "oră",
  minute: "minut",
  month: "lună",
  second: "secundă",
  selectedDateDescription: (e) => `Dată selectată: ${e.date}`,
  selectedRangeDescription: (e) => `Interval selectat: de la ${e.startDate} până la ${e.endDate}`,
  selectedTimeDescription: (e) => `Ora selectată: ${e.time}`,
  startDate: "Dată început",
  timeZoneName: "fus orar",
  weekday: "ziua din săptămână",
  year: "an"
};
var d4 = {};
d4 = {
  calendar: "Календарь",
  day: "день",
  dayPeriod: "AM/PM",
  endDate: "Дата окончания",
  era: "эра",
  hour: "час",
  minute: "минута",
  month: "месяц",
  second: "секунда",
  selectedDateDescription: (e) => `Выбранная дата: ${e.date}`,
  selectedRangeDescription: (e) => `Выбранный диапазон: с ${e.startDate} по ${e.endDate}`,
  selectedTimeDescription: (e) => `Выбранное время: ${e.time}`,
  startDate: "Дата начала",
  timeZoneName: "часовой пояс",
  weekday: "день недели",
  year: "год"
};
var f4 = {};
f4 = {
  calendar: "Kalendár",
  day: "deň",
  dayPeriod: "AM/PM",
  endDate: "Dátum ukončenia",
  era: "letopočet",
  hour: "hodina",
  minute: "minúta",
  month: "mesiac",
  second: "sekunda",
  selectedDateDescription: (e) => `Vybratý dátum: ${e.date}`,
  selectedRangeDescription: (e) => `Vybratý rozsah: od ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Vybratý čas: ${e.time}`,
  startDate: "Dátum začatia",
  timeZoneName: "časové pásmo",
  weekday: "deň týždňa",
  year: "rok"
};
var h4 = {};
h4 = {
  calendar: "Koledar",
  day: "dan",
  dayPeriod: "dop/pop",
  endDate: "Datum konca",
  era: "doba",
  hour: "ura",
  minute: "minuta",
  month: "mesec",
  second: "sekunda",
  selectedDateDescription: (e) => `Izbrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Izbrano območje: ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Izbrani čas: ${e.time}`,
  startDate: "Datum začetka",
  timeZoneName: "časovni pas",
  weekday: "dan v tednu",
  year: "leto"
};
var p4 = {};
p4 = {
  calendar: "Kalendar",
  day: "дан",
  dayPeriod: "пре подне/по подне",
  endDate: "Datum završetka",
  era: "ера",
  hour: "сат",
  minute: "минут",
  month: "месец",
  second: "секунд",
  selectedDateDescription: (e) => `Izabrani datum: ${e.date}`,
  selectedRangeDescription: (e) => `Izabrani opseg: od ${e.startDate} do ${e.endDate}`,
  selectedTimeDescription: (e) => `Izabrano vreme: ${e.time}`,
  startDate: "Datum početka",
  timeZoneName: "временска зона",
  weekday: "дан у недељи",
  year: "година"
};
var m4 = {};
m4 = {
  calendar: "Kalender",
  day: "dag",
  dayPeriod: "fm/em",
  endDate: "Slutdatum",
  era: "era",
  hour: "timme",
  minute: "minut",
  month: "månad",
  second: "sekund",
  selectedDateDescription: (e) => `Valt datum: ${e.date}`,
  selectedRangeDescription: (e) => `Valt intervall: ${e.startDate} till ${e.endDate}`,
  selectedTimeDescription: (e) => `Vald tid: ${e.time}`,
  startDate: "Startdatum",
  timeZoneName: "tidszon",
  weekday: "veckodag",
  year: "år"
};
var v4 = {};
v4 = {
  calendar: "Takvim",
  day: "gün",
  dayPeriod: "ÖÖ/ÖS",
  endDate: "Bitiş Tarihi",
  era: "çağ",
  hour: "saat",
  minute: "dakika",
  month: "ay",
  second: "saniye",
  selectedDateDescription: (e) => `Seçilen Tarih: ${e.date}`,
  selectedRangeDescription: (e) => `Seçilen Aralık: ${e.startDate} - ${e.endDate}`,
  selectedTimeDescription: (e) => `Seçilen Zaman: ${e.time}`,
  startDate: "Başlangıç Tarihi",
  timeZoneName: "saat dilimi",
  weekday: "haftanın günü",
  year: "yıl"
};
var y4 = {};
y4 = {
  calendar: "Календар",
  day: "день",
  dayPeriod: "дп/пп",
  endDate: "Дата завершення",
  era: "ера",
  hour: "година",
  minute: "хвилина",
  month: "місяць",
  second: "секунда",
  selectedDateDescription: (e) => `Вибрана дата: ${e.date}`,
  selectedRangeDescription: (e) => `Вибраний діапазон: ${e.startDate} — ${e.endDate}`,
  selectedTimeDescription: (e) => `Вибраний час: ${e.time}`,
  startDate: "Дата початку",
  timeZoneName: "часовий пояс",
  weekday: "день тижня",
  year: "рік"
};
var g4 = {};
g4 = {
  calendar: "日历",
  day: "日",
  dayPeriod: "上午/下午",
  endDate: "结束日期",
  era: "纪元",
  hour: "小时",
  minute: "分钟",
  month: "月",
  second: "秒",
  selectedDateDescription: (e) => `选定的日期：${e.date}`,
  selectedRangeDescription: (e) => `选定的范围：${e.startDate} 至 ${e.endDate}`,
  selectedTimeDescription: (e) => `选定的时间：${e.time}`,
  startDate: "开始日期",
  timeZoneName: "时区",
  weekday: "工作日",
  year: "年"
};
var b4 = {};
b4 = {
  calendar: "日曆",
  day: "日",
  dayPeriod: "上午/下午",
  endDate: "結束日期",
  era: "纪元",
  hour: "小时",
  minute: "分钟",
  month: "月",
  second: "秒",
  selectedDateDescription: (e) => `選定的日期：${e.date}`,
  selectedRangeDescription: (e) => `選定的範圍：${e.startDate} 至 ${e.endDate}`,
  selectedTimeDescription: (e) => `選定的時間：${e.time}`,
  startDate: "開始日期",
  timeZoneName: "时区",
  weekday: "工作日",
  year: "年"
};
var Hs = {};
Hs = {
  "ar-AE": Vb,
  "bg-BG": jb,
  "cs-CZ": zb,
  "da-DK": Kb,
  "de-DE": Ub,
  "el-GR": qb,
  "en-US": Hb,
  "es-ES": Wb,
  "et-EE": Qb,
  "fi-FI": Gb,
  "fr-FR": Zb,
  "he-IL": Yb,
  "hr-HR": Jb,
  "hu-HU": Xb,
  "it-IT": e4,
  "ja-JP": t4,
  "ko-KR": r4,
  "lt-LT": n4,
  "lv-LV": i4,
  "nb-NO": a4,
  "nl-NL": o4,
  "pl-PL": s4,
  "pt-BR": u4,
  "pt-PT": l4,
  "ro-RO": c4,
  "ru-RU": d4,
  "sk-SK": f4,
  "sl-SI": h4,
  "sr-SP": p4,
  "sv-SE": m4,
  "tr-TR": v4,
  "uk-UA": y4,
  "zh-CN": g4,
  "zh-TW": b4
};
function $4(e, t, r) {
  let { direction: n } = lt(), i = G(() => md(t), [
    t
  ]), a = (u) => {
    if (u.currentTarget.contains(u.target) && (u.altKey && (u.key === "ArrowDown" || u.key === "ArrowUp") && "setOpen" in e && (u.preventDefault(), u.stopPropagation(), e.setOpen(!0)), !r))
      switch (u.key) {
        case "ArrowLeft":
          u.preventDefault(), u.stopPropagation(), n === "rtl" ? i.focusNext() : i.focusPrevious();
          break;
        case "ArrowRight":
          u.preventDefault(), u.stopPropagation(), n === "rtl" ? i.focusPrevious() : i.focusNext();
          break;
      }
  }, o = () => {
    var u;
    let l = (u = window.event) === null || u === void 0 ? void 0 : u.target, c = gt(t.current, {
      tabbable: !0
    });
    if (l && (c.currentNode = l, l = c.previousNode()), !l) {
      let d;
      do
        d = c.lastChild(), d && (l = d);
      while (d);
    }
    for (; l != null && l.hasAttribute("data-placeholder"); ) {
      let d = c.previousNode();
      if (d && d.hasAttribute("data-placeholder")) l = d;
      else break;
    }
    l && l.focus();
  }, { pressProps: s } = _a({
    preventFocusOnPress: !0,
    allowTextSelectionOnPress: !0,
    onPressStart(u) {
      u.pointerType === "mouse" && o();
    },
    onPress(u) {
      u.pointerType !== "mouse" && o();
    }
  });
  return ge(s, {
    onKeyDown: a
  });
}
function JS(e) {
  return e && e.__esModule ? e.default : e;
}
const x4 = /* @__PURE__ */ new WeakMap(), Co = "__role_" + Date.now(), D4 = "__focusManager_" + Date.now();
function XS(e, t, r) {
  var n;
  let { isInvalid: i, validationErrors: a, validationDetails: o } = t.displayValidation, { labelProps: s, fieldProps: u, descriptionProps: l, errorMessageProps: c } = zs({
    ...e,
    labelElementType: "span",
    isInvalid: i,
    errorMessage: e.errorMessage || a
  }), d = q(null), { focusWithinProps: f } = ci({
    ...e,
    onFocusWithin(w) {
      var E;
      d.current = t.value, (E = e.onFocus) === null || E === void 0 || E.call(e, w);
    },
    onBlurWithin: (w) => {
      var E;
      t.confirmPlaceholder(), t.value !== d.current && t.commitValidation(), (E = e.onBlur) === null || E === void 0 || E.call(e, w);
    },
    onFocusWithinChange: e.onFocusChange
  }), h = zt(JS(Hs), "@react-aria/datepicker"), p = t.maxGranularity === "hour" ? "selectedTimeDescription" : "selectedDateDescription", v = t.maxGranularity === "hour" ? "time" : "date", g = t.value ? h.format(p, {
    [v]: t.formatValue({
      month: "long"
    })
  }) : "", $ = Rs(g), m = e[Co] === "presentation" ? u["aria-describedby"] : [
    $["aria-describedby"],
    u["aria-describedby"]
  ].filter(Boolean).join(" ") || void 0, b = e[D4], D = G(() => b || md(r), [
    b,
    r
  ]), S = $4(t, r, e[Co] === "presentation");
  x4.set(t, {
    ariaLabel: e["aria-label"],
    ariaLabelledBy: [
      s.id,
      e["aria-labelledby"]
    ].filter(Boolean).join(" ") || void 0,
    ariaDescribedBy: m,
    focusManager: D
  });
  let T = q(e.autoFocus), R;
  e[Co] === "presentation" ? R = {
    role: "presentation"
  } : R = ge(u, {
    role: "group",
    "aria-disabled": e.isDisabled || void 0,
    "aria-describedby": m
  }), ue(() => {
    T.current && D.focusFirst(), T.current = !1;
  }, [
    D
  ]), fd(e.inputRef, t.value, t.setValue), Ad({
    ...e,
    focus() {
      D.focusFirst();
    }
  }, t, e.inputRef);
  let y = {
    type: "hidden",
    name: e.name,
    value: ((n = t.value) === null || n === void 0 ? void 0 : n.toString()) || ""
  };
  e.validationBehavior === "native" && (y.type = "text", y.hidden = !0, y.required = e.isRequired, y.onChange = () => {
  });
  let A = Me(e);
  return {
    labelProps: {
      ...s,
      onClick: () => {
        D.focusFirst();
      }
    },
    fieldProps: ge(A, R, S, f, {
      onKeyDown(w) {
        e.onKeyDown && e.onKeyDown(w);
      },
      onKeyUp(w) {
        e.onKeyUp && e.onKeyUp(w);
      }
    }),
    inputProps: y,
    descriptionProps: l,
    errorMessageProps: c,
    isInvalid: i,
    validationErrors: a,
    validationDetails: o
  };
}
function e7(e) {
  return e && e.__esModule ? e.default : e;
}
function t7() {
  let { locale: e } = lt(), t = yy(e7(Hs), "@react-aria/datepicker");
  return G(() => {
    try {
      return new Intl.DisplayNames(e, {
        type: "dateTimeField"
      });
    } catch {
      return new r7(e, t);
    }
  }, [
    e,
    t
  ]);
}
class r7 {
  of(t) {
    return this.dictionary.getStringForLocale(t, this.locale);
  }
  constructor(t, r) {
    this.locale = t, this.dictionary = r;
  }
}
var E4 = {};
E4 = {
  Empty: "فارغ"
};
var w4 = {};
w4 = {
  Empty: "Изпразни"
};
var C4 = {};
C4 = {
  Empty: "Prázdné"
};
var S4 = {};
S4 = {
  Empty: "Tom"
};
var k4 = {};
k4 = {
  Empty: "Leer"
};
var T4 = {};
T4 = {
  Empty: "Άδειο"
};
var P4 = {};
P4 = {
  Empty: "Empty"
};
var A4 = {};
A4 = {
  Empty: "Vacío"
};
var _4 = {};
_4 = {
  Empty: "Tühjenda"
};
var F4 = {};
F4 = {
  Empty: "Tyhjä"
};
var O4 = {};
O4 = {
  Empty: "Vide"
};
var I4 = {};
I4 = {
  Empty: "ריק"
};
var R4 = {};
R4 = {
  Empty: "Prazno"
};
var B4 = {};
B4 = {
  Empty: "Üres"
};
var M4 = {};
M4 = {
  Empty: "Vuoto"
};
var N4 = {};
N4 = {
  Empty: "空"
};
var L4 = {};
L4 = {
  Empty: "비어 있음"
};
var V4 = {};
V4 = {
  Empty: "Tuščias"
};
var j4 = {};
j4 = {
  Empty: "Tukšs"
};
var z4 = {};
z4 = {
  Empty: "Tom"
};
var K4 = {};
K4 = {
  Empty: "Leeg"
};
var U4 = {};
U4 = {
  Empty: "Pusty"
};
var q4 = {};
q4 = {
  Empty: "Vazio"
};
var H4 = {};
H4 = {
  Empty: "Vazio"
};
var W4 = {};
W4 = {
  Empty: "Gol"
};
var Q4 = {};
Q4 = {
  Empty: "Не заполнено"
};
var G4 = {};
G4 = {
  Empty: "Prázdne"
};
var Z4 = {};
Z4 = {
  Empty: "Prazen"
};
var Y4 = {};
Y4 = {
  Empty: "Prazno"
};
var J4 = {};
J4 = {
  Empty: "Tomt"
};
var X4 = {};
X4 = {
  Empty: "Boş"
};
var e3 = {};
e3 = {
  Empty: "Пусто"
};
var t3 = {};
t3 = {
  Empty: "空"
};
var r3 = {};
r3 = {
  Empty: "空白"
};
var n3 = {};
n3 = {
  "ar-AE": E4,
  "bg-BG": w4,
  "cs-CZ": C4,
  "da-DK": S4,
  "de-DE": k4,
  "el-GR": T4,
  "en-US": P4,
  "es-ES": A4,
  "et-EE": _4,
  "fi-FI": F4,
  "fr-FR": O4,
  "he-IL": I4,
  "hr-HR": R4,
  "hu-HU": B4,
  "it-IT": M4,
  "ja-JP": N4,
  "ko-KR": L4,
  "lt-LT": V4,
  "lv-LV": j4,
  "nb-NO": z4,
  "nl-NL": K4,
  "pl-PL": U4,
  "pt-BR": q4,
  "pt-PT": H4,
  "ro-RO": W4,
  "ru-RU": Q4,
  "sk-SK": G4,
  "sl-SI": Z4,
  "sr-SP": Y4,
  "sv-SE": J4,
  "tr-TR": X4,
  "uk-UA": e3,
  "zh-CN": t3,
  "zh-TW": r3
};
function n7(e) {
  return e && e.__esModule ? e.default : e;
}
function i7(e) {
  const t = q();
  let { value: r, textValue: n, minValue: i, maxValue: a, isDisabled: o, isReadOnly: s, isRequired: u, onIncrement: l, onIncrementPage: c, onDecrement: d, onDecrementPage: f, onDecrementToMin: h, onIncrementToMax: p } = e;
  const v = zt(n7(n3), "@react-aria/spinbutton"), g = () => clearTimeout(t.current);
  ue(() => () => g(), []);
  let $ = (E) => {
    if (!(E.ctrlKey || E.metaKey || E.shiftKey || E.altKey || s))
      switch (E.key) {
        case "PageUp":
          if (c) {
            E.preventDefault(), c == null || c();
            break;
          }
        case "ArrowUp":
        case "Up":
          l && (E.preventDefault(), l == null || l());
          break;
        case "PageDown":
          if (f) {
            E.preventDefault(), f == null || f();
            break;
          }
        case "ArrowDown":
        case "Down":
          d && (E.preventDefault(), d == null || d());
          break;
        case "Home":
          h && (E.preventDefault(), h == null || h());
          break;
        case "End":
          p && (E.preventDefault(), p == null || p());
          break;
      }
  }, m = q(!1), b = () => {
    m.current = !0;
  }, D = () => {
    m.current = !1;
  }, S = n === "" ? v.format("Empty") : (n || `${r}`).replace("-", "−");
  ue(() => {
    m.current && (XC("assertive"), Qn(S, "assertive"));
  }, [
    S
  ]);
  const T = st((E) => {
    g(), l == null || l(), t.current = window.setTimeout(() => {
      (a === void 0 || isNaN(a) || r === void 0 || isNaN(r) || r < a) && T(60);
    }, E);
  }), R = st((E) => {
    g(), d == null || d(), t.current = window.setTimeout(() => {
      (i === void 0 || isNaN(i) || r === void 0 || isNaN(r) || r > i) && R(60);
    }, E);
  });
  let y = (E) => {
    E.preventDefault();
  }, { addGlobalListener: A, removeAllGlobalListeners: w } = cd();
  return {
    spinButtonProps: {
      role: "spinbutton",
      "aria-valuenow": r !== void 0 && !isNaN(r) ? r : void 0,
      "aria-valuetext": S,
      "aria-valuemin": i,
      "aria-valuemax": a,
      "aria-disabled": o || void 0,
      "aria-readonly": s || void 0,
      "aria-required": u || void 0,
      onKeyDown: $,
      onFocus: b,
      onBlur: D
    },
    incrementButtonProps: {
      onPressStart: () => {
        T(400), A(window, "contextmenu", y);
      },
      onPressEnd: () => {
        g(), w();
      },
      onFocus: b,
      onBlur: D
    },
    decrementButtonProps: {
      onPressStart: () => {
        R(400), A(window, "contextmenu", y);
      },
      onPressEnd: () => {
        g(), w();
      },
      onFocus: b,
      onBlur: D
    }
  };
}
function a7(e, t, r) {
  let n = q(""), { locale: i } = lt(), a = t7(), { ariaLabel: o, ariaLabelledBy: s, ariaDescribedBy: u, focusManager: l } = x4.get(t), c = e.isPlaceholder ? "" : e.text, d = G(() => t.dateFormatter.resolvedOptions(), [
    t.dateFormatter
  ]), f = Wt({
    month: "long",
    timeZone: d.timeZone
  }), h = Wt({
    hour: "numeric",
    hour12: d.hour12,
    timeZone: d.timeZone
  });
  if (e.type === "month" && !e.isPlaceholder) {
    let x = f.format(t.dateValue);
    c = x !== c ? `${c} – ${x}` : x;
  } else e.type === "hour" && !e.isPlaceholder && (c = h.format(t.dateValue));
  let { spinButtonProps: p } = i7({
    // The ARIA spec says aria-valuenow is optional if there's no value, but aXe seems to require it.
    // This doesn't seem to have any negative effects with real AT since we also use aria-valuetext.
    // https://github.com/dequelabs/axe-core/issues/3505
    value: e.value,
    textValue: c,
    minValue: e.minValue,
    maxValue: e.maxValue,
    isDisabled: t.isDisabled,
    isReadOnly: t.isReadOnly || !e.isEditable,
    isRequired: t.isRequired,
    onIncrement: () => {
      n.current = "", t.increment(e.type);
    },
    onDecrement: () => {
      n.current = "", t.decrement(e.type);
    },
    onIncrementPage: () => {
      n.current = "", t.incrementPage(e.type);
    },
    onDecrementPage: () => {
      n.current = "", t.decrementPage(e.type);
    },
    onIncrementToMax: () => {
      n.current = "", t.setSegment(e.type, e.maxValue);
    },
    onDecrementToMin: () => {
      n.current = "", t.setSegment(e.type, e.minValue);
    }
  }), v = G(() => new Hy(i, {
    maximumFractionDigits: 0
  }), [
    i
  ]), g = () => {
    if (e.text === e.placeholder && l.focusPrevious(), v.isValidPartialNumber(e.text) && !t.isReadOnly && !e.isPlaceholder) {
      let x = e.text.slice(0, -1), U = v.parse(x);
      x = U === 0 ? "" : x, x.length === 0 || U === 0 ? t.clearSegment(e.type) : t.setSegment(e.type, U), n.current = x;
    } else e.type === "dayPeriod" && t.clearSegment(e.type);
  }, $ = (x) => {
    if (x.key === "a" && (yr() ? x.metaKey : x.ctrlKey) && x.preventDefault(), !(x.ctrlKey || x.metaKey || x.shiftKey || x.altKey))
      switch (x.key) {
        case "Backspace":
        case "Delete":
          x.preventDefault(), x.stopPropagation(), g();
          break;
      }
  }, { startsWith: m } = Wy({
    sensitivity: "base"
  }), b = Wt({
    hour: "numeric",
    hour12: !0
  }), D = G(() => {
    let x = /* @__PURE__ */ new Date();
    return x.setHours(0), b.formatToParts(x).find((U) => U.type === "dayPeriod").value;
  }, [
    b
  ]), S = G(() => {
    let x = /* @__PURE__ */ new Date();
    return x.setHours(12), b.formatToParts(x).find((U) => U.type === "dayPeriod").value;
  }, [
    b
  ]), T = Wt({
    year: "numeric",
    era: "narrow",
    timeZone: "UTC"
  }), R = G(() => {
    if (e.type !== "era") return [];
    let x = Ve(new et(1, 1, 1), t.calendar), U = t.calendar.getEras().map((j) => {
      let ae = x.set({
        year: 1,
        month: 1,
        day: 1,
        era: j
      }).toDate("UTC"), me = T.formatToParts(ae).find(($e) => $e.type === "era").value;
      return {
        era: j,
        formatted: me
      };
    }), K = o7(U.map((j) => j.formatted));
    if (K) for (let j of U) j.formatted = j.formatted.slice(K);
    return U;
  }, [
    T,
    t.calendar,
    e.type
  ]), y = (x) => {
    if (t.isDisabled || t.isReadOnly) return;
    let U = n.current + x;
    switch (e.type) {
      case "dayPeriod":
        if (m(D, x)) t.setSegment("dayPeriod", 0);
        else if (m(S, x)) t.setSegment("dayPeriod", 12);
        else break;
        l.focusNext();
        break;
      case "era": {
        let K = R.find((j) => m(j.formatted, x));
        K && (t.setSegment("era", K.era), l.focusNext());
        break;
      }
      case "day":
      case "hour":
      case "minute":
      case "second":
      case "month":
      case "year": {
        if (!v.isValidPartialNumber(U)) return;
        let K = v.parse(U), j = K, ae = e.minValue === 0;
        if (e.type === "hour" && t.dateFormatter.resolvedOptions().hour12) {
          switch (t.dateFormatter.resolvedOptions().hourCycle) {
            case "h11":
              K > 11 && (j = v.parse(x));
              break;
            case "h12":
              ae = !1, K > 12 && (j = v.parse(x));
              break;
          }
          e.value >= 12 && K > 1 && (K += 12);
        } else K > e.maxValue && (j = v.parse(x));
        if (isNaN(K)) return;
        let ne = j !== 0 || ae;
        ne && t.setSegment(e.type, j), +(K + "0") > e.maxValue || U.length >= String(e.maxValue).length ? (n.current = "", ne && l.focusNext()) : n.current = U;
        break;
      }
    }
  }, A = () => {
    n.current = "", Xo(r.current, {
      containingElement: Is(r.current)
    }), window.getSelection().collapse(r.current);
  }, w = q("");
  Un(r, "beforeinput", (x) => {
    switch (x.preventDefault(), x.inputType) {
      case "deleteContentBackward":
      case "deleteContentForward":
        v.isValidPartialNumber(e.text) && !t.isReadOnly && g();
        break;
      case "insertCompositionText":
        w.current = r.current.textContent, r.current.textContent = r.current.textContent;
        break;
      default:
        x.data != null && y(x.data);
        break;
    }
  }), Un(r, "input", (x) => {
    let { inputType: U, data: K } = x;
    switch (U) {
      case "insertCompositionText":
        r.current.textContent = w.current, (m(D, K) || m(S, K)) && y(K);
        break;
    }
  }), Oe(() => {
    let x = r.current;
    return () => {
      document.activeElement === x && (l.focusPrevious() || l.focusNext());
    };
  }, [
    r,
    l
  ]);
  let E = Ta() || e.type === "timeZoneName" ? {
    role: "textbox",
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuetext": null,
    "aria-valuenow": null
  } : {}, k = G(() => t.segments.find((x) => x.isEditable), [
    t.segments
  ]);
  e !== k && !t.isInvalid && (u = void 0);
  let C = Ct(), P = !t.isDisabled && !t.isReadOnly && e.isEditable, L = e.type === "literal" ? "" : a.of(e.type), O = cn({
    "aria-label": `${L}${o ? `, ${o}` : ""}${s ? ", " : ""}`,
    "aria-labelledby": s
  });
  return e.type === "literal" ? {
    segmentProps: {
      "aria-hidden": !0
    }
  } : {
    segmentProps: ge(p, O, {
      id: C,
      ...E,
      "aria-invalid": t.isInvalid ? "true" : void 0,
      "aria-describedby": u,
      "aria-readonly": t.isReadOnly || !e.isEditable ? "true" : void 0,
      "data-placeholder": e.isPlaceholder || void 0,
      contentEditable: P,
      suppressContentEditableWarning: P,
      spellCheck: P ? "false" : void 0,
      autoCapitalize: P ? "off" : void 0,
      autoCorrect: P ? "off" : void 0,
      // Capitalization was changed in React 17...
      [parseInt(F.version, 10) >= 17 ? "enterKeyHint" : "enterkeyhint"]: P ? "next" : void 0,
      inputMode: t.isDisabled || e.type === "dayPeriod" || e.type === "era" || !P ? void 0 : "numeric",
      tabIndex: t.isDisabled ? void 0 : 0,
      onKeyDown: $,
      onFocus: A,
      style: {
        caretColor: "transparent"
      },
      // Prevent pointer events from reaching useDatePickerGroup, and allow native browser behavior to focus the segment.
      onPointerDown(x) {
        x.stopPropagation();
      },
      onMouseDown(x) {
        x.stopPropagation();
      }
    })
  };
}
function o7(e) {
  e.sort();
  let t = e[0], r = e[e.length - 1];
  for (let n = 0; n < t.length; n++)
    if (t[n] !== r[n]) return n;
  return 0;
}
function s7(e) {
  return e && e.__esModule ? e.default : e;
}
function u7(e, t, r) {
  var n, i;
  let a = zt(s7(Hs), "@react-aria/datepicker"), { isInvalid: o, validationErrors: s, validationDetails: u } = t.displayValidation, { labelProps: l, fieldProps: c, descriptionProps: d, errorMessageProps: f } = zs({
    ...e,
    labelElementType: "span",
    isInvalid: o,
    errorMessage: e.errorMessage || s
  }), h = c["aria-labelledby"] || c.id, { locale: p } = lt(), v = t.formatValue(p, {
    month: "long"
  }), g = v ? a.format("selectedRangeDescription", {
    startDate: v.start,
    endDate: v.end
  }) : "", $ = Rs(g), m = {
    "aria-label": a.format("startDate"),
    "aria-labelledby": h
  }, b = {
    "aria-label": a.format("endDate"),
    "aria-labelledby": h
  }, D = Ct(), S = Ct(), T = $4(t, r), R = [
    $["aria-describedby"],
    c["aria-describedby"]
  ].filter(Boolean).join(" ") || void 0, y = G(() => md(r, {
    // Exclude the button from the focus manager.
    accept: (P) => P.id !== D
  }), [
    r,
    D
  ]), A = {
    [D4]: y,
    [Co]: "presentation",
    "aria-describedby": R,
    placeholderValue: e.placeholderValue,
    hideTimeZone: e.hideTimeZone,
    hourCycle: e.hourCycle,
    granularity: e.granularity,
    shouldForceLeadingZeros: e.shouldForceLeadingZeros,
    isDisabled: e.isDisabled,
    isReadOnly: e.isReadOnly,
    isRequired: e.isRequired,
    validationBehavior: e.validationBehavior
  }, w = Me(e), { focusWithinProps: E } = ci({
    ...e,
    isDisabled: t.isOpen,
    onBlurWithin: e.onBlur,
    onFocusWithin: e.onFocus,
    onFocusWithinChange: e.onFocusChange
  }), k = q(Zr), C = q(Zr);
  return {
    groupProps: ge(w, T, c, $, E, {
      role: "group",
      "aria-disabled": e.isDisabled || null,
      "aria-describedby": R,
      onKeyDown(P) {
        t.isOpen || e.onKeyDown && e.onKeyDown(P);
      },
      onKeyUp(P) {
        t.isOpen || e.onKeyUp && e.onKeyUp(P);
      }
    }),
    labelProps: {
      ...l,
      onClick: () => {
        y.focusFirst();
      }
    },
    buttonProps: {
      ...$,
      id: D,
      "aria-haspopup": "dialog",
      "aria-label": a.format("calendar"),
      "aria-labelledby": `${D} ${h}`,
      "aria-describedby": R,
      "aria-expanded": t.isOpen,
      isDisabled: e.isDisabled || e.isReadOnly,
      onPress: () => t.setOpen(!0)
    },
    dialogProps: {
      id: S,
      "aria-labelledby": `${D} ${h}`
    },
    startFieldProps: {
      ...m,
      ...A,
      value: (n = t.value) === null || n === void 0 ? void 0 : n.start,
      onChange: (P) => t.setDateTime("start", P),
      autoFocus: e.autoFocus,
      name: e.startName,
      [va]: {
        realtimeValidation: t.realtimeValidation,
        displayValidation: t.displayValidation,
        updateValidation(P) {
          k.current = P, t.updateValidation(ps(P, C.current));
        },
        resetValidation: t.resetValidation,
        commitValidation: t.commitValidation
      }
    },
    endFieldProps: {
      ...b,
      ...A,
      value: (i = t.value) === null || i === void 0 ? void 0 : i.end,
      onChange: (P) => t.setDateTime("end", P),
      name: e.endName,
      [va]: {
        realtimeValidation: t.realtimeValidation,
        displayValidation: t.displayValidation,
        updateValidation(P) {
          C.current = P, t.updateValidation(ps(k.current, P));
        },
        resetValidation: t.resetValidation,
        commitValidation: t.commitValidation
      }
    },
    descriptionProps: d,
    errorMessageProps: f,
    calendarProps: {
      autoFocus: !0,
      value: t.dateRange,
      onChange: t.setDateRange,
      minValue: e.minValue,
      maxValue: e.maxValue,
      isDisabled: e.isDisabled,
      isReadOnly: e.isReadOnly,
      isDateUnavailable: e.isDateUnavailable,
      allowsNonContiguousRanges: e.allowsNonContiguousRanges,
      defaultFocusedValue: t.dateRange ? void 0 : e.placeholderValue,
      isInvalid: t.isInvalid,
      errorMessage: typeof e.errorMessage == "function" ? e.errorMessage(t.displayValidation) : e.errorMessage || t.displayValidation.validationErrors.join(" ")
    },
    isInvalid: o,
    validationErrors: s,
    validationDetails: u
  };
}
function l7(e, t) {
  let { role: r = "dialog" } = e, n = ai();
  n = e["aria-label"] ? void 0 : n;
  let i = q(!1);
  return ue(() => {
    if (t.current && !t.current.contains(document.activeElement)) {
      fn(t.current);
      let a = setTimeout(() => {
        document.activeElement === t.current && (i.current = !0, t.current && (t.current.blur(), fn(t.current)), i.current = !1);
      }, 500);
      return () => {
        clearTimeout(a);
      };
    }
  }, [
    t
  ]), IS(), {
    dialogProps: {
      ...Me(e, {
        labelable: !0
      }),
      role: r,
      tabIndex: -1,
      "aria-labelledby": e["aria-labelledby"] || n,
      // Prevent blur events from reaching useOverlay, which may cause
      // popovers to close. Since focus is contained within the dialog,
      // we don't want this to occur due to the above useEffect.
      onBlur: (a) => {
        i.current && a.stopPropagation();
      }
    },
    titleProps: {
      id: n
    }
  };
}
const i3 = /* @__PURE__ */ new WeakMap();
function c7(e, t, r) {
  let { keyboardDelegate: n, isDisabled: i, isRequired: a, name: o, validationBehavior: s = "aria" } = e, u = Vs({
    usage: "search",
    sensitivity: "base"
  }), l = G(() => n || new Us(t.collection, t.disabledKeys, null, u), [
    n,
    t.collection,
    t.disabledKeys,
    u
  ]), { menuTriggerProps: c, menuProps: d } = Lb({
    isDisabled: i,
    type: "listbox"
  }, t, r), f = (y) => {
    switch (y.key) {
      case "ArrowLeft": {
        y.preventDefault();
        let A = t.selectedKey != null ? l.getKeyAbove(t.selectedKey) : l.getFirstKey();
        A && t.setSelectedKey(A);
        break;
      }
      case "ArrowRight": {
        y.preventDefault();
        let A = t.selectedKey != null ? l.getKeyBelow(t.selectedKey) : l.getFirstKey();
        A && t.setSelectedKey(A);
        break;
      }
    }
  }, { typeSelectProps: h } = tb({
    keyboardDelegate: l,
    selectionManager: t.selectionManager,
    onTypeSelect(y) {
      t.setSelectedKey(y);
    }
  }), { isInvalid: p, validationErrors: v, validationDetails: g } = t.displayValidation, { labelProps: $, fieldProps: m, descriptionProps: b, errorMessageProps: D } = zs({
    ...e,
    labelElementType: "span",
    isInvalid: p,
    errorMessage: e.errorMessage || v
  });
  h.onKeyDown = h.onKeyDownCapture, delete h.onKeyDownCapture;
  let S = Me(e, {
    labelable: !0
  }), T = ge(h, c, m), R = Ct();
  return i3.set(t, {
    isDisabled: i,
    isRequired: a,
    name: o,
    validationBehavior: s
  }), {
    labelProps: {
      ...$,
      onClick: () => {
        e.isDisabled || (r.current.focus(), ly("keyboard"));
      }
    },
    triggerProps: ge(S, {
      ...T,
      isDisabled: i,
      onKeyDown: zr(T.onKeyDown, f, e.onKeyDown),
      onKeyUp: e.onKeyUp,
      "aria-labelledby": [
        R,
        T["aria-labelledby"],
        T["aria-label"] && !T["aria-labelledby"] ? T.id : null
      ].filter(Boolean).join(" "),
      onFocus(y) {
        t.isFocused || (e.onFocus && e.onFocus(y), e.onFocusChange && e.onFocusChange(!0), t.setFocused(!0));
      },
      onBlur(y) {
        t.isOpen || (e.onBlur && e.onBlur(y), e.onFocusChange && e.onFocusChange(!1), t.setFocused(!1));
      }
    }),
    valueProps: {
      id: R
    },
    menuProps: {
      ...d,
      autoFocus: t.focusStrategy || !0,
      shouldSelectOnPressUp: !0,
      shouldFocusOnHover: !0,
      disallowEmptySelection: !0,
      linkBehavior: "selection",
      onBlur: (y) => {
        y.currentTarget.contains(y.relatedTarget) || (e.onBlur && e.onBlur(y), e.onFocusChange && e.onFocusChange(!1), t.setFocused(!1));
      },
      "aria-labelledby": [
        m["aria-labelledby"],
        T["aria-label"] && !m["aria-labelledby"] ? T.id : null
      ].filter(Boolean).join(" ")
    },
    descriptionProps: b,
    errorMessageProps: D,
    isInvalid: p,
    validationErrors: v,
    validationDetails: g
  };
}
function d7(e, t, r) {
  let n = i3.get(t) || {}, { autoComplete: i, name: a = n.name, isDisabled: o = n.isDisabled } = e, { validationBehavior: s, isRequired: u } = n, l = m6(), { visuallyHiddenProps: c } = Y0();
  fd(e.selectRef, t.selectedKey, t.setSelectedKey), Ad({
    validationBehavior: s,
    focus: () => r.current.focus()
  }, t, e.selectRef);
  var d;
  return {
    containerProps: {
      ...c,
      "aria-hidden": !0,
      "data-react-aria-prevent-focus": !0,
      "data-a11y-ignore": "aria-hidden-focus"
    },
    inputProps: {
      type: "text",
      tabIndex: l == null || t.isFocused || t.isOpen ? -1 : 0,
      style: {
        fontSize: 16
      },
      onFocus: () => r.current.focus(),
      disabled: o
    },
    selectProps: {
      tabIndex: -1,
      autoComplete: i,
      disabled: o,
      required: s === "native" && u,
      name: a,
      value: (d = t.selectedKey) !== null && d !== void 0 ? d : "",
      onChange: (f) => t.setSelectedKey(f.target.value)
    }
  };
}
function f7(e) {
  let { state: t, triggerRef: r, label: n, name: i, isDisabled: a } = e, o = q(null), { containerProps: s, inputProps: u, selectProps: l } = d7({
    ...e,
    selectRef: o
  }, t, r);
  var c;
  return t.collection.size <= 300 ? /* @__PURE__ */ F.createElement("div", {
    ...s,
    "data-testid": "hidden-select-container"
  }, /* @__PURE__ */ F.createElement("input", u), /* @__PURE__ */ F.createElement("label", null, n, /* @__PURE__ */ F.createElement("select", {
    ...l,
    ref: o
  }, /* @__PURE__ */ F.createElement("option", null), [
    ...t.collection.getKeys()
  ].map((d) => {
    let f = t.collection.getItem(d);
    if (f.type === "item") return /* @__PURE__ */ F.createElement("option", {
      key: f.key,
      value: f.key
    }, f.textValue);
  })))) : i ? /* @__PURE__ */ F.createElement("input", {
    type: "hidden",
    autoComplete: l.autoComplete,
    name: i,
    disabled: a,
    value: (c = t.selectedKey) !== null && c !== void 0 ? c : ""
  }) : null;
}
function h7(e) {
  let t = Me(e, {
    labelable: !0
  }), r;
  return e.orientation === "vertical" && (r = "vertical"), e.elementType !== "hr" ? {
    separatorProps: {
      ...t,
      role: "separator",
      "aria-orientation": r
    }
  } : {
    separatorProps: t
  };
}
var lc = { exports: {} }, Yu = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gp;
function p7() {
  if (gp) return Yu;
  gp = 1;
  var e = F;
  function t(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var r = typeof Object.is == "function" ? Object.is : t, n = e.useState, i = e.useEffect, a = e.useLayoutEffect, o = e.useDebugValue;
  function s(d, f) {
    var h = f(), p = n({ inst: { value: h, getSnapshot: f } }), v = p[0].inst, g = p[1];
    return a(function() {
      v.value = h, v.getSnapshot = f, u(v) && g({ inst: v });
    }, [d, h, f]), i(function() {
      return u(v) && g({ inst: v }), d(function() {
        u(v) && g({ inst: v });
      });
    }, [d]), o(h), h;
  }
  function u(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var h = f();
      return !r(d, h);
    } catch {
      return !0;
    }
  }
  function l(d, f) {
    return f();
  }
  var c = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? l : s;
  return Yu.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : c, Yu;
}
var Ju = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bp;
function m7() {
  return bp || (bp = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = F, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(b) {
      {
        for (var D = arguments.length, S = new Array(D > 1 ? D - 1 : 0), T = 1; T < D; T++)
          S[T - 1] = arguments[T];
        n("error", b, S);
      }
    }
    function n(b, D, S) {
      {
        var T = t.ReactDebugCurrentFrame, R = T.getStackAddendum();
        R !== "" && (D += "%s", S = S.concat([R]));
        var y = S.map(function(A) {
          return String(A);
        });
        y.unshift("Warning: " + D), Function.prototype.apply.call(console[b], console, y);
      }
    }
    function i(b, D) {
      return b === D && (b !== 0 || 1 / b === 1 / D) || b !== b && D !== D;
    }
    var a = typeof Object.is == "function" ? Object.is : i, o = e.useState, s = e.useEffect, u = e.useLayoutEffect, l = e.useDebugValue, c = !1, d = !1;
    function f(b, D, S) {
      c || e.startTransition !== void 0 && (c = !0, r("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var T = D();
      if (!d) {
        var R = D();
        a(T, R) || (r("The result of getSnapshot should be cached to avoid an infinite loop"), d = !0);
      }
      var y = o({
        inst: {
          value: T,
          getSnapshot: D
        }
      }), A = y[0].inst, w = y[1];
      return u(function() {
        A.value = T, A.getSnapshot = D, h(A) && w({
          inst: A
        });
      }, [b, T, D]), s(function() {
        h(A) && w({
          inst: A
        });
        var E = function() {
          h(A) && w({
            inst: A
          });
        };
        return b(E);
      }, [b]), l(T), T;
    }
    function h(b) {
      var D = b.getSnapshot, S = b.value;
      try {
        var T = D();
        return !a(S, T);
      } catch {
        return !0;
      }
    }
    function p(b, D, S) {
      return D();
    }
    var v = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", g = !v, $ = g ? p : f, m = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : $;
    Ju.useSyncExternalStore = m, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Ju;
}
process.env.NODE_ENV === "production" ? lc.exports = p7() : lc.exports = m7();
var v7 = lc.exports;
class _d {
  get childNodes() {
    throw new Error("childNodes is not supported");
  }
  clone() {
    let t = new _d(this.type, this.key);
    return t.value = this.value, t.level = this.level, t.hasChildNodes = this.hasChildNodes, t.rendered = this.rendered, t.textValue = this.textValue, t["aria-label"] = this["aria-label"], t.index = this.index, t.parentKey = this.parentKey, t.prevKey = this.prevKey, t.nextKey = this.nextKey, t.firstChildKey = this.firstChildKey, t.lastChildKey = this.lastChildKey, t.props = this.props, t;
  }
  constructor(t, r) {
    this.value = null, this.level = 0, this.hasChildNodes = !1, this.rendered = null, this.textValue = "", this["aria-label"] = void 0, this.index = 0, this.parentKey = null, this.prevKey = null, this.nextKey = null, this.firstChildKey = null, this.lastChildKey = null, this.props = {}, this.type = t, this.key = r;
  }
}
class a3 {
  *[Symbol.iterator]() {
    let t = this.firstChild;
    for (; t; )
      yield t, t = t.nextSibling;
  }
  get firstChild() {
    return this._firstChild;
  }
  set firstChild(t) {
    this._firstChild = t, this.ownerDocument.markDirty(this);
  }
  get lastChild() {
    return this._lastChild;
  }
  set lastChild(t) {
    this._lastChild = t, this.ownerDocument.markDirty(this);
  }
  get previousSibling() {
    return this._previousSibling;
  }
  set previousSibling(t) {
    this._previousSibling = t, this.ownerDocument.markDirty(this);
  }
  get nextSibling() {
    return this._nextSibling;
  }
  set nextSibling(t) {
    this._nextSibling = t, this.ownerDocument.markDirty(this);
  }
  get parentNode() {
    return this._parentNode;
  }
  set parentNode(t) {
    this._parentNode = t, this.ownerDocument.markDirty(this);
  }
  get isConnected() {
    var t;
    return ((t = this.parentNode) === null || t === void 0 ? void 0 : t.isConnected) || !1;
  }
  appendChild(t) {
    this.ownerDocument.startTransaction(), t.parentNode && t.parentNode.removeChild(t), this.firstChild == null && (this.firstChild = t), this.lastChild ? (this.lastChild.nextSibling = t, t.index = this.lastChild.index + 1, t.previousSibling = this.lastChild) : (t.previousSibling = null, t.index = 0), t.parentNode = this, t.nextSibling = null, this.lastChild = t, this.ownerDocument.markDirty(this), t.hasSetProps && this.ownerDocument.addNode(t), this.ownerDocument.endTransaction(), this.ownerDocument.queueUpdate();
  }
  insertBefore(t, r) {
    if (r == null) return this.appendChild(t);
    this.ownerDocument.startTransaction(), t.parentNode && t.parentNode.removeChild(t), t.nextSibling = r, t.previousSibling = r.previousSibling, t.index = r.index, this.firstChild === r ? this.firstChild = t : r.previousSibling && (r.previousSibling.nextSibling = t), r.previousSibling = t, t.parentNode = r.parentNode;
    let n = r;
    for (; n; )
      n.index++, n = n.nextSibling;
    t.hasSetProps && this.ownerDocument.addNode(t), this.ownerDocument.endTransaction(), this.ownerDocument.queueUpdate();
  }
  removeChild(t) {
    if (t.parentNode !== this) return;
    this.ownerDocument.startTransaction();
    let r = t.nextSibling;
    for (; r; )
      r.index--, r = r.nextSibling;
    t.nextSibling && (t.nextSibling.previousSibling = t.previousSibling), t.previousSibling && (t.previousSibling.nextSibling = t.nextSibling), this.firstChild === t && (this.firstChild = t.nextSibling), this.lastChild === t && (this.lastChild = t.previousSibling), t.parentNode = null, t.nextSibling = null, t.previousSibling = null, t.index = 0, this.ownerDocument.removeNode(t), this.ownerDocument.endTransaction(), this.ownerDocument.queueUpdate();
  }
  addEventListener() {
  }
  removeEventListener() {
  }
  constructor(t) {
    this._firstChild = null, this._lastChild = null, this._previousSibling = null, this._nextSibling = null, this._parentNode = null, this.ownerDocument = t;
  }
}
class ya extends a3 {
  get index() {
    return this._index;
  }
  set index(t) {
    this._index = t, this.ownerDocument.markDirty(this);
  }
  get level() {
    return this.parentNode instanceof ya ? this.parentNode.level + (this.node.type === "item" ? 1 : 0) : 0;
  }
  updateNode() {
    var t, r, n, i;
    let a = this.ownerDocument.getMutableNode(this);
    a.index = this.index, a.level = this.level, a.parentKey = this.parentNode instanceof ya ? this.parentNode.node.key : null;
    var o;
    a.prevKey = (o = (t = this.previousSibling) === null || t === void 0 ? void 0 : t.node.key) !== null && o !== void 0 ? o : null;
    var s;
    a.nextKey = (s = (r = this.nextSibling) === null || r === void 0 ? void 0 : r.node.key) !== null && s !== void 0 ? s : null, a.hasChildNodes = !!this.firstChild;
    var u;
    a.firstChildKey = (u = (n = this.firstChild) === null || n === void 0 ? void 0 : n.node.key) !== null && u !== void 0 ? u : null;
    var l;
    a.lastChildKey = (l = (i = this.lastChild) === null || i === void 0 ? void 0 : i.node.key) !== null && l !== void 0 ? l : null;
  }
  setProps(t, r, n) {
    let i = this.ownerDocument.getMutableNode(this), { value: a, textValue: o, id: s, ...u } = t;
    if (u.ref = r, i.props = u, i.rendered = n, i.value = a, i.textValue = o || (typeof n == "string" ? n : "") || t["aria-label"] || "", s != null && s !== i.key) {
      if (this.hasSetProps) throw new Error("Cannot change the id of an item");
      i.key = s;
    }
    this.hasSetProps || (this.ownerDocument.addNode(this), this.ownerDocument.endTransaction(), this.hasSetProps = !0), this.ownerDocument.queueUpdate();
  }
  get style() {
    return {};
  }
  hasAttribute() {
  }
  setAttribute() {
  }
  setAttributeNS() {
  }
  removeAttribute() {
  }
  constructor(t, r) {
    super(r), this.nodeType = 8, this._index = 0, this.hasSetProps = !1, this.node = new _d(t, `react-aria-${++r.nodeId}`), this.ownerDocument.startTransaction();
  }
}
class y7 {
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  *[Symbol.iterator]() {
    let t = this.firstKey != null ? this.keyMap.get(this.firstKey) : void 0;
    for (; t; )
      yield t, t = t.nextKey != null ? this.keyMap.get(t.nextKey) : void 0;
  }
  getChildren(t) {
    let r = this.keyMap;
    return {
      *[Symbol.iterator]() {
        let n = r.get(t), i = (n == null ? void 0 : n.firstChildKey) != null ? r.get(n.firstChildKey) : null;
        for (; i; )
          yield i, i = i.nextKey != null ? r.get(i.nextKey) : void 0;
      }
    };
  }
  getKeyBefore(t) {
    let r = this.keyMap.get(t);
    if (!r) return null;
    if (r.prevKey != null) {
      for (r = this.keyMap.get(r.prevKey); r && r.type !== "item" && r.lastChildKey != null; ) r = this.keyMap.get(r.lastChildKey);
      var n;
      return (n = r == null ? void 0 : r.key) !== null && n !== void 0 ? n : null;
    }
    return r.parentKey;
  }
  getKeyAfter(t) {
    let r = this.keyMap.get(t);
    if (!r) return null;
    if (r.type !== "item" && r.firstChildKey != null) return r.firstChildKey;
    for (; r; ) {
      if (r.nextKey != null) return r.nextKey;
      if (r.parentKey != null) r = this.keyMap.get(r.parentKey);
      else return null;
    }
    return null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    let t = this.lastKey != null ? this.keyMap.get(this.lastKey) : null;
    for (; (t == null ? void 0 : t.lastChildKey) != null; ) t = this.keyMap.get(t.lastChildKey);
    var r;
    return (r = t == null ? void 0 : t.key) !== null && r !== void 0 ? r : null;
  }
  getItem(t) {
    var r;
    return (r = this.keyMap.get(t)) !== null && r !== void 0 ? r : null;
  }
  at() {
    throw new Error("Not implemented");
  }
  clone() {
    let t = this.constructor, r = new t();
    return r.keyMap = new Map(this.keyMap), r.firstKey = this.firstKey, r.lastKey = this.lastKey, r;
  }
  addNode(t) {
    if (this.frozen) throw new Error("Cannot add a node to a frozen collection");
    this.keyMap.set(t.key, t);
  }
  removeNode(t) {
    if (this.frozen) throw new Error("Cannot remove a node to a frozen collection");
    this.keyMap.delete(t);
  }
  commit(t, r, n = !1) {
    if (this.frozen) throw new Error("Cannot commit a frozen collection");
    this.firstKey = t, this.lastKey = r, this.frozen = !n;
  }
  constructor() {
    this.keyMap = /* @__PURE__ */ new Map(), this.firstKey = null, this.lastKey = null, this.frozen = !1;
  }
}
class g7 extends a3 {
  get isConnected() {
    return !0;
  }
  createElement(t) {
    return new ya(t, this);
  }
  /**
  * Lazily gets a mutable instance of a Node. If the node has already
  * been cloned during this update cycle, it just returns the existing one.
  */
  getMutableNode(t) {
    let r = t.node;
    return this.mutatedNodes.has(t) || (r = t.node.clone(), this.mutatedNodes.add(t), t.node = r), this.markDirty(t), r;
  }
  getMutableCollection() {
    return !this.isSSR && !this.collectionMutated && (this.collection = this.collection.clone(), this.collectionMutated = !0), this.collection;
  }
  markDirty(t) {
    this.dirtyNodes.add(t);
  }
  startTransaction() {
    this.transactionCount++;
  }
  endTransaction() {
    this.transactionCount--;
  }
  addNode(t) {
    let r = this.getMutableCollection();
    if (!r.getItem(t.node.key)) {
      r.addNode(t.node);
      for (let n of t) this.addNode(n);
    }
    this.markDirty(t);
  }
  removeNode(t) {
    for (let n of t) this.removeNode(n);
    this.getMutableCollection().removeNode(t.node.key), this.markDirty(t);
  }
  /** Finalizes the collection update, updating all nodes and freezing the collection. */
  getCollection() {
    return this.transactionCount > 0 ? this.collection : (this.updateCollection(), this.collection);
  }
  updateCollection() {
    for (let a of this.dirtyNodes) a instanceof ya && a.isConnected && a.updateNode();
    if (this.dirtyNodes.clear(), this.mutatedNodes.size || this.collectionMutated) {
      var t, r;
      let a = this.getMutableCollection();
      for (let o of this.mutatedNodes) o.isConnected && a.addNode(o.node);
      var n, i;
      a.commit((n = (t = this.firstChild) === null || t === void 0 ? void 0 : t.node.key) !== null && n !== void 0 ? n : null, (i = (r = this.lastChild) === null || r === void 0 ? void 0 : r.node.key) !== null && i !== void 0 ? i : null, this.isSSR), this.mutatedNodes.clear();
    }
    this.collectionMutated = !1;
  }
  queueUpdate() {
    if (!(this.dirtyNodes.size === 0 || this.transactionCount > 0))
      for (let t of this.subscriptions) t();
  }
  subscribe(t) {
    return this.subscriptions.add(t), () => this.subscriptions.delete(t);
  }
  resetAfterSSR() {
    this.isSSR && (this.isSSR = !1, this.firstChild = null, this.lastChild = null, this.nodeId = 0);
  }
  constructor(t) {
    super(null), this.nodeType = 11, this.ownerDocument = this, this.dirtyNodes = /* @__PURE__ */ new Set(), this.isSSR = !1, this.nodeId = 0, this.nodesByProps = /* @__PURE__ */ new WeakMap(), this.mutatedNodes = /* @__PURE__ */ new Set(), this.subscriptions = /* @__PURE__ */ new Set(), this.transactionCount = 0, this.collection = t, this.collectionMutated = !0;
  }
}
function Fd(e) {
  let { children: t, items: r, idScope: n, addIdAndValue: i, dependencies: a = [] } = e, o = G(() => /* @__PURE__ */ new WeakMap(), a);
  return G(() => {
    if (r && typeof t == "function") {
      let l = [];
      for (let c of r) {
        let d = o.get(c);
        if (!d) {
          d = t(c);
          var s, u;
          let f = (u = (s = d.props.id) !== null && s !== void 0 ? s : c.key) !== null && u !== void 0 ? u : c.id;
          if (f == null) throw new Error("Could not determine key for item");
          n && (f = n + ":" + f), d = /* @__PURE__ */ Gi(d, i ? {
            key: f,
            id: f,
            value: c
          } : {
            key: f
          }), o.set(c, d);
        }
        l.push(d);
      }
      return l;
    } else if (typeof t != "function") return t;
  }, [
    t,
    r,
    o,
    n,
    i
  ]);
}
function b7(e) {
  return Fd({
    ...e,
    addIdAndValue: !0
  });
}
const o3 = /* @__PURE__ */ de(!1);
function $7(e, t) {
  let { collection: r, document: n } = Od(t);
  return {
    portal: s3(e, n),
    collection: r
  };
}
function x7(e, t, r) {
  let n = vn(), i = q(n);
  i.current = n;
  let a = ye(() => i.current ? r() : t(), [
    t,
    r
  ]);
  return v7.useSyncExternalStore(e, a);
}
const D7 = typeof F.useSyncExternalStore == "function" ? F.useSyncExternalStore : x7;
function Od(e) {
  let t = G(() => new g7(e || new y7()), [
    e
  ]), r = ye((o) => t.subscribe(o), [
    t
  ]), n = ye(() => {
    let o = t.getCollection();
    return t.isSSR && t.resetAfterSSR(), o;
  }, [
    t
  ]), i = ye(() => (t.isSSR = !0, t.getCollection()), [
    t
  ]);
  return {
    collection: D7(r, n, i),
    document: t
  };
}
const cc = /* @__PURE__ */ de(null), Ws = /* @__PURE__ */ de(null);
function s3(e, t) {
  let r = ce(Ws), n = t ?? r, i = b7(e), a = G(() => /* @__PURE__ */ F.createElement(o3.Provider, {
    value: !0
  }, i), [
    i
  ]);
  return vn() ? /* @__PURE__ */ F.createElement(cc.Provider, {
    value: n
  }, a) : /* @__PURE__ */ D$(a, n);
}
function E7(e) {
  return /* @__PURE__ */ F.createElement(F.Fragment, null, s3(e));
}
function u3(e, t, r) {
  let n = ce(o3);
  var i;
  return n ? (i = l3(e, t, r, "children" in t ? t.children : null)) !== null && i !== void 0 ? i : /* @__PURE__ */ F.createElement(F.Fragment, null) : null;
}
function w7(e, t, r) {
  return ye((n) => {
    n == null || n.setProps(e, t, r);
  }, [
    e,
    t,
    r
  ]);
}
function l3(e, t, r, n, i) {
  let a = w7(t, r, n), o = ce(cc);
  if (o) {
    let s = o.ownerDocument.nodesByProps.get(t);
    return s || (s = o.ownerDocument.createElement(e), s.setProps(t, r, n), o.appendChild(s), o.ownerDocument.updateCollection(), o.ownerDocument.nodesByProps.set(t, s)), i ? /* @__PURE__ */ F.createElement(cc.Provider, {
      value: s
    }, i) : null;
  }
  return /* @__PURE__ */ F.createElement(e, {
    ref: a
  }, i);
}
const dc = Symbol("default");
function Lt({ values: e, children: t }) {
  for (let [r, n] of e)
    t = /* @__PURE__ */ F.createElement(r.Provider, {
      value: n
    }, t);
  return t;
}
function ct(e) {
  let { className: t, style: r, children: n, defaultClassName: i, defaultChildren: a, defaultStyle: o, values: s } = e;
  return G(() => {
    let u, l, c;
    return typeof t == "function" ? u = t({
      ...s,
      defaultClassName: i
    }) : u = t, typeof r == "function" ? l = r({
      ...s,
      defaultStyle: o || {}
    }) : l = r, typeof n == "function" ? c = n({
      ...s,
      defaultChildren: a
    }) : n == null ? c = a : c = n, {
      className: u ?? i,
      style: l || o ? {
        ...o,
        ...l
      } : void 0,
      children: c ?? a,
      "data-rac": ""
    };
  }, [
    t,
    r,
    n,
    i,
    a,
    o,
    s
  ]);
}
function Ra(e, t) {
  return (r) => t(typeof e == "function" ? e(r) : e, r);
}
function di(e, t) {
  let r = ce(e);
  if (t === null)
    return null;
  if (r && typeof r == "object" && "slots" in r && r.slots) {
    let n = new Intl.ListFormat().format(Object.keys(r.slots).map((a) => `"${a}"`));
    if (!t && !r.slots[dc]) throw new Error(`A slot prop is required. Valid slot names are ${n}.`);
    let i = t || dc;
    if (!r.slots[i])
      throw new Error(`Invalid slot "${t}". Valid slot names are ${n}.`);
    return r.slots[i];
  }
  return r;
}
function at(e, t, r) {
  let n = di(r, e.slot) || {}, { ref: i, ...a } = n, o = Pa(G(() => Gv(t, i), [
    t,
    i
  ])), s = ge(a, e);
  return "style" in a && a.style && "style" in e && e.style && (typeof a.style == "function" || typeof e.style == "function" ? s.style = (u) => {
    let l = typeof a.style == "function" ? a.style(u) : a.style, c = {
      ...u.defaultStyle,
      ...l
    }, d = typeof e.style == "function" ? e.style({
      ...u,
      defaultStyle: c
    }) : e.style;
    return {
      ...c,
      ...d
    };
  } : s.style = {
    ...a.style,
    ...e.style
  }), [
    s,
    o
  ];
}
function Qs() {
  let [e, t] = re(!0), r = q(!1), n = ye((i) => {
    r.current = !0, t(!!i);
  }, []);
  return Oe(() => {
    r.current || t(!1);
  }, []), [
    n,
    e
  ];
}
function C7(e, t = !0) {
  let [r, n] = re(!0);
  return c3(e, r && t, ye(() => n(!1), [])), r && t;
}
function S7(e, t) {
  let [r, n] = re(!1), [i, a] = re("idle");
  return !t && e.current && i === "idle" && (r = !0, n(!0), a("exiting")), !e.current && i === "exited" && a("idle"), c3(e, r, ye(() => {
    a("exited"), n(!1);
  }, [])), r;
}
function c3(e, t, r) {
  let n = q(null);
  t && e.current && (n.current = window.getComputedStyle(e.current).animation), Oe(() => {
    if (t && e.current) {
      let i = window.getComputedStyle(e.current);
      if (i.animationName && i.animationName !== "none" && i.animation !== n.current) {
        let a = (s) => {
          s.target === e.current && (o.removeEventListener("animationend", a), xc.flushSync(() => {
            r();
          }));
        }, o = e.current;
        return o.addEventListener("animationend", a), () => {
          o.removeEventListener("animationend", a);
        };
      } else r();
    }
  }, [
    e,
    t,
    r
  ]);
}
if (typeof HTMLTemplateElement < "u") {
  const e = Object.getOwnPropertyDescriptor(Node.prototype, "firstChild").get;
  Object.defineProperty(HTMLTemplateElement.prototype, "firstChild", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.dataset.reactAriaHidden ? this.content.firstChild : e.call(this);
    }
  });
}
const ga = /* @__PURE__ */ de(!1), k7 = typeof DocumentFragment < "u" ? new DocumentFragment() : null;
function d3(e) {
  let t = ce(ga), r = vn();
  if (t)
    return /* @__PURE__ */ F.createElement(F.Fragment, null, e.children);
  let n = /* @__PURE__ */ F.createElement(ga.Provider, {
    value: !0
  }, e.children);
  return r ? /* @__PURE__ */ F.createElement("template", {
    "data-react-aria-hidden": !0
  }, n) : /* @__PURE__ */ xc.createPortal(n, k7);
}
function Id(e) {
  let t = (r, n) => ce(ga) ? null : e(r, n);
  return t.displayName = e.displayName || e.name, F.forwardRef(t);
}
function Rd(e) {
  const t = /^(data-.*)$/;
  let r = {};
  for (const n in e) t.test(n) || (r[n] = e[n]);
  return r;
}
const T7 = /* @__PURE__ */ new Set([
  "form",
  "formAction",
  "formEncType",
  "formMethod",
  "formNoValidate",
  "formTarget",
  "name",
  "value"
]), Ba = /* @__PURE__ */ de({});
function P7(e, t) {
  [e, t] = at(e, t, Ba);
  let r = e, { buttonProps: n, isPressed: i } = YC(e, t), { focusProps: a, isFocused: o, isFocusVisible: s } = Kr(e), { hoverProps: u, isHovered: l } = yn(e), c = ct({
    ...e,
    values: {
      isHovered: l,
      isPressed: i,
      isFocused: o,
      isFocusVisible: s,
      isDisabled: e.isDisabled || !1
    },
    defaultClassName: "react-aria-Button"
  });
  return /* @__PURE__ */ F.createElement("button", {
    ...Me(e, {
      propNames: T7
    }),
    ...ge(n, a, u),
    ...c,
    ref: t,
    slot: e.slot || void 0,
    "data-disabled": e.isDisabled || void 0,
    "data-pressed": r.isPressed || i || void 0,
    "data-hovered": l || void 0,
    "data-focused": o || void 0,
    "data-focus-visible": s || void 0
  });
}
const f3 = /* @__PURE__ */ Id(P7), gn = /* @__PURE__ */ de({});
function A7(e, t) {
  [e, t] = at(e, t, gn);
  let { elementType: r = "span", ...n } = e;
  return /* @__PURE__ */ F.createElement(r, {
    className: "react-aria-Text",
    ...n,
    ref: t
  });
}
const Bd = /* @__PURE__ */ Ae(A7);
function Zn(e, t, r) {
  return t != null && e.compare(t) < 0 || r != null && e.compare(r) > 0;
}
function fc(e, t, r, n, i) {
  let a = {};
  for (let s in t)
    a[s] = Math.floor(t[s] / 2), a[s] > 0 && t[s] % 2 === 0 && a[s]--;
  let o = tn(e, t, r).subtract(a);
  return ba(e, o, t, r, n, i);
}
function tn(e, t, r, n, i) {
  let a = e;
  return t.years ? a = Gl(e) : t.months ? a = br(e) : t.weeks && (a = hn(e, r)), ba(e, a, t, r, n, i);
}
function hc(e, t, r, n, i) {
  let a = {
    ...t
  };
  t.days ? a.days-- : t.weeks ? a.weeks-- : t.months ? a.months-- : t.years && a.years--;
  let o = tn(e, t, r).subtract(a);
  return ba(e, o, t, r, n, i);
}
function ba(e, t, r, n, i, a) {
  return i && e.compare(i) >= 0 && (t = bd(t, tn(bt(i), r, n))), a && e.compare(a) <= 0 && (t = gd(t, hc(bt(a), r, n))), t;
}
function Sr(e, t, r) {
  return t && (e = bd(e, bt(t))), r && (e = gd(e, bt(r))), e;
}
function h3(e, t, r) {
  if (!r) return e;
  for (; e.compare(t) >= 0 && r(e); ) e = e.subtract({
    days: 1
  });
  if (e.compare(t) >= 0) return e;
}
function _7(e) {
  let t = G(() => new hr(e.locale), [
    e.locale
  ]), r = G(() => t.resolvedOptions(), [
    t
  ]), { locale: n, createCalendar: i, visibleDuration: a = {
    months: 1
  }, minValue: o, maxValue: s, selectionAlignment: u, isDateUnavailable: l, pageBehavior: c = "visible" } = e, d = G(() => i(r.calendar), [
    i,
    r.calendar
  ]), [f, h] = Jt(e.value, e.defaultValue, e.onChange), p = G(() => f ? Ve(bt(f), d) : null, [
    f,
    d
  ]), v = G(() => f && "timeZone" in f ? f.timeZone : r.timeZone, [
    f,
    r.timeZone
  ]), g = G(() => e.focusedValue ? Sr(Ve(bt(e.focusedValue), d), o, s) : void 0, [
    e.focusedValue,
    d,
    o,
    s
  ]), $ = G(() => Sr(e.defaultFocusedValue ? Ve(bt(e.defaultFocusedValue), d) : p || Ve(Ns(v), d), o, s), [
    e.defaultFocusedValue,
    p,
    v,
    d,
    o,
    s
  ]), [m, b] = Jt(g, $, e.onFocusChange), [D, S] = re(() => {
    switch (u) {
      case "start":
        return tn(m, a, n, o, s);
      case "end":
        return hc(m, a, n, o, s);
      case "center":
      default:
        return fc(m, a, n, o, s);
    }
  }), [T, R] = re(e.autoFocus || !1), y = G(() => {
    let x = {
      ...a
    };
    return x.days ? x.days-- : x.days = -1, D.add(x);
  }, [
    D,
    a
  ]), [A, w] = re(d.identifier);
  if (d.identifier !== A) {
    let x = Ve(m, d);
    S(fc(x, a, n, o, s)), b(x), w(d.identifier);
  }
  Zn(m, o, s) ? b(Sr(m, o, s)) : m.compare(D) < 0 ? S(hc(m, a, n, o, s)) : m.compare(y) > 0 && S(tn(m, a, n, o, s));
  function E(x) {
    x = Sr(x, o, s), b(x);
  }
  function k(x) {
    if (!e.isDisabled && !e.isReadOnly) {
      if (x === null) {
        h(null);
        return;
      }
      if (x = Sr(x, o, s), x = h3(x, D, l), !x) return;
      x = Ve(x, (f == null ? void 0 : f.calendar) || new xt()), f && "hour" in f ? h(f.set(x)) : h(x);
    }
  }
  let C = G(() => p ? l && l(p) ? !0 : Zn(p, o, s) : !1, [
    p,
    l,
    o,
    s
  ]), P = e.isInvalid || e.validationState === "invalid" || C, L = P ? "invalid" : null, O = G(() => c === "visible" ? a : Xu(a), [
    c,
    a
  ]);
  return {
    isDisabled: e.isDisabled,
    isReadOnly: e.isReadOnly,
    value: p,
    setValue: k,
    visibleRange: {
      start: D,
      end: y
    },
    minValue: o,
    maxValue: s,
    focusedDate: m,
    timeZone: v,
    validationState: L,
    isValueInvalid: P,
    setFocusedDate(x) {
      E(x), R(!0);
    },
    focusNextDay() {
      E(m.add({
        days: 1
      }));
    },
    focusPreviousDay() {
      E(m.subtract({
        days: 1
      }));
    },
    focusNextRow() {
      a.days ? this.focusNextPage() : (a.weeks || a.months || a.years) && E(m.add({
        weeks: 1
      }));
    },
    focusPreviousRow() {
      a.days ? this.focusPreviousPage() : (a.weeks || a.months || a.years) && E(m.subtract({
        weeks: 1
      }));
    },
    focusNextPage() {
      let x = D.add(O);
      b(Sr(m.add(O), o, s)), S(tn(ba(m, x, O, n, o, s), O, n));
    },
    focusPreviousPage() {
      let x = D.subtract(O);
      b(Sr(m.subtract(O), o, s)), S(tn(ba(m, x, O, n, o, s), O, n));
    },
    focusSectionStart() {
      a.days ? E(D) : a.weeks ? E(hn(m, n)) : (a.months || a.years) && E(br(m));
    },
    focusSectionEnd() {
      a.days ? E(y) : a.weeks ? E(Dy(m, n)) : (a.months || a.years) && E(oi(m));
    },
    focusNextSection(x) {
      if (!x && !a.days) {
        E(m.add(Xu(a)));
        return;
      }
      a.days ? this.focusNextPage() : a.weeks ? E(m.add({
        months: 1
      })) : (a.months || a.years) && E(m.add({
        years: 1
      }));
    },
    focusPreviousSection(x) {
      if (!x && !a.days) {
        E(m.subtract(Xu(a)));
        return;
      }
      a.days ? this.focusPreviousPage() : a.weeks ? E(m.subtract({
        months: 1
      })) : (a.months || a.years) && E(m.subtract({
        years: 1
      }));
    },
    selectFocusedDate() {
      k(m);
    },
    selectDate(x) {
      k(x);
    },
    isFocused: T,
    setFocused: R,
    isInvalid(x) {
      return Zn(x, o, s);
    },
    isSelected(x) {
      return p != null && Je(x, p) && !this.isCellDisabled(x) && !this.isCellUnavailable(x);
    },
    isCellFocused(x) {
      return T && m && Je(x, m);
    },
    isCellDisabled(x) {
      return e.isDisabled || x.compare(D) < 0 || x.compare(y) > 0 || this.isInvalid(x, o, s);
    },
    isCellUnavailable(x) {
      return e.isDateUnavailable && e.isDateUnavailable(x);
    },
    isPreviousVisibleRangeInvalid() {
      let x = D.subtract({
        days: 1
      });
      return Je(x, D) || this.isInvalid(x, o, s);
    },
    isNextVisibleRangeInvalid() {
      let x = y.add({
        days: 1
      });
      return Je(x, y) || this.isInvalid(x, o, s);
    },
    getDatesInWeek(x, U = D) {
      let K = U.add({
        weeks: x
      }), j = [];
      K = hn(K, n);
      let ae = yd(K, n);
      for (let ne = 0; ne < ae; ne++) j.push(null);
      for (; j.length < 7; ) {
        j.push(K);
        let ne = K.add({
          days: 1
        });
        if (Je(K, ne)) break;
        K = ne;
      }
      for (; j.length < 7; ) j.push(null);
      return j;
    }
  };
}
function Xu(e) {
  let t = {
    ...e
  };
  for (let r in e) t[r] = 1;
  return t;
}
function F7(e) {
  let { value: t, defaultValue: r, onChange: n, createCalendar: i, locale: a, visibleDuration: o = {
    months: 1
  }, minValue: s, maxValue: u, ...l } = e, [c, d] = Jt(t, r || null, n), [f, h] = re(null), p = "center";
  if (c && c.start && c.end) {
    let U = fc(bt(c.start), o, a, s, u).add(o).subtract({
      days: 1
    });
    c.end.compare(U) > 0 && (p = "start");
  }
  let v = q(null), [g, $] = re(null), m = G(() => bd(s, g == null ? void 0 : g.start), [
    s,
    g
  ]), b = G(() => gd(u, g == null ? void 0 : g.end), [
    u,
    g
  ]), D = _7({
    ...l,
    value: c && c.start,
    createCalendar: i,
    locale: a,
    visibleDuration: o,
    minValue: m,
    maxValue: b,
    selectionAlignment: p
  }), S = (x) => {
    x && e.isDateUnavailable && !e.allowsNonContiguousRanges ? (v.current = {
      start: xp(x, D, -1),
      end: xp(x, D, 1)
    }, $(v.current)) : (v.current = null, $(null));
  }, [T, R] = re(D.visibleRange);
  (!Ql(D.visibleRange.start, T.start) || !Ql(D.visibleRange.end, T.end)) && (S(f), R(D.visibleRange));
  let y = (x) => {
    x ? (h(x), S(x)) : (h(null), S(null));
  }, A = f ? el(f, D.focusedDate) : c && el(c.start, c.end), w = (x) => {
    if (!e.isReadOnly && (x = Sr(x, m, b), x = h3(x, D.visibleRange.start, e.isDateUnavailable), !!x))
      if (!f) y(x);
      else {
        let U = el(f, x);
        d({
          start: $p(U.start, c == null ? void 0 : c.start),
          end: $p(U.end, c == null ? void 0 : c.end)
        }), y(null);
      }
  }, [E, k] = re(!1), { isDateUnavailable: C } = e, P = G(() => !c || f ? !1 : C && (C(c.start) || C(c.end)) ? !0 : Zn(c.start, s, u) || Zn(c.end, s, u), [
    C,
    c,
    f,
    s,
    u
  ]), L = e.isInvalid || e.validationState === "invalid" || P;
  return {
    ...D,
    value: c,
    setValue: d,
    anchorDate: f,
    setAnchorDate: y,
    highlightedRange: A,
    validationState: L ? "invalid" : null,
    isValueInvalid: L,
    selectFocusedDate() {
      w(D.focusedDate);
    },
    selectDate: w,
    highlightDate(x) {
      f && D.setFocusedDate(x);
    },
    isSelected(x) {
      return A && x.compare(A.start) >= 0 && x.compare(A.end) <= 0 && !D.isCellDisabled(x) && !D.isCellUnavailable(x);
    },
    isInvalid(x) {
      var U, K;
      return D.isInvalid(x) || Zn(x, (U = v.current) === null || U === void 0 ? void 0 : U.start, (K = v.current) === null || K === void 0 ? void 0 : K.end);
    },
    isDragging: E,
    setDragging: k
  };
}
function el(e, t) {
  return !e || !t ? null : (t.compare(e) < 0 && ([e, t] = [
    t,
    e
  ]), {
    start: bt(e),
    end: bt(t)
  });
}
function $p(e, t) {
  return e = Ve(e, (t == null ? void 0 : t.calendar) || new xt()), t && "hour" in t ? t.set(e) : e;
}
function xp(e, t, r) {
  let n = e.add({
    days: r
  });
  for (; (r < 0 ? n.compare(t.visibleRange.start) >= 0 : n.compare(t.visibleRange.end) <= 0) && !t.isCellUnavailable(n); ) n = n.add({
    days: r
  });
  return t.isCellUnavailable(n) ? n.add({
    days: -r
  }) : null;
}
class pc {
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(t) {
    let r = this.keyMap.get(t);
    return r ? r.prevKey : null;
  }
  getKeyAfter(t) {
    let r = this.keyMap.get(t);
    return r ? r.nextKey : null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(t) {
    return this.keyMap.get(t);
  }
  at(t) {
    const r = [
      ...this.getKeys()
    ];
    return this.getItem(r[t]);
  }
  getChildren(t) {
    let r = this.keyMap.get(t);
    return (r == null ? void 0 : r.childNodes) || [];
  }
  constructor(t) {
    this.keyMap = /* @__PURE__ */ new Map(), this.iterable = t;
    let r = (a) => {
      if (this.keyMap.set(a.key, a), a.childNodes && a.type === "section") for (let o of a.childNodes) r(o);
    };
    for (let a of t) r(a);
    let n, i = 0;
    for (let [a, o] of this.keyMap)
      n ? (n.nextKey = a, o.prevKey = n.key) : (this.firstKey = a, o.prevKey = void 0), o.type === "item" && (o.index = i++), n = o, n.nextKey = void 0;
    this.lastKey = n == null ? void 0 : n.key;
  }
}
class It extends Set {
  constructor(t, r, n) {
    super(t), t instanceof It ? (this.anchorKey = r || t.anchorKey, this.currentKey = n || t.currentKey) : (this.anchorKey = r, this.currentKey = n);
  }
}
function O7(e, t) {
  if (e.size !== t.size) return !1;
  for (let r of e)
    if (!t.has(r)) return !1;
  return !0;
}
function I7(e) {
  let { selectionMode: t = "none", disallowEmptySelection: r, allowDuplicateSelectionEvents: n, selectionBehavior: i = "toggle", disabledBehavior: a = "all" } = e, o = q(!1), [, s] = re(!1), u = q(null), l = q(null), [, c] = re(null), d = G(() => Dp(e.selectedKeys), [
    e.selectedKeys
  ]), f = G(() => Dp(e.defaultSelectedKeys, new It()), [
    e.defaultSelectedKeys
  ]), [h, p] = Jt(d, f, e.onSelectionChange), v = G(() => e.disabledKeys ? new Set(e.disabledKeys) : /* @__PURE__ */ new Set(), [
    e.disabledKeys
  ]), [g, $] = re(i);
  i === "replace" && g === "toggle" && typeof h == "object" && h.size === 0 && $("replace");
  let m = q(i);
  return ue(() => {
    i !== m.current && ($(i), m.current = i);
  }, [
    i
  ]), {
    selectionMode: t,
    disallowEmptySelection: r,
    selectionBehavior: g,
    setSelectionBehavior: $,
    get isFocused() {
      return o.current;
    },
    setFocused(b) {
      o.current = b, s(b);
    },
    get focusedKey() {
      return u.current;
    },
    get childFocusStrategy() {
      return l.current;
    },
    setFocusedKey(b, D = "first") {
      u.current = b, l.current = D, c(b);
    },
    selectedKeys: h,
    setSelectedKeys(b) {
      (n || !O7(b, h)) && p(b);
    },
    disabledKeys: v,
    disabledBehavior: a
  };
}
function Dp(e, t) {
  return e ? e === "all" ? "all" : new It(e) : t;
}
class R7 {
  /**
  * The type of selection that is allowed in the collection.
  */
  get selectionMode() {
    return this.state.selectionMode;
  }
  /**
  * Whether the collection allows empty selection.
  */
  get disallowEmptySelection() {
    return this.state.disallowEmptySelection;
  }
  /**
  * The selection behavior for the collection.
  */
  get selectionBehavior() {
    return this.state.selectionBehavior;
  }
  /**
  * Sets the selection behavior for the collection.
  */
  setSelectionBehavior(t) {
    this.state.setSelectionBehavior(t);
  }
  /**
  * Whether the collection is currently focused.
  */
  get isFocused() {
    return this.state.isFocused;
  }
  /**
  * Sets whether the collection is focused.
  */
  setFocused(t) {
    this.state.setFocused(t);
  }
  /**
  * The current focused key in the collection.
  */
  get focusedKey() {
    return this.state.focusedKey;
  }
  /** Whether the first or last child of the focused key should receive focus. */
  get childFocusStrategy() {
    return this.state.childFocusStrategy;
  }
  /**
  * Sets the focused key.
  */
  setFocusedKey(t, r) {
    (t == null || this.collection.getItem(t)) && this.state.setFocusedKey(t, r);
  }
  /**
  * The currently selected keys in the collection.
  */
  get selectedKeys() {
    return this.state.selectedKeys === "all" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;
  }
  /**
  * The raw selection value for the collection.
  * Either 'all' for select all, or a set of keys.
  */
  get rawSelection() {
    return this.state.selectedKeys;
  }
  /**
  * Returns whether a key is selected.
  */
  isSelected(t) {
    return this.state.selectionMode === "none" ? !1 : (t = this.getKey(t), this.state.selectedKeys === "all" ? this.canSelectItem(t) : this.state.selectedKeys.has(t));
  }
  /**
  * Whether the selection is empty.
  */
  get isEmpty() {
    return this.state.selectedKeys !== "all" && this.state.selectedKeys.size === 0;
  }
  /**
  * Whether all items in the collection are selected.
  */
  get isSelectAll() {
    if (this.isEmpty) return !1;
    if (this.state.selectedKeys === "all") return !0;
    if (this._isSelectAll != null) return this._isSelectAll;
    let t = this.getSelectAllKeys(), r = this.state.selectedKeys;
    return this._isSelectAll = t.every((n) => r.has(n)), this._isSelectAll;
  }
  get firstSelectedKey() {
    let t = null;
    for (let r of this.state.selectedKeys) {
      let n = this.collection.getItem(r);
      (!t || n && Zu(this.collection, n, t) < 0) && (t = n);
    }
    return t == null ? void 0 : t.key;
  }
  get lastSelectedKey() {
    let t = null;
    for (let r of this.state.selectedKeys) {
      let n = this.collection.getItem(r);
      (!t || n && Zu(this.collection, n, t) > 0) && (t = n);
    }
    return t == null ? void 0 : t.key;
  }
  get disabledKeys() {
    return this.state.disabledKeys;
  }
  get disabledBehavior() {
    return this.state.disabledBehavior;
  }
  /**
  * Extends the selection to the given key.
  */
  extendSelection(t) {
    if (this.selectionMode === "none") return;
    if (this.selectionMode === "single") {
      this.replaceSelection(t);
      return;
    }
    t = this.getKey(t);
    let r;
    if (this.state.selectedKeys === "all") r = new It([
      t
    ], t, t);
    else {
      let n = this.state.selectedKeys, i = n.anchorKey || t;
      r = new It(n, i, t);
      for (let a of this.getKeyRange(i, n.currentKey || t)) r.delete(a);
      for (let a of this.getKeyRange(t, i)) this.canSelectItem(a) && r.add(a);
    }
    this.state.setSelectedKeys(r);
  }
  getKeyRange(t, r) {
    let n = this.collection.getItem(t), i = this.collection.getItem(r);
    return n && i ? Zu(this.collection, n, i) <= 0 ? this.getKeyRangeInternal(t, r) : this.getKeyRangeInternal(r, t) : [];
  }
  getKeyRangeInternal(t, r) {
    let n = [], i = t;
    for (; i; ) {
      let a = this.collection.getItem(i);
      if ((a && a.type === "item" || a.type === "cell" && this.allowsCellSelection) && n.push(i), i === r) return n;
      i = this.collection.getKeyAfter(i);
    }
    return [];
  }
  getKey(t) {
    let r = this.collection.getItem(t);
    if (!r || r.type === "cell" && this.allowsCellSelection) return t;
    for (; r.type !== "item" && r.parentKey != null; ) r = this.collection.getItem(r.parentKey);
    return !r || r.type !== "item" ? null : r.key;
  }
  /**
  * Toggles whether the given key is selected.
  */
  toggleSelection(t) {
    if (this.selectionMode === "none") return;
    if (this.selectionMode === "single" && !this.isSelected(t)) {
      this.replaceSelection(t);
      return;
    }
    if (t = this.getKey(t), t == null) return;
    let r = new It(this.state.selectedKeys === "all" ? this.getSelectAllKeys() : this.state.selectedKeys);
    r.has(t) ? r.delete(t) : this.canSelectItem(t) && (r.add(t), r.anchorKey = t, r.currentKey = t), !(this.disallowEmptySelection && r.size === 0) && this.state.setSelectedKeys(r);
  }
  /**
  * Replaces the selection with only the given key.
  */
  replaceSelection(t) {
    if (this.selectionMode === "none" || (t = this.getKey(t), t == null)) return;
    let r = this.canSelectItem(t) ? new It([
      t
    ], t, t) : new It();
    this.state.setSelectedKeys(r);
  }
  /**
  * Replaces the selection with the given keys.
  */
  setSelectedKeys(t) {
    if (this.selectionMode === "none") return;
    let r = new It();
    for (let n of t)
      if (n = this.getKey(n), n != null && (r.add(n), this.selectionMode === "single"))
        break;
    this.state.setSelectedKeys(r);
  }
  getSelectAllKeys() {
    let t = [], r = (n) => {
      for (; n; ) {
        if (this.canSelectItem(n)) {
          let i = this.collection.getItem(n);
          i.type === "item" && t.push(n), i.hasChildNodes && (this.allowsCellSelection || i.type !== "item") && r(US(qs(i, this.collection)).key);
        }
        n = this.collection.getKeyAfter(n);
      }
    };
    return r(this.collection.getFirstKey()), t;
  }
  /**
  * Selects all items in the collection.
  */
  selectAll() {
    !this.isSelectAll && this.selectionMode === "multiple" && this.state.setSelectedKeys("all");
  }
  /**
  * Removes all keys from the selection.
  */
  clearSelection() {
    !this.disallowEmptySelection && (this.state.selectedKeys === "all" || this.state.selectedKeys.size > 0) && this.state.setSelectedKeys(new It());
  }
  /**
  * Toggles between select all and an empty selection.
  */
  toggleSelectAll() {
    this.isSelectAll ? this.clearSelection() : this.selectAll();
  }
  select(t, r) {
    this.selectionMode !== "none" && (this.selectionMode === "single" ? this.isSelected(t) && !this.disallowEmptySelection ? this.toggleSelection(t) : this.replaceSelection(t) : this.selectionBehavior === "toggle" || r && (r.pointerType === "touch" || r.pointerType === "virtual") ? this.toggleSelection(t) : this.replaceSelection(t));
  }
  /**
  * Returns whether the current selection is equal to the given selection.
  */
  isSelectionEqual(t) {
    if (t === this.state.selectedKeys) return !0;
    let r = this.selectedKeys;
    if (t.size !== r.size) return !1;
    for (let n of t)
      if (!r.has(n)) return !1;
    for (let n of r)
      if (!t.has(n)) return !1;
    return !0;
  }
  canSelectItem(t) {
    var r;
    if (this.state.selectionMode === "none" || this.state.disabledKeys.has(t)) return !1;
    let n = this.collection.getItem(t);
    return !(!n || !(n == null || (r = n.props) === null || r === void 0) && r.isDisabled || n.type === "cell" && !this.allowsCellSelection);
  }
  isDisabled(t) {
    var r, n;
    return this.state.disabledBehavior === "all" && (this.state.disabledKeys.has(t) || !!(!((n = this.collection.getItem(t)) === null || n === void 0 || (r = n.props) === null || r === void 0) && r.isDisabled));
  }
  isLink(t) {
    var r, n;
    return !!(!((n = this.collection.getItem(t)) === null || n === void 0 || (r = n.props) === null || r === void 0) && r.href);
  }
  getItemProps(t) {
    var r;
    return (r = this.collection.getItem(t)) === null || r === void 0 ? void 0 : r.props;
  }
  constructor(t, r, n) {
    this.collection = t, this.state = r;
    var i;
    this.allowsCellSelection = (i = n == null ? void 0 : n.allowsCellSelection) !== null && i !== void 0 ? i : !1, this._isSelectAll = null;
  }
}
function p3(e) {
  let { filter: t } = e, r = I7(e), n = G(() => e.disabledKeys ? new Set(e.disabledKeys) : /* @__PURE__ */ new Set(), [
    e.disabledKeys
  ]), i = ye((l) => t ? new pc(t(l)) : new pc(l), [
    t
  ]), a = G(() => ({
    suppressTextValueWarning: e.suppressTextValueWarning
  }), [
    e.suppressTextValueWarning
  ]), o = KS(e, i, a), s = G(() => new R7(o, r), [
    o,
    r
  ]);
  const u = q(null);
  return ue(() => {
    if (r.focusedKey != null && !o.getItem(r.focusedKey)) {
      const l = u.current.getItem(r.focusedKey), c = [
        ...u.current.getKeys()
      ].map((v) => {
        const g = u.current.getItem(v);
        return g.type === "item" ? g : null;
      }).filter((v) => v !== null), d = [
        ...o.getKeys()
      ].map((v) => {
        const g = o.getItem(v);
        return g.type === "item" ? g : null;
      }).filter((v) => v !== null), f = c.length - d.length;
      let h = Math.min(f > 1 ? Math.max(l.index - f + 1, 0) : l.index, d.length - 1), p;
      for (; h >= 0; ) {
        if (!s.isDisabled(d[h].key)) {
          p = d[h];
          break;
        }
        h < d.length - 1 ? h++ : (h > l.index && (h = l.index), h--);
      }
      r.setFocusedKey(p ? p.key : null);
    }
    u.current = o;
  }, [
    o,
    s,
    r,
    r.focusedKey
  ]), {
    collection: o,
    disabledKeys: n,
    selectionManager: s
  };
}
function m3(e) {
  var t;
  let [r, n] = Jt(e.selectedKey, (t = e.defaultSelectedKey) !== null && t !== void 0 ? t : null, e.onSelectionChange), i = G(() => r != null ? [
    r
  ] : [], [
    r
  ]), { collection: a, disabledKeys: o, selectionManager: s } = p3({
    ...e,
    selectionMode: "single",
    disallowEmptySelection: !0,
    allowDuplicateSelectionEvents: !0,
    selectedKeys: i,
    onSelectionChange: (l) => {
      var c;
      let d = (c = l.values().next().value) !== null && c !== void 0 ? c : null;
      d === r && e.onSelectionChange && e.onSelectionChange(d), n(d);
    }
  }), u = r != null ? a.getItem(r) : null;
  return {
    collection: a,
    disabledKeys: o,
    selectionManager: s,
    selectedKey: r,
    setSelectedKey: n,
    selectedItem: u
  };
}
function Ma(e) {
  let [t, r] = Jt(e.isOpen, e.defaultOpen || !1, e.onOpenChange);
  const n = ye(() => {
    r(!0);
  }, [
    r
  ]), i = ye(() => {
    r(!1);
  }, [
    r
  ]), a = ye(() => {
    r(!t);
  }, [
    r,
    t
  ]);
  return {
    isOpen: t,
    setOpen: r,
    open: n,
    close: i,
    toggle: a
  };
}
function B7(e) {
  var t, r;
  let { defaultFilter: n, menuTrigger: i = "input", allowsEmptyCollection: a = !1, allowsCustomValue: o, shouldCloseOnBlur: s = !0 } = e, [u, l] = re(!1), [c, d] = re(!1), [f, h] = re(null), p = (I) => {
    e.onSelectionChange && e.onSelectionChange(I), I === m && ($e(), ae());
  };
  var v;
  let { collection: g, selectionManager: $, selectedKey: m, setSelectedKey: b, selectedItem: D, disabledKeys: S } = m3({
    ...e,
    onSelectionChange: p,
    items: (v = e.items) !== null && v !== void 0 ? v : e.defaultItems
  });
  var T, R;
  let [y, A] = Jt(e.inputValue, (R = (T = e.defaultInputValue) !== null && T !== void 0 ? T : (t = g.getItem(m)) === null || t === void 0 ? void 0 : t.textValue) !== null && R !== void 0 ? R : "", e.onInputChange), w = g, E = G(() => (
    // No default filter if items are controlled.
    e.items != null || !n ? g : M7(g, y, n)
  ), [
    g,
    y,
    n,
    e.items
  ]), [k, C] = re(E), P = q("focus"), O = Ma({
    ...e,
    onOpenChange: (I) => {
      e.onOpenChange && e.onOpenChange(I, I ? P.current : void 0), $.setFocused(I), I || $.setFocusedKey(null);
    },
    isOpen: void 0,
    defaultOpen: void 0
  }), x = (I = null, M) => {
    let W = M === "manual" || M === "focus" && i === "focus";
    (a || E.size > 0 || W && w.size > 0 || e.items) && (W && !O.isOpen && e.items === void 0 && l(!0), P.current = M, h(I), O.open());
  }, U = (I = null, M) => {
    let W = M === "manual" || M === "focus" && i === "focus";
    !(a || E.size > 0 || W && w.size > 0 || e.items) && !O.isOpen || (W && !O.isOpen && e.items === void 0 && l(!0), O.isOpen || (P.current = M), j(I));
  }, K = ye(() => {
    C(u ? w : E);
  }, [
    u,
    w,
    E
  ]), j = ye((I = null) => {
    O.isOpen && K(), h(I), O.toggle();
  }, [
    O,
    K
  ]), ae = ye(() => {
    O.isOpen && (K(), O.close());
  }, [
    O,
    K
  ]), [ne, me] = re(y), $e = () => {
    var I, M;
    let W = (M = (I = g.getItem(m)) === null || I === void 0 ? void 0 : I.textValue) !== null && M !== void 0 ? M : "";
    me(W), A(W);
  };
  var _e, Fe;
  let V = q((Fe = (_e = e.selectedKey) !== null && _e !== void 0 ? _e : e.defaultSelectedKey) !== null && Fe !== void 0 ? Fe : null);
  var ie;
  let De = q((ie = (r = g.getItem(m)) === null || r === void 0 ? void 0 : r.textValue) !== null && ie !== void 0 ? ie : "");
  ue(() => {
    var I;
    c && (E.size > 0 || a) && !O.isOpen && y !== ne && i !== "manual" && x(null, "input"), !u && !a && O.isOpen && E.size === 0 && ae(), m != null && m !== V.current && ae(), y !== ne && ($.setFocusedKey(null), l(!1), y === "" && (e.inputValue === void 0 || e.selectedKey === void 0) && b(null)), m !== V.current && (e.inputValue === void 0 || e.selectedKey === void 0) ? $e() : ne !== y && me(y);
    var M;
    let W = (M = (I = g.getItem(m)) === null || I === void 0 ? void 0 : I.textValue) !== null && M !== void 0 ? M : "";
    !c && m != null && e.inputValue === void 0 && m === V.current && De.current !== W && (me(W), A(W)), V.current = m, De.current = W;
  });
  let ze = Ia({
    ...e,
    value: G(() => ({
      inputValue: y,
      selectedKey: m
    }), [
      y,
      m
    ])
  }), He = () => {
    o && m == null ? xr() : qr();
  }, xr = () => {
    V.current = null, b(null), ae();
  }, qr = () => {
    if (e.selectedKey !== void 0 && e.inputValue !== void 0) {
      var I;
      e.onSelectionChange(m);
      var M;
      let W = (M = (I = g.getItem(m)) === null || I === void 0 ? void 0 : I.textValue) !== null && M !== void 0 ? M : "";
      me(W), ae();
    } else
      $e(), ae();
  };
  const $n = () => {
    if (o) {
      var I, M;
      const W = (M = (I = g.getItem(m)) === null || I === void 0 ? void 0 : I.textValue) !== null && M !== void 0 ? M : "";
      y === W ? qr() : xr();
    } else
      qr();
  };
  let Qd = () => {
    O.isOpen && $.focusedKey != null ? m === $.focusedKey ? qr() : b($.focusedKey) : $n();
  }, tu = q(y), Gd = (I) => {
    I ? (tu.current = y, i === "focus" && x(null, "focus")) : (s && $n(), y !== tu.current && ze.commitValidation()), d(I);
  }, _ = G(() => O.isOpen ? u ? w : E : k, [
    O.isOpen,
    w,
    E,
    u,
    k
  ]);
  return {
    ...ze,
    ...O,
    focusStrategy: f,
    toggle: U,
    open: x,
    close: $n,
    selectionManager: $,
    selectedKey: m,
    setSelectedKey: b,
    disabledKeys: S,
    isFocused: c,
    setFocused: Gd,
    selectedItem: D,
    collection: _,
    inputValue: y,
    setInputValue: A,
    commit: Qd,
    revert: He
  };
}
function M7(e, t, r) {
  return new pc(v3(e, e, t, r));
}
function v3(e, t, r, n) {
  let i = [];
  for (let a of t)
    if (a.type === "section" && a.hasChildNodes) {
      let o = v3(e, qs(a, e), r, n);
      [
        ...o
      ].some((s) => s.type === "item") && i.push({
        ...a,
        childNodes: o
      });
    } else a.type === "item" && n(a.textValue, r) ? i.push({
      ...a
    }) : a.type !== "item" && i.push({
      ...a
    });
  return i;
}
var y3 = {};
y3 = {
  rangeOverflow: (e) => `يجب أن تكون القيمة ${e.maxValue} أو قبل ذلك.`,
  rangeReversed: "تاريخ البدء يجب أن يكون قبل تاريخ الانتهاء.",
  rangeUnderflow: (e) => `يجب أن تكون القيمة ${e.minValue} أو بعد ذلك.`,
  unavailableDate: "البيانات المحددة غير متاحة."
};
var g3 = {};
g3 = {
  rangeOverflow: (e) => `Стойността трябва да е ${e.maxValue} или по-ранна.`,
  rangeReversed: "Началната дата трябва да е преди крайната.",
  rangeUnderflow: (e) => `Стойността трябва да е ${e.minValue} или по-късно.`,
  unavailableDate: "Избраната дата не е налична."
};
var b3 = {};
b3 = {
  rangeOverflow: (e) => `Hodnota musí být ${e.maxValue} nebo dřívější.`,
  rangeReversed: "Datum zahájení musí předcházet datu ukončení.",
  rangeUnderflow: (e) => `Hodnota musí být ${e.minValue} nebo pozdější.`,
  unavailableDate: "Vybrané datum není k dispozici."
};
var $3 = {};
$3 = {
  rangeOverflow: (e) => `Værdien skal være ${e.maxValue} eller tidligere.`,
  rangeReversed: "Startdatoen skal være før slutdatoen.",
  rangeUnderflow: (e) => `Værdien skal være ${e.minValue} eller nyere.`,
  unavailableDate: "Den valgte dato er ikke tilgængelig."
};
var x3 = {};
x3 = {
  rangeOverflow: (e) => `Der Wert muss ${e.maxValue} oder früher sein.`,
  rangeReversed: "Das Anfangsdatum muss vor dem Enddatum liegen.",
  rangeUnderflow: (e) => `Der Wert muss ${e.minValue} oder später sein.`,
  unavailableDate: "Das ausgewählte Datum ist nicht verfügbar."
};
var D3 = {};
D3 = {
  rangeOverflow: (e) => `Η τιμή πρέπει να είναι ${e.maxValue} ή παλαιότερη.`,
  rangeReversed: "Η ημερομηνία έναρξης πρέπει να είναι πριν από την ημερομηνία λήξης.",
  rangeUnderflow: (e) => `Η τιμή πρέπει να είναι ${e.minValue} ή μεταγενέστερη.`,
  unavailableDate: "Η επιλεγμένη ημερομηνία δεν είναι διαθέσιμη."
};
var E3 = {};
E3 = {
  rangeUnderflow: (e) => `Value must be ${e.minValue} or later.`,
  rangeOverflow: (e) => `Value must be ${e.maxValue} or earlier.`,
  rangeReversed: "Start date must be before end date.",
  unavailableDate: "Selected date unavailable."
};
var w3 = {};
w3 = {
  rangeOverflow: (e) => `El valor debe ser ${e.maxValue} o anterior.`,
  rangeReversed: "La fecha de inicio debe ser anterior a la fecha de finalización.",
  rangeUnderflow: (e) => `El valor debe ser ${e.minValue} o posterior.`,
  unavailableDate: "Fecha seleccionada no disponible."
};
var C3 = {};
C3 = {
  rangeOverflow: (e) => `Väärtus peab olema ${e.maxValue} või varasem.`,
  rangeReversed: "Alguskuupäev peab olema enne lõppkuupäeva.",
  rangeUnderflow: (e) => `Väärtus peab olema ${e.minValue} või hilisem.`,
  unavailableDate: "Valitud kuupäev pole saadaval."
};
var S3 = {};
S3 = {
  rangeOverflow: (e) => `Arvon on oltava ${e.maxValue} tai sitä aikaisempi.`,
  rangeReversed: "Aloituspäivän on oltava ennen lopetuspäivää.",
  rangeUnderflow: (e) => `Arvon on oltava ${e.minValue} tai sitä myöhäisempi.`,
  unavailableDate: "Valittu päivämäärä ei ole käytettävissä."
};
var k3 = {};
k3 = {
  rangeOverflow: (e) => `La valeur doit être ${e.maxValue} ou antérieure.`,
  rangeReversed: "La date de début doit être antérieure à la date de fin.",
  rangeUnderflow: (e) => `La valeur doit être ${e.minValue} ou ultérieure.`,
  unavailableDate: "La date sélectionnée n’est pas disponible."
};
var T3 = {};
T3 = {
  rangeOverflow: (e) => `הערך חייב להיות ${e.maxValue} או מוקדם יותר.`,
  rangeReversed: "תאריך ההתחלה חייב להיות לפני תאריך הסיום.",
  rangeUnderflow: (e) => `הערך חייב להיות ${e.minValue} או מאוחר יותר.`,
  unavailableDate: "התאריך הנבחר אינו זמין."
};
var P3 = {};
P3 = {
  rangeOverflow: (e) => `Vrijednost mora biti ${e.maxValue} ili ranije.`,
  rangeReversed: "Datum početka mora biti prije datuma završetka.",
  rangeUnderflow: (e) => `Vrijednost mora biti ${e.minValue} ili kasnije.`,
  unavailableDate: "Odabrani datum nije dostupan."
};
var A3 = {};
A3 = {
  rangeOverflow: (e) => `Az értéknek ${e.maxValue} vagy korábbinak kell lennie.`,
  rangeReversed: "A kezdő dátumnak a befejező dátumnál korábbinak kell lennie.",
  rangeUnderflow: (e) => `Az értéknek ${e.minValue} vagy későbbinek kell lennie.`,
  unavailableDate: "A kiválasztott dátum nem érhető el."
};
var _3 = {};
_3 = {
  rangeOverflow: (e) => `Il valore deve essere ${e.maxValue} o precedente.`,
  rangeReversed: "La data di inizio deve essere antecedente alla data di fine.",
  rangeUnderflow: (e) => `Il valore deve essere ${e.minValue} o successivo.`,
  unavailableDate: "Data selezionata non disponibile."
};
var F3 = {};
F3 = {
  rangeOverflow: (e) => `値は ${e.maxValue} 以下にする必要があります。`,
  rangeReversed: "開始日は終了日より前にする必要があります。",
  rangeUnderflow: (e) => `値は ${e.minValue} 以上にする必要があります。`,
  unavailableDate: "選択した日付は使用できません。"
};
var O3 = {};
O3 = {
  rangeOverflow: (e) => `값은 ${e.maxValue} 이전이어야 합니다.`,
  rangeReversed: "시작일은 종료일 이전이어야 합니다.",
  rangeUnderflow: (e) => `값은 ${e.minValue} 이상이어야 합니다.`,
  unavailableDate: "선택한 날짜를 사용할 수 없습니다."
};
var I3 = {};
I3 = {
  rangeOverflow: (e) => `Reikšmė turi būti ${e.maxValue} arba ankstesnė.`,
  rangeReversed: "Pradžios data turi būti ankstesnė nei pabaigos data.",
  rangeUnderflow: (e) => `Reikšmė turi būti ${e.minValue} arba naujesnė.`,
  unavailableDate: "Pasirinkta data nepasiekiama."
};
var R3 = {};
R3 = {
  rangeOverflow: (e) => `Vērtībai ir jābūt ${e.maxValue} vai agrākai.`,
  rangeReversed: "Sākuma datumam ir jābūt pirms beigu datuma.",
  rangeUnderflow: (e) => `Vērtībai ir jābūt ${e.minValue} vai vēlākai.`,
  unavailableDate: "Atlasītais datums nav pieejams."
};
var B3 = {};
B3 = {
  rangeOverflow: (e) => `Verdien må være ${e.maxValue} eller tidligere.`,
  rangeReversed: "Startdatoen må være før sluttdatoen.",
  rangeUnderflow: (e) => `Verdien må være ${e.minValue} eller senere.`,
  unavailableDate: "Valgt dato utilgjengelig."
};
var M3 = {};
M3 = {
  rangeOverflow: (e) => `Waarde moet ${e.maxValue} of eerder zijn.`,
  rangeReversed: "De startdatum moet voor de einddatum liggen.",
  rangeUnderflow: (e) => `Waarde moet ${e.minValue} of later zijn.`,
  unavailableDate: "Geselecteerde datum niet beschikbaar."
};
var N3 = {};
N3 = {
  rangeOverflow: (e) => `Wartość musi mieć wartość ${e.maxValue} lub wcześniejszą.`,
  rangeReversed: "Data rozpoczęcia musi być wcześniejsza niż data zakończenia.",
  rangeUnderflow: (e) => `Wartość musi mieć wartość ${e.minValue} lub późniejszą.`,
  unavailableDate: "Wybrana data jest niedostępna."
};
var L3 = {};
L3 = {
  rangeOverflow: (e) => `O valor deve ser ${e.maxValue} ou anterior.`,
  rangeReversed: "A data inicial deve ser anterior à data final.",
  rangeUnderflow: (e) => `O valor deve ser ${e.minValue} ou posterior.`,
  unavailableDate: "Data selecionada indisponível."
};
var V3 = {};
V3 = {
  rangeOverflow: (e) => `O valor tem de ser ${e.maxValue} ou anterior.`,
  rangeReversed: "A data de início deve ser anterior à data de fim.",
  rangeUnderflow: (e) => `O valor tem de ser ${e.minValue} ou posterior.`,
  unavailableDate: "Data selecionada indisponível."
};
var j3 = {};
j3 = {
  rangeOverflow: (e) => `Valoarea trebuie să fie ${e.maxValue} sau anterioară.`,
  rangeReversed: "Data de început trebuie să fie anterioară datei de sfârșit.",
  rangeUnderflow: (e) => `Valoarea trebuie să fie ${e.minValue} sau ulterioară.`,
  unavailableDate: "Data selectată nu este disponibilă."
};
var z3 = {};
z3 = {
  rangeOverflow: (e) => `Значение должно быть не позже ${e.maxValue}.`,
  rangeReversed: "Дата начала должна предшествовать дате окончания.",
  rangeUnderflow: (e) => `Значение должно быть не раньше ${e.minValue}.`,
  unavailableDate: "Выбранная дата недоступна."
};
var K3 = {};
K3 = {
  rangeOverflow: (e) => `Hodnota musí byť ${e.maxValue} alebo skoršia.`,
  rangeReversed: "Dátum začiatku musí byť skorší ako dátum konca.",
  rangeUnderflow: (e) => `Hodnota musí byť ${e.minValue} alebo neskoršia.`,
  unavailableDate: "Vybratý dátum je nedostupný."
};
var U3 = {};
U3 = {
  rangeOverflow: (e) => `Vrednost mora biti ${e.maxValue} ali starejša.`,
  rangeReversed: "Začetni datum mora biti pred končnim datumom.",
  rangeUnderflow: (e) => `Vrednost mora biti ${e.minValue} ali novejša.`,
  unavailableDate: "Izbrani datum ni na voljo."
};
var q3 = {};
q3 = {
  rangeOverflow: (e) => `Vrednost mora da bude ${e.maxValue} ili starija.`,
  rangeReversed: "Datum početka mora biti pre datuma završetka.",
  rangeUnderflow: (e) => `Vrednost mora da bude ${e.minValue} ili novija.`,
  unavailableDate: "Izabrani datum nije dostupan."
};
var H3 = {};
H3 = {
  rangeOverflow: (e) => `Värdet måste vara ${e.maxValue} eller tidigare.`,
  rangeReversed: "Startdatumet måste vara före slutdatumet.",
  rangeUnderflow: (e) => `Värdet måste vara ${e.minValue} eller senare.`,
  unavailableDate: "Det valda datumet är inte tillgängligt."
};
var W3 = {};
W3 = {
  rangeOverflow: (e) => `Değer, ${e.maxValue} veya öncesi olmalıdır.`,
  rangeReversed: "Başlangıç tarihi bitiş tarihinden önce olmalıdır.",
  rangeUnderflow: (e) => `Değer, ${e.minValue} veya sonrası olmalıdır.`,
  unavailableDate: "Seçilen tarih kullanılamıyor."
};
var Q3 = {};
Q3 = {
  rangeOverflow: (e) => `Значення має бути не пізніше ${e.maxValue}.`,
  rangeReversed: "Дата початку має передувати даті завершення.",
  rangeUnderflow: (e) => `Значення має бути не раніше ${e.minValue}.`,
  unavailableDate: "Вибрана дата недоступна."
};
var G3 = {};
G3 = {
  rangeOverflow: (e) => `值必须是 ${e.maxValue} 或更早日期。`,
  rangeReversed: "开始日期必须早于结束日期。",
  rangeUnderflow: (e) => `值必须是 ${e.minValue} 或更晚日期。`,
  unavailableDate: "所选日期不可用。"
};
var Z3 = {};
Z3 = {
  rangeOverflow: (e) => `值必須是 ${e.maxValue} 或更早。`,
  rangeReversed: "開始日期必須在結束日期之前。",
  rangeUnderflow: (e) => `值必須是 ${e.minValue} 或更晚。`,
  unavailableDate: "所選日期無法使用。"
};
var Y3 = {};
Y3 = {
  "ar-AE": y3,
  "bg-BG": g3,
  "cs-CZ": b3,
  "da-DK": $3,
  "de-DE": x3,
  "el-GR": D3,
  "en-US": E3,
  "es-ES": w3,
  "et-EE": C3,
  "fi-FI": S3,
  "fr-FR": k3,
  "he-IL": T3,
  "hr-HR": P3,
  "hu-HU": A3,
  "it-IT": _3,
  "ja-JP": F3,
  "ko-KR": O3,
  "lt-LT": I3,
  "lv-LV": R3,
  "nb-NO": B3,
  "nl-NL": M3,
  "pl-PL": N3,
  "pt-BR": L3,
  "pt-PT": V3,
  "ro-RO": j3,
  "ru-RU": z3,
  "sk-SK": K3,
  "sl-SI": U3,
  "sr-SP": q3,
  "sv-SE": H3,
  "tr-TR": W3,
  "uk-UA": Q3,
  "zh-CN": G3,
  "zh-TW": Z3
};
function N7(e) {
  return e && e.__esModule ? e.default : e;
}
const J3 = new Ur(N7(Y3));
function X3() {
  return typeof navigator < "u" && (navigator.language || navigator.userLanguage) || "en-US";
}
function mc(e, t, r, n, i) {
  let a = e != null && r != null && e.compare(r) > 0, o = e != null && t != null && e.compare(t) < 0, s = e != null && (n == null ? void 0 : n(e)) || !1, u = a || o || s, l = [];
  if (u) {
    let c = X3(), d = Ur.getGlobalDictionaryForPackage("@react-stately/datepicker") || J3, f = new vy(c, d), h = new hr(c, $a({}, i)), p = h.resolvedOptions().timeZone;
    o && l.push(f.format("rangeUnderflow", {
      minValue: h.format(t.toDate(p))
    })), a && l.push(f.format("rangeOverflow", {
      maxValue: h.format(r.toDate(p))
    })), s && l.push(f.format("unavailableDate"));
  }
  return {
    isInvalid: u,
    validationErrors: l,
    validationDetails: {
      badInput: s,
      customError: !1,
      patternMismatch: !1,
      rangeOverflow: a,
      rangeUnderflow: o,
      stepMismatch: !1,
      tooLong: !1,
      tooShort: !1,
      typeMismatch: !1,
      valueMissing: !1,
      valid: !u
    }
  };
}
function L7(e, t, r, n, i) {
  let a = mc(e == null ? void 0 : e.start, t, r, n, i), o = mc(e == null ? void 0 : e.end, t, r, n, i), s = ps(a, o);
  if (e.end != null && e.start != null && e.end.compare(e.start) < 0) {
    let u = Ur.getGlobalDictionaryForPackage("@react-stately/datepicker") || J3;
    s = ps(s, {
      isInvalid: !0,
      validationErrors: [
        u.getStringForLocale("rangeReversed", X3())
      ],
      validationDetails: {
        ...js,
        rangeUnderflow: !0,
        rangeOverflow: !0,
        valid: !1
      }
    });
  }
  return s;
}
const V7 = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "2-digit",
  second: "2-digit"
}, j7 = {
  year: "numeric",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit"
};
function $a(e, t) {
  e = {
    ...t.shouldForceLeadingZeros ? j7 : V7,
    ...e
  };
  let n = t.granularity || "minute", i = Object.keys(e);
  var a;
  let o = i.indexOf((a = t.maxGranularity) !== null && a !== void 0 ? a : "year");
  o < 0 && (o = 0);
  let s = i.indexOf(n);
  if (s < 0 && (s = 2), o > s) throw new Error("maxGranularity must be greater than granularity");
  let u = i.slice(o, s + 1).reduce((c, d) => (c[d] = e[d], c), {});
  return t.hourCycle != null && (u.hour12 = t.hourCycle === 12), u.timeZone = t.timeZone || "UTC", (n === "hour" || n === "minute" || n === "second") && t.timeZone && !t.hideTimeZone && (u.timeZoneName = "short"), t.showEra && o === 0 && (u.era = "short"), u;
}
function so(e) {
  return e && "hour" in e ? e : new Cd();
}
function e1(e, t) {
  if (e === null) return null;
  if (e)
    return Ve(e, t);
}
function ki(e, t, r, n) {
  if (e) return e1(e, r);
  let i = Ve(by(n).set({
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  }), r);
  return t === "year" || t === "month" || t === "day" ? bt(i) : n ? i : $r(i);
}
function t1(e, t) {
  let r = e && "timeZone" in e ? e.timeZone : void 0, n = e && "minute" in e ? "minute" : "day";
  if (e && t && !(t in e)) throw new Error("Invalid granularity " + t + " for value " + e.toString());
  let [i, a] = re([
    n,
    r
  ]);
  e && (i[0] !== n || i[1] !== r) && a([
    n,
    r
  ]), t || (t = e ? n : i[0]);
  let o = e ? r : i[1];
  return [
    t,
    o
  ];
}
const z7 = new Ur({
  ach: {
    year: "mwaka",
    month: "dwe",
    day: "nino"
  },
  af: {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  am: {
    year: "ዓዓዓዓ",
    month: "ሚሜ",
    day: "ቀቀ"
  },
  an: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  ar: {
    year: "سنة",
    month: "شهر",
    day: "يوم"
  },
  ast: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  az: {
    year: "iiii",
    month: "aa",
    day: "gg"
  },
  be: {
    year: "гггг",
    month: "мм",
    day: "дд"
  },
  bg: {
    year: "гггг",
    month: "мм",
    day: "дд"
  },
  bn: {
    year: "yyyy",
    month: "মিমি",
    day: "dd"
  },
  br: {
    year: "bbbb",
    month: "mm",
    day: "dd"
  },
  bs: {
    year: "gggg",
    month: "mm",
    day: "dd"
  },
  ca: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  cak: {
    year: "jjjj",
    month: "ii",
    day: "q'q'"
  },
  ckb: {
    year: "ساڵ",
    month: "مانگ",
    day: "ڕۆژ"
  },
  cs: {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  cy: {
    year: "bbbb",
    month: "mm",
    day: "dd"
  },
  da: {
    year: "åååå",
    month: "mm",
    day: "dd"
  },
  de: {
    year: "jjjj",
    month: "mm",
    day: "tt"
  },
  dsb: {
    year: "llll",
    month: "mm",
    day: "źź"
  },
  el: {
    year: "εεεε",
    month: "μμ",
    day: "ηη"
  },
  en: {
    year: "yyyy",
    month: "mm",
    day: "dd"
  },
  eo: {
    year: "jjjj",
    month: "mm",
    day: "tt"
  },
  es: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  et: {
    year: "aaaa",
    month: "kk",
    day: "pp"
  },
  eu: {
    year: "uuuu",
    month: "hh",
    day: "ee"
  },
  fa: {
    year: "سال",
    month: "ماه",
    day: "روز"
  },
  ff: {
    year: "hhhh",
    month: "ll",
    day: "ññ"
  },
  fi: {
    year: "vvvv",
    month: "kk",
    day: "pp"
  },
  fr: {
    year: "aaaa",
    month: "mm",
    day: "jj"
  },
  fy: {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  ga: {
    year: "bbbb",
    month: "mm",
    day: "ll"
  },
  gd: {
    year: "bbbb",
    month: "mm",
    day: "ll"
  },
  gl: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  he: {
    year: "שנה",
    month: "חודש",
    day: "יום"
  },
  hr: {
    year: "gggg",
    month: "mm",
    day: "dd"
  },
  hsb: {
    year: "llll",
    month: "mm",
    day: "dd"
  },
  hu: {
    year: "éééé",
    month: "hh",
    day: "nn"
  },
  ia: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  id: {
    year: "tttt",
    month: "bb",
    day: "hh"
  },
  it: {
    year: "aaaa",
    month: "mm",
    day: "gg"
  },
  ja: {
    year: " 年 ",
    month: "月",
    day: "日"
  },
  ka: {
    year: "წწწწ",
    month: "თთ",
    day: "რრ"
  },
  kk: {
    year: "жжжж",
    month: "аа",
    day: "кк"
  },
  kn: {
    year: "ವವವವ",
    month: "ಮಿಮೀ",
    day: "ದಿದಿ"
  },
  ko: {
    year: "연도",
    month: "월",
    day: "일"
  },
  lb: {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  lo: {
    year: "ປປປປ",
    month: "ດດ",
    day: "ວວ"
  },
  lt: {
    year: "mmmm",
    month: "mm",
    day: "dd"
  },
  lv: {
    year: "gggg",
    month: "mm",
    day: "dd"
  },
  meh: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  ml: {
    year: "വർഷം",
    month: "മാസം",
    day: "തീയതി"
  },
  ms: {
    year: "tttt",
    month: "mm",
    day: "hh"
  },
  nl: {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  nn: {
    year: "åååå",
    month: "mm",
    day: "dd"
  },
  no: {
    year: "åååå",
    month: "mm",
    day: "dd"
  },
  oc: {
    year: "aaaa",
    month: "mm",
    day: "jj"
  },
  pl: {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  pt: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  rm: {
    year: "oooo",
    month: "mm",
    day: "dd"
  },
  ro: {
    year: "aaaa",
    month: "ll",
    day: "zz"
  },
  ru: {
    year: "гггг",
    month: "мм",
    day: "дд"
  },
  sc: {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  scn: {
    year: "aaaa",
    month: "mm",
    day: "jj"
  },
  sk: {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  sl: {
    year: "llll",
    month: "mm",
    day: "dd"
  },
  sr: {
    year: "гггг",
    month: "мм",
    day: "дд"
  },
  sv: {
    year: "åååå",
    month: "mm",
    day: "dd"
  },
  szl: {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  tg: {
    year: "сссс",
    month: "мм",
    day: "рр"
  },
  th: {
    year: "ปปปป",
    month: "ดด",
    day: "วว"
  },
  tr: {
    year: "yyyy",
    month: "aa",
    day: "gg"
  },
  uk: {
    year: "рррр",
    month: "мм",
    day: "дд"
  },
  "zh-CN": {
    year: "年",
    month: "月",
    day: "日"
  },
  "zh-TW": {
    year: "年",
    month: "月",
    day: "日"
  }
}, "en");
function K7(e, t, r) {
  return e === "era" || e === "dayPeriod" ? t : e === "year" || e === "month" || e === "day" ? z7.getStringForLocale(e, r) : "––";
}
const uo = {
  year: !0,
  month: !0,
  day: !0,
  hour: !0,
  minute: !0,
  second: !0,
  dayPeriod: !0,
  era: !0
}, Ep = {
  year: 5,
  month: 2,
  day: 7,
  hour: 2,
  minute: 15,
  second: 15
}, U7 = {
  dayperiod: "dayPeriod"
};
function q7(e) {
  let { locale: t, createCalendar: r, hideTimeZone: n, isDisabled: i, isReadOnly: a, isRequired: o, minValue: s, maxValue: u, isDateUnavailable: l } = e, c = e.value || e.defaultValue || e.placeholderValue, [d, f] = t1(c, e.granularity), h = f || "UTC";
  if (c && !(d in c)) throw new Error("Invalid granularity " + d + " for value " + c.toString());
  let p = G(() => new hr(t), [
    t
  ]), v = G(() => r(p.resolvedOptions().calendar), [
    r,
    p
  ]), [g, $] = Jt(e.value, e.defaultValue, e.onChange), m = G(() => e1(g, v), [
    g,
    v
  ]), [b, D] = re(() => ki(e.placeholderValue, d, v, f)), S = m || b, T = v.identifier === "gregory" && S.era === "BC", R = G(() => {
    var V;
    return {
      granularity: d,
      maxGranularity: (V = e.maxGranularity) !== null && V !== void 0 ? V : "year",
      timeZone: f,
      hideTimeZone: n,
      hourCycle: e.hourCycle,
      showEra: T,
      shouldForceLeadingZeros: e.shouldForceLeadingZeros
    };
  }, [
    e.maxGranularity,
    d,
    e.hourCycle,
    e.shouldForceLeadingZeros,
    f,
    n,
    T
  ]), y = G(() => $a({}, R), [
    R
  ]), A = G(() => new hr(t, y), [
    t,
    y
  ]), w = G(() => A.resolvedOptions(), [
    A
  ]), E = G(() => A.formatToParts(/* @__PURE__ */ new Date()).filter((V) => uo[V.type]).reduce((V, ie) => (V[ie.type] = !0, V), {}), [
    A
  ]), [k, C] = re(() => e.value || e.defaultValue ? {
    ...E
  } : {}), P = q(), L = q(v.identifier);
  ue(() => {
    v.identifier !== L.current && (L.current = v.identifier, D((V) => Object.keys(k).length > 0 ? Ve(V, v) : ki(e.placeholderValue, d, v, f)));
  }, [
    v,
    d,
    k,
    f,
    e.placeholderValue
  ]), g && Object.keys(k).length < Object.keys(E).length && (k = {
    ...E
  }, C(k)), g == null && Object.keys(k).length === Object.keys(E).length && (k = {}, C(k), D(ki(e.placeholderValue, d, v, f)));
  let O = m && Object.keys(k).length >= Object.keys(E).length ? m : b, x = (V) => {
    if (e.isDisabled || e.isReadOnly) return;
    let ie = Object.keys(k), De = Object.keys(E);
    V == null ? ($(null), D(ki(e.placeholderValue, d, v, f)), C({})) : ie.length >= De.length || ie.length === De.length - 1 && E.dayPeriod && !k.dayPeriod && P.current !== "dayPeriod" ? (V = Ve(V, (c == null ? void 0 : c.calendar) || new xt()), $(V)) : D(V), P.current = null;
  }, U = G(() => O.toDate(h), [
    O,
    h
  ]), K = G(() => A.formatToParts(U).map((V) => {
    let ie = uo[V.type];
    V.type === "era" && v.getEras().length === 1 && (ie = !1);
    let De = uo[V.type] && !k[V.type], ze = uo[V.type] ? K7(V.type, V.value, t) : null;
    return {
      type: U7[V.type] || V.type,
      text: De ? ze : V.value,
      ...H7(O, V.type, w),
      isPlaceholder: De,
      placeholder: ze,
      isEditable: ie
    };
  }), [
    U,
    k,
    A,
    w,
    O,
    v,
    t
  ]);
  E.era && k.year && !k.era ? (k.era = !0, C({
    ...k
  })) : !E.era && k.era && (delete k.era, C({
    ...k
  }));
  let j = (V) => {
    k[V] = !0, V === "year" && E.era && (k.era = !0), C({
      ...k
    });
  }, ae = (V, ie) => {
    if (k[V])
      x(W7(O, V, ie, w));
    else {
      j(V);
      let De = Object.keys(k), ze = Object.keys(E);
      (De.length >= ze.length || De.length === ze.length - 1 && E.dayPeriod && !k.dayPeriod) && x(O);
    }
  }, ne = G(() => mc(g, s, u, l, R), [
    g,
    s,
    u,
    l,
    R
  ]), me = Ia({
    ...e,
    value: g,
    builtinValidation: ne
  }), $e = me.displayValidation.isInvalid, _e = e.validationState || ($e ? "invalid" : null);
  var Fe;
  return {
    ...me,
    value: m,
    dateValue: U,
    calendar: v,
    setValue: x,
    segments: K,
    dateFormatter: A,
    validationState: _e,
    isInvalid: $e,
    granularity: d,
    maxGranularity: (Fe = e.maxGranularity) !== null && Fe !== void 0 ? Fe : "year",
    isDisabled: i,
    isReadOnly: a,
    isRequired: o,
    increment(V) {
      ae(V, 1);
    },
    decrement(V) {
      ae(V, -1);
    },
    incrementPage(V) {
      ae(V, Ep[V] || 1);
    },
    decrementPage(V) {
      ae(V, -(Ep[V] || 1));
    },
    setSegment(V, ie) {
      j(V), x(Q7(O, V, ie, w));
    },
    confirmPlaceholder() {
      if (e.isDisabled || e.isReadOnly) return;
      let V = Object.keys(k), ie = Object.keys(E);
      V.length === ie.length - 1 && E.dayPeriod && !k.dayPeriod && (k = {
        ...E
      }, C(k), x(O.copy()));
    },
    clearSegment(V) {
      delete k[V], P.current = V, C({
        ...k
      });
      let ie = ki(e.placeholderValue, d, v, f), De = O;
      if (V === "dayPeriod" && "hour" in O && "hour" in ie) {
        let ze = O.hour >= 12, He = ie.hour >= 12;
        ze && !He ? De = O.set({
          hour: O.hour - 12
        }) : !ze && He && (De = O.set({
          hour: O.hour + 12
        }));
      } else V in O && (De = O.set({
        [V]: ie[V]
      }));
      $(null), x(De);
    },
    formatValue(V) {
      if (!m) return "";
      let ie = $a(V, R);
      return new hr(t, ie).format(U);
    }
  };
}
function H7(e, t, r) {
  switch (t) {
    case "era": {
      let n = e.calendar.getEras();
      return {
        value: n.indexOf(e.era),
        minValue: 0,
        maxValue: n.length - 1
      };
    }
    case "year":
      return {
        value: e.year,
        minValue: 1,
        maxValue: e.calendar.getYearsInEra(e)
      };
    case "month":
      return {
        value: e.month,
        minValue: J6(e),
        maxValue: e.calendar.getMonthsInYear(e)
      };
    case "day":
      return {
        value: e.day,
        minValue: X6(e),
        maxValue: e.calendar.getDaysInMonth(e)
      };
  }
  if ("hour" in e) switch (t) {
    case "dayPeriod":
      return {
        value: e.hour >= 12 ? 12 : 0,
        minValue: 0,
        maxValue: 12
      };
    case "hour":
      if (r.hour12) {
        let n = e.hour >= 12;
        return {
          value: e.hour,
          minValue: n ? 12 : 0,
          maxValue: n ? 23 : 11
        };
      }
      return {
        value: e.hour,
        minValue: 0,
        maxValue: 23
      };
    case "minute":
      return {
        value: e.minute,
        minValue: 0,
        maxValue: 59
      };
    case "second":
      return {
        value: e.second,
        minValue: 0,
        maxValue: 59
      };
  }
  return {};
}
function W7(e, t, r, n) {
  switch (t) {
    case "era":
    case "year":
    case "month":
    case "day":
      return e.cycle(t, r, {
        round: t === "year"
      });
  }
  if ("hour" in e) switch (t) {
    case "dayPeriod": {
      let i = e.hour, a = i >= 12;
      return e.set({
        hour: a ? i - 12 : i + 12
      });
    }
    case "hour":
    case "minute":
    case "second":
      return e.cycle(t, r, {
        round: t !== "hour",
        hourCycle: n.hour12 ? 12 : 24
      });
  }
}
function Q7(e, t, r, n) {
  switch (t) {
    case "day":
    case "month":
    case "year":
    case "era":
      return e.set({
        [t]: r
      });
  }
  if ("hour" in e) switch (t) {
    case "dayPeriod": {
      let i = e.hour, a = i >= 12;
      return r >= 12 === a ? e : e.set({
        hour: a ? i - 12 : i + 12
      });
    }
    case "hour":
      if (n.hour12) {
        let a = e.hour >= 12;
        !a && r === 12 && (r = 0), a && r < 12 && (r += 12);
      }
    case "minute":
    case "second":
      return e.set({
        [t]: r
      });
  }
}
function G7(e) {
  var t, r;
  let n = Ma(e), [i, a] = Jt(e.value, e.defaultValue || null, e.onChange), [o, s] = re(() => i || {
    start: null,
    end: null
  });
  i == null && o.start && o.end && (o = {
    start: null,
    end: null
  }, s(o));
  let u = i || o, l = (O) => {
    s(O || {
      start: null,
      end: null
    }), O != null && O.start && O.end ? a(O) : a(null);
  }, c = (u == null ? void 0 : u.start) || (u == null ? void 0 : u.end) || e.placeholderValue, [d, f] = t1(c, e.granularity), h = d === "hour" || d === "minute" || d === "second";
  var p;
  let v = (p = e.shouldCloseOnSelect) !== null && p !== void 0 ? p : !0, [g, $] = re(null), [m, b] = re(null);
  u && u.start && u.end && (g = u, "hour" in u.start && (m = u));
  let D = (O, x) => {
    l({
      start: "timeZone" in x.start ? x.start.set(bt(O.start)) : $r(O.start, x.start),
      end: "timeZone" in x.end ? x.end.set(bt(O.end)) : $r(O.end, x.end)
    }), $(null), b(null), C.commitValidation();
  }, S = (O) => {
    let x = typeof v == "function" ? v() : v;
    h ? x || O.start && O.end && (m != null && m.start) && (m != null && m.end) ? D(O, {
      start: (m == null ? void 0 : m.start) || so(e.placeholderValue),
      end: (m == null ? void 0 : m.end) || so(e.placeholderValue)
    }) : $(O) : O.start && O.end ? (l(O), C.commitValidation()) : $(O), x && n.setOpen(!1);
  }, T = (O) => {
    g != null && g.start && (g != null && g.end) && O.start && O.end ? D(g, O) : b(O);
  }, R = (u == null || (t = u.start) === null || t === void 0 ? void 0 : t.calendar.identifier) === "gregory" && u.start.era === "BC" || (u == null || (r = u.end) === null || r === void 0 ? void 0 : r.calendar.identifier) === "gregory" && u.end.era === "BC", y = G(() => ({
    granularity: d,
    timeZone: f,
    hideTimeZone: e.hideTimeZone,
    hourCycle: e.hourCycle,
    shouldForceLeadingZeros: e.shouldForceLeadingZeros,
    showEra: R
  }), [
    d,
    e.hourCycle,
    e.shouldForceLeadingZeros,
    f,
    e.hideTimeZone,
    R
  ]), { minValue: A, maxValue: w, isDateUnavailable: E } = e, k = G(() => L7(u, A, w, E, y), [
    u,
    A,
    w,
    E,
    y
  ]), C = Ia({
    ...e,
    value: i,
    name: G(() => [
      e.startName,
      e.endName
    ], [
      e.startName,
      e.endName
    ]),
    builtinValidation: k
  }), P = C.displayValidation.isInvalid, L = e.validationState || (P ? "invalid" : null);
  return {
    ...C,
    value: u,
    setValue: l,
    dateRange: g,
    timeRange: m,
    granularity: d,
    hasTime: h,
    setDate(O, x) {
      S({
        ...g,
        [O]: x
      });
    },
    setTime(O, x) {
      T({
        ...m,
        [O]: x
      });
    },
    setDateTime(O, x) {
      l({
        ...u,
        [O]: x
      });
    },
    setDateRange: S,
    setTimeRange: T,
    ...n,
    setOpen(O) {
      !O && !(u != null && u.start && (u != null && u.end)) && (g != null && g.start) && (g != null && g.end) && h && D(g, {
        start: (m == null ? void 0 : m.start) || so(e.placeholderValue),
        end: (m == null ? void 0 : m.end) || so(e.placeholderValue)
      }), n.setOpen(O);
    },
    validationState: L,
    isInvalid: P,
    formatValue(O, x) {
      if (!u || !u.start || !u.end) return null;
      let U = "timeZone" in u.start ? u.start.timeZone : void 0, K = e.granularity || (u.start && "minute" in u.start ? "minute" : "day"), j = "timeZone" in u.end ? u.end.timeZone : void 0, ae = e.granularity || (u.end && "minute" in u.end ? "minute" : "day"), ne = $a(x, {
        granularity: K,
        timeZone: U,
        hideTimeZone: e.hideTimeZone,
        hourCycle: e.hourCycle,
        showEra: u.start.calendar.identifier === "gregory" && u.start.era === "BC" || u.end.calendar.identifier === "gregory" && u.end.era === "BC"
      }), me = u.start.toDate(U || "UTC"), $e = u.end.toDate(j || "UTC"), _e = new hr(O, ne), Fe;
      if (U === j && K === ae && u.start.compare(u.end) !== 0) {
        try {
          let V = _e.formatRangeToParts(me, $e), ie = -1;
          for (let He = 0; He < V.length; He++) {
            let xr = V[He];
            if (xr.source === "shared" && xr.type === "literal") ie = He;
            else if (xr.source === "endRange") break;
          }
          let De = "", ze = "";
          for (let He = 0; He < V.length; He++)
            He < ie ? De += V[He].value : He > ie && (ze += V[He].value);
          return {
            start: De,
            end: ze
          };
        } catch {
        }
        Fe = _e;
      } else {
        let V = $a(x, {
          granularity: ae,
          timeZone: j,
          hideTimeZone: e.hideTimeZone,
          hourCycle: e.hourCycle
        });
        Fe = new hr(O, V);
      }
      return {
        start: _e.format(me),
        end: Fe.format($e)
      };
    }
  };
}
function Z7(e) {
  let t = Ma(e), [r, n] = re(null), i = m3({
    ...e,
    onSelectionChange: (u) => {
      e.onSelectionChange != null && e.onSelectionChange(u), t.close(), a.commitValidation();
    }
  }), a = Ia({
    ...e,
    value: i.selectedKey
  }), [o, s] = re(!1);
  return {
    ...a,
    ...i,
    ...t,
    focusStrategy: r,
    open(u = null) {
      i.collection.size !== 0 && (n(u), t.open());
    },
    toggle(u = null) {
      i.collection.size !== 0 && (n(u), t.toggle());
    },
    isFocused: o,
    setFocused: s
  };
}
const r1 = /* @__PURE__ */ de({}), Md = /* @__PURE__ */ de(null), Gs = /* @__PURE__ */ de(null);
function Y7(e, t) {
  [e, t] = at(e, t, r1);
  let { locale: r } = lt(), n = F7({
    ...e,
    locale: r,
    createCalendar: Ky
  }), { calendarProps: i, prevButtonProps: a, nextButtonProps: o, errorMessageProps: s, title: u } = nS(e, n, t), l = ct({
    ...e,
    values: {
      state: n,
      isDisabled: e.isDisabled || !1,
      isInvalid: n.isValueInvalid
    },
    defaultClassName: "react-aria-RangeCalendar"
  });
  return /* @__PURE__ */ F.createElement("div", {
    ...l,
    ...i,
    ref: t,
    slot: e.slot || void 0,
    "data-disabled": e.isDisabled || void 0,
    "data-invalid": n.isValueInvalid || void 0
  }, /* @__PURE__ */ F.createElement(Lt, {
    values: [
      [
        Ba,
        {
          slots: {
            previous: a,
            next: o
          }
        }
      ],
      [
        sd,
        {
          "aria-hidden": !0,
          level: 2,
          children: u
        }
      ],
      [
        Gs,
        n
      ],
      [
        gn,
        {
          slots: {
            errorMessage: s
          }
        }
      ]
    ]
  }, /* @__PURE__ */ F.createElement(sc, null, /* @__PURE__ */ F.createElement("h2", null, i["aria-label"])), l.children, /* @__PURE__ */ F.createElement(sc, null, /* @__PURE__ */ F.createElement("button", {
    "aria-label": o["aria-label"],
    disabled: o.isDisabled,
    onClick: () => n.focusNextPage(),
    tabIndex: -1
  }))));
}
const J7 = /* @__PURE__ */ Ae(Y7), Zs = /* @__PURE__ */ de(null);
function X7(e, t) {
  let r = ce(Md), n = ce(Gs), i = r ?? n, a = i.visibleRange.start;
  e.offset && (a = a.add(e.offset));
  let { gridProps: o, headerProps: s, weekDays: u } = iS({
    startDate: a,
    endDate: oi(a),
    weekdayStyle: e.weekdayStyle
  }, i);
  var l;
  return /* @__PURE__ */ F.createElement(Zs.Provider, {
    value: {
      headerProps: s,
      weekDays: u,
      startDate: a
    }
  }, /* @__PURE__ */ F.createElement("table", {
    ...Me(e),
    ...o,
    ref: t,
    style: e.style,
    className: (l = e.className) !== null && l !== void 0 ? l : "react-aria-CalendarGrid"
  }, typeof e.children != "function" ? e.children : /* @__PURE__ */ F.createElement(F.Fragment, null, /* @__PURE__ */ F.createElement(n1, null, (c) => /* @__PURE__ */ F.createElement(i1, null, c)), /* @__PURE__ */ F.createElement(a1, null, e.children))));
}
const ek = /* @__PURE__ */ Ae(X7);
function tk(e, t) {
  let { children: r, style: n, className: i } = e, { headerProps: a, weekDays: o } = ce(Zs);
  return /* @__PURE__ */ F.createElement("thead", {
    ...Me(e),
    ...a,
    ref: t,
    style: n,
    className: i || "react-aria-CalendarGridHeader"
  }, /* @__PURE__ */ F.createElement("tr", null, o.map((s, u) => /* @__PURE__ */ F.cloneElement(r(s), {
    key: u
  }))));
}
const n1 = /* @__PURE__ */ Ae(tk);
function rk(e, t) {
  let { children: r, style: n, className: i } = e;
  return /* @__PURE__ */ F.createElement("th", {
    ...Me(e),
    ref: t,
    style: n,
    className: i || "react-aria-CalendarHeaderCell"
  }, r);
}
const i1 = /* @__PURE__ */ Ae(rk);
function nk(e, t) {
  let { children: r, style: n, className: i } = e, a = ce(Md), o = ce(Gs), s = a ?? o, { startDate: u } = ce(Zs), { locale: l } = lt(), c = rC(u, l);
  return /* @__PURE__ */ F.createElement("tbody", {
    ...Me(e),
    ref: t,
    style: n,
    className: i || "react-aria-CalendarGridBody"
  }, [
    ...new Array(c).keys()
  ].map((d) => /* @__PURE__ */ F.createElement("tr", {
    key: d
  }, s.getDatesInWeek(d, u).map((f, h) => f ? /* @__PURE__ */ F.cloneElement(r(f), {
    key: h
  }) : /* @__PURE__ */ F.createElement("td", {
    key: h
  })))));
}
const a1 = /* @__PURE__ */ Ae(nk);
function ik({ date: e, ...t }, r) {
  let n = ce(Md), i = ce(Gs), a = n ?? i;
  var o;
  let { startDate: s } = (o = ce(Zs)) !== null && o !== void 0 ? o : {
    startDate: a.visibleRange.start
  }, u = q(null), { cellProps: l, buttonProps: c, ...d } = oS({
    date: e
  }, a, u), { hoverProps: f, isHovered: h } = yn({
    ...t,
    isDisabled: d.isDisabled
  }), { focusProps: p, isFocusVisible: v } = Kr();
  v && (v = d.isFocused);
  let g = !G6(s, e), $ = !1, m = !1;
  "highlightedRange" in a && a.highlightedRange && ($ = Je(e, a.highlightedRange.start), m = Je(e, a.highlightedRange.end));
  let b = ct({
    ...t,
    defaultChildren: d.formattedDate,
    defaultClassName: "react-aria-CalendarCell",
    values: {
      date: e,
      isHovered: h,
      isOutsideMonth: g,
      isFocusVisible: v,
      isSelectionStart: $,
      isSelectionEnd: m,
      ...d
    }
  }), D = {
    "data-focused": d.isFocused || void 0,
    "data-hovered": h || void 0,
    "data-pressed": d.isPressed || void 0,
    "data-unavailable": d.isUnavailable || void 0,
    "data-disabled": d.isDisabled || void 0,
    "data-focus-visible": v || void 0,
    "data-outside-visible-range": d.isOutsideVisibleRange || void 0,
    "data-outside-month": g || void 0,
    "data-selected": d.isSelected || void 0,
    "data-selection-start": $ || void 0,
    "data-selection-end": m || void 0,
    "data-invalid": d.isInvalid || void 0
  };
  return /* @__PURE__ */ F.createElement("td", {
    ...l,
    ref: r
  }, /* @__PURE__ */ F.createElement("div", {
    ...ge(Me(t), c, p, f, D, b),
    ref: u
  }));
}
const ak = /* @__PURE__ */ Ae(ik), Na = /* @__PURE__ */ de(null);
function ok(e, t) {
  let r = ce(Na);
  return r != null && r.isInvalid ? /* @__PURE__ */ F.createElement(uk, {
    ...e,
    ref: t
  }) : null;
}
const sk = /* @__PURE__ */ Ae(ok), uk = /* @__PURE__ */ Ae((e, t) => {
  let r = ce(Na), n = ct({
    ...e,
    defaultClassName: "react-aria-FieldError",
    defaultChildren: r.validationErrors.length === 0 ? void 0 : r.validationErrors.join(" "),
    values: r
  });
  return n.children == null ? null : /* @__PURE__ */ F.createElement(Bd, {
    slot: "errorMessage",
    ...n,
    ref: t
  });
}), Nd = /* @__PURE__ */ de(null), Ys = /* @__PURE__ */ de({});
function lk(e, t) {
  [e, t] = at(e, t, Ys);
  let { elementType: r = "label", ...n } = e;
  return /* @__PURE__ */ F.createElement(r, {
    className: "react-aria-Label",
    ...n,
    ref: t
  });
}
const ck = /* @__PURE__ */ Id(lk), Ld = /* @__PURE__ */ de({});
let dk = (e) => {
  let { onHoverStart: t, onHoverChange: r, onHoverEnd: n, ...i } = e;
  return i;
};
function fk(e, t) {
  [e, t] = at(e, t, Ld);
  let { hoverProps: r, isHovered: n } = yn(e), { isFocused: i, isFocusVisible: a, focusProps: o } = Kr({
    isTextInput: !0,
    autoFocus: e.autoFocus
  }), s = !!e["aria-invalid"] && e["aria-invalid"] !== "false", u = ct({
    ...e,
    values: {
      isHovered: n,
      isFocused: i,
      isFocusVisible: a,
      isDisabled: e.disabled || !1,
      isInvalid: s
    },
    defaultClassName: "react-aria-Input"
  });
  return /* @__PURE__ */ F.createElement("input", {
    ...ge(dk(e), o, r),
    ...u,
    ref: t,
    "data-focused": i || void 0,
    "data-disabled": e.disabled || void 0,
    "data-hovered": n || void 0,
    "data-focus-visible": a || void 0,
    "data-invalid": s || void 0
  });
}
const o1 = /* @__PURE__ */ Id(fk);
var s1 = {};
s1 = {
  colorSwatchPicker: "تغييرات الألوان",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "حدد عنصرًا",
  tableResizer: "أداة تغيير الحجم"
};
var u1 = {};
u1 = {
  colorSwatchPicker: "Цветови мостри",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Изберете предмет",
  tableResizer: "Преоразмерител"
};
var l1 = {};
l1 = {
  colorSwatchPicker: "Vzorky barev",
  dropzoneLabel: "Místo pro přetažení",
  selectPlaceholder: "Vyberte položku",
  tableResizer: "Změna velikosti"
};
var c1 = {};
c1 = {
  colorSwatchPicker: "Farveprøver",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Vælg et element",
  tableResizer: "Størrelsesændring"
};
var d1 = {};
d1 = {
  colorSwatchPicker: "Farbfelder",
  dropzoneLabel: "Ablegebereich",
  selectPlaceholder: "Element wählen",
  tableResizer: "Größenanpassung"
};
var f1 = {};
f1 = {
  colorSwatchPicker: "Χρωματικά δείγματα",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Επιλέξτε ένα αντικείμενο",
  tableResizer: "Αλλαγή μεγέθους"
};
var h1 = {};
h1 = {
  selectPlaceholder: "Select an item",
  tableResizer: "Resizer",
  dropzoneLabel: "DropZone",
  colorSwatchPicker: "Color swatches"
};
var p1 = {};
p1 = {
  colorSwatchPicker: "Muestras de colores",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Seleccionar un artículo",
  tableResizer: "Cambiador de tamaño"
};
var m1 = {};
m1 = {
  colorSwatchPicker: "Värvinäidised",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Valige üksus",
  tableResizer: "Suuruse muutja"
};
var v1 = {};
v1 = {
  colorSwatchPicker: "Värimallit",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Valitse kohde",
  tableResizer: "Koon muuttaja"
};
var y1 = {};
y1 = {
  colorSwatchPicker: "Échantillons de couleurs",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Sélectionner un élément",
  tableResizer: "Redimensionneur"
};
var g1 = {};
g1 = {
  colorSwatchPicker: "דוגמיות צבע",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "בחר פריט",
  tableResizer: "שינוי גודל"
};
var b1 = {};
b1 = {
  colorSwatchPicker: "Uzorci boja",
  dropzoneLabel: "Zona spuštanja",
  selectPlaceholder: "Odaberite stavku",
  tableResizer: "Promjena veličine"
};
var $1 = {};
$1 = {
  colorSwatchPicker: "Színtárak",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Válasszon ki egy elemet",
  tableResizer: "Átméretező"
};
var x1 = {};
x1 = {
  colorSwatchPicker: "Campioni di colore",
  dropzoneLabel: "Zona di rilascio",
  selectPlaceholder: "Seleziona un elemento",
  tableResizer: "Ridimensionamento"
};
var D1 = {};
D1 = {
  colorSwatchPicker: "カラースウォッチ",
  dropzoneLabel: "ドロップゾーン",
  selectPlaceholder: "項目を選択",
  tableResizer: "サイズ変更ツール"
};
var E1 = {};
E1 = {
  colorSwatchPicker: "색상 견본",
  dropzoneLabel: "드롭 영역",
  selectPlaceholder: "항목 선택",
  tableResizer: "크기 조정기"
};
var w1 = {};
w1 = {
  colorSwatchPicker: "Spalvų pavyzdžiai",
  dropzoneLabel: "„DropZone“",
  selectPlaceholder: "Pasirinkite elementą",
  tableResizer: "Dydžio keitiklis"
};
var C1 = {};
C1 = {
  colorSwatchPicker: "Krāsu paraugi",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Izvēlēties vienumu",
  tableResizer: "Izmēra mainītājs"
};
var S1 = {};
S1 = {
  colorSwatchPicker: "Fargekart",
  dropzoneLabel: "Droppsone",
  selectPlaceholder: "Velg et element",
  tableResizer: "Størrelsesendrer"
};
var k1 = {};
k1 = {
  colorSwatchPicker: "kleurstalen",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Selecteer een item",
  tableResizer: "Resizer"
};
var T1 = {};
T1 = {
  colorSwatchPicker: "Próbki kolorów",
  dropzoneLabel: "Strefa upuszczania",
  selectPlaceholder: "Wybierz element",
  tableResizer: "Zmiana rozmiaru"
};
var P1 = {};
P1 = {
  colorSwatchPicker: "Amostras de cores",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Selecione um item",
  tableResizer: "Redimensionador"
};
var A1 = {};
A1 = {
  colorSwatchPicker: "Amostras de cores",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Selecione um item",
  tableResizer: "Redimensionador"
};
var _1 = {};
_1 = {
  colorSwatchPicker: "Specimene de culoare",
  dropzoneLabel: "Zonă de plasare",
  selectPlaceholder: "Selectați un element",
  tableResizer: "Instrument de redimensionare"
};
var F1 = {};
F1 = {
  colorSwatchPicker: "Цветовые образцы",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Выберите элемент",
  tableResizer: "Средство изменения размера"
};
var O1 = {};
O1 = {
  colorSwatchPicker: "Vzorkovníky farieb",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Vyberte položku",
  tableResizer: "Nástroj na zmenu veľkosti"
};
var I1 = {};
I1 = {
  colorSwatchPicker: "Barvne palete",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Izberite element",
  tableResizer: "Spreminjanje velikosti"
};
var R1 = {};
R1 = {
  colorSwatchPicker: "Uzorci boje",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Izaberite stavku",
  tableResizer: "Promena veličine"
};
var B1 = {};
B1 = {
  colorSwatchPicker: "Färgrutor",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Välj en artikel",
  tableResizer: "Storleksändrare"
};
var M1 = {};
M1 = {
  colorSwatchPicker: "Renk örnekleri",
  dropzoneLabel: "Bırakma Bölgesi",
  selectPlaceholder: "Bir öğe seçin",
  tableResizer: "Yeniden boyutlandırıcı"
};
var N1 = {};
N1 = {
  colorSwatchPicker: "Зразки кольорів",
  dropzoneLabel: "DropZone",
  selectPlaceholder: "Виберіть елемент",
  tableResizer: "Засіб змінення розміру"
};
var L1 = {};
L1 = {
  colorSwatchPicker: "颜色色板",
  dropzoneLabel: "放置区域",
  selectPlaceholder: "选择一个项目",
  tableResizer: "尺寸调整器"
};
var V1 = {};
V1 = {
  colorSwatchPicker: "色票",
  dropzoneLabel: "放置區",
  selectPlaceholder: "選取項目",
  tableResizer: "大小調整器"
};
var j1 = {};
j1 = {
  "ar-AE": s1,
  "bg-BG": u1,
  "cs-CZ": l1,
  "da-DK": c1,
  "de-DE": d1,
  "el-GR": f1,
  "en-US": h1,
  "es-ES": p1,
  "et-EE": m1,
  "fi-FI": v1,
  "fr-FR": y1,
  "he-IL": g1,
  "hr-HR": b1,
  "hu-HU": $1,
  "it-IT": x1,
  "ja-JP": D1,
  "ko-KR": E1,
  "lt-LT": w1,
  "lv-LV": C1,
  "nb-NO": S1,
  "nl-NL": k1,
  "pl-PL": T1,
  "pt-BR": P1,
  "pt-PT": A1,
  "ro-RO": _1,
  "ru-RU": F1,
  "sk-SK": O1,
  "sl-SI": I1,
  "sr-SP": R1,
  "sv-SE": B1,
  "tr-TR": M1,
  "uk-UA": N1,
  "zh-CN": L1,
  "zh-TW": V1
};
const z1 = /* @__PURE__ */ de(null);
function hk(e, t) {
  let { render: r } = ce(z1);
  return /* @__PURE__ */ F.createElement(F.Fragment, null, r(e, t));
}
const pk = /* @__PURE__ */ Ae(hk), Vd = /* @__PURE__ */ de({}), mk = /* @__PURE__ */ de({});
function vk(e, t) {
  let [r, n] = at(e, t, mk), i = u3("header", e, t);
  return i || /* @__PURE__ */ F.createElement("header", {
    className: "react-aria-Header",
    ...r,
    ref: n
  }, r.children);
}
const yk = /* @__PURE__ */ Ae(vk), K1 = /* @__PURE__ */ de({});
function gk(e, t) {
  let [r, n] = at(e, t, K1), { elementType: i, orientation: a, style: o, className: s } = r, u = i || "hr";
  u === "hr" && a === "vertical" && (u = "div");
  let { separatorProps: l } = h7({
    elementType: i,
    orientation: a
  }), c = u3("separator", e, t);
  return c || /* @__PURE__ */ F.createElement(u, {
    ...Me(r),
    ...l,
    style: o,
    className: s ?? "react-aria-Separator",
    ref: n,
    slot: r.slot || void 0
  });
}
const bk = /* @__PURE__ */ Ae(gk), La = /* @__PURE__ */ de(null), fi = /* @__PURE__ */ de(null);
function $k(e, t) {
  [e, t] = at(e, t, La);
  let r = ce(ga), n = ce(fi);
  return ce(Ws) ? /* @__PURE__ */ F.createElement(E7, e) : n ? r ? null : /* @__PURE__ */ F.createElement(q1, {
    state: n,
    props: e,
    listBoxRef: t
  }) : /* @__PURE__ */ F.createElement(xk, {
    props: e,
    listBoxRef: t
  });
}
function xk({ props: e, listBoxRef: t }) {
  let { portal: r, collection: n } = $7(e);
  e = {
    ...e,
    collection: n,
    children: null,
    items: null
  };
  let i = p3(e);
  return /* @__PURE__ */ F.createElement(F.Fragment, null, r, /* @__PURE__ */ F.createElement(q1, {
    state: i,
    props: e,
    listBoxRef: t
  }));
}
const U1 = /* @__PURE__ */ Ae($k);
function q1({ state: e, props: t, listBoxRef: r }) {
  let { dragAndDropHooks: n, layout: i = "stack", orientation: a = "vertical" } = t, { collection: o, selectionManager: s } = e, u = !!(n != null && n.useDraggableCollectionState), l = !!(n != null && n.useDroppableCollectionState), { direction: c } = lt(), { disabledBehavior: d, disabledKeys: f } = s, h = Vs({
    usage: "search",
    sensitivity: "base"
  }), p = G(() => t.keyboardDelegate || new Us({
    collection: o,
    collator: h,
    ref: r,
    disabledKeys: f,
    disabledBehavior: d,
    layout: i,
    orientation: a,
    direction: c
  }), [
    o,
    h,
    r,
    d,
    f,
    a,
    c,
    t.keyboardDelegate,
    i
  ]), { listBoxProps: v } = VS({
    ...t,
    shouldSelectOnPressUp: u || t.shouldSelectOnPressUp,
    keyboardDelegate: p
  }, e, r), g = Fd({
    items: o,
    children: (L) => {
      switch (L.type) {
        case "section":
          return /* @__PURE__ */ F.createElement(Dk, {
            section: L
          });
        case "separator":
          return /* @__PURE__ */ F.createElement(bk, L.props);
        case "item":
          return /* @__PURE__ */ F.createElement(H1, {
            item: L
          });
        default:
          throw new Error("Unsupported node type in Menu: " + L.type);
      }
    }
  }), $ = q(u), m = q(l);
  ue(() => {
    $.current !== u && console.warn("Drag hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior."), m.current !== l && console.warn("Drop hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.");
  }, [
    u,
    l
  ]);
  let b, D, S, T = !1, R = null, y = q(null);
  if (u && n) {
    b = n.useDraggableCollectionState({
      collection: o,
      selectionManager: s,
      preview: n.renderDragPreview ? y : void 0
    }), n.useDraggableCollection({}, b, r);
    let L = n.DragPreview;
    R = n.renderDragPreview ? /* @__PURE__ */ F.createElement(L, {
      ref: y
    }, n.renderDragPreview) : null;
  }
  if (l && n) {
    D = n.useDroppableCollectionState({
      collection: o,
      selectionManager: s
    });
    let L = n.dropTargetDelegate || new n.ListDropTargetDelegate(o, r, {
      orientation: a,
      layout: i,
      direction: c
    });
    S = n.useDroppableCollection({
      keyboardDelegate: p,
      dropTargetDelegate: L
    }, D, r), T = D.isDropTarget({
      type: "root"
    });
  }
  let { focusProps: A, isFocused: w, isFocusVisible: E } = Kr(), k = {
    isDropTarget: T,
    isEmpty: e.collection.size === 0,
    isFocused: w,
    isFocusVisible: E,
    layout: t.layout || "stack",
    state: e
  }, C = ct({
    className: t.className,
    style: t.style,
    defaultClassName: "react-aria-ListBox",
    values: k
  }), P = null;
  return e.collection.size === 0 && t.renderEmptyState && (P = /* @__PURE__ */ F.createElement("div", {
    // eslint-disable-next-line
    role: "option",
    style: {
      display: "contents"
    }
  }, t.renderEmptyState(k))), /* @__PURE__ */ F.createElement(fy, null, /* @__PURE__ */ F.createElement("div", {
    ...Me(t),
    ...ge(v, A, S == null ? void 0 : S.collectionProps),
    ...C,
    ref: r,
    slot: t.slot || void 0,
    onScroll: t.onScroll,
    "data-drop-target": T || void 0,
    "data-empty": e.collection.size === 0 || void 0,
    "data-focused": w || void 0,
    "data-focus-visible": E || void 0,
    "data-layout": t.layout || "stack",
    "data-orientation": t.orientation || "vertical"
  }, /* @__PURE__ */ F.createElement(Lt, {
    values: [
      [
        La,
        t
      ],
      [
        fi,
        e
      ],
      [
        Vd,
        {
          dragAndDropHooks: n,
          dragState: b,
          dropState: D
        }
      ],
      [
        K1,
        {
          elementType: "div"
        }
      ],
      [
        z1,
        {
          render: Sk
        }
      ]
    ]
  }, g), P, R));
}
function Dk({ section: e, className: t, style: r }) {
  var n, i;
  let a = ce(fi), [o, s] = Qs();
  var u;
  let { headingProps: l, groupProps: c } = WS({
    heading: s,
    "aria-label": (u = e.props["aria-label"]) !== null && u !== void 0 ? u : void 0
  }), d = Fd({
    items: a.collection.getChildren(e.key),
    children: (f) => {
      switch (f.type) {
        case "header":
          return /* @__PURE__ */ F.createElement(Ek, {
            item: f,
            headingProps: l,
            headingRef: o
          });
        case "item":
          return /* @__PURE__ */ F.createElement(H1, {
            item: f
          });
        default:
          throw new Error("Unsupported element type in Section: " + f.type);
      }
    }
  });
  return /* @__PURE__ */ F.createElement("section", {
    ...Me(e.props),
    ...c,
    className: t || ((n = e.props) === null || n === void 0 ? void 0 : n.className) || "react-aria-Section",
    style: r || ((i = e.props) === null || i === void 0 ? void 0 : i.style),
    ref: e.props.ref
  }, d);
}
function Ek({ item: e, headingProps: t, headingRef: r }) {
  let { ref: n, ...i } = e.props;
  return /* @__PURE__ */ F.createElement(yk, {
    ...t,
    ...i,
    ref: Gv(r, n)
  }, e.rendered);
}
function wk(e, t) {
  return l3("item", e, t, e.children);
}
const Ck = /* @__PURE__ */ Ae(wk);
function H1({ item: e }) {
  var t;
  let r = Pa(e.props.ref), n = ce(fi), { dragAndDropHooks: i, dragState: a, dropState: o } = ce(Vd), { optionProps: s, labelProps: u, descriptionProps: l, ...c } = HS({
    key: e.key,
    "aria-label": (t = e.props) === null || t === void 0 ? void 0 : t["aria-label"]
  }, n, r), { hoverProps: d, isHovered: f } = yn({
    isDisabled: !c.allowsSelection && !c.hasAction,
    onHoverStart: e.props.onHoverStart,
    onHoverChange: e.props.onHoverChange,
    onHoverEnd: e.props.onHoverEnd
  }), h = null;
  a && i && (h = i.useDraggableItem({
    key: e.key
  }, a));
  let p = null;
  o && i && (p = i.useDroppableItem({
    target: {
      type: "item",
      key: e.key,
      dropPosition: "on"
    }
  }, o, r));
  let v = e.props, g = a && a.isDragging(e.key), $ = ct({
    ...v,
    id: void 0,
    children: e.rendered,
    defaultClassName: "react-aria-ListBoxItem",
    values: {
      ...c,
      isHovered: f,
      selectionMode: n.selectionManager.selectionMode,
      selectionBehavior: n.selectionManager.selectionBehavior,
      allowsDragging: !!a,
      isDragging: g,
      isDropTarget: p == null ? void 0 : p.isDropTarget
    }
  }), m = (i == null ? void 0 : i.renderDropIndicator) || ((D) => /* @__PURE__ */ F.createElement(pk, {
    target: D
  }));
  ue(() => {
    e.textValue || console.warn("A `textValue` prop is required for <ListBoxItem> elements with non-plain text children in order to support accessibility features such as type to select.");
  }, [
    e.textValue
  ]);
  let b = v.href ? "a" : "div";
  return /* @__PURE__ */ F.createElement(F.Fragment, null, (i == null ? void 0 : i.useDropIndicator) && m({
    type: "item",
    key: e.key,
    dropPosition: "before"
  }), /* @__PURE__ */ F.createElement(b, {
    ...ge(s, d, h == null ? void 0 : h.dragProps, p == null ? void 0 : p.dropProps),
    ...$,
    ref: r,
    "data-allows-dragging": !!a || void 0,
    "data-selected": c.isSelected || void 0,
    "data-disabled": c.isDisabled || void 0,
    "data-hovered": f || void 0,
    "data-focused": c.isFocused || void 0,
    "data-focus-visible": c.isFocusVisible || void 0,
    "data-pressed": c.isPressed || void 0,
    "data-dragging": g || void 0,
    "data-drop-target": (p == null ? void 0 : p.isDropTarget) || void 0,
    "data-selection-mode": n.selectionManager.selectionMode === "none" ? void 0 : n.selectionManager.selectionMode
  }, /* @__PURE__ */ F.createElement(Lt, {
    values: [
      [
        gn,
        {
          slots: {
            label: u,
            description: l
          }
        }
      ]
    ]
  }, $.children)), (i == null ? void 0 : i.useDropIndicator) && n.collection.getKeyAfter(e.key) == null && m({
    type: "item",
    key: e.key,
    dropPosition: "after"
  }));
}
function Sk(e, t) {
  t = Pa(t);
  let { dragAndDropHooks: r, dropState: n } = ce(Vd), { dropIndicatorProps: i, isHidden: a, isDropTarget: o } = r.useDropIndicator(e, n, t);
  return a ? null : /* @__PURE__ */ F.createElement(Tk, {
    ...e,
    dropIndicatorProps: i,
    isDropTarget: o,
    ref: t
  });
}
function kk(e, t) {
  let { dropIndicatorProps: r, isDropTarget: n, ...i } = e, a = ct({
    ...i,
    defaultClassName: "react-aria-DropIndicator",
    values: {
      isDropTarget: n
    }
  });
  return /* @__PURE__ */ F.createElement("div", {
    ...r,
    ...a,
    // eslint-disable-next-line
    role: "option",
    ref: t,
    "data-drop-target": n || void 0
  });
}
const Tk = /* @__PURE__ */ Ae(kk), Js = /* @__PURE__ */ de({});
function Pk(e, t) {
  [e, t] = at(e, t, Js);
  let { isDisabled: r, isInvalid: n, onHoverStart: i, onHoverChange: a, onHoverEnd: o, ...s } = e, { hoverProps: u, isHovered: l } = yn({
    onHoverStart: i,
    onHoverChange: a,
    onHoverEnd: o,
    isDisabled: r
  }), { isFocused: c, isFocusVisible: d, focusProps: f } = Kr({
    within: !0
  });
  r ?? (r = !!e["aria-disabled"] && e["aria-disabled"] !== "false"), n ?? (n = !!e["aria-invalid"] && e["aria-invalid"] !== "false");
  let h = ct({
    ...e,
    values: {
      isHovered: l,
      isFocusWithin: c,
      isFocusVisible: d,
      isDisabled: r,
      isInvalid: n
    },
    defaultClassName: "react-aria-Group"
  });
  var p, v;
  return /* @__PURE__ */ F.createElement("div", {
    ...ge(s, f, u),
    ...h,
    ref: t,
    role: (p = e.role) !== null && p !== void 0 ? p : "group",
    slot: (v = e.slot) !== null && v !== void 0 ? v : void 0,
    "data-focus-within": c || void 0,
    "data-hovered": l || void 0,
    "data-focus-visible": d || void 0,
    "data-disabled": r || void 0,
    "data-invalid": n || void 0
  }, h.children);
}
const W1 = /* @__PURE__ */ Ae(Pk), Q1 = /* @__PURE__ */ de({
  placement: "bottom"
});
function Ak(e, t) {
  [e, t] = at(e, t, Q1);
  let r = e.placement, n = {
    position: "absolute",
    [r]: "100%",
    transform: r === "top" || r === "bottom" ? "translateX(-50%)" : "translateY(-50%)"
  }, i = ct({
    ...e,
    defaultClassName: "react-aria-OverlayArrow",
    values: {
      placement: r
    }
  });
  return i.style && Object.keys(i.style).forEach((a) => i.style[a] === void 0 && delete i.style[a]), /* @__PURE__ */ F.createElement("div", {
    ...e,
    ...i,
    style: {
      ...n,
      ...i.style
    },
    ref: t,
    "data-placement": r
  });
}
const _k = /* @__PURE__ */ Ae(Ak), hi = /* @__PURE__ */ de(null);
function Fk(e, t) {
  [e, t] = at(e, t, hi);
  let r = ce(pi), n = Ma(e), i = e.isOpen != null || e.defaultOpen != null || !r ? n : r, a = S7(t, i.isOpen) || e.isExiting || !1;
  if (ce(ga)) {
    let s = e.children;
    return typeof s == "function" && (s = s({
      trigger: e.trigger || null,
      placement: "bottom",
      isEntering: !1,
      isExiting: !1,
      defaultChildren: null
    })), /* @__PURE__ */ F.createElement(F.Fragment, null, s);
  }
  return i && !i.isOpen && !a ? null : /* @__PURE__ */ F.createElement(Ik, {
    ...e,
    triggerRef: e.triggerRef,
    state: i,
    popoverRef: t,
    isExiting: a
  });
}
const Ok = /* @__PURE__ */ Ae(Fk);
function Ik({ state: e, isExiting: t, UNSTABLE_portalContainer: r, ...n }) {
  let i = q(null), [a, o] = re(0);
  Oe(() => {
    i.current && e.isOpen && o(i.current.getBoundingClientRect().width);
  }, [
    e.isOpen,
    i
  ]);
  var s;
  let { popoverProps: u, underlayProps: l, arrowProps: c, placement: d } = AS({
    ...n,
    offset: (s = n.offset) !== null && s !== void 0 ? s : 8,
    arrowSize: a
  }, e), f = n.popoverRef, h = C7(f, !!d) || n.isEntering || !1, p = ct({
    ...n,
    defaultClassName: "react-aria-Popover",
    values: {
      trigger: n.trigger || null,
      placement: d,
      isEntering: h,
      isExiting: t
    }
  }), v = {
    ...u.style,
    ...p.style
  };
  return /* @__PURE__ */ F.createElement(OS, {
    isExiting: t,
    portalContainer: r
  }, !n.isNonModal && e.isOpen && /* @__PURE__ */ F.createElement("div", {
    "data-testid": "underlay",
    ...l,
    style: {
      position: "fixed",
      inset: 0
    }
  }), /* @__PURE__ */ F.createElement("div", {
    ...ge(Me(n), u),
    ...p,
    ref: f,
    slot: n.slot || void 0,
    style: v,
    "data-trigger": n.trigger,
    "data-placement": d,
    "data-entering": h || void 0,
    "data-exiting": t || void 0
  }, !n.isNonModal && /* @__PURE__ */ F.createElement(fp, {
    onDismiss: e.close
  }), /* @__PURE__ */ F.createElement(Q1.Provider, {
    value: {
      ...c,
      placement: d,
      ref: i
    }
  }, p.children), /* @__PURE__ */ F.createElement(fp, {
    onDismiss: e.close
  })));
}
const jd = /* @__PURE__ */ de(null), pi = /* @__PURE__ */ de(null);
function Rk(e) {
  let t = Ma(e), r = q(null), { triggerProps: n, overlayProps: i } = m0({
    type: "dialog"
  }, t, r);
  return n.id = Ct(), i["aria-labelledby"] = n.id, /* @__PURE__ */ F.createElement(Lt, {
    values: [
      [
        pi,
        t
      ],
      [
        jd,
        i
      ],
      [
        hi,
        {
          trigger: "DialogTrigger",
          triggerRef: r
        }
      ]
    ]
  }, /* @__PURE__ */ F.createElement(l6, {
    ...n,
    ref: r,
    isPressed: t.isOpen
  }, e.children));
}
function Bk(e, t) {
  let r = e["aria-labelledby"];
  [e, t] = at(e, t, jd);
  let { dialogProps: n, titleProps: i } = l7({
    ...e,
    // Only pass aria-labelledby from props, not context.
    // Context is used as a fallback below.
    "aria-labelledby": r
  }, t), a = ce(pi), o = e.children;
  typeof o == "function" && (o = o({
    close: (a == null ? void 0 : a.close) || (() => {
    })
  })), !n["aria-label"] && !n["aria-labelledby"] && (e["aria-labelledby"] ? n["aria-labelledby"] = e["aria-labelledby"] : console.warn('If a Dialog does not contain a <Heading slot="title">, it must have an aria-label or aria-labelledby attribute for accessibility.'));
  var s;
  return /* @__PURE__ */ F.createElement("section", {
    ...Me(e),
    ...n,
    ref: t,
    slot: e.slot || void 0,
    style: e.style,
    className: (s = e.className) !== null && s !== void 0 ? s : "react-aria-Dialog"
  }, /* @__PURE__ */ F.createElement(Lt, {
    values: [
      [
        sd,
        {
          slots: {
            [dc]: {},
            title: {
              ...i,
              level: 2
            }
          }
        }
      ]
    ]
  }, o));
}
const Mk = /* @__PURE__ */ Ae(Bk), Nk = /* @__PURE__ */ de(null), G1 = /* @__PURE__ */ de(null);
function Lk(e, t) {
  [e, t] = at(e, t, Nk);
  let { collection: r, document: n } = Od(), { children: i, isDisabled: a = !1, isInvalid: o = !1, isRequired: s = !1 } = e;
  i = G(() => typeof i == "function" ? i({
    isOpen: !1,
    isDisabled: a,
    isInvalid: o,
    isRequired: s,
    defaultChildren: null
  }) : i, [
    i,
    a,
    o,
    s
  ]);
  var u;
  return /* @__PURE__ */ F.createElement(F.Fragment, null, /* @__PURE__ */ F.createElement(d3, null, /* @__PURE__ */ F.createElement(Lt, {
    values: [
      [
        Ws,
        n
      ],
      [
        La,
        {
          items: (u = e.items) !== null && u !== void 0 ? u : e.defaultItems
        }
      ]
    ]
  }, i)), /* @__PURE__ */ F.createElement(Vk, {
    props: e,
    collection: r,
    comboBoxRef: t
  }));
}
function Vk({ props: e, collection: t, comboBoxRef: r }) {
  let { name: n, formValue: i = "key", allowsCustomValue: a } = e;
  a && (i = "text");
  let { validationBehavior: o } = di(Nd) || {};
  var s, u;
  let l = (u = (s = e.validationBehavior) !== null && s !== void 0 ? s : o) !== null && u !== void 0 ? u : "native", { contains: c } = Wy({
    sensitivity: "base"
  }), d = B7({
    defaultFilter: e.defaultFilter || c,
    ...e,
    // If props.items isn't provided, rely on collection filtering (aka listbox.items is provided or defaultItems provided to Combobox)
    items: e.items,
    children: void 0,
    collection: t,
    validationBehavior: l
  }), f = q(null), h = q(null), p = q(null), v = q(null), [g, $] = Qs(), { buttonProps: m, inputProps: b, listBoxProps: D, labelProps: S, descriptionProps: T, errorMessageProps: R, ...y } = YS({
    ...Rd(e),
    label: $,
    inputRef: h,
    buttonRef: f,
    listBoxRef: p,
    popoverRef: v,
    name: i === "text" ? n : void 0,
    validationBehavior: l
  }, d), [A, w] = re(null), E = ye(() => {
    if (h.current) {
      var L;
      let O = (L = f.current) === null || L === void 0 ? void 0 : L.getBoundingClientRect(), x = h.current.getBoundingClientRect(), U = O ? Math.min(O.left, x.left) : x.left, K = O ? Math.max(O.right, x.right) : x.right;
      w(K - U + "px");
    }
  }, [
    f,
    h,
    w
  ]);
  Os({
    ref: h,
    onResize: E
  });
  let k = G(() => ({
    isOpen: d.isOpen,
    isDisabled: e.isDisabled || !1,
    isInvalid: y.isInvalid || !1,
    isRequired: e.isRequired || !1
  }), [
    d.isOpen,
    e.isDisabled,
    y.isInvalid,
    e.isRequired
  ]), C = ct({
    ...e,
    values: k,
    defaultClassName: "react-aria-ComboBox"
  }), P = Me(e);
  return delete P.id, /* @__PURE__ */ F.createElement(Lt, {
    values: [
      [
        G1,
        d
      ],
      [
        Ys,
        {
          ...S,
          ref: g
        }
      ],
      [
        Ba,
        {
          ...m,
          ref: f,
          isPressed: d.isOpen
        }
      ],
      [
        Ld,
        {
          ...b,
          ref: h
        }
      ],
      [
        pi,
        d
      ],
      [
        hi,
        {
          ref: v,
          triggerRef: h,
          placement: "bottom start",
          isNonModal: !0,
          trigger: "ComboBox",
          style: {
            "--trigger-width": A
          }
        }
      ],
      [
        La,
        {
          ...D,
          ref: p
        }
      ],
      [
        fi,
        d
      ],
      [
        gn,
        {
          slots: {
            description: T,
            errorMessage: R
          }
        }
      ],
      [
        Js,
        {
          isInvalid: y.isInvalid,
          isDisabled: e.isDisabled || !1
        }
      ],
      [
        Na,
        y
      ]
    ]
  }, /* @__PURE__ */ F.createElement("div", {
    ...P,
    ...C,
    ref: r,
    slot: e.slot || void 0,
    "data-focused": d.isFocused || void 0,
    "data-open": d.isOpen || void 0,
    "data-disabled": e.isDisabled || void 0,
    "data-invalid": y.isInvalid || void 0,
    "data-required": e.isRequired || void 0
  }), n && i === "key" && /* @__PURE__ */ F.createElement("input", {
    type: "hidden",
    name: n,
    value: d.selectedKey
  }));
}
const jk = /* @__PURE__ */ Ae(Lk), Z1 = /* @__PURE__ */ de(null), Xs = /* @__PURE__ */ de(null), zd = /* @__PURE__ */ de(null);
function zk(e, t) {
  let r = ce(Xs), n = ce(zd);
  return r || n ? /* @__PURE__ */ F.createElement(Y1, {
    ...e,
    ref: t
  }) : /* @__PURE__ */ F.createElement(Kk, {
    ...e,
    ref: t
  });
}
const Kk = /* @__PURE__ */ Ae((e, t) => {
  let [r, n] = at({
    slot: e.slot
  }, t, Z1), { locale: i } = lt(), a = q7({
    ...r,
    locale: i,
    createCalendar: Ky
  }), o = q(null), { fieldProps: s, inputProps: u } = XS({
    ...r,
    inputRef: o
  }, a, n);
  return /* @__PURE__ */ F.createElement(Lt, {
    values: [
      [
        Xs,
        a
      ],
      [
        Ld,
        {
          ...u,
          ref: o
        }
      ],
      [
        Js,
        {
          ...s,
          ref: n,
          isInvalid: a.isInvalid
        }
      ]
    ]
  }, /* @__PURE__ */ F.createElement(Y1, e));
}), Y1 = /* @__PURE__ */ Ae((e, t) => {
  let { className: r, children: n } = e, i = ce(Xs), a = ce(zd), o = i ?? a;
  return /* @__PURE__ */ F.createElement(F.Fragment, null, /* @__PURE__ */ F.createElement(W1, {
    ...e,
    ref: t,
    slot: e.slot || void 0,
    className: r ?? "react-aria-DateInput",
    isInvalid: o.isInvalid
  }, o.segments.map((s, u) => /* @__PURE__ */ Gi(n(s), {
    key: u
  }))), /* @__PURE__ */ F.createElement(o1, null));
}), Uk = /* @__PURE__ */ Ae(zk);
function qk({ segment: e, ...t }, r) {
  let n = ce(Xs), i = ce(zd), a = n ?? i, o = Pa(r), { segmentProps: s } = a7(e, a, o), { focusProps: u, isFocused: l, isFocusVisible: c } = Kr(), { hoverProps: d, isHovered: f } = yn({
    ...t,
    isDisabled: a.isDisabled || e.type === "literal"
  }), h = ct({
    ...t,
    values: {
      ...e,
      isReadOnly: !e.isEditable,
      isInvalid: a.isInvalid,
      isDisabled: a.isDisabled,
      isHovered: f,
      isFocused: l,
      isFocusVisible: c
    },
    defaultChildren: e.text,
    defaultClassName: "react-aria-DateSegment"
  });
  return /* @__PURE__ */ F.createElement("div", {
    ...ge(Me(t), s, u, d),
    ...h,
    ref: o,
    "data-placeholder": e.isPlaceholder || void 0,
    "data-invalid": a.isInvalid || void 0,
    "data-readonly": !e.isEditable || void 0,
    "data-disabled": a.isDisabled || void 0,
    "data-type": e.type,
    "data-hovered": f || void 0,
    "data-focused": l || void 0,
    "data-focus-visible": c || void 0
  });
}
const Hk = /* @__PURE__ */ Ae(qk), Wk = /* @__PURE__ */ de(null), Qk = /* @__PURE__ */ de(null);
function Gk(e, t) {
  [e, t] = at(e, t, Wk);
  let { validationBehavior: r } = di(Nd) || {};
  var n, i;
  let a = (i = (n = e.validationBehavior) !== null && n !== void 0 ? n : r) !== null && i !== void 0 ? i : "native", o = G7({
    ...e,
    validationBehavior: a
  }), s = q(null), [u, l] = Qs(), { groupProps: c, labelProps: d, startFieldProps: f, endFieldProps: h, buttonProps: p, dialogProps: v, calendarProps: g, descriptionProps: $, errorMessageProps: m, ...b } = u7({
    ...Rd(e),
    label: l,
    validationBehavior: a
  }, o, s), [D, S] = re(null), T = ye(() => {
    s.current && S(s.current.offsetWidth + "px");
  }, []);
  Os({
    ref: s,
    onResize: T
  });
  let { focusProps: R, isFocused: y, isFocusVisible: A } = Kr({
    within: !0
  }), w = ct({
    ...e,
    values: {
      state: o,
      isFocusWithin: y,
      isFocusVisible: A,
      isDisabled: e.isDisabled || !1,
      isInvalid: o.isInvalid,
      isOpen: o.isOpen
    },
    defaultClassName: "react-aria-DateRangePicker"
  }), E = Me(e);
  return delete E.id, /* @__PURE__ */ F.createElement(Lt, {
    values: [
      [
        Qk,
        o
      ],
      [
        Js,
        {
          ...c,
          ref: s,
          isInvalid: o.isInvalid
        }
      ],
      [
        Ba,
        {
          ...p,
          isPressed: o.isOpen
        }
      ],
      [
        Ys,
        {
          ...d,
          ref: u,
          elementType: "span"
        }
      ],
      [
        r1,
        g
      ],
      [
        pi,
        o
      ],
      [
        hi,
        {
          trigger: "DateRangePicker",
          triggerRef: s,
          placement: "bottom start",
          style: {
            "--trigger-width": D
          }
        }
      ],
      [
        jd,
        v
      ],
      [
        Z1,
        {
          slots: {
            start: f,
            end: h
          }
        }
      ],
      [
        gn,
        {
          slots: {
            description: $,
            errorMessage: m
          }
        }
      ],
      [
        Na,
        b
      ]
    ]
  }, /* @__PURE__ */ F.createElement("div", {
    ...R,
    ...E,
    ...w,
    ref: t,
    slot: e.slot || void 0,
    "data-focus-within": y || void 0,
    "data-invalid": o.isInvalid || void 0,
    "data-focus-visible": A || void 0,
    "data-disabled": e.isDisabled || void 0,
    "data-open": o.isOpen || void 0
  }));
}
const Zk = /* @__PURE__ */ Ae(Gk);
function Yk(e, t) {
  [e, t] = at(e, t, sd);
  let { children: r, level: n = 3, className: i, ...a } = e, o = `h${n}`;
  return /* @__PURE__ */ F.createElement(o, {
    ...a,
    ref: t,
    className: i ?? "react-aria-Heading"
  }, r);
}
const Jk = /* @__PURE__ */ Ae(Yk);
function Xk(e) {
  return e && e.__esModule ? e.default : e;
}
const So = /* @__PURE__ */ de(null), vc = /* @__PURE__ */ de(null);
function e8(e, t) {
  [e, t] = at(e, t, So);
  let { validationBehavior: r } = di(Nd) || {};
  var n, i;
  let a = (i = (n = e.validationBehavior) !== null && n !== void 0 ? n : r) !== null && i !== void 0 ? i : "native", { collection: o, document: s } = Od(), u = Z7({
    ...e,
    collection: o,
    children: void 0,
    validationBehavior: a
  }), { isFocusVisible: l, focusProps: c } = Kr({
    within: !0
  }), d = q(null), [f, h] = Qs(), { labelProps: p, triggerProps: v, valueProps: g, menuProps: $, descriptionProps: m, errorMessageProps: b, ...D } = c7({
    ...Rd(e),
    label: h,
    validationBehavior: a
  }, u, d), [S, T] = re(null), R = ye(() => {
    d.current && T(d.current.offsetWidth + "px");
  }, [
    d
  ]);
  Os({
    ref: d,
    onResize: R
  });
  let y = G(() => ({
    isOpen: u.isOpen,
    isFocused: u.isFocused,
    isFocusVisible: l,
    isDisabled: e.isDisabled || !1,
    isInvalid: D.isInvalid || !1,
    isRequired: e.isRequired || !1
  }), [
    u.isOpen,
    u.isFocused,
    l,
    e.isDisabled,
    D.isInvalid,
    e.isRequired
  ]), A = ct({
    ...e,
    values: y,
    defaultClassName: "react-aria-Select"
  }), w = Me(e);
  return delete w.id, /* @__PURE__ */ F.createElement(F.Fragment, null, /* @__PURE__ */ F.createElement(d3, null, /* @__PURE__ */ F.createElement(Lt, {
    values: [
      [
        So,
        e
      ],
      [
        vc,
        u
      ],
      [
        Ws,
        s
      ]
    ]
  }, A.children)), /* @__PURE__ */ F.createElement(Lt, {
    values: [
      [
        So,
        e
      ],
      [
        vc,
        u
      ],
      [
        J1,
        g
      ],
      [
        Ys,
        {
          ...p,
          ref: f,
          elementType: "span"
        }
      ],
      [
        Ba,
        {
          ...v,
          ref: d,
          isPressed: u.isOpen
        }
      ],
      [
        pi,
        u
      ],
      [
        hi,
        {
          trigger: "Select",
          triggerRef: d,
          placement: "bottom start",
          style: {
            "--trigger-width": S
          }
        }
      ],
      [
        La,
        $
      ],
      [
        fi,
        u
      ],
      [
        gn,
        {
          slots: {
            description: m,
            errorMessage: b
          }
        }
      ],
      [
        Na,
        D
      ]
    ]
  }, /* @__PURE__ */ F.createElement("div", {
    ...w,
    ...A,
    ...c,
    ref: t,
    slot: e.slot || void 0,
    "data-focused": u.isFocused || void 0,
    "data-focus-visible": l || void 0,
    "data-open": u.isOpen || void 0,
    "data-disabled": e.isDisabled || void 0,
    "data-invalid": D.isInvalid || void 0,
    "data-required": e.isRequired || void 0
  }), /* @__PURE__ */ F.createElement(f7, {
    state: u,
    triggerRef: d,
    label: h,
    name: e.name,
    isDisabled: e.isDisabled
  })));
}
const t8 = /* @__PURE__ */ Ae(e8), J1 = /* @__PURE__ */ de(null);
function r8(e, t) {
  var r, n;
  [e, t] = at(e, t, J1);
  let i = ce(vc), { placeholder: a } = di(So), o = i.selectedKey != null ? i.collection.getItem(i.selectedKey) : null, s = o == null ? void 0 : o.rendered;
  typeof s == "function" && (s = s({
    isHovered: !1,
    isPressed: !1,
    isSelected: !1,
    isFocused: !1,
    isFocusVisible: !1,
    isDisabled: !1,
    selectionMode: "single",
    selectionBehavior: "toggle"
  }));
  let u = zt(Xk(j1), "react-aria-components");
  var l, c;
  let d = ct({
    ...e,
    defaultChildren: s || a || u.format("selectPlaceholder"),
    defaultClassName: "react-aria-SelectValue",
    values: {
      selectedItem: (l = (r = i.selectedItem) === null || r === void 0 ? void 0 : r.value) !== null && l !== void 0 ? l : null,
      selectedText: (c = (n = i.selectedItem) === null || n === void 0 ? void 0 : n.textValue) !== null && c !== void 0 ? c : null,
      isPlaceholder: !o
    }
  }), f = Me(e);
  return /* @__PURE__ */ F.createElement("span", {
    ref: t,
    ...f,
    ...d,
    "data-placeholder": !o || void 0
  }, /* @__PURE__ */ F.createElement(gn.Provider, {
    value: void 0
  }, d.children));
}
const n8 = /* @__PURE__ */ Ae(r8);
var wp = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, vt = (e) => !e || typeof e != "object" || Object.keys(e).length === 0, i8 = (e, t) => JSON.stringify(e) === JSON.stringify(t);
function X1(e, t) {
  e.forEach(function(r) {
    Array.isArray(r) ? X1(r, t) : t.push(r);
  });
}
function e$(e) {
  let t = [];
  return X1(e, t), t;
}
var t$ = (...e) => e$(e).filter(Boolean), r$ = (e, t) => {
  let r = {}, n = Object.keys(e), i = Object.keys(t);
  for (let a of n) if (i.includes(a)) {
    let o = e[a], s = t[a];
    typeof o == "object" && typeof s == "object" ? r[a] = r$(o, s) : Array.isArray(o) || Array.isArray(s) ? r[a] = t$(s, o) : r[a] = s + " " + o;
  } else r[a] = e[a];
  for (let a of i) n.includes(a) || (r[a] = t[a]);
  return r;
}, Cp = (e) => !e || typeof e != "string" ? e : e.replace(/\s+/g, " ").trim();
const Kd = "-";
function a8(e) {
  const t = s8(e), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = e;
  function i(o) {
    const s = o.split(Kd);
    return s[0] === "" && s.length !== 1 && s.shift(), n$(s, t) || o8(o);
  }
  function a(o, s) {
    const u = r[o] || [];
    return s && n[o] ? [...u, ...n[o]] : u;
  }
  return {
    getClassGroupId: i,
    getConflictingClassGroupIds: a
  };
}
function n$(e, t) {
  var o;
  if (e.length === 0)
    return t.classGroupId;
  const r = e[0], n = t.nextPart.get(r), i = n ? n$(e.slice(1), n) : void 0;
  if (i)
    return i;
  if (t.validators.length === 0)
    return;
  const a = e.join(Kd);
  return (o = t.validators.find(({
    validator: s
  }) => s(a))) == null ? void 0 : o.classGroupId;
}
const Sp = /^\[(.+)\]$/;
function o8(e) {
  if (Sp.test(e)) {
    const t = Sp.exec(e)[1], r = t == null ? void 0 : t.substring(0, t.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}
function s8(e) {
  const {
    theme: t,
    prefix: r
  } = e, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return l8(Object.entries(e.classGroups), r).forEach(([a, o]) => {
    yc(o, n, a, t);
  }), n;
}
function yc(e, t, r, n) {
  e.forEach((i) => {
    if (typeof i == "string") {
      const a = i === "" ? t : kp(t, i);
      a.classGroupId = r;
      return;
    }
    if (typeof i == "function") {
      if (u8(i)) {
        yc(i(n), t, r, n);
        return;
      }
      t.validators.push({
        validator: i,
        classGroupId: r
      });
      return;
    }
    Object.entries(i).forEach(([a, o]) => {
      yc(o, kp(t, a), r, n);
    });
  });
}
function kp(e, t) {
  let r = e;
  return t.split(Kd).forEach((n) => {
    r.nextPart.has(n) || r.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(n);
  }), r;
}
function u8(e) {
  return e.isThemeGetter;
}
function l8(e, t) {
  return t ? e.map(([r, n]) => {
    const i = n.map((a) => typeof a == "string" ? t + a : typeof a == "object" ? Object.fromEntries(Object.entries(a).map(([o, s]) => [t + o, s])) : a);
    return [r, i];
  }) : e;
}
function c8(e) {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  function i(a, o) {
    r.set(a, o), t++, t > e && (t = 0, n = r, r = /* @__PURE__ */ new Map());
  }
  return {
    get(a) {
      let o = r.get(a);
      if (o !== void 0)
        return o;
      if ((o = n.get(a)) !== void 0)
        return i(a, o), o;
    },
    set(a, o) {
      r.has(a) ? r.set(a, o) : i(a, o);
    }
  };
}
const i$ = "!";
function d8(e) {
  const t = e.separator, r = t.length === 1, n = t[0], i = t.length;
  return function(o) {
    const s = [];
    let u = 0, l = 0, c;
    for (let v = 0; v < o.length; v++) {
      let g = o[v];
      if (u === 0) {
        if (g === n && (r || o.slice(v, v + i) === t)) {
          s.push(o.slice(l, v)), l = v + i;
          continue;
        }
        if (g === "/") {
          c = v;
          continue;
        }
      }
      g === "[" ? u++ : g === "]" && u--;
    }
    const d = s.length === 0 ? o : o.substring(l), f = d.startsWith(i$), h = f ? d.substring(1) : d, p = c && c > l ? c - l : void 0;
    return {
      modifiers: s,
      hasImportantModifier: f,
      baseClassName: h,
      maybePostfixModifierPosition: p
    };
  };
}
function f8(e) {
  if (e.length <= 1)
    return e;
  const t = [];
  let r = [];
  return e.forEach((n) => {
    n[0] === "[" ? (t.push(...r.sort(), n), r = []) : r.push(n);
  }), t.push(...r.sort()), t;
}
function h8(e) {
  return {
    cache: c8(e.cacheSize),
    splitModifiers: d8(e),
    ...a8(e)
  };
}
const p8 = /\s+/;
function m8(e, t) {
  const {
    splitModifiers: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: i
  } = t, a = /* @__PURE__ */ new Set();
  return e.trim().split(p8).map((o) => {
    const {
      modifiers: s,
      hasImportantModifier: u,
      baseClassName: l,
      maybePostfixModifierPosition: c
    } = r(o);
    let d = n(c ? l.substring(0, c) : l), f = !!c;
    if (!d) {
      if (!c)
        return {
          isTailwindClass: !1,
          originalClassName: o
        };
      if (d = n(l), !d)
        return {
          isTailwindClass: !1,
          originalClassName: o
        };
      f = !1;
    }
    const h = f8(s).join(":");
    return {
      isTailwindClass: !0,
      modifierId: u ? h + i$ : h,
      classGroupId: d,
      originalClassName: o,
      hasPostfixModifier: f
    };
  }).reverse().filter((o) => {
    if (!o.isTailwindClass)
      return !0;
    const {
      modifierId: s,
      classGroupId: u,
      hasPostfixModifier: l
    } = o, c = s + u;
    return a.has(c) ? !1 : (a.add(c), i(u, l).forEach((d) => a.add(s + d)), !0);
  }).reverse().map((o) => o.originalClassName).join(" ");
}
function v8() {
  let e = 0, t, r, n = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (r = a$(t)) && (n && (n += " "), n += r);
  return n;
}
function a$(e) {
  if (typeof e == "string")
    return e;
  let t, r = "";
  for (let n = 0; n < e.length; n++)
    e[n] && (t = a$(e[n])) && (r && (r += " "), r += t);
  return r;
}
function gc(e, ...t) {
  let r, n, i, a = o;
  function o(u) {
    const l = t.reduce((c, d) => d(c), e());
    return r = h8(l), n = r.cache.get, i = r.cache.set, a = s, s(u);
  }
  function s(u) {
    const l = n(u);
    if (l)
      return l;
    const c = m8(u, r);
    return i(u, c), c;
  }
  return function() {
    return a(v8.apply(null, arguments));
  };
}
function Ne(e) {
  const t = (r) => r[e] || [];
  return t.isThemeGetter = !0, t;
}
const o$ = /^\[(?:([a-z-]+):)?(.+)\]$/i, y8 = /^\d+\/\d+$/, g8 = /* @__PURE__ */ new Set(["px", "full", "screen"]), b8 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, $8 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, x8 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, D8 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, E8 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
function nr(e) {
  return rn(e) || g8.has(e) || y8.test(e);
}
function Er(e) {
  return mi(e, "length", _8);
}
function rn(e) {
  return !!e && !Number.isNaN(Number(e));
}
function lo(e) {
  return mi(e, "number", rn);
}
function Ti(e) {
  return !!e && Number.isInteger(Number(e));
}
function w8(e) {
  return e.endsWith("%") && rn(e.slice(0, -1));
}
function ve(e) {
  return o$.test(e);
}
function wr(e) {
  return b8.test(e);
}
const C8 = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
function S8(e) {
  return mi(e, C8, s$);
}
function k8(e) {
  return mi(e, "position", s$);
}
const T8 = /* @__PURE__ */ new Set(["image", "url"]);
function P8(e) {
  return mi(e, T8, O8);
}
function A8(e) {
  return mi(e, "", F8);
}
function Pi() {
  return !0;
}
function mi(e, t, r) {
  const n = o$.exec(e);
  return n ? n[1] ? typeof t == "string" ? n[1] === t : t.has(n[1]) : r(n[2]) : !1;
}
function _8(e) {
  return $8.test(e) && !x8.test(e);
}
function s$() {
  return !1;
}
function F8(e) {
  return D8.test(e);
}
function O8(e) {
  return E8.test(e);
}
function bc() {
  const e = Ne("colors"), t = Ne("spacing"), r = Ne("blur"), n = Ne("brightness"), i = Ne("borderColor"), a = Ne("borderRadius"), o = Ne("borderSpacing"), s = Ne("borderWidth"), u = Ne("contrast"), l = Ne("grayscale"), c = Ne("hueRotate"), d = Ne("invert"), f = Ne("gap"), h = Ne("gradientColorStops"), p = Ne("gradientColorStopPositions"), v = Ne("inset"), g = Ne("margin"), $ = Ne("opacity"), m = Ne("padding"), b = Ne("saturate"), D = Ne("scale"), S = Ne("sepia"), T = Ne("skew"), R = Ne("space"), y = Ne("translate"), A = () => ["auto", "contain", "none"], w = () => ["auto", "hidden", "clip", "visible", "scroll"], E = () => ["auto", ve, t], k = () => [ve, t], C = () => ["", nr, Er], P = () => ["auto", rn, ve], L = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], O = () => ["solid", "dashed", "dotted", "double", "none"], x = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], U = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], K = () => ["", "0", ve], j = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], ae = () => [rn, lo], ne = () => [rn, ve];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Pi],
      spacing: [nr, Er],
      blur: ["none", "", wr, ve],
      brightness: ae(),
      borderColor: [e],
      borderRadius: ["none", "", "full", wr, ve],
      borderSpacing: k(),
      borderWidth: C(),
      contrast: ae(),
      grayscale: K(),
      hueRotate: ne(),
      invert: K(),
      gap: k(),
      gradientColorStops: [e],
      gradientColorStopPositions: [w8, Er],
      inset: E(),
      margin: E(),
      opacity: ae(),
      padding: k(),
      saturate: ae(),
      scale: ae(),
      sepia: K(),
      skew: ne(),
      space: k(),
      translate: k()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", ve]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [wr]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": j()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": j()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...L(), ve]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: w()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": w()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": w()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: A()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": A()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": A()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [v]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [v]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [v]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [v]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [v]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [v]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [v]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [v]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [v]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Ti, ve]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: E()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", ve]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: K()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: K()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Ti, ve]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Pi]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Ti, ve]
        }, ve]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": P()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": P()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Pi]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Ti, ve]
        }, ve]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": P()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": P()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", ve]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", ve]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [f]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [f]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [f]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...U()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...U(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...U(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [m]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [m]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [m]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [m]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [m]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [m]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [m]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [m]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [m]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [g]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [g]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [g]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [g]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [g]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [g]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [g]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [g]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [g]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [R]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [R]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ve, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [ve, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [ve, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [wr]
        }, wr]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [ve, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [ve, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [ve, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [ve, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", wr, Er]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", lo]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Pi]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ve]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", rn, lo]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", nr, ve]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ve]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", ve]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [$]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [$]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...O(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", nr, Er]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", nr, ve]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: k()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ve]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ve]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [$]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...L(), k8]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", S8]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, P8]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [p]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [p]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [p]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [h]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [a]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [a]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [a]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [a]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [a]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [a]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [a]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [a]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [a]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [a]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [a]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [a]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [a]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [a]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [a]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [s]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [s]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [s]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [s]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [s]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [s]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [s]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [s]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [s]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [$]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...O(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [s]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [s]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [$]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: O()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...O()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [nr, ve]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [nr, Er]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: C()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [$]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [nr, Er]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", wr, A8]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Pi]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [$]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...x(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": x()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [u]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", wr, ve]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [l]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [c]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [b]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [S]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [u]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [l]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [c]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [$]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [b]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [S]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [o]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [o]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [o]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ve]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: ne()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", ve]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: ne()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", ve]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [D]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [D]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [D]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Ti, ve]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [y]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [y]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [T]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [T]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ve]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ve]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": k()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": k()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": k()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": k()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": k()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": k()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": k()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": k()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": k()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": k()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": k()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": k()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": k()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": k()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": k()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": k()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": k()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": k()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ve]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [nr, Er, lo]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
function I8(e, {
  cacheSize: t,
  prefix: r,
  separator: n,
  extend: i = {},
  override: a = {}
}) {
  ko(e, "cacheSize", t), ko(e, "prefix", r), ko(e, "separator", n);
  for (const o in a)
    R8(e[o], a[o]);
  for (const o in i)
    B8(e[o], i[o]);
  return e;
}
function ko(e, t, r) {
  r !== void 0 && (e[t] = r);
}
function R8(e, t) {
  if (t)
    for (const r in t)
      ko(e, r, t[r]);
}
function B8(e, t) {
  if (t)
    for (const r in t) {
      const n = t[r];
      n !== void 0 && (e[r] = (e[r] || []).concat(n));
    }
}
function M8(e, ...t) {
  return typeof e == "function" ? gc(bc, e, ...t) : gc(() => I8(bc(), e), ...t);
}
const bn = /* @__PURE__ */ gc(bc);
var N8 = { twMerge: !0, twMergeConfig: {}, responsiveVariants: !1 }, u$ = (e) => e || void 0, xa = (...e) => u$(e$(e).filter(Boolean).join(" ")), tl = null, ar = {}, $c = !1, Ai = (...e) => (t) => t.twMerge ? ((!tl || $c) && ($c = !1, tl = vt(ar) ? bn : M8({ ...ar, extend: { theme: ar.theme, classGroups: ar.classGroups, conflictingClassGroupModifiers: ar.conflictingClassGroupModifiers, conflictingClassGroups: ar.conflictingClassGroups, ...ar.extend } })), u$(tl(xa(e)))) : xa(e), Tp = (e, t) => {
  for (let r in t) e.hasOwnProperty(r) ? e[r] = xa(e[r], t[r]) : e[r] = t[r];
  return e;
}, Kt = (e, t) => {
  let { extend: r = null, slots: n = {}, variants: i = {}, compoundVariants: a = [], compoundSlots: o = [], defaultVariants: s = {} } = e, u = { ...N8, ...t }, l = r != null && r.base ? xa(r.base, e == null ? void 0 : e.base) : e == null ? void 0 : e.base, c = r != null && r.variants && !vt(r.variants) ? r$(i, r.variants) : i, d = r != null && r.defaultVariants && !vt(r.defaultVariants) ? { ...r.defaultVariants, ...s } : s;
  !vt(u.twMergeConfig) && !i8(u.twMergeConfig, ar) && ($c = !0, ar = u.twMergeConfig);
  let f = vt(r == null ? void 0 : r.slots), h = vt(n) ? {} : { base: xa(e == null ? void 0 : e.base, f && (r == null ? void 0 : r.base)), ...n }, p = f ? h : Tp({ ...r == null ? void 0 : r.slots }, vt(h) ? { base: e == null ? void 0 : e.base } : h), v = vt(r == null ? void 0 : r.compoundVariants) ? a : t$(r == null ? void 0 : r.compoundVariants, a), g = (m) => {
    if (vt(c) && vt(n) && f) return Ai(l, m == null ? void 0 : m.class, m == null ? void 0 : m.className)(u);
    if (v && !Array.isArray(v)) throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof v}`);
    if (o && !Array.isArray(o)) throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof o}`);
    let b = (k, C, P = [], L) => {
      let O = P;
      if (typeof C == "string") O = O.concat(Cp(C).split(" ").map((x) => `${k}:${x}`));
      else if (Array.isArray(C)) O = O.concat(C.reduce((x, U) => x.concat(`${k}:${U}`), []));
      else if (typeof C == "object" && typeof L == "string") {
        for (let x in C) if (C.hasOwnProperty(x) && x === L) {
          let U = C[x];
          if (U && typeof U == "string") {
            let K = Cp(U);
            O[L] ? O[L] = O[L].concat(K.split(" ").map((j) => `${k}:${j}`)) : O[L] = K.split(" ").map((j) => `${k}:${j}`);
          } else Array.isArray(U) && U.length > 0 && (O[L] = U.reduce((K, j) => K.concat(`${k}:${j}`), []));
        }
      }
      return O;
    }, D = (k, C = c, P = null, L = null) => {
      var O;
      let x = C[k];
      if (!x || vt(x)) return null;
      let U = (O = L == null ? void 0 : L[k]) != null ? O : m == null ? void 0 : m[k];
      if (U === null) return null;
      let K = wp(U), j = Array.isArray(u.responsiveVariants) && u.responsiveVariants.length > 0 || u.responsiveVariants === !0, ae = d == null ? void 0 : d[k], ne = [];
      if (typeof K == "object" && j) for (let [_e, Fe] of Object.entries(K)) {
        let V = x[Fe];
        if (_e === "initial") {
          ae = Fe;
          continue;
        }
        Array.isArray(u.responsiveVariants) && !u.responsiveVariants.includes(_e) || (ne = b(_e, V, ne, P));
      }
      let me = K != null && typeof K != "object" ? K : wp(ae), $e = x[me || "false"];
      return typeof ne == "object" && typeof P == "string" && ne[P] ? Tp(ne, $e) : ne.length > 0 ? (ne.push($e), ne) : $e;
    }, S = () => c ? Object.keys(c).map((k) => D(k, c)) : null, T = (k, C) => {
      if (!c || typeof c != "object") return null;
      let P = new Array();
      for (let L in c) {
        let O = D(L, c, k, C), x = k === "base" && typeof O == "string" ? O : O && O[k];
        x && (P[P.length] = x);
      }
      return P;
    }, R = {};
    for (let k in m) m[k] !== void 0 && (R[k] = m[k]);
    let y = (k, C) => {
      var P;
      let L = typeof (m == null ? void 0 : m[k]) == "object" ? { [k]: (P = m[k]) == null ? void 0 : P.initial } : {};
      return { ...d, ...R, ...L, ...C };
    }, A = (k = [], C) => {
      let P = [];
      for (let { class: L, className: O, ...x } of k) {
        let U = !0;
        for (let [K, j] of Object.entries(x)) {
          let ae = y(K, C);
          if (Array.isArray(j)) {
            if (!j.includes(ae[K])) {
              U = !1;
              break;
            }
          } else if (ae[K] !== j) {
            U = !1;
            break;
          }
        }
        U && (L && P.push(L), O && P.push(O));
      }
      return P;
    }, w = (k) => {
      let C = A(v, k);
      if (!Array.isArray(C)) return C;
      let P = {};
      for (let L of C) if (typeof L == "string" && (P.base = Ai(P.base, L)(u)), typeof L == "object") for (let [O, x] of Object.entries(L)) P[O] = Ai(P[O], x)(u);
      return P;
    }, E = (k) => {
      if (o.length < 1) return null;
      let C = {};
      for (let { slots: P = [], class: L, className: O, ...x } of o) {
        if (!vt(x)) {
          let U = !0;
          for (let K of Object.keys(x)) {
            let j = y(K, k)[K];
            if (j === void 0 || (Array.isArray(x[K]) ? !x[K].includes(j) : x[K] !== j)) {
              U = !1;
              break;
            }
          }
          if (!U) continue;
        }
        for (let U of P) C[U] = C[U] || [], C[U].push([L, O]);
      }
      return C;
    };
    if (!vt(n) || !f) {
      let k = {};
      if (typeof p == "object" && !vt(p)) for (let C of Object.keys(p)) k[C] = (P) => {
        var L, O;
        return Ai(p[C], T(C, P), ((L = w(P)) != null ? L : [])[C], ((O = E(P)) != null ? O : [])[C], P == null ? void 0 : P.class, P == null ? void 0 : P.className)(u);
      };
      return k;
    }
    return Ai(l, S(), A(v), m == null ? void 0 : m.class, m == null ? void 0 : m.className)(u);
  }, $ = () => {
    if (!(!c || typeof c != "object")) return Object.keys(c);
  };
  return g.variantKeys = $(), g.extend = r, g.base = l, g.slots = p, g.variants = c, g.defaultVariants = d, g.compoundSlots = o, g.compoundVariants = v, g;
};
const vi = Kt({
  base: "outline outline-spillover-600 dark:outline-spillover-500 forced-colors:outline-[Highlight] outline-offset-2",
  variants: {
    isFocusVisible: {
      false: "outline-0",
      true: "outline-2"
    }
  }
});
function Va(e, t) {
  return Ra(e, (r) => bn(t, r));
}
const L8 = Kt({
  extend: vi,
  base: "flex flex-row items-center justify-center gap-1.5 h-10 px-3 text-sm shadow-md pressed:shadow-none transition rounded-md cursor-pointer",
  variants: {
    variant: {
      primary: "bg-spillover-700 hover:bg-spillover-500 pressed:bg-spillover-400 text-white",
      secondary: "bg-gray-100 hover:bg-gray-200 pressed:bg-gray-300 text-gray-800 dark:bg-zinc-600 dark:hover:bg-zinc-500 dark:pressed:bg-zinc-400 dark:text-zinc-100",
      destructive: "bg-orange-700 hover:bg-orange-800 pressed:bg-orange-900 text-white",
      icon: "text-gray-500 p-0 shadow-none"
    },
    isDisabled: {
      true: "bg-gray-100 dark:bg-zinc-800 text-gray-300 dark:text-zinc-600 forced-colors:text-[GrayText] border-black/5 dark:border-white/5 cursor-not-allowed"
    },
    isLoading: {
      true: "cursor-wait"
    },
    reverse: {
      true: "flex-row-reverse"
    },
    circle: {
      true: "rounded-full w-10 h-10"
    }
  },
  defaultVariants: {
    variant: "primary"
  }
});
function Xt({
  Icon: e,
  isLoading: t,
  reverse: r,
  circle: n,
  children: i,
  ...a
}) {
  return /* @__PURE__ */ Se(
    f3,
    {
      ...a,
      className: Ra(
        a.className,
        (o, s) => L8({
          ...s,
          variant: a.variant,
          reverse: r,
          circle: n,
          isLoading: t,
          className: o
        })
      ),
      children: [
        e && (t ? /* @__PURE__ */ N(Cv, { size: 20, className: "animate-spin" }) : /* @__PURE__ */ N(e, { size: 20 })),
        i
      ]
    }
  );
}
function Ud({ option: e, type: t, onClick: r }) {
  const n = () => {
    r && r(e, t);
  };
  return /* @__PURE__ */ N(
    "div",
    {
      className: `p-3 bg-gray-100 rounded-md text-gray-600 hover:bg-gray-200 transition duration-200 text-sm ${r && "cursor-pointer"} whitespace-pre-line`,
      onClick: n,
      children: e
    }
  );
}
const V8 = Wv({
  context: Hv().min(5, "Please provide some more context")
});
function j8({ onOptionSelected: e }) {
  const [t, { generatedOptions: r, loading: n }] = od(), {
    register: i,
    handleSubmit: a,
    formState: { errors: o }
  } = Nv({ resolver: Vv(V8) }), s = ({ context: l }) => t("text", l, { n: 3 }), u = r || [];
  return /* @__PURE__ */ Se(
    "form",
    {
      onSubmit: a(s),
      className: "flex flex-col gap-4 py-2 px-4 w-full box-border",
      children: [
        /* @__PURE__ */ Se("div", { className: "w-full flex flex-col gap-1", children: [
          /* @__PURE__ */ N("label", { className: "text-sm text-gray-700", children: "Give us some context..." }),
          /* @__PURE__ */ N("div", { className: "w-full flex flex-col gap-4", children: /* @__PURE__ */ N(
            "textarea",
            {
              className: "box-border w-full h-20 border border-gray-300 rounded-md p-2",
              ...i("context"),
              autoFocus: !0
            }
          ) }),
          o.context && /* @__PURE__ */ N("div", { className: "text-red-500 text-sm", children: o.context.message })
        ] }),
        /* @__PURE__ */ N(
          Xt,
          {
            isDisabled: n,
            isLoading: n,
            Icon: Ps,
            onPress: a(s),
            children: "Generate Text"
          }
        ),
        u.length > 0 && /* @__PURE__ */ Se("div", { className: "w-full flex flex-col gap-4 mt-4", children: [
          /* @__PURE__ */ N("div", { className: "text-gray-700", children: "Pick an option or try again for new options" }),
          u.map((l, c) => /* @__PURE__ */ N(
            Ud,
            {
              option: l,
              type: "text",
              onClick: e
            },
            c
          ))
        ] })
      ]
    }
  );
}
const z8 = Wv({
  context: Hv().min(5, "Please provide some more context")
});
function K8({ onOptionSelected: e }) {
  const [t, { generatedOptions: r, loading: n }] = od(), {
    register: i,
    handleSubmit: a,
    formState: { errors: o }
  } = Nv({ resolver: Vv(z8) }), s = ({ context: l }) => t("post_caption", l, { n: 3 }), u = r || [];
  return /* @__PURE__ */ Se(
    "form",
    {
      onSubmit: a(s),
      className: "flex flex-col gap-4 py-2 px-4 w-full box-border",
      children: [
        /* @__PURE__ */ Se("div", { className: "w-full flex flex-col gap-1", children: [
          /* @__PURE__ */ N("label", { className: "text-sm text-gray-700", children: "Give us some context..." }),
          /* @__PURE__ */ N("div", { className: "w-full flex flex-col gap-4", children: /* @__PURE__ */ N(
            "textarea",
            {
              className: "box-border w-full h-20 border border-gray-300 rounded-md p-2",
              ...i("context"),
              autoFocus: !0
            }
          ) }),
          o.context && /* @__PURE__ */ N("div", { className: "text-red-500 text-sm", children: o.context.message })
        ] }),
        /* @__PURE__ */ N(
          Xt,
          {
            isLoading: n,
            isDisabled: n,
            Icon: Ps,
            onPress: a(s),
            children: "Generate Caption"
          }
        ),
        u.length > 0 && /* @__PURE__ */ Se("div", { className: "w-full flex flex-col gap-4 mt-4", children: [
          /* @__PURE__ */ N("div", { className: "text-gray-700", children: "Pick an option or try again for new options" }),
          u.map((l, c) => /* @__PURE__ */ N(
            Ud,
            {
              option: l,
              type: "post_caption",
              onClick: e
            },
            c
          ))
        ] })
      ]
    }
  );
}
function Ut({
  type: e,
  text: t,
  onOptionSelected: r,
  loadingMsg: n,
  children: i,
  autoRun: a = !0,
  retry: o = !0,
  n: s = 1
}) {
  const [u, { generatedOptions: l, loading: c }] = od(), d = () => {
    t && t.trim().length > 0 && u(e, t, { n: s });
  };
  return ue(() => {
    a && d();
  }, []), /* @__PURE__ */ Se("div", { className: "w-full flex flex-col gap-4 py-2 px-4 box-border", children: [
    i,
    c ? /* @__PURE__ */ Se("div", { className: "text-gray-700 flex flex-row items-center gap-2", children: [
      /* @__PURE__ */ N(EE, { className: "animate-spin" }),
      n || "Loading..."
    ] }) : o && /* @__PURE__ */ N(Xt, { variant: "secondary", Icon: wE, onPress: d, children: "Retry" }),
    l == null ? void 0 : l.map((f, h) => /* @__PURE__ */ N(
      Ud,
      {
        type: e,
        option: f,
        onClick: r
      },
      h
    ))
  ] });
}
function U8({ message: e }) {
  return /* @__PURE__ */ N(
    Ut,
    {
      type: "translate",
      text: e,
      loadingMsg: "Translating...",
      retry: !1
    }
  );
}
function q8({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ N(
    Ut,
    {
      type: "spellcheck",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Checking spelling..."
    }
  );
}
function H8({ message: e }) {
  return /* @__PURE__ */ N(
    Ut,
    {
      type: "summarize",
      text: e,
      loadingMsg: "Summarizing...",
      retry: !1
    }
  );
}
function W8({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ N(
    Ut,
    {
      type: "improve_writing",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Improving writing..."
    }
  );
}
function Q8({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ N(
    Ut,
    {
      type: "make_longer",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Making text longer..."
    }
  );
}
function G8({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ N(
    Ut,
    {
      type: "make_shorter",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Making text shorter..."
    }
  );
}
function Z8({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ N(
    Ut,
    {
      type: "make_more_formal",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Making more formal..."
    }
  );
}
function Y8({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ N(
    Ut,
    {
      type: "make_more_casual",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Making more casual..."
    }
  );
}
function J8({ text: e, onOptionSelected: t }) {
  return /* @__PURE__ */ N(
    Ut,
    {
      type: "continue_writing",
      text: e,
      onOptionSelected: (n, i) => {
        t(`${e} ${n}`, i);
      },
      loadingMsg: "Continuing your text..."
    }
  );
}
function X8({ message: e, onOptionSelected: t }) {
  return /* @__PURE__ */ N(
    Ut,
    {
      type: "review_reply",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Generating reply...",
      n: 3
    }
  );
}
function eT({ message: e, onOptionSelected: t }) {
  return /* @__PURE__ */ N(
    Ut,
    {
      type: "comment_reply",
      text: e,
      onOptionSelected: t,
      loadingMsg: "Generating reply...",
      n: 3
    }
  );
}
const l$ = [
  {
    name: "GenerateText",
    title: "Generate Text",
    Icon: ih,
    component: j8
  },
  {
    name: "GenerateCaption",
    title: "Generate Caption",
    Icon: ih,
    component: K8
  },
  {
    name: "GenerateReviewReply",
    title: "Generate Reply",
    Icon: TE,
    component: X8
  },
  {
    name: "GenerateCommentReply",
    title: "Generate Reply",
    Icon: CE,
    component: eT
  },
  {
    name: "Translate",
    title: "Translate",
    Icon: xE,
    component: U8
  },
  {
    name: "SpellCheck",
    title: "Fix Spelling & Grammar",
    Icon: kE,
    component: q8
  },
  {
    name: "Summarize",
    title: "Summarize",
    Icon: DE,
    component: H8
  },
  {
    name: "ImproveWriting",
    title: "Improve Writing",
    Icon: bE,
    component: W8
  },
  {
    name: "MakeLonger",
    title: "Make Longer",
    Icon: yE,
    component: Q8
  },
  {
    name: "MakeShorter",
    title: "Make Shorter",
    Icon: vE,
    component: G8
  },
  {
    name: "MakeMoreFormal",
    title: "Make More Formal",
    Icon: hE,
    component: Z8
  },
  {
    name: "MakeMoreCasual",
    title: "Make More Casual",
    Icon: SE,
    component: Y8
  },
  {
    name: "ContinueWriting",
    title: "Continue Writing",
    Icon: gE,
    component: J8
  }
], tT = l$.map((e) => e.name);
function rT({
  message: e,
  text: t,
  onOptionSelected: r,
  onCloseButtonClick: n,
  tools: i
}) {
  i ?? (i = tT);
  const a = l$.filter((o) => i.includes(o.name)).map(
    (o) => /* @__PURE__ */ N(Tv, { title: o.title, Icon: o.Icon, children: /* @__PURE__ */ N(
      o.component,
      {
        message: e,
        text: t,
        onOptionSelected: r
      }
    ) }, o.name)
  );
  return /* @__PURE__ */ N(
    OE,
    {
      title: "AI Helpers",
      Icon: Ps,
      onCloseButtonClick: n,
      children: a
    }
  );
}
function c$(e) {
  return /* @__PURE__ */ N(
    Mk,
    {
      ...e,
      className: bn(
        "outline outline-0 p-4 [[data-placement]>&]:p-4 max-h-[inherit] overflow-auto relative",
        e.className
      )
    }
  );
}
const nT = Kt({
  base: "bg-white dark:bg-zinc-900/70 dark:backdrop-blur-2xl dark:backdrop-saturate-200 forced-colors:bg-[Canvas] shadow-md rounded-md bg-clip-padding border border-black/10 dark:border-white/[15%] text-slate-700 dark:text-zinc-300",
  variants: {
    isEntering: {
      true: "animate-in fade-in placement-bottom:slide-in-from-top-1 placement-top:slide-in-from-bottom-1 placement-left:slide-in-from-right-1 placement-right:slide-in-from-left-1 ease-out duration-200"
    },
    isExiting: {
      true: "animate-out fade-out placement-bottom:slide-out-to-top-1 placement-top:slide-out-to-bottom-1 placement-left:slide-out-to-right-1 placement-right:slide-out-to-left-1 ease-in duration-150"
    }
  }
});
function eu({ children: e, showArrow: t, className: r, ...n }) {
  const i = di(hi), a = (i == null ? void 0 : i.trigger) === "SubmenuTrigger";
  let o = t ? 12 : 8;
  return o = a ? o - 6 : o, /* @__PURE__ */ Se(
    Ok,
    {
      UNSTABLE_portalContainer: document.getElementById("sfs-portal"),
      offset: o,
      ...n,
      className: Ra(
        r,
        (s, u) => nT({ ...u, className: s })
      ),
      children: [
        t && /* @__PURE__ */ N(_k, { className: "group", children: /* @__PURE__ */ N(
          "svg",
          {
            width: 12,
            height: 12,
            viewBox: "0 0 12 12",
            className: "block fill-white dark:fill-[#1f1f21] forced-colors:fill-[Canvas] stroke-1 stroke-black/10 dark:stroke-zinc-600 forced-colors:stroke-[ButtonBorder] group-placement-bottom:rotate-180 group-placement-left:-rotate-90 group-placement-right:rotate-90",
            children: /* @__PURE__ */ N("path", { d: "M0 0 L6 6 L12 0" })
          }
        ) }),
        e
      ]
    }
  );
}
function OT({
  message: e,
  text: t,
  onOptionSelected: r,
  className: n,
  children: i,
  tools: a
}) {
  return /* @__PURE__ */ Se(Rk, { children: [
    /* @__PURE__ */ N(
      Xt,
      {
        circle: !0,
        Icon: Ps,
        "aria-label": "AI Text Helpers",
        className: n,
        children: i
      }
    ),
    /* @__PURE__ */ N(
      eu,
      {
        showArrow: !0,
        shouldCloseOnInteractOutside: () => !1,
        className: "w-[340px]",
        children: /* @__PURE__ */ N(
          c$,
          {
            className: "p-0 [[data-placement]>&]:p-0",
            "aria-label": "AI Text Helpers",
            children: ({ close: o }) => /* @__PURE__ */ N(
              rT,
              {
                tools: a,
                message: e,
                text: t,
                onOptionSelected: r,
                onCloseButtonClick: o
              }
            )
          }
        )
      }
    )
  ] });
}
const Pp = [
  "Loading, please wait...",
  "Still loading...",
  "Almost there...",
  "This is taking longer than expected..."
];
function iT({ msgInterval: e = 5e3, ...t }) {
  const [r, n] = re(0);
  ue(() => {
    const a = setInterval(() => {
      n((o) => o < Pp.length - 1 ? o + 1 : (clearInterval(a), o));
    }, e);
    return () => clearInterval(a);
  }, [e]);
  const i = Pp[r];
  return /* @__PURE__ */ Se("div", { className: "flex flex-col gap-4 items-center justify-center w-full h-full", children: [
    /* @__PURE__ */ N(
      Cv,
      {
        size: 46,
        ...t,
        className: bn("animate-spin text-spillover-700", t.className)
      }
    ),
    /* @__PURE__ */ N("p", { className: "text-slate-400 animate-pulse", children: i })
  ] });
}
function qd(e) {
  return /* @__PURE__ */ N(
    ck,
    {
      ...e,
      className: bn(
        "text-sm text-gray-500 dark:text-zinc-400 font-medium cursor-default w-fit",
        e.className
      )
    }
  );
}
function Hd(e) {
  return /* @__PURE__ */ N(
    Bd,
    {
      ...e,
      slot: "description",
      className: bn("text-sm text-gray-600", e.className)
    }
  );
}
function Wd(e) {
  return /* @__PURE__ */ N(
    sk,
    {
      ...e,
      className: Va(
        e.className,
        "text-sm text-red-600 forced-colors:text-[Mark]"
      )
    }
  );
}
const aT = Kt({
  variants: {
    isFocusWithin: {
      false: "border-gray-300 dark:border-zinc-500 forced-colors:border-[ButtonBorder]",
      true: "border-gray-600 dark:border-zinc-300 forced-colors:border-[Highlight]"
    },
    isInvalid: {
      true: "border-red-600 dark:border-red-600 forced-colors:border-[Mark]"
    },
    isDisabled: {
      true: "border-gray-200 dark:border-zinc-700 forced-colors:border-[GrayText]"
    }
  }
}), d$ = Kt({
  extend: vi,
  base: "group flex gap-1 pr-1.5 items-center h-10 shadow-sm bg-white dark:bg-zinc-900 forced-colors:bg-[Field] border rounded-lg overflow-hidden",
  variants: aT.variants
});
function f$(e) {
  return /* @__PURE__ */ N(
    W1,
    {
      ...e,
      className: Ra(
        e.className,
        (t, r) => d$({ ...r, className: t })
      )
    }
  );
}
function oT(e) {
  return /* @__PURE__ */ N(
    o1,
    {
      ...e,
      className: Va(
        e.className,
        "px-2 py-1.5 flex-1 min-w-0 outline outline-0 bg-white dark:bg-zinc-900 text-sm text-gray-800 dark:text-zinc-200 disabled:text-gray-200 dark:disabled:text-zinc-600"
      )
    }
  );
}
Kt({
  extend: vi,
  base: "group relative flex items-center gap-8 cursor-default select-none py-1.5 px-2.5 rounded-md will-change-transform text-sm forced-color-adjust-none",
  variants: {
    isSelected: {
      false: "text-slate-700 dark:text-zinc-300 hover:bg-slate-200 dark:hover:bg-zinc-700 -outline-offset-2",
      true: "bg-spillover-600 text-white forced-colors:bg-[Highlight] forced-colors:text-[HighlightText] [&:has(+[data-selected])]:rounded-b-none [&+[data-selected]]:rounded-t-none -outline-offset-4 outline-white dark:outline-white forced-colors:outline-[HighlightText]"
    },
    isDisabled: {
      true: "text-slate-300 dark:text-zinc-600 forced-colors:text-[GrayText]"
    }
  }
});
const sT = Kt({
  base: "group flex items-center gap-4 cursor-default select-none py-2 pl-3 pr-1 rounded-md outline outline-0 text-sm forced-color-adjust-none",
  variants: {
    isDisabled: {
      false: "text-gray-900 dark:text-zinc-100",
      true: "text-gray-300 dark:text-zinc-600 forced-colors:text-[GrayText]"
    },
    isFocused: {
      true: "bg-spillover-600 text-white forced-colors:bg-[Highlight] forced-colors:text-[HighlightText]"
    }
  },
  compoundVariants: [
    {
      isFocused: !1,
      isOpen: !0,
      className: "bg-gray-100 dark:bg-zinc-700/60"
    }
  ]
});
function h$(e) {
  const t = e.textValue || (typeof e.children == "string" ? e.children : void 0);
  return /* @__PURE__ */ N(
    Ck,
    {
      ...e,
      textValue: t,
      className: sT,
      children: Ra(e.children, (r, { isSelected: n }) => /* @__PURE__ */ Se(_p, { children: [
        /* @__PURE__ */ N("span", { className: "flex items-center flex-1 gap-2 font-normal truncate group-selected:font-semibold", children: r }),
        /* @__PURE__ */ N("span", { className: "flex items-center w-5", children: n && /* @__PURE__ */ N(mE, { className: "w-4 h-4" }) })
      ] }))
    }
  );
}
function uT() {
  const e = ce(G1);
  return (e == null ? void 0 : e.selectedKey) && /* @__PURE__ */ N(
    Xt,
    {
      variant: "icon",
      Icon: (t) => /* @__PURE__ */ N(Sv, { ...t, size: 16 }),
      onPress: () => e == null ? void 0 : e.setSelectedKey(null)
    }
  );
}
function p$({
  label: e,
  description: t,
  isClearable: r,
  errorMessage: n,
  children: i,
  items: a,
  ...o
}) {
  return /* @__PURE__ */ Se(
    jk,
    {
      ...o,
      className: Va(
        o.className,
        "group flex flex-col gap-1"
      ),
      children: [
        e && /* @__PURE__ */ N(qd, { children: e }),
        /* @__PURE__ */ Se(f$, { children: [
          /* @__PURE__ */ N(oT, {}),
          r && /* @__PURE__ */ N(uT, {}),
          /* @__PURE__ */ N(Xt, { variant: "icon", Icon: wv })
        ] }),
        t && /* @__PURE__ */ N(Hd, { children: t }),
        /* @__PURE__ */ N(Wd, { children: n }),
        /* @__PURE__ */ N(eu, { className: "w-[--trigger-width]", children: /* @__PURE__ */ N(
          U1,
          {
            items: a,
            className: "outline-0 p-1 max-h-[inherit] overflow-auto [clip-path:inset(0_0_0_0_round_.75rem)]",
            children: i
          }
        ) })
      ]
    }
  );
}
function m$(e) {
  return /* @__PURE__ */ N(h$, { ...e });
}
const lT = Vr`
  query ListBusinesses {
    allowedBusinesses {
      id
      name
      senalysisId
      locations {
        id
        name
      }
    }
  }
`;
function cT({ defaultBusinessId: e = null } = {}) {
  const [t, r] = re(e), { data: n } = xv(lT), i = (n == null ? void 0 : n.allowedBusinesses) || [], a = i.find((o) => o.id === t);
  return ue(() => {
    !t && i.length && r(i[0].id);
  }, [i, t]), {
    business: a,
    businessSelectProps: {
      businesses: i,
      selectedId: t,
      onSelectionChange: r
    }
  };
}
function dT({
  businesses: e = [],
  selectedId: t = null,
  onSelectionChange: r
}) {
  return /* @__PURE__ */ N(
    p$,
    {
      placeholder: "Select a business",
      items: e,
      selectedKey: t,
      onSelectionChange: r,
      children: (n) => /* @__PURE__ */ N(m$, { children: n.name })
    }
  );
}
function fT({ locations: e = [] }) {
  const [t, r] = re(null), n = e.find((i) => i.id === t);
  return ue(() => {
    n || r(null);
  }, [n]), {
    location: n,
    locationSelectProps: {
      locations: e,
      selectedId: t,
      onSelectionChange: r
    }
  };
}
function hT({
  locations: e = [],
  selectedId: t = null,
  onSelectionChange: r,
  ...n
}) {
  return /* @__PURE__ */ N(
    p$,
    {
      placeholder: "Select a location",
      items: e,
      selectedKey: t,
      onSelectionChange: r,
      ...n,
      children: (i) => /* @__PURE__ */ N(m$, { children: i.name })
    }
  );
}
function pT({ title: e, subtitle: t, children: r, ...n }) {
  return /* @__PURE__ */ Se(
    "section",
    {
      ...n,
      className: bn(
        "border border-gray-300 rounded-2xl bg-white",
        n.className
      ),
      children: [
        /* @__PURE__ */ Se("header", { className: "flex items-center gap-2 px-5 py-2 pb-1 border-b border-gray-300 text-spillover-900", children: [
          /* @__PURE__ */ N("h2", { className: "text-lg font-semibold uppercase", children: e }),
          t && /* @__PURE__ */ N("p", { className: "text-xs lowercase", children: t })
        ] }),
        r
      ]
    }
  );
}
const mT = Kt({
  base: "inline p-0.5 type-literal:px-0 rounded outline outline-0 forced-color-adjust-none caret-transparent text-gray-800 dark:text-zinc-200 forced-colors:text-[ButtonText]",
  variants: {
    isPlaceholder: {
      true: "text-gray-600 dark:text-zinc-400 italic"
    },
    isDisabled: {
      true: "text-gray-200 dark:text-zinc-600 forced-colors:text-[GrayText]"
    },
    isFocused: {
      true: "bg-spillover-600 text-white dark:text-white forced-colors:bg-[Highlight] forced-colors:text-[HighlightText]"
    }
  }
});
function Ap(e) {
  return /* @__PURE__ */ N(
    Uk,
    {
      className: (t) => d$({
        ...t,
        class: "block min-w-[150px] px-2 py-1.5 text-sm"
      }),
      ...e,
      children: (t) => /* @__PURE__ */ N(Hk, { segment: t, className: mT })
    }
  );
}
Kt({
  extend: vi,
  base: "w-9 h-9 text-sm cursor-default rounded-full flex items-center justify-center forced-color-adjust-none",
  variants: {
    isSelected: {
      false: "text-zinc-900 dark:text-zinc-200 hover:bg-gray-100 dark:hover:bg-zinc-700 pressed:bg-gray-200 dark:pressed:bg-zinc-600",
      true: "bg-spillover-600 invalid:bg-red-600 text-white forced-colors:bg-[Highlight] forced-colors:invalid:bg-[Mark] forced-colors:text-[HighlightText]"
    },
    isDisabled: {
      true: "text-gray-300 dark:text-zinc-600 forced-colors:text-[GrayText]"
    }
  }
});
function vT() {
  const e = lt();
  return /* @__PURE__ */ Se("header", { className: "flex items-center gap-1 pb-4 px-1 w-full", children: [
    /* @__PURE__ */ N(Xt, { variant: "icon", slot: "previous", children: e === "rtl" ? /* @__PURE__ */ N(nh, { "aria-hidden": !0 }) : /* @__PURE__ */ N(Al, { "aria-hidden": !0 }) }),
    /* @__PURE__ */ N(Jk, { className: "flex-1 font-semibold text-xl text-center mx-2 text-zinc-900 dark:text-zinc-200" }),
    /* @__PURE__ */ N(Xt, { variant: "icon", slot: "next", children: e === "rtl" ? /* @__PURE__ */ N(Al, { "aria-hidden": !0 }) : /* @__PURE__ */ N(nh, { "aria-hidden": !0 }) })
  ] });
}
function yT() {
  return /* @__PURE__ */ N(n1, { children: (e) => /* @__PURE__ */ N(i1, { className: "text-xs text-gray-500 font-semibold", children: e }) });
}
const gT = Kt({
  extend: vi,
  base: "w-full h-full flex items-center justify-center rounded-full forced-color-adjust-none text-zinc-900 dark:text-zinc-200",
  variants: {
    selectionState: {
      none: "group-hover:bg-gray-100 dark:group-hover:bg-zinc-700 group-pressed:bg-gray-200 dark:group-pressed:bg-zinc-600",
      middle: [
        "group-hover:bg-spillover-200 dark:group-hover:bg-spillover-900 forced-colors:group-hover:bg-[Highlight]",
        "group-invalid:group-hover:bg-red-200 dark:group-invalid:group-hover:bg-red-900 forced-colors:group-invalid:group-hover:bg-[Mark] text-white",
        "group-pressed:bg-spillover-300 dark:group-pressed:bg-spillover-800 forced-colors:group-pressed:bg-[Highlight] forced-colors:text-[HighlightText]",
        "group-invalid:group-pressed:bg-red-300 dark:group-invalid:group-pressed:bg-red-800 forced-colors:group-invalid:group-pressed:bg-[Mark]"
      ],
      cap: "bg-spillover-600 group-invalid:bg-red-600 forced-colors:bg-[Highlight] forced-colors:group-invalid:bg-[Mark] text-white forced-colors:text-[HighlightText]"
    },
    isDisabled: {
      true: "text-gray-300 dark:text-zinc-600 forced-colors:text-[GrayText]"
    }
  }
});
function bT({ errorMessage: e, children: t, ...r }) {
  return /* @__PURE__ */ Se(J7, { ...r, children: [
    /* @__PURE__ */ N(vT, {}),
    t,
    /* @__PURE__ */ Se(ek, { className: "[&_td]:px-0", children: [
      /* @__PURE__ */ N(yT, {}),
      /* @__PURE__ */ N(a1, { children: (n) => /* @__PURE__ */ N(
        ak,
        {
          date: n,
          className: "group w-9 h-9 text-sm outline outline-0 cursor-default outside-month:text-gray-300 selected:bg-spillover-100 dark:selected:bg-spillover-700/30 forced-colors:selected:bg-[Highlight] invalid:selected:bg-red-100 dark:invalid:selected:bg-red-700/30 forced-colors:invalid:selected:bg-[Mark] [td:first-child_&]:rounded-s-full selection-start:rounded-s-full [td:last-child_&]:rounded-e-full selection-end:rounded-e-full",
          children: ({
            formattedDate: i,
            isSelected: a,
            isSelectionStart: o,
            isSelectionEnd: s,
            isFocusVisible: u,
            isDisabled: l
          }) => /* @__PURE__ */ N(
            "span",
            {
              className: gT({
                selectionState: a && (o || s) ? "cap" : a ? "middle" : "none",
                isDisabled: l,
                isFocusVisible: u
              }),
              children: i
            }
          )
        }
      ) })
    ] }),
    e && /* @__PURE__ */ N(Bd, { slot: "errorMessage", className: "text-sm text-red-600", children: e })
  ] });
}
function $T({
  label: e,
  description: t,
  errorMessage: r,
  children: n,
  ...i
}) {
  return /* @__PURE__ */ Se(
    Zk,
    {
      ...i,
      className: Va(
        i.className,
        "group flex flex-col gap-1"
      ),
      children: [
        e && /* @__PURE__ */ N(qd, { children: e }),
        /* @__PURE__ */ Se(f$, { className: "min-w-[208px] w-auto", children: [
          /* @__PURE__ */ N(Ap, { slot: "start", className: "px-2 py-1.5 text-sm" }),
          /* @__PURE__ */ N(
            "span",
            {
              "aria-hidden": "true",
              className: "text-gray-800 dark:text-zinc-200 forced-colors:text-[ButtonText] group-disabled:text-gray-200 group-disabled:dark:text-zinc-600 group-disabled:forced-colors:text-[GrayText]",
              children: "–"
            }
          ),
          /* @__PURE__ */ N(Ap, { slot: "end", className: "flex-1 px-2 py-1.5 text-sm" }),
          /* @__PURE__ */ N(Xt, { variant: "icon", Icon: pE })
        ] }),
        t && /* @__PURE__ */ N(Hd, { children: t }),
        /* @__PURE__ */ N(Wd, { children: r }),
        /* @__PURE__ */ N(eu, { children: /* @__PURE__ */ N(c$, { children: /* @__PURE__ */ N(bT, { children: n }) }) })
      ]
    }
  );
}
const xT = Kt({
  extend: vi,
  base: "flex items-center text-start gap-4 w-full cursor-default border border-black/10 dark:border-white/10 shadow-[inset_0_1px_0_0_rgba(255,255,255,0.1)] dark:shadow-none rounded-lg pl-3 pr-2 py-2 min-w-[150px] transition bg-gray-50 dark:bg-zinc-700",
  variants: {
    isDisabled: {
      false: "text-gray-800 dark:text-zinc-300 hover:bg-gray-100 pressed:bg-gray-200 dark:hover:bg-zinc-600 dark:pressed:bg-zinc-500 group-invalid:border-red-600 forced-colors:group-invalid:border-[Mark]",
      true: "text-gray-200 dark:text-zinc-600 forced-colors:text-[GrayText] dark:bg-zinc-800 dark:border-white/5 forced-colors:border-[GrayText]"
    }
  }
});
function DT({
  label: e,
  description: t,
  errorMessage: r,
  children: n,
  items: i,
  ...a
}) {
  return /* @__PURE__ */ Se(
    t8,
    {
      ...a,
      className: Va(
        a.className,
        "group flex flex-col gap-1"
      ),
      children: [
        e && /* @__PURE__ */ N(qd, { children: e }),
        /* @__PURE__ */ Se(f3, { className: xT, children: [
          /* @__PURE__ */ N(n8, { className: "flex-1 text-sm placeholder-shown:italic" }),
          /* @__PURE__ */ N(
            wv,
            {
              "aria-hidden": !0,
              className: "w-4 h-4 text-gray-600 dark:text-zinc-400 forced-colors:text-[ButtonText] group-disabled:text-gray-200 dark:group-disabled:text-zinc-600 forced-colors:group-disabled:text-[GrayText]"
            }
          )
        ] }),
        t && /* @__PURE__ */ N(Hd, { children: t }),
        /* @__PURE__ */ N(Wd, { children: r }),
        /* @__PURE__ */ N(eu, { className: "min-w-[--trigger-width]", children: /* @__PURE__ */ N(
          U1,
          {
            items: i,
            className: "outline-none p-1 max-h-[inherit] overflow-auto [clip-path:inset(0_0_0_0_round_.75rem)]",
            children: n
          }
        ) })
      ]
    }
  );
}
function ET(e) {
  return /* @__PURE__ */ N(h$, { ...e });
}
const v$ = [
  { id: "custom", name: "Custom" },
  { id: "today", name: "Today" },
  { id: "thisWeek", name: "This Week" },
  { id: "thisMonth", name: "This Month" },
  { id: "thisYear", name: "This Year" },
  { id: "yesterday", name: "Yesterday" },
  { id: "previousWeek", name: "Previous Week" },
  { id: "previousMonth", name: "Previous Month" },
  { id: "previousYear", name: "Previous Year" },
  { id: "last7Days", name: "Last 7 Days" },
  { id: "last30Days", name: "Last 30 Days" },
  { id: "last90Days", name: "Last 90 Days" },
  { id: "last6Months", name: "Last 6 Months" },
  { id: "last12Months", name: "Last 12 Months" }
];
function wT(e, t) {
  switch (e) {
    case "custom":
      return null;
    case "today":
      return { start: t, end: t };
    case "thisWeek":
      return {
        start: hn(t, "en-US"),
        end: t
      };
    case "thisMonth":
      return {
        start: br(t),
        end: t
      };
    case "thisYear":
      return {
        start: Gl(t),
        end: t
      };
    case "yesterday": {
      const r = t.subtract({ days: 1 });
      return {
        start: r,
        end: r
      };
    }
    case "previousWeek": {
      const r = hn(
        t.subtract({ weeks: 1 }),
        "en-US"
      );
      return {
        start: r,
        end: Dy(r, "en-US")
      };
    }
    case "previousMonth": {
      const r = br(
        t.subtract({ months: 1 })
      );
      return {
        start: r,
        end: oi(r)
      };
    }
    case "previousYear": {
      const r = Gl(t.subtract({ years: 1 }));
      return {
        start: r,
        end: Y6(r)
      };
    }
    case "last7Days":
      return {
        start: t.subtract({ days: 7 }),
        end: t
      };
    case "last30Days":
      return {
        start: t.subtract({ days: 30 }),
        end: t
      };
    case "last90Days":
      return {
        start: t.subtract({ days: 90 }),
        end: t
      };
    case "last6Months":
      return {
        start: t.subtract({ months: 6 }),
        end: t
      };
    case "last12Months":
      return {
        start: t.subtract({ months: 12 }),
        end: t
      };
    default:
      throw new Error(`Unknown preset: ${e}`);
  }
}
function CT({
  defaultPreset: e = "custom",
  onChange: t
}) {
  const [r, n] = re(null), i = (a) => {
    n(a);
    const o = Ns(fa()), s = wT(a, o);
    t && t(a, s);
  };
  return ue(() => {
    i(e);
  }, []), {
    setSelectedPresetDateRange: n,
    presetDateRangeProps: {
      presets: v$,
      selectedPreset: r,
      onSelectionChange: i
    }
  };
}
function ST({
  presets: e,
  selectedPreset: t,
  onSelectionChange: r,
  ...n
}) {
  return /* @__PURE__ */ N(
    DT,
    {
      items: v$,
      selectedKey: t,
      onSelectionChange: r,
      ...n,
      children: (i) => /* @__PURE__ */ N(ET, { children: i.name })
    }
  );
}
const kT = Vr`
  query ReportsEmbedURL(
    $businessId: GID!
    $locationId: GID
    $startDate: ISO8601Date
    $endDate: ISO8601Date
  ) {
    reportsEmbedUrl(
      businessId: $businessId
      locationId: $locationId
      startDate: $startDate
      endDate: $endDate
    )
  }
`;
function IT({
  defaultBusinessId: e = null,
  showBusinessSelect: t = !1
}) {
  const { businessSelectProps: r, business: n } = cT({
    defaultBusinessId: e
  }), { locationSelectProps: i, location: a } = fT({
    locations: (n == null ? void 0 : n.locations) || []
  }), [o, s] = re(null), { data: u } = xv(kT, {
    skip: !n || !o,
    variables: {
      businessId: n == null ? void 0 : n.id,
      locationId: a == null ? void 0 : a.id,
      startDate: o == null ? void 0 : o.start.toString(),
      endDate: o == null ? void 0 : o.end.toString()
    }
  }), l = u == null ? void 0 : u.reportsEmbedUrl, { presetDateRangeProps: c, setSelectedPresetDateRange: d } = CT({
    defaultPreset: "last30Days",
    onChange: (p, v) => {
      p !== "custom" && s(v);
    }
  }), f = (p) => {
    s(p), d("custom");
  }, h = o && new hr("en-US").formatRange(
    o.start.toDate(fa()),
    o.end.toDate(fa())
  );
  return /* @__PURE__ */ Se("div", { className: "sfs-customer-reports w-full h-full flex flex-col gap-8", children: [
    /* @__PURE__ */ Se("div", { className: "sfs-customer-reports__header flex flex-row justify-between items-center", children: [
      /* @__PURE__ */ Se("div", { className: "sfs-customer-reports__left flex flex-row gap-4 items-center", children: [
        t && /* @__PURE__ */ N(dT, { ...r, ariaLabel: "Business" }),
        n && /* @__PURE__ */ N(
          hT,
          {
            ...i,
            isClearable: !0,
            ariaLabel: "Location"
          }
        ),
        /* @__PURE__ */ N("div", { className: "sfs-customer-reports__date-range flex flex-row items-center", children: /* @__PURE__ */ N(
          $T,
          {
            ariaLabel: "Date range",
            value: o,
            onChange: f,
            children: /* @__PURE__ */ N(
              ST,
              {
                ...c,
                ariaLabel: "Preset Date Range",
                className: "mb-4"
              }
            )
          }
        ) })
      ] }),
      /* @__PURE__ */ N("div", { className: "sfs-customer-reports__right flex flex-row gap-4 items-center", children: /* @__PURE__ */ N(Xt, { Icon: $E, children: "Export" }) })
    ] }),
    /* @__PURE__ */ N(
      pT,
      {
        title: "Reports",
        subtitle: h,
        className: "sfs-customer-reports__content h-full w-full",
        children: l ? /* @__PURE__ */ N(
          "iframe",
          {
            title: "Reports",
            src: l,
            className: "sfs-customer-reports__iframe w-full h-[calc(100%_-_50px)] border-0"
          }
        ) : /* @__PURE__ */ N(iT, {})
      }
    )
  ] });
}
export {
  rT as AITextHelpers,
  OT as AITextHelpersButton,
  IT as CustomerReports,
  FT as SpilloverProvider
};
